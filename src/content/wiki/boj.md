---
layout  : wiki
title   : boj
summary : 
date    : 2020-04-27 21:37:43 +0900
lastmod : 2020-07-27 20:03:35 +0900
tags    : 
draft   : false
parent  : 
---

## 리스트
 * [X] 10830 제출 (MOD 주의하자)
 * [X] 1300 제출 (long long 주의하자)
 * [X] 2261 line sweep으로 푼거 다시 제출 (시간복잡도 잘 생각하기)
 * [X] 1167 dfs 를 주의하면서 짜자
 * [X] 11725
 * [X] 12025 index_tree 로 풀어보기 (압축하는데 시간이 생각보다 많이드나? ㅠ 조금더 고민해보자)
 * [X] 1967 : 1167 하고 똑같네
 * [X] 1086 : 50자 때문에 삽질을 엄청 많이 했다.. 입력이 숫자라고 해서 항상 long long 으로 입력 받을수 있는 건 아니란걸 다시 상기하게 됬다. 이외에도 자리수를 셀때 모듈러 한걸 그 숫자라고 생각해서 삽질을 많이 했다.
 * [X] 2618 : 경찰차 - 2일 정도 고민했는데 도저히 모르겠어서 구글링해서 답지를 봤다. 나름 변명하자면, 전부 다 본건 아니고 dp 조건이 뭔지 봤다.(사실 이거면 다 본게 맞긴하지만) 처음 보는 형태여서, 답지를 본게 크게 후회되지는 않는다. 새로 배운걸 요약하자면, 굳이 dp table을 모두 채울 필요도 없고, 여러 index 중 1개가 우리가 구하는 조건일수 있다. ~~흠.. 머라 서술할지가 어렵네 ~~ 그리고 dp table 에 대해서 조금더 생각하게 됬고, dp index로 둔것끼리 중복된 역할을 하는지 의심해봐야된다는 것이다. dp 자체가 메모리를 적게 사용하는건 아니니, 결정하는 최소 조건만이 들어가야지 공간, 시간 복잡도가 안터진다.
 * [X] 13344 : Chess Tournament - 단순한 위상정렬 문제이다. solved.ac 에서 플레티넘 5로 책정됬길레 공부가 될것 같아서 풀었는데, 별 큰 도움 안됬다. 그냥 단순히 Union-Find + Indegree 문제라서, 골드 1로 측정되도 괜찮을것 같은데, 아마도 2개 섞인거라 다들 플레티넘 준듯... 큰 이득이 없었다.
 * [X] 11266 : 단절점 - 예전에 주변에서 공부하라고 했는데, 공부 안하다가 DFS Spanning Tree 문제에 크게 당한 이후로 공부해야 겠다고 생각만 하다가 오늘 문제를 풀어봤다. 개념만 보고 풀었는데 통과해서 다행이다.
 * [X] 11500 : 단절선 - ~~단절점에서 조금 더 공부하면 될것 같아서 적어둠~~ 그냥 생각 조금만 틀면 되서 해결함. 문제 조건을 잘 봐야한다는걸 다시 깨달음. 정렬을 안해서 1번 틀림.
 * [X] 2150 : Strongly Connected Component - 강결합컴포넌트(SCC) 라고 불리는 문제이다. 코사라주(Kosaraju) 알고리즘을 배웠는데, 생각보다 구현이 간단하다고 생각해서 풀어봤다. 중간에 `push_back(move(data))`을 해줬는데, vector 의 deep copy가 일어날까봐 걱정한것 빼고는 크게 특별한게 없는 문제였다.
 * [X] 13510 : 트리와 쿼리 1 - 처음에 보고 한참동안 몰라서 초록책을 계속 뒤져보다가 트리 거의 마지막에 나와있길레, 이거다 싶어서 구현을 시작했다. 책만 보고 구현하는게 목표여서 점심시간, 모각코 시간마다 코딩했는데 계속 틀려서 30번 가량 틀렸다. 중간에 이걸로 푸는게 아닌가?? 하면서 다른 사람 구현체를 가져다가 채점해봤는데, 맞더라.... 구현이 틀렸다는걸 알고 다시 한번 읽어보니까 놓친 부분이 있더라
   * 사용하는 개념은 Heavy-Light Decomposition 이라는 건데, 예전에 아는 형이 알려줬던 트리 펼치기와 비슷하지만, 연속성 보장 등 측면에서 그 다음단계 알고리즘 인것같다. 아이디어가 굉장히 참신하다고 생각했다. 틀린건 Heavy Path 안에서 index의 연속을 보장하기 위해서, dfs 순서를 신경써줘야 되는데, 대부분의 구현체에서는 이를 edge의 0번 index가 항상 heavy 하도록 구현하는 것인데, 나는 괜히 heavy 배열을 만들어서 이를 해결하려다가 dfs 순서 보장이 안되서 틀렸었다.
