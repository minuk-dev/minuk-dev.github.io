---
layout: wiki
title: Effective kotlin
date: 2025-02-12 02:26:26 +0900
lastmod: 2025-03-04 01:18:53 +0900
tags: 
draft: true
parent: 
---
## 1부 좋은 코드
### 1장 안정성

#### Item 1. 가변성을 제한하라

- 코틀린에서 가변성 제한하기:
	- 일기 전용 프로퍼티(val)
	- 가변 컬렉션과 읽기 전용 컬렉션 구분하기
	- 데이터 클래스의 copy

#### Item 2. 변수의 스코프를 최소화하라
#### Item 3. 최대한 플랫폼 타입을 사용하지 말라

#### Item 4. Inferred 타입으로 리턴하지 말라
- 타입을 확실하게 지정해야하는 경우에는 명시적으로 타입을 지정해야한다는 원칙을 가지고 있으면 된다.
- inferred 타입은 프로젝트가 진전될 때, 제한이 너무 많아지거나 예측하지 못한 결과를 낼수 있다.
#### Item 5. 에외를 활용해 코드에 제한을 걸어라
- 제한 방법
	- required: argument 제한
	- check: 상태와 관련된 동작 제한
	- assert: 어떤것이 true 인지 확인, 테스트 모드에서만 작동
	- return 혹은 throw 와 함께 활용하는 Elvis 연산자
- 장점:
	- 제한을 걸면 문서를 읽지 않은 개발자도 문제를 확인할 수 있습니다.
	- 문제가 있을 경우에 함수가 예상하지 못한 동작을 하지 않고 예외를 throw한다.
	- 코드가 어느 정도 자체적으로 검사됩니다. 따라서 이와 관련된 단위테스트를 줄일 수 있다.
	- 스마트 캐스트 기능을 활용할 수 있게 되므로, 캐스팅을 적게 할 수 있다.
#### Item 6. 사용자 정의 오류보다는 표준 오류를 사용하라
- IllegalArgumentException, IllegalStateException 
- IndexOutOfBoundsException
- ConcurrentModificationException: 동시 수정 금지했지만 발생
- UnsupportedOperation
- NoSuchElementException

#### Item 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 많은 개발자가 예외가 전파되는 과정을 제대로 추적하지 못한다.
- 코틀린의 모든 예외는 unchecked 예외입니다. 따라서 사용자가 예외를 처리하지 않을 수도 있으며, 이와 관련된 내용은 문서에도 제대로 드러나지 않습니다.
- 예외는 예외적인 상황을 처리하기 위해 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않습니다.
- try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한됩니다.

- get: 특정 위치에 있는 요소를 추출할 때 사용합니다. 만약 요소가 해당 위치에 없다면 IndexOutOfBoundsException을 발생시킵니다.
- getOrNull: out of range 오류가 발생할 수 있는 경우에 사용하며, 발생한 경우에는 null을 리턴합니다.

#### Item 8. 적절하게 null을 처리하라
- null 을 처리하는 방법:
	- ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리한다.
	- 오류를 throw 한다.
	- 함수 또는 프로퍼티를 리팩러팅해서 nullable 타입이 나오지 않게 바꾼다.

- 대부분의 팀에서는 !! 연산자 사용을 피해야합니다.
- 의미 없는 nullability 피하기
- lateinit 프로퍼티와 notNull 델리게이트

#### Item 9. use를 사용하여 리소스를 닫아라
- use를 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있습니다. 또한 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋습니다.

#### Item 10. 단위 테스트를 만들어라
- 단위 테스트에서 일반적으로 확인하는 내용:
	- 일반적인 유스케이스 (이를 happy path라고 표현합니다.): 요소가 사용될 거라고 예상되는 일반적인 방법을 테스트합니다.
	- 일반적인 오류 케이스와 잠재적인 문제: 제대로 동작하지 않을 거라고 예상되는 일반적인 부분, 과거에 문제가 발생했던 부분 등을 테스트합니다.
	- 에지 케이스와 잘못된 아규먼트
- 단위 테스트의 장점:
	- 테스트가 잘 된 요소는 신뢰할 수 있다.
	- 리펙터링 하는 것이 두렵지 않다.
	- 수동으로 테스트하는 것보다 단위테스트로 확인하는 것이 빠르다.
- 단위 테스트의 단점:
	- 만드는데 시간이 걸린다. -> 하지만 대부분 수동테스트 시간을 단축시켜주므로 시간을 절약한다.
	- 테스트를 화룡할 수 있게 코드를 조정해야한다. -> 잘 정립된 아키텍쳐를 사용하게 강제하게 된다.
	- 좋은 단위 테스트를 만드는 것이 어렵다.

### 2장 가독성
#### Item 11. 가독성을 목표로 설계하라
- 인식 부하 감소
- 극단적이 되지 않기
- 컨벤션

#### Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라

#### Item 13. Unit?을 리턴하지 마라

#### Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라

#### Item 15. 리시버를 명시적으로 참조하라
- apply, with, run 을 사용하면 리시버가 여러개가 된다.
- DSL 마커
- 짧게 적을 수 있다는 이유만으로 리시버를 제거하지 않아야한다.

#### Item 16. 프로퍼티는 동작이 아니라 상태를 나타내야한다.
- 연산 비용이 높거나, 복잡도가 O(1) 보다 큰 경우: 관습적으로 프로퍼티를 사용할 때 연산 비용이 많이 필요하다고 생각하지 않는다. 따라서, 연산 비용이 크다면 하수로 사용하는 것이 좋습니다.
- 비지니스 로직(애플리케이션의 동작)을 포함하는 경우: 관습적으로 코드를 읽을 때 프로퍼티가 로깅, 리스너 통지, 바인드된 요소 변경과 같은 단순한 동작이상을 할 것이라고 기대하지 않는다.
- 결정적이지 않을 경우: 같은 동작을 연속적으로 두번 해쓴ㄴ데, 다른 값이 나올수 있다면 함수를 사용하는 것이 좋습니다.
- 변환의 경우: 변환은 관습적으로 `Int.toDouble()`과 같은 변환 함수로 이루어진다.
- 게터에서 프로퍼티의 상태 변경이 일어나야하는 경우: 관습적으로 게터에서 프로퍼티의 상태변화를 일으킨다고 생각하지는 않는다.

#### Item 17. 이름 있는 아규먼트를 사용하라
- 이름 있는 아규먼트는 사용하면 코드가 길어지지만 다음 두가지 장점이 생긴다.:
	- 이름을 기반으로 값이 무엇을 나타내는지 알 수 있다.
	- 파라미터 입력 순서와 상관 없으므로 안전하다.
- 다음 경우 추천한다.:
	- 디폴트 아규먼트 경우
	- 같은 타입의 파라미터가 많은 경우
	- 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)

#### 18. 코딩 컨벤션을 지켜라
- 어떤 프로젝트를 접해도 쉽게 이해할 수 있다.
- 다른 외부 개발자도 프로젝트의 코드를 쉽게 이해할 수 있습니다.
- 다른 개발자도 코드의 작동 방식을 쉽게 추측할 수 있습니다.
- 코드를 병합하고, 한 프로젝트의 코드 일부를 다른 코드로 이동하는 것이 쉽습니다.

## 2부 코드 설계
### 3장 재사용성
### Item 19. knowledge 를 반복하여 사용하지 말라
- 실용주의 프로그래머라는 책에서 DRY 규칙이라고 표현한다.
- Knowledge:
	- 로직: 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
	- 공통 알고리즘: 원하는 동작을 하기 위한 알고리즘
- 모든 것은 변화한다:
	- 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
	- 디자인 표준이 변화했다.
	- 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야한다.

#### 20. 일반적인 알고리즘을 반복해서 구현하지 말라
- 코드 작성 속도가 빨라진다.
- 구현을 따로 읽지 않아도, 함수의 이름 등만 보고도 무엇을 하는지 확실하게 알 수 있다.
- 직접 구현할 때 발생할 수 있는 실수를 줄일수 있다.
- 제작자들이 한 번만 최적화하면 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있습니다.


#### 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라
- stdlib 에서 다음과 같은 프로퍼티 델리게이터를 알아두면 좋다.
	- lazy
	- Delegates.observable
	- Delegates.vetoable
	- Delegates.notNull

#### 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

#### 23. 타입 파라미터의 새도인을 피하라

#### 24. 제네릭 타입과 variance 한정자를 활용하라
- 타입 파라미터의 기본적인 variance 동작은 invariant 이다. 만약 `Cut<T>` 라고 하면 타입 파라미터 `T` 는 invariant 이다. A가 B의 서브타입이라할때, `Cpu<A>`와 `Cup<B>`는 아무런 관계를 갖지 않는다.
- `out` 한정자는 타입 파라미터를 covariant하게 만든다. 만약 `Cup<T>` 라고 할때, 타입 파라미터 T는 covariant이다. A가 B의 서브타입이라 할때, `Cup<A>`는 `Cup<B>`의 서브타입이 된다.
- `in` 한정자는 타입 파라미터를 contravariant하게 만든다. 만약 `Cup<T>`라고 할때, 타입 파라미터 T는 contravariant이다. A가 B의 서브타입이라고 할대 `Cup<B>`는 `Cup<A>`의 슈퍼타입이 된다. contravariant 타입은 `in` 위치에 사용할 수 있다.
- 리턴만 되는 타입에는 out 한정자를 사용한다.
- 허용만 되는 타입에는 in 한정자를 사용한다.

#### Item 25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

### 4장 추상화 설계
- 복잡성을 숨기기 위해
- 코드를 체계화하기 위해
- 만드는 사람에게 변화의 자유를 주기 위해

#### Item 26. 함수 내부의 추상화 레벨을 통일하라

#### Item 27. 변화로부터 코드를 보호하려면 추상화를 사용하라
- 상수:
	- 이름을 붙일 수 있고, 나중에 해당 값을 쉽게 변경할 수 있다.
- 함수
- 클래스
- 인터페이스

- 몇가지 규칙:
	- 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 벼경하기 어렵다. 따라서 추상화 방법을 사용하는 것이 좋다. 최대한 모듈과 부분을 분리하는 것이 좋다.
	- 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경 쓰지 않아도 된다. 클래스 등은 한번만 정의하면 됙 ㅣ때문이다.
	- 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 어플리케이션을 만든다면 추상화를 사용하는 것이 좋다.
	- 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮다. 문제가 발생했다면 최대한 빨리 직접 변경하면 된다.

#### Item 28. API 안정성을 확인하라

#### Item 29. 외부 API 를 랩(Wrap) 해서 사용하라

#### Item 30. 요소의 가시성을 최소화하라
- 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다.
- 최대한 제한이 되어 있어야 변경하기 쉽다.
- 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다.
- 가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.

#### Item 31. 문서로 규약하라
#### Item 32. 추상화 규약을 지켜라

### 5장 객체 생성
#### Item 33. 생성자 대신 팩토리 함수를 사용하라
- 생성자와 다르게, 함수에 이름을 붙일 수 있다.
- 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있다.
- 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없다.:
	- 캐시, 싱글턴 등을 적용할 수 있다.
- 팩토리 함수는 아직 존재하지 읂는 객체를 리턴할 수도 있다.
- 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있다.
- 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있다.
- 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있다.
- 생성자는 즉시 슈퍼클래스 또는 기본 생성자를 호출해야하지만, 팩토리 함수를 사용하면 원하는 때에 생성자를 호출 할 수 있다. 

- from: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입 변환 함수
- of: 파라미터를 여러개 받고, 이를 통함해서 인스턴스를 만들어주는 함수
- valueOf: from 또는 of 와 비슷한 기능을 하면서도, 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수이다. 
- instance, getInstance: 싱글턴
- createInstance, newInstance: 매번 새 인스턴스 호출
- getType: 팩토리 함수가 다른 클래스에 있을때 사용하는 이름 (싱글턴 가능성 있음)
- newType: 팩토리 함수가 다른 클래스에 있을때 사용하는 이름, 매번 새 인스턴스 호출

#### Item 34. 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라
#### Item 35. 복잡한 객체를 생성하기 위한 DSL 을 정의하라
### 6장 클래스 설계
#### Item 36. 상속보다는 컴포지션을 사용하라
- 컴포지션이 더 안전하다. 다른 클래스의 내부적인 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하므로 안전하다.
- 컴포지션이 더 유연하다. 상속은 한 클래스만을 대상으로 할 수 있지만, 컴포지션은 여러 클래스를 대상으로 할 수 있다. 상속은 모든 것을 받지만, 컴포지션은 필요한 것만 받을 수 있다.
- 컴포지션이 더 명시적이다.
- 컴포지션은 생각보다 번거롭다.
- 상속은 다형성을 활용할 수 있다.

#### Item 37. 데이터 집합 표현에 data 한정자를 사용하라
- 리턴타입을 Tuple 을 쓰지 않고, 명시적으로 만들어서 반환할경우:
	- 함수의 리턴 타입이 더 명확해진다.
	- 리턴 타입이 더 짧아지며, 전달하기 쉬워진다.
	- 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면 경고가 출력된다.

#### Item 38. 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용해라

#### Item 39. 태그 클래스보다는 클래스 계층을 사용해라
- 코틀린에서는 태그 클래스보다 타입 계층을 사용하는 것이 좋다.
- 이러한 타입 계층을 만들때 sealed 클래스를 사용한다.

#### Item 40. equals의 규약을 지켜라
- 동등성:
	- 구조적 동등성: equals 메서드와 이를 기반으로 만들어진 == 연산자로 확인하는 동등성
	- 레퍼런스적 동등성: === 연산자로 확인하는 동등성
- equals의 규약:
	- 반사적(reflexive) 동작: x 가 null 이 아닌 값이라면, `x.equals(x)`는 true 를 리턴해야한다.
	- 대칭적(symmetric) 동작: x와 y가 null이 아니라면, `x.equals(y)`와 `y.equals(x)` 는 같은 결과를 출력해야한다.
	- 연속적 동작(transitive) 동작: x, y, z 가 null이 아니라면, `x.equals(y)` 와 `y.equals(z)` 가 true라면, `x.equals(z)` 도 true 여야한다.
	- 일관적(consistent) 동작: x 와 y 가 null이 아니라면, `x.equals(y)` 는 여러번 실행하더라도 항상 같은 결과를 리턴해야한다.
	- null과 관련된 동작: x가 null이 아닌 값이라면, `x.equals(null)` 는 항상 false 를 리턴해야한다.

#### Item 41. hashCode의 규약을 지켜라
-  어떤 객체를 변경하지 않았다면, 여러번 호출해도 그 결과가 항상 같아야한다.
- equals 메서드의 실행 결과로 두 객체가 같다고 나온다면, hashCode 메서드의 호출 결과도 같다고 나와야 한다.

#### Item 42. compareTo 의 규약을 지켜라
- 비대칭적 동작: a >= b 이고 b >= a 라면 a == b 이여야한다.
- 연속적 동작: a >= b 이고, b >= c 라면, a >= c 이다.
- 코넥스적(connex relation) 동작: 두 요소는 어떤 확실한 관계를 갖고 있어야한다. 즉, a >= b 또는 b >= a 중 적어도 하나는 항상 true 여야한다.

- 과연 구현해야할까?

#### Item 43. API 의 필수적이지 않는 부분을 확장 함수로 추출하라
- 확장 함수는 읽어 들여야한다.
- 확장 함수는 virtual 이 아니다
- 맴버는 높은 우선 순위를 갖는다
- 확장 함수는 클래스 위가 아니라 타입 위에 만들어진다.
- 확장 함수는 클래스 레퍼런스에 나오지 않는다.

#### Item 44. 맴버 확장 함수의 사용을 피하라

## 3부 효율성

### 7장 비용 줄이기
#### Item 45. 불필요한 객체 생성을 피하라
- 객체 생성 비용은 항상 클까?
- 무거운 객체를 외부 스코프로 보내기

#### Item 46. 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라
- 타입 아규먼트를 reified 로 사용할 수 있다.
- 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.
- 비지역적 리턴(non-local return)을 사용할 수 있다

- crossinline 과 noinline


### Item 47. 인라인 클래스의 사용을 고려하라

### Item 48. 더 이상 사용하지 않는 객체의 레퍼런스를 제거하다

## 8장 효율적인 컬렉션 처리

#### Item 49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라
- 시퀀스의 장점:
	- 자연스러운 처리 순서를 유지한다.
	- 최소한만 연산한다.
	- 무한 시퀀스의 형태로 사용할 수 있다.
	- 각각의 단계에서 컬렉션을 만들어 내지 않는다.

#### Item 50. 컬렉션 처리 단계 수를 제한하라

#### Item 51. 성능이 중요한 부분에는 기본 자료형 배열을 사용하라

#### Item 52. mutable 컬렉션 사용을 고려하라
