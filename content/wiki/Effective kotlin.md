---
layout: wiki
title: Effective kotlin
date: 2025-02-12 02:26:26 +0900
lastmod: 2025-02-23 23:02:31 +0900
tags: 
draft: true
parent: 
---
## 1부 좋은 코드
### 1장 안정성

#### Item 1. 가변성을 제한하라

- 코틀린에서 가변성 제한하기:
	- 일기 전용 프로퍼티(val)
	- 가변 컬렉션과 읽기 전용 컬렉션 구분하기
	- 데이터 클래스의 copy

#### Item 2. 변수의 스코프를 최소화하라
#### Item 3. 최대한 플랫폼 타입을 사용하지 말라

#### Item 4. Inferred 타입으로 리턴하지 말라
- 타입을 확실하게 지정해야하는 경우에는 명시적으로 타입을 지정해야한다는 원칙을 가지고 있으면 된다.
- inferred 타입은 프로젝트가 진전될 때, 제한이 너무 많아지거나 예측하지 못한 결과를 낼수 있다.
#### Item 5. 에외를 활용해 코드에 제한을 걸어라
- 제한 방법
	- required: argument 제한
	- check: 상태와 관련된 동작 제한
	- assert: 어떤것이 true 인지 확인, 테스트 모드에서만 작동
	- return 혹은 throw 와 함께 활용하는 Elvis 연산자
- 장점:
	- 제한을 걸면 문서를 읽지 않은 개발자도 문제를 확인할 수 있습니다.
	- 문제가 있을 경우에 함수가 예상하지 못한 동작을 하지 않고 예외를 throw한다.
	- 코드가 어느 정도 자체적으로 검사됩니다. 따라서 이와 관련된 단위테스트를 줄일 수 있다.
	- 스마트 캐스트 기능을 활용할 수 있게 되므로, 캐스팅을 적게 할 수 있다.
#### Item 6. 사용자 정의 오류보다는 표준 오류를 사용하라
- IllegalArgumentException, IllegalStateException 
- IndexOutOfBoundsException
- ConcurrentModificationException: 동시 수정 금지했지만 발생
- UnsupportedOperation
- NoSuchElementException

#### Item 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 많은 개발자가 예외가 전파되는 과정을 제대로 추적하지 못한다.
- 코틀린의 모든 예외는 unchecked 예외입니다. 따라서 사용자가 예외를 처리하지 않을 수도 있으며, 이와 관련된 내용은 문서에도 제대로 드러나지 않습니다.
- 예외는 예외적인 상황을 처리하기 위해 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않습니다.
- try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한됩니다.

- get: 특정 위치에 있는 요소를 추출할 때 사용합니다. 만약 요소가 해당 위치에 없다면 IndexOutOfBoundsException을 발생시킵니다.
- getOrNull: out of range 오류가 발생할 수 있는 경우에 사용하며, 발생한 경우에는 null을 리턴합니다.

#### Item 8. 적절하게 null을 처리하라
- null 을 처리하는 방법:
	- ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리한다.
	- 오류를 throw 한다.
	- 함수 또는 프로퍼티를 리팩러팅해서 nullable 타입이 나오지 않게 바꾼다.

- 대부분의 팀에서는 !! 연산자 사용을 피해야합니다.
- 의미 없는 nullability 피하기
- lateinit 프로퍼티와 notNull 델리게이트

#### Item 9. use를 사용하여 리소스를 닫아라
- use를 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있습니다. 또한 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋습니다.

#### Item 10. 단위 테스트를 만들어라
- 단위 테스트에서 일반적으로 확인하는 내용:
	- 일반적인 유스케이스 (이를 happy path라고 표현합니다.): 요소가 사용될 거라고 예상되는 일반적인 방법을 테스트합니다.
	- 일반적인 오류 케이스와 잠재적인 문제: 제대로 동작하지 않을 거라고 예상되는 일반적인 부분, 과거에 문제가 발생했던 부분 등을 테스트합니다.
	- 에지 케이스와 잘못된 아규먼트
- 단위 테스트의 장점:
	- 테스트가 잘 된 요소는 신뢰할 수 있다.
	- 리펙터링 하는 것이 두렵지 않다.
	- 수동으로 테스트하는 것보다 단위테스트로 확인하는 것이 빠르다.
- 단위 테스트의 단점:
	- 만드는데 시간이 걸린다. -> 하지만 대부분 수동테스트 시간을 단축시켜주므로 시간을 절약한다.
	- 테스트를 화룡할 수 있게 코드를 조정해야한다. -> 잘 정립된 아키텍쳐를 사용하게 강제하게 된다.
	- 좋은 단위 테스트를 만드는 것이 어렵다.

### 2장 가독성
#### Item 11. 가독성을 목표로 설계하라
- 인식 부하 감소
- 극단적이 되지 않기
- 컨벤션

#### Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라

#### Item 13. Unit?을 리턴하지 마라

#### Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라

#### Item 15. 리시버를 명시적으로 참조하라