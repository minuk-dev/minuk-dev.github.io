<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MD98 page</title><link>http://makerdark98.dev/</link><description>Recent content on MD98 page</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 16 Jul 2020 20:35:14 +0900</lastBuildDate><atom:link href="http://makerdark98.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>LFS Paper</title><link>http://makerdark98.dev/wiki/lfs/</link><pubDate>Thu, 16 Jul 2020 20:35:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/lfs/</guid><description>The Design and Implementation of a Log-Structured File system 읽은 계기 주변에서 읽어보라 해서 F2FS 에서 관련 논문으로 조회되서 우연히 김박사넷에 관심 분야에 뭐뭐 있나 찾아보다가 보여서 잡담 겸사겸사 영어 공부할겸 영어로 paraphase 하면서 작문하는 연습을 하기로 했다. 영어로 먼적 작문 하고 한글로 다시 번역하는 식으로 진행 Abstract This paper introduces log-structured file system. (이 논문에서는 log-structured file system 을 소개한다.) This FS has a log-like structure and it contains all modifications sequentially.</description></item><item><title>Flash Translation Layer</title><link>http://makerdark98.dev/wiki/ftl/</link><pubDate>Tue, 14 Jul 2020 19:32:21 +0900</pubDate><guid>http://makerdark98.dev/wiki/ftl/</guid><description>FTL ? Flash Translation Layer의 약자. SSD를 Disk 처럼 사용할 수 있게 변환하는 Layer 구성요소 STL (Sector Translation Layer) Address Mapping : Logical Address 를 Physical Address 로 변환 Garbage Collection : 안 쓰는 NAND Memory를 초기화하여 쓰기 가능한 상태로 바꾸는 것. Wear Leveling : 특정한 NAND Memory에 쓰기가 몰리지 않게 하여, 전체적인 수명을 관리하는 것. BML (Bad-Block Management Layer) BBM(Bad Block Management) : NAND 특성상, 새 NAND 조차 불량 블록이 있을수 있으며, 이런 블록을 관리.</description></item><item><title>PPN(Physical Page Number)</title><link>http://makerdark98.dev/wiki/ppn/</link><pubDate>Tue, 14 Jul 2020 19:29:54 +0900</pubDate><guid>http://makerdark98.dev/wiki/ppn/</guid><description>같이 볼거리 [[FTL]] [[LPN]] 요약 FTL에 의해 변환된 주소를 Page 단위에 따라서 나누고 여기에 번호를 붙인것. PBN(Page Block Number)의 변화와 상관없이 연속적으로 붙여진다. 예시 : Page Block에 4개의 Page가 들어갈 경우 0번 Page Block 은 PPN이 0~3, 1번 Page Block은 4~7을 가지고 있다.</description></item><item><title>LPN(Logical Page Number)</title><link>http://makerdark98.dev/wiki/lpn/</link><pubDate>Tue, 14 Jul 2020 19:28:19 +0900</pubDate><guid>http://makerdark98.dev/wiki/lpn/</guid><description>같이 볼거리 [[FTL]] [[PPN]] 요약 Logical Page Number 이며, [[FTL]]에 의해 변환되기 전 논리적 Page 주소를 Page 단위로 나누고, 이 Page에 번호를 붙인것</description></item><item><title>Load Balance</title><link>http://makerdark98.dev/wiki/load-balance/</link><pubDate>Mon, 13 Jul 2020 20:06:55 +0900</pubDate><guid>http://makerdark98.dev/wiki/load-balance/</guid><description>기본 개념 한 대의 서버로 여러 Client의 요청을 처리할 수 없고, Client에겐 단일 point 로 보이고 싶을때 사용하는 방법 Client가 Load Balancer (이하 LB) 에게 Request를 보내게 하고, LB는 일정한 알고리즘에 따라 Web Application Server(이하 WAS)에게 나눠주는 방법 상황에 따라 L4, L7 이 필요하다. 궁금점 WAS는 Client를 어떻게 식별(Identification)하나? 당연하게도 cookie 로 식별(Identification)할 수 있다. 하지만 cookie 없이 IP는 식별 불가능한가? 라는 생각이 든다. 이를 위한 표준으로 Forwarded 라는 값이 있고, 여기에 Proxy Ip들을 넣어주면 된다.</description></item><item><title>생각 쓰레기통</title><link>http://makerdark98.dev/wiki/%EC%83%9D%EA%B0%81%EC%93%B0%EB%A0%88%EA%B8%B0%ED%86%B5/</link><pubDate>Sun, 12 Jul 2020 20:52:58 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%83%9D%EA%B0%81%EC%93%B0%EB%A0%88%EA%B8%B0%ED%86%B5/</guid><description>생각쓰레기통 생각버리기 - 1 두서없는 글이다. 만약 나 말고 이 글을 읽는 사람이라면 읽기만하고 어떤 이야기도 하지않으면 좋겠다. 이글의 마지막에도 이야기하겠지만 당장은 뭔가 일을 벌일 생각이 없다. 아직은 준비하는 시간이다. 어정쩡하게 말해서 아래서 언급하는 계기를 만들지 않으면 좋겠다. 나는 자살에 대해서 생각하고 있다. 언제나, 거의 초등학교 중학교 쯔음이다. 자살기도도 해본적 있으니 어린아이의 힘으로 어린 아이의 용기로는 한계가 있었다. 혹시 모른다. 지금도 어정쩡하게 생각만 하는게 아니라 어떤 계기가 있으면 다시 시도해볼만 하다고 생각한다.</description></item><item><title>Cache</title><link>http://makerdark98.dev/wiki/cache/</link><pubDate>Mon, 06 Jul 2020 20:38:22 +0900</pubDate><guid>http://makerdark98.dev/wiki/cache/</guid><description>요약 Pinciple of Locality 에 따라 최근 접근한 데이터 또는 인접한 데이터를 빠르게 접근할수 있는 곳에 두고 접근하는 것. Cache 의 종류 출처 : https://parksb.github.io/article/29.html L1 Cache : 프로세서와 가장 가까운 캐시. 속도를 위해 I$ 와 D$ 로 나뉜다. Instruction Cache (I$) : 메모리의 TEXT 영역 데이터를 다루는 캐시 Data Cache (D$) : TEXT 영역을 제외한 모든 데이터를 다루는 캐시. L2 Cache : 용량이 큰 캐시, 크기를 위해 L1캐시처럼 나누지 않는다.</description></item><item><title>UART (Universal asynchronous receiver/transmitter)</title><link>http://makerdark98.dev/wiki/uart/</link><pubDate>Mon, 06 Jul 2020 20:15:52 +0900</pubDate><guid>http://makerdark98.dev/wiki/uart/</guid><description>요약 범용 비동기화 송수신기 : 병렬 데이터의 형태를 직렬 방식으로 전환하여 데이터를 전송하는 컴퓨터 하드웨어의 일종 데이터 송수신 형태 비트수 1 2 3 4 5 6 7 8 9 10 11 시작 비트 (start bit) 5-8 데이터 비트 패리티비트(parity bit) 종료 비트 (Stop bit(s)) Start Data 0 Data 1 Data 3 Data 3 Data 4 Data 5 Data 6 Data 7 Parity Stop</description></item><item><title>VHDCI (Very-high-dencity cable interconnect)</title><link>http://makerdark98.dev/wiki/vhdci/</link><pubDate>Mon, 06 Jul 2020 20:13:27 +0900</pubDate><guid>http://makerdark98.dev/wiki/vhdci/</guid><description>요약 68개의 pin connect로 구성되어 있으며 이는 SCSI-3에서 SPI-2 문서에 소개된다.</description></item><item><title>boxplot</title><link>http://makerdark98.dev/wiki/boxplot/</link><pubDate>Mon, 06 Jul 2020 20:06:22 +0900</pubDate><guid>http://makerdark98.dev/wiki/boxplot/</guid><description>잘 나와있는 곳 https://boxnwhis.kr/2019/02/19/boxplot.html 같이 보면 좋은 자료 [[quartile]] 요약 사분위수(quartile) 을 시각화하여 쉽게 보는 그래프의 일종 얼마나 데이터가 넓게 분포되어있는가를 확인한다.</description></item><item><title>quartile (사분위수)</title><link>http://makerdark98.dev/wiki/quartile/</link><pubDate>Mon, 06 Jul 2020 20:03:22 +0900</pubDate><guid>http://makerdark98.dev/wiki/quartile/</guid><description>요약 quartile : 사분위수, 사분위 값으로 불리며, 통계에서 데이터의 분포를 확인할때 자주 쓰이며, 주로 [[boxplot]] 의 형태로 표현된다. Quart 의미 0 최소값 1 제 1 사분위수 (25%) 2 제 2 사분위수 (50% 중간값) 3 제 3 사분위수 (75%) 4 최대값</description></item><item><title>statistics</title><link>http://makerdark98.dev/wiki/statistics/</link><pubDate>Mon, 06 Jul 2020 20:02:25 +0900</pubDate><guid>http://makerdark98.dev/wiki/statistics/</guid><description>기본 용어 [[quartile]]</description></item><item><title>FSM (Finite State machine)</title><link>http://makerdark98.dev/wiki/fsm/</link><pubDate>Mon, 06 Jul 2020 19:56:41 +0900</pubDate><guid>http://makerdark98.dev/wiki/fsm/</guid><description>요약 유한 상태 기계 흔히 (내 기준으로) 논리회로 설계와 오토마타 수업때 들을수 있으며 Mealy machine 과 Moore machine 의 형태로 배우게 된다. Mealy Machine Input 이 Output을 결정할때 관여한다. State Diagram 을 만들 때 Input과 Output 을 전부 작성한다. Moore Machine 현재 상태만이 Output을 결정하고 Input은 다음 상태를 결정한다.</description></item><item><title>open-nvm</title><link>http://makerdark98.dev/wiki/open-nvm/</link><pubDate>Mon, 06 Jul 2020 19:38:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/open-nvm/</guid><description>기본 용어 정리 [[FSM]] [[VHDCI]] [[UART]] 공식 홈페이지 http://open-fpga-nvm.github.io/home/ 나름 정리 최근 몇년간, 여러 nvm 기술들이 현대 메모리 시스템들의 결정적인 문제(집적, 지연시간, 전력) 의 문제를 해결할 가능성이 있다는 것을 보여주었다. 이런 최첨단 NVMs 은 높은 저장 용량과 신뢰할만한 성능을 적은 전력 소모에서 보여주는 동안, 광범위한 연구가 이러한 NVMs 을 기존에 존재하던 다른 메모리 조직 층에 맞출려고 하고 있다. 기존 연구들이 이론적인 NVM의 가능성을 을 탐구하고 NVM 시스템을 위한 메모리 관리 기술에서 전례없는 관점을 제공했음에도 불구하고 누구나 접근할수 있는 데이터들은 간단한 분석 모델 또는 검증되지 않은 현실 장비들로부터 생성된다.</description></item><item><title>MRAM (Magnetic Random Access Memory)</title><link>http://makerdark98.dev/wiki/mram/</link><pubDate>Mon, 06 Jul 2020 19:19:38 +0900</pubDate><guid>http://makerdark98.dev/wiki/mram/</guid><description>출처 https://www.samsungsemiconstory.com/1992 https://en.wikipedia.org/wiki/Magnetoresistive_random-access_memory 간단 요약 자성체 소자를 이용한 비휘발성 메모리, Flash Memory 대비 쓰기 속도가 약 1000배 빠르고 전력 소모가 적은 특징이 있다. 위키피디아 번역 일반적인 RAM chip 기술과는 다르게, MRAM은 데이터를 전기 충전이나 흐름으로 저장하지 않고 자기 저장 요소를 사용한다. 이 자기 저장 요소는 2가지 강자성 판들로 구성되며, 각자 자기화 되어 있으며 얇은 절연판에 의해 분리되어 있다. 한 판은 영구적으로 구성되어 있으며, 다른 한판은 메모리를 저장하기 위한 외부 장에 맞추어 바뀌게 된다.</description></item><item><title>slack terminal에서 사용하기</title><link>http://makerdark98.dev/posts/slack-term/</link><pubDate>Fri, 03 Jul 2020 22:00:00 +0900</pubDate><guid>http://makerdark98.dev/posts/slack-term/</guid><description>slack 을 terminal에서 사용하기 Slack 이란 ? Slack 의 공식 문구 : Slack is where work flows. &amp;hellip; 이하 생략 회사~(나는 회사를 다녀본적이 없지만 듣기로는)~, IT 동아리 등 여러 곳에서 업무나 자료공유, 대화 등을 하기 위한 메신저 주로 활동하는 동아리들(교내 동아리, 군내 동아리)에서 사용하고 있다. 내가 느끼는 불편한점 주로 작업하는 곳이 부대 내이다보니, 매번 브라우저를 통해서 로그인 하는게 불편했다. 그래서 생각한게, ssh 로 접속할때 tmux 에다가 띄울수 있으면 어떨까?</description></item><item><title>vfs - file</title><link>http://makerdark98.dev/wiki/file/</link><pubDate>Fri, 03 Jul 2020 20:49:21 +0900</pubDate><guid>http://makerdark98.dev/wiki/file/</guid><description>코드 struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ const struct file_operations *f_op; /* * Protects f_ep_links, f_flags. * Must not be taken from IRQ context. */ spinlock_t f_lock; enum rw_hint f_write_hint; atomic_long_t f_count; unsigned int f_flags; fmode_t f_mode; struct mutex f_pos_lock; loff_t f_pos; struct fown_struct f_owner; const struct cred *f_cred; struct file_ra_state f_ra; u64 f_version; #ifdef CONFIG_SECURITY void *f_security; #endif /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.</description></item><item><title>kiocb</title><link>http://makerdark98.dev/wiki/kiocb/</link><pubDate>Fri, 03 Jul 2020 20:30:47 +0900</pubDate><guid>http://makerdark98.dev/wiki/kiocb/</guid><description>간략 설명 동기/비동기 IO 함수에게 완료할때 실행할 콜백함수를 전달하기 위한 구조체? 매개변수 설명 ki_filp : 해당 파일 ki_complete : 상태가 완료가 될때 실행되는 콜백함수 나머진 아직 모르겠네 알게되면 추가로 정리함 private ki_flags ki_hint ki_ioprio ki_cookie 코드 struct kiocb { struct file *ki_filp; /* The &amp;#39;ki_filp&amp;#39; pointer is shared in a union for aio */ randomized_struct_fields_start loff_t ki_pos; void (*ki_complete)(struct kiocb *iocb, long ret, long ret2); void *private; int ki_flags; u16 ki_hint; u16 ki_ioprio; /* See linux/ioprio.</description></item><item><title>VFS-Virtual File System</title><link>http://makerdark98.dev/wiki/vfs/</link><pubDate>Fri, 03 Jul 2020 20:30:09 +0900</pubDate><guid>http://makerdark98.dev/wiki/vfs/</guid><description>용어 [[file]] [[kiocb]]</description></item><item><title>linux</title><link>http://makerdark98.dev/wiki/linux/</link><pubDate>Fri, 03 Jul 2020 20:29:46 +0900</pubDate><guid>http://makerdark98.dev/wiki/linux/</guid><description>공부 [[VFS]]</description></item><item><title>F2FS- A New File System for Flash Storage</title><link>http://makerdark98.dev/wiki/f2fs-paper/</link><pubDate>Thu, 02 Jul 2020 22:31:19 +0900</pubDate><guid>http://makerdark98.dev/wiki/f2fs-paper/</guid><description>Changman Lee, Dongho Sim, Joo-Young Hwang, and Sangyeun Cho, Samsung Electronics Co., Ltd. USENIX Conference on File and Stoarage Technologies (FAST 15) 1. Introduction a. Flash Memory의 한계점 쓰기 작업 전 지우기 (erase-before-write requirement) 순차적으로 지워진 Blocks에 쓰기 (need to write on erased blocks sequentially) 제한된 쓰고 지우기 cycles (limited write cycles per erase block) b. Flash Memory 사용의 증가 이때까지는 HDD를 계속해서 저장 매체로 썻으나 점점 더 많은 저장 매체가 필요하고 빠른걸 원하게 되었다.</description></item><item><title>english/proverb</title><link>http://makerdark98.dev/wiki/english/proverb/</link><pubDate>Sun, 28 Jun 2020 23:29:00 +0900</pubDate><guid>http://makerdark98.dev/wiki/english/proverb/</guid><description>References https://lemongrad.com/proverbs-with-meanings-and-examples/ Proverb A bad workman always blames his tools. : 장인은 도구탓 안한다 A bird in hand is worth two in the bush. : 손안에 든 이익이 더 좋다&amp;hellip;? Absense makes the heart grow fonder. : 멀수록 사이가 좋아진다. A cat has nine lives. : 고양이 목숨 - 위험천만하게 살아가는 사람에게 하는 말? A chain is only as strong as its weakest link. : 체인의 강도는 가장 약한 부분이 결정한다.</description></item><item><title>english</title><link>http://makerdark98.dev/wiki/english/</link><pubDate>Sun, 28 Jun 2020 23:28:18 +0900</pubDate><guid>http://makerdark98.dev/wiki/english/</guid><description>Proverb [[english/proverb]]</description></item><item><title>tui 환경 개발</title><link>http://makerdark98.dev/posts/tui%ED%99%98%EA%B2%BD%EA%B0%9C%EB%B0%9C/</link><pubDate>Sat, 27 Jun 2020 19:00:00 +0900</pubDate><guid>http://makerdark98.dev/posts/tui%ED%99%98%EA%B2%BD%EA%B0%9C%EB%B0%9C/</guid><description>TUI 환경 개발 TUI란? TUI : Text-based user interface 관련 내용 wikipedia : https://en.wikipedia.org/wiki/Text-based_user_interface 텍스트 기반 인터페이스를 지칭하며, 대표적인 예시 프로그램으로는 vim, tig, ranger 정도가 있다. 왜 TUI 환경인가? 나는 개인적으로 GUI 환경을 좋아하지 않는다. 이유는 여러가지가 있겠지만 제일 큰 것은 마우스의 사용이다. 물론 마우스가 훌륭한 장비이다. 사용자에게 친숙한 경험을 제공한다. 비숙련자도 숙련자와 큰 차이 없이 클릭으로 프로그램을 사용할 수 있게 해준다. 하지만 이는 역으로 생각해보면 아무리 숙련된다고 해도 비숙련자와 차이가 크게 나지 않는다는 걸 의미한다고 생각했다.</description></item><item><title>tool</title><link>http://makerdark98.dev/wiki/tool/</link><pubDate>Sat, 27 Jun 2020 15:17:31 +0900</pubDate><guid>http://makerdark98.dev/wiki/tool/</guid><description>tool 모음 [[vim]] [[Nexus]] [[docker]] [[hugo]] [[linux command]] script [[사지방]] 설정 [[tool configuration]]</description></item><item><title>verilog (베릴로그)</title><link>http://makerdark98.dev/wiki/verilog/</link><pubDate>Thu, 25 Jun 2020 20:46:51 +0900</pubDate><guid>http://makerdark98.dev/wiki/verilog/</guid><description>개요 opennvm가 verilog가 짜져있어서 읽을수 있을 수준까지 공부하는게 목표 출처 기본 문법 : https://blog.naver.com/PostView.nhn?blogId=kyj0833&amp;amp;logNo=221490972642&amp;amp;from=search&amp;amp;redirect=Log&amp;amp;widgetTypeCall=true&amp;amp;directAccess=false 리눅스에서 verilog 사용하기 : https://www.sapphosound.com/archives/1894 http://www.asic-world.com/verilog/intro1.html#Design_Styles 기본 문법 module module_name(port_list); port, reg, wire, parameter declaration submodule instance primitive gate always, initial assign, funciton, task declaration function, task definition endmodule Hello World module main; initial begin $display(&amp;#34;Hello World&amp;#34;); $finish; end endmodule D flip-flop Code module d_ff (d, clk, q, q_bar); input d, clk; output q, q_bar; wire d, clk; reg q, q_bar; always @ (posedge clk) begin q &amp;lt;= d; q_bar &amp;lt;= !</description></item><item><title>IOMMU (Input Output Memory Management Unit)</title><link>http://makerdark98.dev/wiki/iommu/</link><pubDate>Mon, 22 Jun 2020 19:35:53 +0900</pubDate><guid>http://makerdark98.dev/wiki/iommu/</guid><description>IOMMU ? IOMMU : Input Output Memory Managment Unit 출처 : http://jake.dothome.co.kr/iommu/ Device가 Main Memory 에 접근할때 디바이스 주소를 물리 주소로 매핑하는 역할</description></item><item><title>delayed work</title><link>http://makerdark98.dev/wiki/delayed_work/</link><pubDate>Sun, 21 Jun 2020 19:42:23 +0900</pubDate><guid>http://makerdark98.dev/wiki/delayed_work/</guid><description>참조 사이트 http://egloos.zum.com/rousalome/v/9990982 delayed work 일정 시간 뒤에 지연시켜서 워크를 실행하는 방법 사용방법 출처 : http://egloos.zum.com/rousalome/v/9982311 INIT_DELAYED_WORKWORK() INIT_DELAYED_WORK(&amp;amp;work, handler); queue_delayed_work(workqueue, &amp;amp;work, delayed_time); 같이보기 좋은 자료 [[workqueue]]</description></item><item><title>회고/2020-06-21</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/</link><pubDate>Sun, 21 Jun 2020 01:12:48 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/</guid><description>간단 회고 새벽 코딩하다가 약간 지쳐서 다른걸 하고자 해서 회고를 쓴다. 구글 계정 결제 문제가 다 해결되서 지금 youtube music에서 노래를 듣고 있다. 오디오북은 amazon에서 서비스 하는 audible 을 들어봤는데 잘 되지 않았고, 그거 이외에도 한국에서 꽤 상위권에 있는 오디오북 어플을 다운 받아서 해봤는데 영 좋지 않다. 지킬앤 하이드를 들어봤는데, 물론 내가 잘 못듣는걸 아는데, 오디오북이 뭔가 집중이 안되는 것 같다. 이제까지 듣던게 전부 TED나 3B1B 같은 정보 전달의 내용이였는데 갑자기 다른 분야가 되서 그런건가 싶다.</description></item><item><title>json web token(jwt)</title><link>http://makerdark98.dev/wiki/jwt/</link><pubDate>Sat, 20 Jun 2020 01:14:03 +0900</pubDate><guid>http://makerdark98.dev/wiki/jwt/</guid><description>간단 설명 잘된 설명 주소 : https://velopert.com/2389 예전 (고등학교 시절)에 봤던 김포프의 유튜브 : https://www.youtube.com/watch?v=MUUqogMpGiA 사실 설명을 굳이 하는 것보다 내가 jwt를 배웠던 링크만 정리하는게 맞을 것 같아서 이렇게 정리함.</description></item><item><title>tmuxinator</title><link>http://makerdark98.dev/wiki/tmuxinator/</link><pubDate>Sat, 20 Jun 2020 01:04:36 +0900</pubDate><guid>http://makerdark98.dev/wiki/tmuxinator/</guid><description>간단 설명 tmux 의 session 을 자동으로 열어주는 거다. 주로 프로젝트 환경을 구성할때 쓴다. [[vim-startify]] 와 함께 사용하면 굉장히 편하다. 아쉬운점은 ruby로 구성되어 있어서 dependency가 있는 편이다. 설치할때는 공식적인 방법(gem 을 이용하는) 편보다 데비안 계열이면 sudo apt install tmuxinator 를 사용해서 조금 뒤쳐진 버전이더라도 쉽게 설치하는게 속이 편하다.</description></item><item><title>vim-startify</title><link>http://makerdark98.dev/wiki/vim-staritfy/</link><pubDate>Sat, 20 Jun 2020 01:02:39 +0900</pubDate><guid>http://makerdark98.dev/wiki/vim-staritfy/</guid><description>간단 설명 공홈 : https://github.com/mhinz/vim-startify Session을 관리해주는 건데 나도 다른 분의 위키를 참고하다보니 알게되었다. 쓰다보니 좋아서 쓰고 있다. 주로 [[tmuxinator]]와 함께 사용하면 엄청 편하다.</description></item><item><title>my-page (나만의 홈페이지 만들기)</title><link>http://makerdark98.dev/wiki/my-page/</link><pubDate>Sat, 20 Jun 2020 00:40:20 +0900</pubDate><guid>http://makerdark98.dev/wiki/my-page/</guid><description>시작 예전에 React를 배우면서 구성하던 게 있었는데, 실제 사용성이 낮고 토이프로젝트로밖에 못쓴다고 생각했다. 물론 토이여도 상관 없을수 있지만 나는 장기적으로 내가 사용할수 있는 서비스를 구축해서 내가 스스로 쓰는게 목표이다. 개발환경 설정 사실 이게 제일 귀찮다. 하지만 한번만 제대로 해놓으면 좋을 꺼라고 생각한다. 그런 의미에서 항상 java로 개발할때 사용하던 Intellij 를 버리고, vim 환경에서 cli로만 짜보자는 생각을 하게되었다. 물론 사실 요세 CLI와 GUI를 구별하는게 의미없다고 생각한다. 하지만 내가 주로 쓰는 툴들이 CLI, TUI 환경인 툴들이다 보니 (vimwiki, tig, tmux, tmuxinator) 당연하게도 spring은 왜 vim에서 못하나 생각이 들었다.</description></item><item><title>blk_mq</title><link>http://makerdark98.dev/wiki/blk_mq/</link><pubDate>Fri, 19 Jun 2020 20:23:19 +0900</pubDate><guid>http://makerdark98.dev/wiki/blk_mq/</guid><description>##blk_mq : Linux Block IO: Introducing Multi-queue SSD Access on Multi-core Systems
https://www.thomas-krenn.com/en/wiki/Linux_Multi-Queue_Block_IO_Queueing_Mechanism_(blk-mq)_Details</description></item><item><title>PRP (Physical Region Page)</title><link>http://makerdark98.dev/wiki/prp/</link><pubDate>Thu, 18 Jun 2020 20:15:03 +0900</pubDate><guid>http://makerdark98.dev/wiki/prp/</guid><description>PRP 출처 : https://m.blog.naver.com/PostView.nhn?blogId=eldkrpdla121&amp;amp;logNo=220536014853&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F 흠.. Pysical Region Page 말 그대로다. 혹시 모르니 위의 출처에 있는 말 그대로를 옮겨적자면, PRP contains the 64-bit physical memory page address. The lower bits (n:2) of this field indicate the offset within the memory page. N is defined by the memory page size. PRP List contains a list of PRPs with generally no offsets.</description></item><item><title>NUMA</title><link>http://makerdark98.dev/wiki/numa/</link><pubDate>Thu, 18 Jun 2020 19:29:33 +0900</pubDate><guid>http://makerdark98.dev/wiki/numa/</guid><description>NUMA Non-Uniform Memory Access 의 약자, 멀티프로세서 환경에서 적용되는 메모리 접근 방식 CPU 마다 메모리를 보유하고 있는데, CPU 가 자신의 메모리에 접근하는 것을 Local Access라고 부른다. 노드 : CPU와 그에 해당하는 메모리를 합쳐서 부르는 말 NUMA에서 다른 노드에 접근하는 것을 Remote Access 라고 부른다.</description></item><item><title>회고/2020-06-17</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/</link><pubDate>Wed, 17 Jun 2020 20:18:56 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/</guid><description>일기 생활 측면 오늘 공부는 이미 글러먹었으니 회고를 쓴다. 오늘 1시간 30분동안 유튜브 프리미엄 결제를 시도하다가 화가나서 결국은 계정을 새로 팠다. 개발용 계정과 사적 계정을 분리할 필요가 있긴 하니 겸사겸사 한다라고 생각한다. (뭐 그래도 예전 계정에서 결제문제 다 사라지면 다시 돌아가야지) 지금은 카카오 페이로 연결되어 있다. 최근에 완우에게서 연락이 왔다 gcp 설정해서 ubuntu server 에서 작업하느라 vim 사용법과 관련된 카톡이였다. 그럭저럭 잘살고 있는 것 같다. 영화 동아리에서 봄날은 간다 를 시청했다.</description></item><item><title>block layer</title><link>http://makerdark98.dev/wiki/block-layer/</link><pubDate>Tue, 16 Jun 2020 19:14:58 +0900</pubDate><guid>http://makerdark98.dev/wiki/block-layer/</guid><description>Block Layer Linux 에서 device에 입출력 할때 request를 처리하는 layer https://lwn.net/Articles/736534/ /dev 에 있는 block device 에 접근할때 사용 함수 호출 순서 출처 : http://egloos.zum.com/moonkh/v/4841748 read(), write() -&amp;gt; bio 구조체를 생성하고 필요한 정보를 할당 -&amp;gt; submit_bio() 호출 -&amp;gt; generic_make_request() 호출 - bio 구조체를 I/O 스케줄러에 등록 -&amp;gt; _make_request() 호출, bio 를 request 로 만들고 request_queue 에 넣는다. submit_bio() 구현부 block/blk-core.c bootlin 링크 : https://elixir.bootlin.com/linux/latest/source/block/blk-core.c#L1139 generic_make_request() blcok/blk-core.</description></item><item><title>workqueue</title><link>http://makerdark98.dev/wiki/workqueue/</link><pubDate>Mon, 15 Jun 2020 20:14:50 +0900</pubDate><guid>http://makerdark98.dev/wiki/workqueue/</guid><description>참조 사이트 https://m.blog.naver.com/PostView.nhn?blogId=leojesus&amp;amp;logNo=80172478497&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F workqueue 사용법 : https://selfish-developer.com/entry/workqueue-%EC%82%AC%EC%9A%A9%EB%B2%95 workqueue 지연처리를 하기 위해서 사용하는 자료구조 (다른 걸로는 SOFTIRQ, TASKLET 이 있음) 사용방법 출처 1: http://egloos.zum.com/rousalome/v/9982311 출처 2: http://egloos.zum.com/rousalome/v/9982570 INIT_WORK() 나 DECLARE_WORK()를 사용해서 초기화 INIT_WORK() : 커널이 실제로 INIT_WORK() 함수를 실행할때 워크를 초기화 DELCARE_WORK() : 커널이 컴파일 될때 세부정보가 포함된 전역 변수 생성 INIT_WORK(&amp;amp;work, handler); schedule_work(&amp;amp;work); /* enqueue work into system queue */ queue_work(&amp;amp;workqueue, &amp;amp;work) /* enqueue work */ queue_work_on(cpu, &amp;amp;workqueue, &amp;amp;work) /* enqueue work with exception handling */ 같이보기 좋은 자료 [[delayed_work]]</description></item><item><title>nvme</title><link>http://makerdark98.dev/wiki/nvme/</link><pubDate>Mon, 15 Jun 2020 20:13:59 +0900</pubDate><guid>http://makerdark98.dev/wiki/nvme/</guid><description>시작 아무것도 모르고 SSD 에 대해서 아는거라곤, 개발자를 위한 SSD 라는 카카오에서 올린 글(https://tech.kakao.com/2016/07/13/coding-for-ssd-part-1/) 와 [[simplessd]] 논문만 보고 무턱대고 시작한 공부 Linux NVMe 공부 [[workqueue]] [[block layer]] [[IO mapping]] [[blk_mq]] [[IOMMU]] [[SGL]]{Scatter-Gatter List} nvme 자료구조 https://testkernel.tistory.com/3 의문점 linux/drivers/nvme/host 에 있는 nvme 함수들은 어떻게 호출되는가? -&amp;gt; scsi interface 를 사용해서 -&amp;gt; 그러면 어디에 있지? source code를 찾아보고 싶다. -&amp;gt; 일단 request 는 찾았다. block device 에 접근 하려면 (실제로 block device는 아닐수도 있지만 SSD를 일단 Block 으로 사용하고 FTL 로 처리?</description></item><item><title>gem5</title><link>http://makerdark98.dev/wiki/gem5/</link><pubDate>Wed, 10 Jun 2020 20:12:01 +0900</pubDate><guid>http://makerdark98.dev/wiki/gem5/</guid><description>짤막한 소개 (공식홈페이지) Learning gem5 gives a prose-heavy introduction to using gem5 for computer architecture research written by Jason Lowe-Power. This is a great resource for junior researchers who plan on using gem5 heavily for a research project. 오픈소스 시스템 레벨, 및 프로세서 시뮬레이터 연구할때 하드웨어를 소프트웨어로 가상화 해서 돌려본다. Simplessd에서도 이걸 사용한다.</description></item><item><title>simple-ssd</title><link>http://makerdark98.dev/wiki/simplessd/</link><pubDate>Wed, 10 Jun 2020 19:39:41 +0900</pubDate><guid>http://makerdark98.dev/wiki/simplessd/</guid><description>새롭게 알게된 것 [[gem5]] 다운로드 simplessd 공홈 하라는 대로 하면 된다. (FullSystem은 example 을 실행해도 그대로 안되서, 그냥 standalone 을 먼저 봐보기로 했다.) 문서 읽기 그냥 홈페이지에 있는 문서를 읽어보자. 중요하니까 정리해놨겠지 Host Interface Layer HIL 이라고도 불리는 Host Interface Layer에 대한 설명이다. HIL 은 host side에 있는 host controller, host controller 에게 추상화된 API를 제공해주는 SSD Interface Host Controller NVMe, SATA and UFS를 구현해 놓았으며, Open-Channel SSD 는 NVMe 를 상속받음.</description></item><item><title>innodb</title><link>http://makerdark98.dev/wiki/innodb/</link><pubDate>Sun, 07 Jun 2020 20:01:38 +0900</pubDate><guid>http://makerdark98.dev/wiki/innodb/</guid><description/></item><item><title>mmap</title><link>http://makerdark98.dev/wiki/mmap/</link><pubDate>Fri, 05 Jun 2020 19:52:18 +0900</pubDate><guid>http://makerdark98.dev/wiki/mmap/</guid><description>MAP_SHARED vs MAP_PRIVATE 이에 관한 내용을 검색해보니 많은 내용들이 나온다. 그런데 대부분 공유하는 내용이랑 메뉴얼을 참조하라고만 하지 직접적 성능비교는 못찾았다. 그래서 결국 생각이 미친게 innodb는 빠른 방법 혹은 느리더라도 사용해야할 이유가 있는 방법을 사용할 거다. innodb storage engine 코드에서 Fgrep으로 찾아보니, /* os/os0proc.cc */ ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | OS_MAP_ANON, -1, 0); 이 내용을 찾았고, 그래서 MAP_PRIVATE를 b+-Tree를 만들때 사용하기로 했다. 추가적으로 addr 를 null을 줄 경우 자동으로 PAGE 단위에 맞게 준다는 걸 알았다.</description></item><item><title>B+ Tree</title><link>http://makerdark98.dev/wiki/b+tree/</link><pubDate>Fri, 05 Jun 2020 19:24:15 +0900</pubDate><guid>http://makerdark98.dev/wiki/b+tree/</guid><description>유틸 일단 B+-Tree 를 In Memory가 아니라, File로 만들꺼니, 기본적인 Util 부분을 짜자. 1. 기본적인 아키텍쳐 레벨의 함수들 정리 및 사용하기 편하게 만들기 일단 [[mmap]] 으로 Page 단위로 memory에 올릴 꺼니, mmap 부터 공부</description></item><item><title>Database</title><link>http://makerdark98.dev/wiki/database/</link><pubDate>Thu, 04 Jun 2020 20:44:44 +0900</pubDate><guid>http://makerdark98.dev/wiki/database/</guid><description>공부 [[mysql]] [[Endurable_Transient_Inconsistency_in_Byte_Addressable_Persistent_B+-Tree]] [[innodb]] [[b+tree]] 구현</description></item><item><title>memory cache 비우기 (linux command)</title><link>http://makerdark98.dev/wiki/memory-cache-clean/</link><pubDate>Tue, 02 Jun 2020 20:39:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/memory-cache-clean/</guid><description>pagecache 해제 echo 1 &amp;gt; /proc/sys/vm/drop_caches dentries, inodes 해제 echo 2 &amp;gt; /proc/sys/vm/drop_caches pagecache, dentries, inodes 모두 해제 echo 3 &amp;gt; /proc/sys/vm/drop_caches 플러싱하기 sync 출처 https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BA%90%EC%8B%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B9%84%EC%9A%B0%EA%B8%B0</description></item><item><title>free (linux command)</title><link>http://makerdark98.dev/wiki/free/</link><pubDate>Tue, 02 Jun 2020 20:37:44 +0900</pubDate><guid>http://makerdark98.dev/wiki/free/</guid><description>linux command -m : MB단위로 데이터 표시 -b : byte단위로 데이터 표시 -k : kilo byte 단위로 데이터 표시 -t : 맨 마지막에 total 량 표시 -o : buffer/cache 표시 안함 -s : 지정한 초단위(Regular interval)로 refresh -l : low &amp;amp; High 메모리 크기 통계 -V : free명령의 버전 표시 예시 : free -m</description></item><item><title>clflush (cache line flush)</title><link>http://makerdark98.dev/wiki/clflush/</link><pubDate>Tue, 02 Jun 2020 19:15:07 +0900</pubDate><guid>http://makerdark98.dev/wiki/clflush/</guid><description>출처 https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_clflush&amp;amp;expand=678,679
내용 void _mm_clflush (void const* p) #include &amp;lt;emmintrin.h&amp;gt;Instruction: clflush m8 CPUID Flags: SSE2 void _mm_clflushopt (void const * p) #include &amp;lt;immintrin.h&amp;gt;Instruction: clflushopt m8 CPUID Flags: CLFLUSHOPT clflush vs clflushopt 출처 : https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/712498 clflushopt : clflush optimization</description></item><item><title>C++ Language</title><link>http://makerdark98.dev/wiki/c++/</link><pubDate>Tue, 02 Jun 2020 19:14:04 +0900</pubDate><guid>http://makerdark98.dev/wiki/c++/</guid><description>Memory [[clflush]] Books [[Modern C++ Design Pattern]]</description></item><item><title>사지방</title><link>http://makerdark98.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/</link><pubDate>Tue, 02 Jun 2020 19:05:23 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/</guid><description>사지방용 script wget https://github.com/alacritty/alacritty/releases/download/v0.4.3-rc1/Alacritty-v0.4.3-rc1-ubuntu_18_04_amd64.tar.gz tar -zxf Alacritty-v0.4.3-rc1-ubuntu_18_04_amd64.tar.gz wget https://github.com/naver/d2codingfont/releases/download/VER1.3.2/D2Coding-Ver1.3.2-20180524.zip unzip D2Coding-Ver1.3.2-20180524.zip mkdir -p .local/share/fonts mv D2Coding .local/share/fonts fc-cache -f -v git clone https://github.com/makerdark98/alacritty-config ~/.config/alacritty echo $&amp;#39;remove Lock = Caps_Lock \nkeysym Caps_Lock = Control_L \nadd Control = Control_L&amp;#39; &amp;gt;&amp;gt; ~/.xmodmap xmodmap ~/.xmodmap ./alacritty &amp;amp; ./alacritty &amp;amp; exit Vimium https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb 슬랙 https://gyeryongdevmeetup.slack.com https://zeropage.slack.com Youtube Music Lyrics https://chrome.google.com/webstore/detail/lyrics-youtube-youtube-mu/fdpanfmdmcblgkecobjdhkgdnfilncfg/related 파일 옮기기 (scp) scp -P 80 ~/test.txt lmu@[IP주소]:/home/lmu 크롭 탭 세이브 https://chrome.</description></item><item><title>2020년 5월 30일 회고</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/</link><pubDate>Sat, 30 May 2020 01:26:59 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/</guid><description>있었던 일을 먼저 잠깐 요약하자면, 테블릿 반출, 2월 말부터(아마도 내가 휴가 복귀한 날) 코로나로 인해 휴가 제한이 걸려 이제서야 나왔다. 휴가 동안은 유튜브 프리미엄을 결제하려고 하는데 예전에 구글 클라우드를 가입하려고 했다가 카드 인증(카메라로 ㅠㅠ) 하라고 해서 결제 정보가 락이 걸려서 4일째 못하고 있는것 정도이다. 테블릿 반출.... 흐음.. 안드로이드로 전환하면 될줄 알고 전환했는데도 안된다고 한다. 전부 다 반출하란다(? 흠... 태생이 안드로이드여야 한다니 무슨말인지 모르겠군.. 차라리 CPU가지고 뭐라고 하면 모르겠다.) 뭐 이런 저런 이유로 요즘 나는 뭘하나 생각해볼 기회가 많이 생겼었다.</description></item><item><title>2020년 3월 회고</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/</link><pubDate>Sat, 30 May 2020 01:23:56 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/</guid><description>오랜만에 글을 쓰게된다. 글은 이성적이여야 한다고 생각하지만 항사 감성에 젖을때 쓰고 싶어지니 아이러니하다. 먼저 글을 쓸때는 항상 지난 나보다는 지금 더 발전했는가를 따지는데, 이번 회고때는 그런것 같아서 다행이다. 토플 공부도 시작했고, 알고리즘도 조금더 열심히 풀면서, 데이터중심 어플리케이션 책도 어느정도 읽었고, 논문도 항상은 아니지만 읽고 있다. 가끔 개발이 생각나긴 하지만 그때 마음 먹은것처럼 중요한것에 집중해야겠지 하면서 다시 마음을 접는다. 항상 글을 쓸때면 하고싶은 말이 너무 많아서 뭐부터 써야할지 고민하게 되고, 하고싶은 말을 전부다 쏟아부어버리니 난잡해져버린다.</description></item><item><title>mysql (storage engine)</title><link>http://makerdark98.dev/wiki/mysql/</link><pubDate>Thu, 28 May 2020 07:48:47 +0900</pubDate><guid>http://makerdark98.dev/wiki/mysql/</guid><description>참고용 홈페이지 https://dev.mysql.com/doc/internals/en/custom-engine.html mysql architecture https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_PFS_PSI.html 환경 설정 일단 지금 집에다가 예전에 썻던 삼성 노트북을 wol 으로 설정하고 (완전히 꺼지면 안켜지니까 shutdown 을 alias 해놓고, suspend를 사용하는 식으로 했다.휴가 때 마다 혹은 가끔씩 reboot 해주면 되겠지?) github 에서 다운로드 해서 private repository 에다가 올려놨다. $ git clone https://github.com/mysql/mysql-server 참고용 홈페이지 1을 보면 알 수 있듯이 storage/example 을 똑같이 카피했다. 일단 지금 목표는 custom engine 을 만들어 보는 거고 가능하다면 2018년 FAST 에 나온 논문인 FAST_PAIR 를 만들어보는거다.</description></item><item><title>block group</title><link>http://makerdark98.dev/wiki/block-group/</link><pubDate>Thu, 30 Apr 2020 20:45:01 +0900</pubDate><guid>http://makerdark98.dev/wiki/block-group/</guid><description>간략 설명 ext2 에서는 블록들의 모임으로, 같은 파일에 속하는 데이터 블록은 같은 블록 그룹에 저장하려고 노력하기 때문에 단편화 현상을 줄일수 있다.</description></item><item><title>group descriptor table</title><link>http://makerdark98.dev/wiki/group-descriptor-table/</link><pubDate>Thu, 30 Apr 2020 20:17:00 +0900</pubDate><guid>http://makerdark98.dev/wiki/group-descriptor-table/</guid><description>설명 슈퍼블록 바로 다음에 위치하며, 파일 시스템의 블록 그룹들에 대한 정보를 가지고 있다. Group Descriptor의 크기는 32bytes로, 블록 크기가 1KB이라면 하나의 블록에 총 32개의 Group Descriptor가 기록될수 있다. 포함하는 주요 정보 Block Bitmap의 블록 번호, Inode Bitmap의 블록 번호, 첫번째 Inode Table Block의 블록번호, 그룹안에 있는 빈블록 수, 그룹 안에 있는 inode 수, 그룹 안에 있는 빈 디렉토리 수 등이다.</description></item><item><title>inode</title><link>http://makerdark98.dev/wiki/inode/</link><pubDate>Thu, 30 Apr 2020 20:08:55 +0900</pubDate><guid>http://makerdark98.dev/wiki/inode/</guid><description>설명 Unix에서 사용하는 전통적 파일 시스템에서 사용하는 자료 구조 정규파일, 디렉토리 등 파일시스템에 대한 정보를 가지고 있다. 일반적으로 inode에 포함된 정보 비트 내용 12-15 파일 형식(일반, 디렉터리, 문자 또는 블록 특별, 선입선출 파이프) 9-11 실행 플레그 8 소유자 읽기 권한 7 소유자 쓰기 권한 6 소유자 실행 권한 5 그룹 읽기 권한 4 그룹 쓰기 권한 3 그룹 실행 권한 2 다른 사용자 읽기 권한 1 다른 사용자 쓰기 권한 0 다른 사용자 실행 권한 링크 수 : 이 아이노드에 대한 디렉터리 참조수 소유자 아이디 그룹 아이디 파일 크기 파일 주소 (주소 정보 39바이트) 마지막 접근 시각 마지막 수정 시각 아이노드 수정 시각</description></item><item><title>Superblock</title><link>http://makerdark98.dev/wiki/superblock/</link><pubDate>Thu, 30 Apr 2020 20:07:08 +0900</pubDate><guid>http://makerdark98.dev/wiki/superblock/</guid><description>설명 파일시스템을 대표하는 블록, 파일시스템의 주요 설정이 들어가있다. 주로 블록의 크기(1KB인지 4KB인지&amp;hellip;), 총 블록의 개수, 블록 그룹의 개수, [[inode]]의 개수, 그룹당 block의 개수</description></item><item><title>The new ext4 filesystem: current status and future plans</title><link>http://makerdark98.dev/wiki/ext4/</link><pubDate>Thu, 30 Apr 2020 19:42:16 +0900</pubDate><guid>http://makerdark98.dev/wiki/ext4/</guid><description>Abstract 주요 키워드 : scalability, performance, reliability, stability 2007 년 논문임을 가만하고 읽으면 좋다. 1. Introduction ext3의 장점 : 안정성(stable), 엄격성(robust) ext3의 단점 : 큰 규모에 한계 (큰 파일과 많은 파일) 단점 극복에 관한 기존 방안 ext3는 최대 16TB 만 지원가능 이미 기업에선 한계점이 보임 (디스크 최대 용량은 매년 2배가 되고 있음) 물론, larger filesystem capacity와 extents mapping을 담고 있는 패치를 2006년 선보였으나, 이 패치는 결국 disk의 형식을 변경하고 호환성을 버릴수 밖에 없었다.</description></item><item><title>계룡 개발 모임</title><link>http://makerdark98.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/</link><pubDate>Tue, 28 Apr 2020 21:48:13 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/</guid><description>이벤트 [[설대회]] [[송편대회]] [[Memory_Leak]] [[썩어버린 Query Language]] 논문 스터디 [[F2FS]] [[Endurable_Transient_Inconsistency_in_Byte_Addressable_Persistent_B+-Tree]] [[ext4]]{The new ext4 filesystem: current status and future plans} 군대에서 개발하던거 [[사지방_개발기]]</description></item><item><title>SSD</title><link>http://makerdark98.dev/wiki/ssd/</link><pubDate>Tue, 28 Apr 2020 21:46:46 +0900</pubDate><guid>http://makerdark98.dev/wiki/ssd/</guid><description>다른 링크 [[SSD 공부자료 모음]] [[SSD(Solid-State Drive)]] [[simplessd]] [[nvme]] [[verilog]] [[F2FS]] [[MRAM]] [[open-nvm]] [[cache]] [[LFS]] 용어 [[FTL]] [[LPN]] [[PPN]]</description></item><item><title>gutentags</title><link>http://makerdark98.dev/wiki/gutentags/</link><pubDate>Tue, 28 Apr 2020 21:21:45 +0900</pubDate><guid>http://makerdark98.dev/wiki/gutentags/</guid><description>발생한 문제점 git 에서 커밋할때마다 아래와 같은 에러로그가 뜬다 hint: Waiting for your editor to close the file... Error detected while processing DirChanged Autocommands for &amp;quot;*&amp;quot;: E475: Invalid argument: Channel doesn't exist E475: Invalid argument: Channel doesn't exist Error detected while processing function &amp;lt;SNR&amp;gt;149_nvim_job_exit_wrapper[1]..gutentags#ctags#on_job_exit[1]..gutentags#remove_job_by_data[2]..gutentags#remove_job: line 22: 해결책 : 아래줄을 추가해줘서 특정 filetypes를 제외해준다. 일단 지금은 gitcommit 만 필요해서 처리했고 나머진 나중에 천천히 추가할 예정 let g:gutentags_exclude_filetypes = [&amp;#39;gitcommit&amp;#39;]</description></item><item><title>Modern C++ Design Pattern/Chatper 18. 메멘토</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-18-%EB%A9%94%EB%A9%98%ED%86%A0/</link><pubDate>Tue, 28 Apr 2020 21:07:07 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-18-%EB%A9%94%EB%A9%98%ED%86%A0/</guid><description>간략 설명 커맨드 패턴에서 이론적으로 과거의 어떤 지점으로 상태를 되돌릴수 있다 메멘토 패턴은 모든 임의의 과거가 아니라 필요할 때 특정 시점으로 되돌리기만 하면 될때 사용한다. 특정 시점의 시스템 상태를 저장하고, 읽기 전용 속성을 가지고 자체적으로 아무 동작을 안하는 객체를 만든다 (이걸 토큰이라고 부르기도 한다) 특징 불변 속성을 가진다. 저장된 잔고 값이 나중에 변경될 수 있다면 존재한 적 없는 과거 상태로 되돌리는게 가능해져 버린다. 대상 객체에 friend로 선언한다. 필드 변수에 접근하기 위해 필수적으로 필요하다.</description></item><item><title>Modern C++ Design Pattern/Chatper 17. 매개자</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-17-%EB%A7%A4%EA%B0%9C%EC%9E%90/</link><pubDate>Mon, 27 Apr 2020 21:43:50 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-17-%EB%A7%A4%EA%B0%9C%EC%9E%90/</guid><description>간단 설명 서로 다른 컴포넌트 간에 포인터나 직접적인 참조를 통한 커뮤니케이션이 필요하다 일부 경우 상대방 객체의 존재를 알아야하는점, 객체의 생성/소멸 시점에대한 관리 때문에 포인터나 참조로 접근하는게 불안정할 수 있다. 이를 위한 매커니즘 전역 정적 변수이거나 모든 컴포넌트에 그 참조가 노출되어야 한다. 내용 여기서는 Boost.Signals2 라이브러리를 사용해서 구현한다. 잘 모르겠다. 일단 요약부분만 적고 나중에 필요하면 찾아보자 요약 매개자 디자인 패턴은 시스탬 내 컴포넌트 모두가 참조할 수 있는 어떤 중간자를 컴포넌트 간에 서로 직접적으로 참조하지 않더라도 커뮤니케이션을 할수 있게 한다는 것을 기본아이디어로 한다.</description></item><item><title>boj</title><link>http://makerdark98.dev/wiki/boj/</link><pubDate>Mon, 27 Apr 2020 21:37:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/boj/</guid><description>리스트 10830 제출 (MOD 주의하자) 1300 제출 (long long 주의하자) 2261 line sweep으로 푼거 다시 제출 (시간복잡도 잘 생각하기) 1167 dfs 를 주의하면서 짜자 11725 12025 index_tree 로 풀어보기 (압축하는데 시간이 생각보다 많이드나? ㅠ 조금더 고민해보자) 1967 : 1167 하고 똑같네 1086 : 50자 때문에 삽질을 엄청 많이 했다.. 입력이 숫자라고 해서 항상 long long 으로 입력 받을수 있는 건 아니란걸 다시 상기하게 됬다. 이외에도 자리수를 셀때 모듈러 한걸 그 숫자라고 생각해서 삽질을 많이 했다.</description></item><item><title>Modern C++ Design Pattern/Chatper 16. 반복자</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-16-%EB%B0%98%EB%B3%B5%EC%9E%90/</link><pubDate>Tue, 21 Apr 2020 23:12:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-16-%EB%B0%98%EB%B3%B5%EC%9E%90/</guid><description>간략 설명 복잡한 데이터 구조를 다루어야 할 때 데이터 순회 문제를 해결하는 방법 표준 라이브러리의 반복자 begin end rbegin rend cbegin cend crbegin crend 이진 트리의 탐색 template &amp;lt;typename U&amp;gt; struct PreOrderIterator; template &amp;lt;typename T&amp;gt; struct BinaryTree; template &amp;lt;typename T&amp;gt; struct Node { T value; Node&amp;lt;T&amp;gt; *left = nullptr; Node&amp;lt;T&amp;gt; *right = nullptr; Node&amp;lt;T&amp;gt; *parent = nullptr; BinaryTree&amp;lt;T&amp;gt;* tree = nullptr; explicit Node(const T&amp;amp; value) : value(value) {} Node(const T&amp;amp; value, Node&amp;lt;T&amp;gt;* const left, Node&amp;lt;T&amp;gt;* const right) : value(value), left(left), right(right) { this-&amp;gt;left-&amp;gt;tree =this-&amp;gt;right-&amp;gt;tree = tree; this-&amp;gt;left-&amp;gt;parent = this-&amp;gt;right-&amp;gt;parent = this; } void set_tree(BinaryTree&amp;lt;T&amp;gt;* t) { tree = t; if (left) left-&amp;gt;set_tree(t); if (right) right-&amp;gt;set_tree(t); } }; template &amp;lt;typename T&amp;gt; struct BinaryTree { Node&amp;lt;T&amp;gt;* root = nullptr; explicit BinaryTree(Node&amp;lt;T&amp;gt;* const root) : root{ root } { root-&amp;gt;set_tree(this); } typedef PreOrderIterator&amp;lt;T&amp;gt; iterator; iterator begin() { Node&amp;lt;T&amp;gt;* n = root; if (n) while (n-&amp;gt;left) n = n-&amp;gt;left; return iterator{ n } } iterator end() { return iteraotr { nullptr }; } }; template &amp;lt;typename U&amp;gt; struct PreOrderIterator { Node&amp;lt;U&amp;gt;* current; explicit PreOrderIterator(Node&amp;lt;U&amp;gt;* current) : current(current) { } bool operator!</description></item><item><title>회고/2020.04.20</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.04.20/</link><pubDate>Mon, 20 Apr 2020 23:11:34 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.04.20/</guid><description>회고 고작 12일 만에 쓰는 회고다. 아무래도 위키를 계속 사용하다보니 회고가 눈에 띄여서 쓰게되는 것 같다. 지난 12일 간 큰 일은 없다. 아마도? 장혁진 선배에게 상장을 카톡으로 받았다. (실물로 받으면 좋겠지만) 여전히 휴가는 못나가는 상태이다. 코로나 사태가 생각보다 장기화 되고 있다 모각코(모여서 각자 코딩)을 오늘 시도했다. 현재는 도운이형만 같이 하고 있는데 나중에는 조금더 많은 사람들이 했으면 좋겠다. 이번에는 7시부터 9시까지 진행했다. 나는 백준을 풀었고, 도운이 형은 C++로 네트워크 프레임워크를 짜고있는 듯 하다.</description></item><item><title>Modern C++ Design Pattern/Chatper 15. 인터프리터</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-15-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</link><pubDate>Mon, 20 Apr 2020 22:46:23 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-15-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</guid><description>인터프리터 디자인 패턴? 입력 데이터를 해석하는 것 대부분 텍스트이지만 텍스트에 한정되지는 않음. 요약 &amp;hellip; 이책에서 굳이 이 내용을 다루는 이유를 모르겠다. 차라리 Lex/Yacc를 보는게 좋다고 생각한다. 아마도 Boost.Spirit을 알려주고 싶어서 굳이 끼워넣은 느낌? 키워드만 정리하자면, AST, Lex/Yacc</description></item><item><title>Modern C++ Design Pattern/Chatper 14. 커맨드</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-14-%EC%BB%A4%EB%A7%A8%EB%93%9C/</link><pubDate>Sun, 19 Apr 2020 21:40:23 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-14-%EC%BB%A4%EB%A7%A8%EB%93%9C/</guid><description>필요성 어떤 객체를 활용할 때 직접 그 객체의 API를 호출하여 조작하는 대신, 작업을 어떻게 하라고 명령을 보내는 방식을 제안한다. 시나리오 struct BankAccount { int balance = 0; int overdraft_limit = -500; void deposit(int amount) { balance += amount; cout &amp;lt;&amp;lt; &amp;#34;deposited &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34;, balance is now &amp;#34; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } void withdraw(int amount) { if (balance - amount &amp;gt;= overdraft_limit) { balance -= amount; cout &amp;lt;&amp;lt; &amp;#34;withdrew &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34;, balance is now &amp;#34; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } } }; 커맨드 패턴의 구현 struct Command { virtual void call() const = 0; }; struct BankAccountCommand : Command { BankAccount&amp;amp; account; enum Action { deposit, withdraw } action; int amount; BankAccountCommand(BankAccount&amp;amp; account, const Action action, const int amount) : account(account), action(action), amount(amount) {} void call() const override { switch (action) { case deposit: account.</description></item><item><title>Modern C++ Design Pattern/Chatper 13. 책임사슬(Chain of Responsibility)</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-13-%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/</link><pubDate>Sat, 18 Apr 2020 22:14:11 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-13-%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/</guid><description>시나리오 struct Creature { string name; int attack, defense; // Constructor, operator... }; 포인터 사슬 class CreatureModifier { CreatureModifier* next{nullptr}; protected: Creature&amp;amp; creture; // reference, pointer or shared_ptr public: explicit CreatureModifier(Creature&amp;amp; creature) : creature(creture) {} void add(CreatureModifier* cm) { if (next) next-&amp;gt;add(cm); else next =cm; } virtual void handle() { if (next) next-&amp;gt;handle(); } }; 참조를 넘겨받아 저장하고 변경할 준비 추상 클래스가 아님 next는 다음 변경 작업을 가리킴 add()를 통해서 작업 사슬에 연결하여 추가 handle() 맴버 함수는 단순히 다음 항목을 처리한다.</description></item><item><title>coc (vim plugin coc)</title><link>http://makerdark98.dev/wiki/coc/</link><pubDate>Wed, 15 Apr 2020 23:13:04 +0900</pubDate><guid>http://makerdark98.dev/wiki/coc/</guid><description>간단 설명 Visual Studio Code 와 동시에 나온 Language Server (동시에 나왔는지는 확실치 않음)을 vim에도 적용하는 플러그인이다. 일부 언어들은 이미 이 플러그인을 만든 사람이 쉽게쉽게 설치 가능하도록 해놨다. 다른 언어는 삽질을 해서 알아냈다. 설치하기 Plug &amp;#39;neoclide/coc.nvim&amp;#39;, { &amp;#39;do&amp;#39;: &amp;#39;./install.sh&amp;#39; } vimrc에 추가했다. 공식 github를 참고한거랑 다르게 썻는데, 공식에 나온대로 하니 잘 설치가 안되서 하다보니 저렇게 해서 됬다. 설치 삽질기 Vim-Plug가 말썽을 부린건지, git clone 과정에서 자꾸 실패했다.</description></item><item><title>Regular Expression (regex)</title><link>http://makerdark98.dev/wiki/regex/</link><pubDate>Mon, 13 Apr 2020 23:48:20 +0900</pubDate><guid>http://makerdark98.dev/wiki/regex/</guid><description>정규 표현식 문법 ^x : x문자로 시작됨 x$ : x문자로 종료됨 .x : 임의의 문자 자주 쓰는 정규표현식 이메일 : ^[a-z0-9_+.-]+@([a-z0-9]+\.)+[a-z0-9]{2,4}$ URL : ^(file|gopher|news|nntp|telnet|https?|ftps?|sftp):\/\/([a-z0-9-]+\.)+[a-z0-9]{2,4}.*$ HTML : \&amp;lt;(/?[^\&amp;gt;]+)\&amp;gt;/ 전화번호 : (\d{3}).*(\d{3, 4}).*(\d{4}) 특정 확장자를 가진 파일명 : ([^\s]+(?=\.(jpg|png|mp3))\.\2) 1부터 50 사이의 번호 - 1과 50 포함 : ^[1-9]{1}|^[1-4]{1}[0-9]{1}$|^50 16 진수 색 코드 : #?([A-Fa-f0-9]){3}(([A-Fa-f0-9]){3})? 적어도 소문자 하나, 대문자 하나, 숫자 하나가 포함되어 있는 8글자~15글자 : (?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,15}</description></item><item><title>glob</title><link>http://makerdark98.dev/wiki/glob/</link><pubDate>Mon, 13 Apr 2020 22:06:38 +0900</pubDate><guid>http://makerdark98.dev/wiki/glob/</guid><description>glob Wikipedia In computer programming, glob patterns specify sets of filenames with wildcard characters. For example, the Unix Bash shell command mv *.txt textfiles/ moves (mv) all files with names ending in .txt from the current directory to the directory textfiles. Here, * is a wildcard standing for &amp;ldquo;any string of characters&amp;rdquo; and *.txt is a glob pattern. The other common wildcard is the question mark (?), which stands for one character.</description></item><item><title>Modern C++ Design Pattern/Chapter 12. 프록시</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-12-%ED%94%84%EB%A1%9D%EC%8B%9C/</link><pubDate>Sun, 12 Apr 2020 23:10:03 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-12-%ED%94%84%EB%A1%9D%EC%8B%9C/</guid><description>스마트 포인터 가장 단순하면서도 직접적인 프록시 패턴의 예 속성 프록시 다른 프로그래밍 언어에서는 get/set 메서드를 지원하는 경우도 있음. template &amp;lt;typename T&amp;gt; struct Property { T value; Property(const T initial_value) { *this = initial_value; } operate T() { return value; } T operator=(T new_value) { return value = new_value; } } struct Creature { Property&amp;lt;int&amp;gt; strength{ 10 }; Property&amp;lt;int&amp;gt; agility{ 5 }; } Creature creature; creature.agility = 20; auto x = creature.</description></item><item><title>hugo</title><link>http://makerdark98.dev/wiki/hugo/</link><pubDate>Sun, 12 Apr 2020 20:41:09 +0900</pubDate><guid>http://makerdark98.dev/wiki/hugo/</guid><description>draft가 true인 것들 보기 $ hugo list drafts</description></item><item><title>tee (Linux Command)</title><link>http://makerdark98.dev/wiki/tee/</link><pubDate>Sun, 12 Apr 2020 20:29:35 +0900</pubDate><guid>http://makerdark98.dev/wiki/tee/</guid><description>사용 용도 stdin을 stdout 과 파일로 모두 보내고 싶을때</description></item><item><title>rm (Linux Command)</title><link>http://makerdark98.dev/wiki/rm/</link><pubDate>Sun, 12 Apr 2020 20:22:32 +0900</pubDate><guid>http://makerdark98.dev/wiki/rm/</guid><description>자주 사용하는 거 모음 특정 파일 제외하고 지우기 단일 $ rm -v !(&amp;#34;filename&amp;#34;) 다중 $ rm -v !(&amp;#34;filename1&amp;#34; | &amp;#34;filename2&amp;#34;) 만약 zsh을 쓰고 있다면 $ setopt extendedglob $ rm ^(&amp;#34;filename1&amp;#34; | &amp;#34;filename2&amp;#34;) Delete Files Using Extended Pattern Matching Operators *(pattern-list) : matches zero or more occurrences of the specified patterns ?(pattern-list) : matches zero or one occurence of the specified patterns +(pattern-list) : matches one or more occurrences of the spcified patterns @(pattern-list) : matches one of the spcified patterns !</description></item><item><title>Modern C++ Design Pattern/Chapter 11. 플라이웨이트</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-11-%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/</link><pubDate>Sat, 11 Apr 2020 23:28:27 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-11-%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/</guid><description>플라이웨이트 패턴 : 많은 수의 가벼운 임시 객체들을 &amp;ldquo;스마트 참조&amp;quot;로 사용하는 것을 말하며, 그러한 객체들을 플라이웨이트라고 부른다. 사용자 이름 struct User { User(const string&amp;amp; first_name, const string&amp;amp; last_name) : first_name{add(first_anem)}, last_name{add(last_name)} {} protected: key first_name, last_name; static bimap&amp;lt;key, string&amp;gt; names; // boost:bimap(양방향 map) static key seed; static key add(const string&amp;amp; s) { ...} }; static key add(const string&amp;amp; s) { auto it = names.right.find(s); if (it == names.</description></item><item><title>Modern C++ Design Pattern/Chapter 10. 퍼사드</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-10-%ED%8D%BC%EC%82%AC%EB%93%9C/</link><pubDate>Thu, 09 Apr 2020 23:56:51 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-10-%ED%8D%BC%EC%82%AC%EB%93%9C/</guid><description>퍼사드는 어디에 있는가? struct Console { vector&amp;lt;Viewport*&amp;gt; viewports; Size charSize, gridSize; }; Console::Console(bool fullscreen, int char_width, int char_height, int width, int height, optional&amp;lt;Size&amp;gt; client_size) { // Implement } Console::Console(const ConsoleCreateionParamters* ccp) { ... } struct ConsoleCreationParameters { optional&amp;lt;Size&amp;gt; client_size; int character_width{10}; int character_height{14}; int width{20}; int height{30}; bool fullscreen{false}; bool create_default_view_and_buffer{true}; }; 요약 하나 이상의 복잡한 서브 시스템 앞에 단순한 인터페이스를 두기 위한 방법</description></item><item><title>Effective Debugging/Chatper 7. 컴파일 시간 기법</title><link>http://makerdark98.dev/wiki/effective-debugging/chapter-7-%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/</link><pubDate>Thu, 09 Apr 2020 22:13:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chapter-7-%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/</guid><description>Item 54. 테스트 케이스를 작성하여 오류 찾기 문제를 안정적으로 재현할 수 있도록 테스트 케이스 작성 테스트 케이스를 최소한으로 간소화 안정장치 확보 (찾아낸 문제만 걸러내는 단위 테스트나 회귀 테스트를 코드에 추가한다.) 기억할 사항 제대로 작성된 최소한의 테스트 케이스를 통해 오류가 발생하는 지점과 해결책을 찾을 수 있다. 사용한 테스트 케이스는 단위 테스트나 회귀 테스트 형태로 소프트웨어에 추가한다. Item 55. 오류가 발생한 즉시 프로그램 중단하기 루틴의 입력값을 검사하거나 호출한 API가 정상적으로 실행됬는지 확인할 때 Assertion을 활용한다.</description></item><item><title>Effective Debugging/Chatper 8. 멀티스레드 코드 디버깅</title><link>http://makerdark98.dev/wiki/effective-debugging/chapter-8-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/</link><pubDate>Thu, 09 Apr 2020 22:13:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chapter-8-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/</guid><description>Item 60. 사후 디버깅으로 교착 상태 분석하기 교착상태를 디버깅할 때는 교착 상태에 빠진 시점의 프로그램 상태(스냅샵)를 구한 뒤, 스레드나 코드 흐름에서 자원을 기다리는 코드 지점을 찾아낸다. Item 61. 프로그램의 실행 흐름을 기록한 뒤 재생하기 발생 빈도가 낮은 동시성 오류를 찾을때는 오류가 발생하는 상황을 기록하고, 그 내용을 분석해서, 기록된 데이터를 다시 디버거로 재생하는 방식으로 작업한다. Item 62. 전문 도구로 교착 상태와 경쟁 상태 찾기 정적 분석 도구를 이용하여 멀티스레드 프로그램에 존재하는 동기화 및 잠금 관련 에러를 걸러낸다.</description></item><item><title>TODO Lists</title><link>http://makerdark98.dev/wiki/todo/</link><pubDate>Wed, 08 Apr 2020 23:56:59 +0900</pubDate><guid>http://makerdark98.dev/wiki/todo/</guid><description>생활측면 손톱 물어뜯는 습관 고치기 위해 물품 사기 공부 SSD [.] simplessd [o] host interface layer simplessd 공식 문서 읽기 [o] linux kernel 에서 해당하는 부분 공부하기 workqueue 공부하기 bio 공부하기 scsi 공부하기 [.] open-nvm 에서 controller 에 해당하는 부분 공부하기 [o] verilog 공부하기 기본 문법 공부하기 FPGA 공부하기 순서 그리기 Internal Cache Layer Flash Translation Layer Database [.</description></item><item><title>vim</title><link>http://makerdark98.dev/wiki/vim/</link><pubDate>Wed, 08 Apr 2020 23:44:39 +0900</pubDate><guid>http://makerdark98.dev/wiki/vim/</guid><description>까먹을만한 단축키 리스트 &amp;lt;Leader&amp;gt;ww : vimwiki index page (Leader는 ,으로 걸어놨다.) &amp;lt;F4&amp;gt; : 위키에서 단어 검색 &amp;lt;S-F4&amp;gt; : 현재 문서를 링크한 모든 문서 검색 &amp;lt;Leader&amp;gt;b : 열린 Buffer들 확인 &amp;lt;Leader&amp;gt;f : find pattern &amp;lt;Leader&amp;gt;e : find file by FZF &amp;lt;Leader&amp;gt;tt : toggle todo list UltiSnip 어캐쓰는지 아직 잘 모르겠다.ㅠ 더 읽어봐야겠다. vimwiki [[vimwiki]] coc 엄청 삽질해서 적용했다. ㅠ 나중에 글로 하나 뺴도 괜찮을 듯 [[coc]] tag [[gutentags]]</description></item><item><title>vimwiki</title><link>http://makerdark98.dev/wiki/vimwiki/</link><pubDate>Wed, 08 Apr 2020 22:51:20 +0900</pubDate><guid>http://makerdark98.dev/wiki/vimwiki/</guid><description>Vimwiki 설정 Vimwiki를 메인으로 쓰기로 결정한 이상, 훨씬 더 잘 활용해서 (예를 들어 단축키같이) 사용하고 싶어졋다. 찾아보니 한국어 자료로는 기계인간님의 위키가 압도적으로 자료가 많아서 거기를 참고하기로 했다. 설정도 그분이 그렇게 쓰는데에는 이유가 있다고 생각해서 그렇게 하기로 했다. 나보다는 훨씬 더 vim을 잘쓰실테니 단축키 설정 기계 인간 님의 위키에 있는걸 그대로 따라하기로 했다. 겸사겸사 FZF도 설치만 해놓고 안썻는데 설정도 해봐야겠다. &amp;quot; vimwiki conceallevel let g:vimwiki_conceallevel = 0 &amp;quot;자주 사용하는 명령어에 단축키를 취향대로 매핑해둔다 &amp;quot; vimwiki command!</description></item><item><title>회고/2020.04.08</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.04.08/</link><pubDate>Wed, 08 Apr 2020 13:38:46 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.04.08/</guid><description>2020.04.08 회고</description></item><item><title>gandi.net</title><link>http://makerdark98.dev/wiki/gandi.net/</link><pubDate>Tue, 07 Apr 2020 22:55:59 +0900</pubDate><guid>http://makerdark98.dev/wiki/gandi.net/</guid><description>Gandi.net https://www.gandi.net/en</description></item><item><title>cloudatcost</title><link>http://makerdark98.dev/wiki/cloudatcost/</link><pubDate>Tue, 07 Apr 2020 22:55:20 +0900</pubDate><guid>http://makerdark98.dev/wiki/cloudatcost/</guid><description>CloudatCost panel 주소 https://panel.cloudatcost.com/index.php# ID/PW 아이디는 네이버 메일, 패스워드는 네이버 메일에서 cloudatcost 검색하면 최근에 reset한 메일이 있다. panel 은 패스워드가 다르다 맨마지막쯔음에 저장되어 있다.</description></item><item><title>web</title><link>http://makerdark98.dev/wiki/web/</link><pubDate>Tue, 07 Apr 2020 22:52:05 +0900</pubDate><guid>http://makerdark98.dev/wiki/web/</guid><description>Tool [[nginx]] [[cloudatcost]] [[gandi.net]] Projects [[my-page]] Basics [[Load-Balance]]</description></item><item><title>nginx</title><link>http://makerdark98.dev/wiki/nginx/</link><pubDate>Tue, 07 Apr 2020 22:51:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/nginx/</guid><description>Nginx 관련 Nginx log위치 /var/log/nginx/access.log /var/log/nginx/error.log</description></item><item><title>정우 대회</title><link>http://makerdark98.dev/wiki/%EC%A0%95%EC%9A%B0-%EB%8C%80%ED%9A%8C/</link><pubDate>Tue, 07 Apr 2020 20:49:06 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%A0%95%EC%9A%B0-%EB%8C%80%ED%9A%8C/</guid><description>계기 정우가 학교에서 대회를 여는데 구현 위주의 문제이고, 한번 풀어봐달라고 해서 푼 코드 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; set&amp;lt;string&amp;gt; visited; bool chk(string data, vector&amp;lt;int&amp;gt; count) { for (auto&amp;amp; c : data) count[c-&amp;#39;a&amp;#39;] --; for(int i=0;i&amp;lt;26;i++) if (count[i] != 0) return false; return true; } vector&amp;lt;string&amp;gt; gen(string data) { vector&amp;lt;string&amp;gt; retval; string f, b, f_r, b_r; vector&amp;lt;string&amp;gt; r; if (data.size() == 1) retval.</description></item><item><title>Operating System Summary</title><link>http://makerdark98.dev/wiki/operating-system-summary/</link><pubDate>Tue, 07 Apr 2020 20:48:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/operating-system-summary/</guid><description>1. Computer System Overview Basic Elements : Processor, Main memory, I/O modules, System bus Basic Instruction Cycle Start → (Fetch next instruction → Execute instruction) → HALT Processor-memory, Processor-I/O, Data processing, Control</description></item><item><title>Understandign Linux Kernel</title><link>http://makerdark98.dev/wiki/understanding-linux-kernel/</link><pubDate>Tue, 07 Apr 2020 20:48:28 +0900</pubDate><guid>http://makerdark98.dev/wiki/understanding-linux-kernel/</guid><description>1. Introduction Linux pros Monolithic kernel Compiled and statically linked traditional Unix kernels Kernel threading Multithreaded application support - lightweight processes(LWP) Preemptive kernel Multiprocessor support - symmetric multiprocessing(SMP) Filesystem STREAMS Basic Operating System Concepts Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. Provide an execution environment to the applications that run on the computer system (the so-called user programs) Multiuser Systems An authentication mechanism for verifying the user&amp;rsquo;s identity A protection mechanism against buggy user programs that could block other applications running in the system A protection mechanism against malicious user programs that could interfere with or spy on the activity of others users An accounting mechanism that limits the amount of resource units assigned to each user Users and Groups User ID(UID), Group ID(GID) superuser Processes Process : An instance of a program in execution or execution context Multi Processing operating system with preemptable processes.</description></item><item><title>Mathematical Statistics</title><link>http://makerdark98.dev/wiki/mathematical-statistics/</link><pubDate>Tue, 07 Apr 2020 20:48:25 +0900</pubDate><guid>http://makerdark98.dev/wiki/mathematical-statistics/</guid><description>Chapter 7 Sampling distribution Definition 7.1 (Statistic) A statistic is a function of the observations in a sample and known constants. The distribution of a statistic is called the sampling distribution of the statistic. $$\bar Y: \text{sample mean}$$
$$S^2 : \text{sample variance}$$
$$Y_{(1)}, Y_{(n)} : \text{minimum and maximum (order statistics)}$$
$$\hat p : \text{sample proportion}$$
Theorem 7.1 $$\text{Suppose }Y_i \overset{iid}{\sim} N\left(0, 1^2 \right)$$
$$\bar Y \sim N(\mu, {\sigma^2\over{n}})$$</description></item><item><title>Effective Debugging</title><link>http://makerdark98.dev/wiki/effective-debugging/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/</guid><description>개인 생각 전체적으로 좋은 내용이 많았다고 생각된다. 하지만 실제로 디버깅할때 이 책의 모든 내용을 떠올리는 건 힘들다고 생각한다. 특히 중후반부부터 시작되는 툴들의 나열은 유의미하지 않았다. 맨 마지막에 상황별 도구 모음을 2~3 페이지에 걸쳐서 나열해줬으면 래퍼런스 북으로서 쓸수 있었을텐데 챕터별 요약 [[Effective Debugging/Chapter 1- 고차원 전략]] [[Effective Debugging/Chapter 2- 범용적인 디버깅 기법]] [[Effective Debugging/Chapter 3- 범용 도구를 활용한 기법]] [[Effective Debugging/Chatper 4- 디버거 활용법]] [[Effective Debugging/Chapter 5- 프로그래밍 기법]] [[Effective Debugging/Chatper 6- 컴파일 시간 기법]] [[Effective Debugging/Chapter 7- 실행 시간 기법]] [[Effective Debugging/Chapter 8- 멀티스레드 코드 디버깅]]</description></item><item><title>Effective Debugging/Chapter 1. 고차원 전략</title><link>http://makerdark98.dev/wiki/effective-debugging/chapter-1-%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chapter-1-%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/</guid><description>Item 1. Issue Tracking (모든 문제를 이슈 추적 시스템으로 관리하기) Github, GitLab JIRA, Bugzilla, Launchpad, OTRS, Redmine, Trac 장점 디버깅 작업 과정을 명확하게 파악할 수 있다. 릴리즈 일정을 수립하게 추적할 수 있다. 작업의 우선순위를 정할 수 있다. 자주 발생하는 이슈나 해결책을 문서로 정리할 수 있다. 해결해야 할 문제를 실수로 빼먹지 않을 수 있다. 릴리즈 노트를 자동으로 생성할 수 있다. 결함을 측정하고, 이를 되돌아보며 교훈을 얻을 수 있는 저장소로 활용할 수 있다.</description></item><item><title>Effective Debugging/Chapter 2. 범용적인 디버깅 기법</title><link>http://makerdark98.dev/wiki/effective-debugging/chapter-2-%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chapter-2-%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/</guid><description>Item 9. 성공적인 디버깅을 위한 마음가짐 소프트웨어에서 발생한 문제는 항상 찾아서 고칠수 있다고 믿는다. 시간을 충분히 판단한다. 고도로 집중한다. 어려운 문제를 만나면 잠을 자는것도 좋다. 기억할 사항 모든 문제는 찾아서 고칠 수 있다고 믿는다. 디버깅 작업에 필요한 시간을 충분히 확보한다. 작업에 최대한 집중할 수 있도록 환경을 마련한다. 힘든 문제를 해결할 때는 효과적인 수면을 취한다. 포기하지 않는다. 디버깅 환경, 도구, 기법을 익히는 데 꾸준히 노력한다. Item 10. 효율적으로 문제 상황 재현하기 효율적으로 문제 상황을 재현하는 것이 가지는 장점 오류를 만들어 내기 위해 시간을 낭비할 필요 없이 곧바로 원인을 해결하는데 집중할 수 있다.</description></item><item><title>Effective Debugging/Chapter 3. 범용 도구를 활용한 기법</title><link>http://makerdark98.dev/wiki/effective-debugging/chapter-3-%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chapter-3-%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/</guid><description>읽을거리
The Art of Command Line(https://github.com/jlevy/the-art-of-command-line) Item 22. 유닉스 명령줄 도구로 디버깅 데이터 분석하기 아래와 같은 순서로 스크립트를 작성한다. 가져오기(Fetching) 선택하기(Selecting) 처리하기(Processing) 정리하기(Summarizing) 읽을거리를 참고해서 CLI 사용법을 좀 더 잘 익히자 기억할 사항 텍스트 형태의 레코드를 가져오고, 선택하고, 처리하고, 정리하는 유닉스 명령어를 이용하여 디버깅 데이터를 분석한다. 여러 가지 유닉스 명령을 파이프라인으로 조합하는 방식으로 복잡한 분석 작업을 간단히 처리할 수 있다. Item 23.</description></item><item><title>Effective Debugging/Chapter 5. 프로그래밍 기법</title><link>http://makerdark98.dev/wiki/effective-debugging/chapter-5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chapter-5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/</guid><description>Item 38. 의심스런 코드를 검토하고 손으로 실행해보기 코드를 작성할 때 흔히 저지르는 실수를 하지 않았는지 살펴본다. 코드가 정확하게 동작하는지 직접 손으로 실행해서 확인한다. 복잡한 자료구조는 그림으로 쉽게 표현한다. 복잡한 코드를 쉽게 표현할 때는 종이나 화이트보드의 공간을 넉넉히 확보하고 색깔도 적절히 활용한다. 실제 물체를 활용하면 문제에 좀 더 집중할 수 있다. Item 39. 동료 검토하기 자신이 작성한 코드를 고무 오리에게 설명한다. 동료 검토를 비롯한 코드 리뷰 과정을 거친다. 다양한 개체가 엮인 코드에서 발생한 오류를 디버익할 떄는 역할 놀이 방식을 적용한다.</description></item><item><title>Effective Debugging/Chatper 4. 디버거 활용법</title><link>http://makerdark98.dev/wiki/effective-debugging/chatper-4-%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chatper-4-%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/</guid><description>Item 28. 디버깅 버전으로 컴파일 하기 이클립스에서 자바 코드를 디버깅할 때 기본적으로 심볼 정보가 생성된다. 옵션을 다르게 줘서 원하는 설정으로 바꿀수 있다. 오라클 JDK 컴파일러에서는 -g 옵션으로 디버깅 정보와 이를 제어하기 위한 다양한 인수를 추가할 수 있다. 유닉스 컴파일러는 대부분 -g 옵션으로 디버깅 정보를 추가할 수 있다. 마이크로소프트에서 제공하는 컴파일러에서는 /Zi 옵션을 지정하면 디버깅 정보가 추가된다. 팁 최신 컴파일러는 상당히 높은 수준으로 최적화하기 때문에 코드의 형태가 완전히 바뀌기도 한다.</description></item><item><title>Effective Debugging/Chatper 6. 컴파일 시간 기법</title><link>http://makerdark98.dev/wiki/effective-debugging/chatper-6-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/</link><pubDate>Tue, 07 Apr 2020 20:44:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/effective-debugging/chatper-6-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/</guid><description>Item 50. 생성된 코드 확인하기 컴파일러에서 생성한 코드를 살펴보면 컴팡리 및 실행 시간에 발생한 문제가 소스 코드의 어느 부분에 관련이 있는지 찾아낼 수 있다. 컴파일러로 생성된 코드를 좀 더 읽기 좋게 표현하려면 컴파일러에 적절한 옵션을 지정하거나 특수한 도구를 사용한다. Item 51. 정적 분석 도구 활용하기 자주하는 실수 모음 널 포인터 참조 동시성 오류 및 경쟁 상태 철자 오류 (변수를 명시적으로 선언하지 않아도 되는 언어에서 주로 발생함) 배열이나 메모리 버퍼에 대한 잘못된 인덱스 참조 잘못된 조건문, 반복문, case문으로 인해 실행될 수 없는 문장 처리하지 않은 예외 사용하지 않는 변수나 루틴 수식 오류 중복된 코드 C++에서의 3의 법칙이나 0의 법칙을 따르지 않거나, 자바에서 클래스를 정의할 때 equals/HashCode 메서드를 일고나성이 없는 형태로 구현한 경우 자원 누수 보안 취약점 문법 오류 기억할 사항 정적 프로그램 분석 도구를 활용하면 컴파일러 경고 메시지로 찾지 못한 잠재적인 버그를 발견할 수 있다.</description></item><item><title>Modern C++ Design Pattern</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/</guid><description>Summary [[Modern C++ Design Pattern/Chapter 1- 개요]] 제 1부 생성 패턴 [[Modern C++ Design Pattern/Chapter 2- 빌더]] [[Modern C++ Design Pattern/Chapter 3- 팩토리]] [[Modern C++ Design Pattern/Chapter 4- 프로토타입]] [[Modern C++ Design Pattern/Chapter 5- 싱글턴]] 제 2부 구조 패턴 In design step, we use well-known three ways. Inheritance Composition Aggregation : One object can be independant nevertheless the object refer to another object. For example, T* or shared_ptr&amp;lt;T&amp;gt; [[Modern C++ Design Pattern/Chapter 6- 어댑터]] [[Modern C++ Design Pattern/Chapter 7- 브릿지]] [[Modern C++ Design Pattern/Chapter 8- 컴포지트]] [[Modern C++ Design Pattern/Chapter 9- 데코레이터]] [[Modern C++ Design Pattern/Chapter 10- 퍼사드]] [[Modern C++ Design Pattern/Chapter 11- 플라이웨이트]] [[Modern C++ Design Pattern/Chapter 12- 프록시]] [[Modern C++ Design Pattern/Chapter 13- 책임사슬(Chain of Responsibility)]] [[Modern C++ Design Pattern/Chapter 14- 커맨드]] [[Modern C++ Design Pattern/Chapter 15- 인터프리터]] [[Modern C++ Design Pattern/Chapter 16- 반복자]] [[Modern C++ Design Pattern/Chapter 17- 매개자]] [[Modern C++ Design Pattern/Chapter 18- 메멘토]]</description></item><item><title>Modern C++ Design Pattern/Chatper 1. 개요</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-1-%EA%B0%9C%EC%9A%94/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-1-%EA%B0%9C%EC%9A%94/</guid><description>CRTP(Curiously Recurring Template Pattern) struct Foo : SomeBase&amp;lt;Foo&amp;gt; { ... } template &amp;lt;typename Derived&amp;gt; struct SomeBase { void foo() { for (auto&amp;amp; item : *static_cast&amp;lt;Derived*&amp;gt;(this)) { ... } } } Property class Person { private: int age_; public: int get_age() const {return age_; } void set_age(int value) {age_ = value; } __declspec(property(get=get_age, put=set_age)) int age; } Person p; p.age = 20; // calls p.set_age(20) Factory Factory Method struct Point { protected: Point(const float x, const float y) : x {x}, y {y} {} public: static Point NewCartesian(float x, float y) { return {x, y}; } static Point NewPolar(float r, float theta) { return {r * cos(theta), r * sin(theta)}; } // skip }; SOLID Design Principle SRP(Single Responsibility Principle) If you need to edit a few classes(or little more?</description></item><item><title>Modern C++ Design Pattern/Chatper 2. 빌더</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-2-%EB%B9%8C%EB%8D%94/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-2-%EB%B9%8C%EB%8D%94/</guid><description>Builder Pattern Simple Builder struct HtmlBuilder { HtmlElement root; HtmlBuilder(string root_name) { root.name = root_name; } void add_child(string child_name string child_text) { HtmlElement e{ child_name, child_text }; root.elements.emplace_back(e); } string str() { return root.str(); } }; Fluent Builder struct HtmlBuilder { HtmlElement root; HtmlBuilder(string root_name) { root.name = root_name; } HtmlBuilder&amp;amp; add_child(string child_name string child_text) { HtmlElement e{ child_name child_text }; root.elements.emplace_back(e); return *this; } /* skip */ }; HtmlBuilder builder{ &amp;#34;ul&amp;#34; }; builder.</description></item><item><title>Modern C++ Design Pattern/Chatper 3. 팩토리</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-3-%ED%8C%A9%ED%86%A0%EB%A6%AC/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-3-%ED%8C%A9%ED%86%A0%EB%A6%AC/</guid><description>Factory Class struct Point { float x, y; friend class PointFacotry; private: Point(float x, float y) : x(x), y(y) {} }; struct PointFactory { static Point NewCartesian(float x, float y) { return Point{x, y}; } static Point NewPolar(float r, flaot theta) { return Point{r * cos(theta), r * sin (theta)}; } }; Inner Factory struct Point { private: Point(float x, float y) : x(x), y(y) {} struct PointFactory { private: PointFactory() {} public : static Point NewCartesian (float x, float y) { return {x, y}; } static Point NewPolar (float r, float theta) { return {r * cos(theta), r * sin (theta)}; } }; public: float x, y; static pointFactory Factory; }; Abstract Factory struct HotDrink { virtual void prepare (int volume) = 0; }; struct Tea: HotDrink { void prepare (int volume) override { cout &amp;lt;&amp;lt; &amp;#34;Take tea bag, boil water, pour&amp;#34; &amp;lt;&amp;lt; volume &amp;lt;&amp;lt; &amp;#34;ml, add some lemon&amp;#34; &amp;lt;&amp;lt; endl; } }; class DrinkFactory { map&amp;lt;string, unique_ptr&amp;lt;HotDrinkFactory&amp;gt;&amp;gt; hot_factories; public: DrinkFactory() { hot_factories[&amp;#34;coffee&amp;#34;] = make_unique&amp;lt;CoffeeFactory&amp;gt;(); hot_factories[&amp;#34;tea&amp;#34;] = make_unique&amp;lt;TeaFactory&amp;gt;(); } unique_ptr&amp;lt;HotDrink&amp;gt; make_drink(const string&amp;amp; name) { auto drink = hot_factories[name] -&amp;gt; make(); drink-&amp;gt;prepare(200); // 200 must be changed other constant variable return drink; } }; Functional Factory class DrinkWithVolumeFactory { map&amp;lt;string, function&amp;lt;unique_ptr&amp;lt;HotDrink&amp;gt;()&amp;gt;&amp;gt; factories; public: DrinkWithVolumeFactory() { factories[&amp;#34;tea&amp;#34;]= [] [ auto tea = make_unique&amp;lt;Tea&amp;gt;(); tea-&amp;gt;prepare(200); return tea; }; } }; inline unique_ptr&amp;lt;HotDrink&amp;gt; DrinkWithVolumeFactory:: make_drink(const string&amp;amp; name) { return factories[name](); } Summary &amp;ldquo;Factory Method&amp;rdquo;, which is member function of creation type, create object and return it.</description></item><item><title>Modern C++ Design Pattern/Chatper 4. 프로토타입</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/</guid><description>객체 생성 같은 값으로 중복되게 초기화 되는 작업이 발생 중복처리 struct Address { string street, city; int suite; } struct Contact { string name; Address address; } struct Contact { string name; Address* address; } 복제 생성자를 통한 중복 초기화 복제 생성자를 배제하고 별도의 인터페이스 template &amp;lt;typename T&amp;gt; struct Clonable { virtual T clone() const = 0; } 직렬화(Serialization) struct Contact { string name; Address* address = nullptr; private: friend class boost:serialization::access; template&amp;lt;class Ar&amp;gt; void serialize(Ar&amp;amp; ar, const unsigned int version) { ar &amp;amp; name; ar &amp;amp; address; // *가 없다는 것에 주의 } }; auto clone = [](const Contact&amp;amp; c) { ostringstream oss; boost::achive::text_oarchive oa(oss); oa &amp;lt;&amp;lt; c; string s = oss.</description></item><item><title>Modern C++ Design Pattern/Chatper 5. 싱글턴</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-5-%EC%8B%B1%EA%B8%80%ED%84%B4/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-5-%EC%8B%B1%EA%B8%80%ED%84%B4/</guid><description>Singleton static Database database{}; /* not recommended */ /** * This method is only secured about MT(Multi Thread)-Safe on C++11 or Higher. */ Database&amp;amp; get_database() { static Database databse; return database; } Traditional Implementation struct Database { protected: Database() { /* Do something */ } public: static Database&amp;amp; get() { // MT-Safe on C++11 or Higher static Database database; return database; } Database(Database const&amp;amp;) = delete; Database(Database &amp;amp;&amp;amp;) = delete; Database&amp;amp; operator=(Database const&amp;amp;) = delete; Database&amp;amp; operator=(Database &amp;amp;&amp;amp;) = delete; }; You can think over inheritance of boost::noncopyable class if you don&amp;rsquo;t perfer to this by your hands.</description></item><item><title>Modern C++ Design Pattern/Chatper 6. 어댑터</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-6-%EC%96%B4%EB%8C%91%ED%84%B0/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-6-%EC%96%B4%EB%8C%91%ED%84%B0/</guid><description>Adapter Pattern We use a example case, drawiing geometric shape. struct Point { int x, y; }; struct Line{ Point start, end; }; struct VectorObject { virtual std::vector&amp;lt;Line&amp;gt;::iterator begin() = 0; virtual std::vector&amp;lt;Line&amp;gt;::iterator end() = 0; }; struct VectorRectangle : VectorObject { VectorRectangle(int x, int y, int width, int height) { lines.emplace_back(Line{ Point{x, y}, Point{x + width, y} }); lines.emplace_back(Line{ Point{x + width, y}, Point {x + width, y + height} }); lines.</description></item><item><title>Modern C++ Design Pattern/Chatper 7. 브릿지</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-7-%EB%B8%8C%EB%A6%BF%EC%A7%80/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-7-%EB%B8%8C%EB%A6%BF%EC%A7%80/</guid><description>Bridge Pattern Pimpl (Pointer to Implmentation) struct Person { string name; void greet(); Person(); ~Person(); class PersonImpl; PersonImpl *impl; // refer to gsl::owner&amp;lt;T&amp;gt; }; struct Person:PersonImpl { void greet(Person* p); } Person::Person() : impl(new PersonImpl) {} Person::~Person() { delete imple; } void Person::greet() { impl-&amp;gt;greet(this); } void Person::PersonImpl::greet(Person* p) { printf(&amp;#34;hello %s&amp;#34;, p-&amp;gt;name.c_str()); } Props Hide implementation. If Person class has many private/protected member variable, it is exposed though the header file to client.</description></item><item><title>Modern C++ Design Pattern/Chatper 8. 컴포지트</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-8-%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-8-%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/</guid><description>Composite Pattern How to announce the object has multiple composite attributes? It is not easy. Properties based on array. class Creature { int strength, agility, intelligence; public: int get_stringth() const { return strength; } void set_strength(int strength) { Creture::strength = strength; } // Other getter/setter.... int sum() const { return strength + agility + intelligence; } double average() const { return sum() / 3.0; } int max() const { return ::max(::max(strength, agility), intelligence); } }; It is not pretty.</description></item><item><title>Modern C++ Design Pattern/Chatper 9. 데코레이터</title><link>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-9-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-9-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/</guid><description>Decorator Dynamic Composition Static Composition Dynamic Decorator struct ColoredShape : Shape { Shape&amp;amp; shape; string color; ColoredShape(Shape&amp;amp; shape, const string&amp;amp; color) : shape{shape}, color{color} {} stinrg str() const override { ostringstream oss; oss &amp;lt;&amp;lt; shape.str() &amp;lt;, &amp;#34; Has the color &amp;#34; &amp;lt;&amp;lt; color; return oss.str(); } }; // Example Code Circle circle{0.5f}; ColoredShape redCircle{circle, &amp;#34;red&amp;#34;}; cout &amp;lt;&amp;lt; redCircle.str(); struct TransparentShape : Shape { Shape&amp;amp; shape; uint8_t transparency; TransparentShape(Shape&amp;amp; shape, const uint8_t transparency) : shape{shape}, transparency{transparency} {} string str() const override { ostringstream oss; oss &amp;lt;&amp;lt; shape.</description></item><item><title>Book Review</title><link>http://makerdark98.dev/wiki/book-reviews/</link><pubDate>Tue, 07 Apr 2020 20:43:34 +0900</pubDate><guid>http://makerdark98.dev/wiki/book-reviews/</guid><description>정리 끝난거 [[Effective Debugging]] 정리 하는 중 [[Modern C++ Design Pattern]] 정리 보류한거 [[Mathematical Statistics]] [[Understanding Linux Kernel]] [[Operating System Summary]] 정리하기로 생각해둔거 Effective Modern C++ Clean Code Pragmatic Programmer Algorithm Coding Interview Data Application</description></item><item><title>lectures/algorithm</title><link>http://makerdark98.dev/wiki/lectures/algorithm/</link><pubDate>Tue, 07 Apr 2020 20:37:08 +0900</pubDate><guid>http://makerdark98.dev/wiki/lectures/algorithm/</guid><description>Basic Sorting algorithm The most common uses of sorted sequences are making lookup or search efficient; making merging of sequences efficient enable processing of data in a defined order Sorting algorithm The output of any sorting algorithm must satisfy two conditions
The output is in non-decreasing order: each element is no smaller than the previous element according to the desired total order The output is a permutation meaning that a reordering, yet retaining all of the original elements of the input.</description></item><item><title>lectures/computer architecture</title><link>http://makerdark98.dev/wiki/lectures/computer-architecture/</link><pubDate>Tue, 07 Apr 2020 20:37:08 +0900</pubDate><guid>http://makerdark98.dev/wiki/lectures/computer-architecture/</guid><description>Large and Fast : Exploiting Memory Hierarchy5. Principle of Locality Temporal locality Spatial locality Taking Advantage of Locality Memory hierarchy Store everything on disk (lowest level) Copy recently accessed (and nearby) items from disk to smaller DRAM(e.g. Main Memory) copy more recently accessed (and nearby) items from DRAM to smaller SRAM memory(e.g. Cache memory attached to CPU) Memory Hierarchy Levels A block (aka line) : unit of copying If accessed data is present in upper level Hit : access satisfied by upper level Hit ratio: hits/accesses If accessed data is absent Miss : block copied from lower level Time taken : miss penalty Miss ratio : misses/accesses = 1 - hit ratio Then accessed data supplied from upper level Memory Technology Static RAM (SRAM) : 0.</description></item><item><title>lectures/image processing</title><link>http://makerdark98.dev/wiki/lectures/image-processing/</link><pubDate>Tue, 07 Apr 2020 20:37:08 +0900</pubDate><guid>http://makerdark98.dev/wiki/lectures/image-processing/</guid><description>PCA (Principal Components Analysis)
Eigenvalues and Eigenvectors The prefix eigen- is adopted from the German word eigen for &amp;ldquo;proper&amp;rdquo;, &amp;ldquo;characteristic&amp;rdquo; Eigenvalues are a special set of scalars associated with a linear system of equations that are sometimes also known as characteristic roots, characteristic values Each eigenvalue is paired with a corresponding so-called eigen vector. Eigenvectors are a special set of vectors associated with a linear system of equations that are sometimes also known as characteristic vectors The Lanczos algorithm is an algorithm for computing the eigenvalues and eigenvectors Eigenvalues and eigenvectors feature prominently in the analysis of transformations Covariance matrix The covariance matrix consists of the variances of the variables along the main diagonal and the covariance between each pair of variables in the other matrix positions Face Recognition obtain face images I_1, &amp;hellip; , I_m (training faces) (very important : the face images must be centered and of the same size)</description></item><item><title>학교 수업</title><link>http://makerdark98.dev/wiki/lectures/</link><pubDate>Tue, 07 Apr 2020 20:37:08 +0900</pubDate><guid>http://makerdark98.dev/wiki/lectures/</guid><description>학교 수업 [[lectures/algorithm]] [[lectures/computer architecture]] [[lectures/image processing]]</description></item><item><title>Tool configuration</title><link>http://makerdark98.dev/wiki/tool-configuration/</link><pubDate>Tue, 07 Apr 2020 20:36:45 +0900</pubDate><guid>http://makerdark98.dev/wiki/tool-configuration/</guid><description>- Neovim - `.vimrc` &amp;quot; vim-bootstrap &amp;quot;***************************************************************************** &amp;quot;&amp;quot; Vim-PLug core &amp;quot;***************************************************************************** let vimplug_exists=expand('~/.config/nvim/autoload/plug.vim') let g:vim_bootstrap_langs = &amp;quot;c,html,javascript,python&amp;quot; let g:vim_bootstrap_editor = &amp;quot;nvim&amp;quot; &amp;quot; nvim or vim if !filereadable(vimplug_exists) if !executable(&amp;quot;curl&amp;quot;) echoerr &amp;quot;You have to install curl or first install vim-plug yourself!&amp;quot; execute &amp;quot;q!&amp;quot; endif echo &amp;quot;Installing Vim-Plug...&amp;quot; echo &amp;quot;&amp;quot; silent exec &amp;quot;!\curl -fLo &amp;quot; . vimplug_exists . &amp;quot; --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&amp;quot; let g:not_finish_vimplug = &amp;quot;yes&amp;quot; autocmd VimEnter * PlugInstall endif &amp;quot; Required: call plug#begin(expand('~/.</description></item><item><title>SSH Server Configuration</title><link>http://makerdark98.dev/wiki/ssh-server/</link><pubDate>Tue, 07 Apr 2020 20:36:17 +0900</pubDate><guid>http://makerdark98.dev/wiki/ssh-server/</guid><description> Installation
sudo apt install openssh-server
sudo vim /etc/ssh/sshd_config
generate key
ssh-keygen -R {id}@{host}
PermitRootLogin prohibit-password</description></item><item><title>Firewall (방화벽) Configuration</title><link>http://makerdark98.dev/wiki/firewall/</link><pubDate>Tue, 07 Apr 2020 20:36:02 +0900</pubDate><guid>http://makerdark98.dev/wiki/firewall/</guid><description> iptables
#iptables -nL
save firewall configuration #iptalbes-save &amp;gt; save_data.rules config firwall 아이피 111.222.111.222에 대해서 destination port 가 22이면 ACCEPT 하여라.
#iptables -A INPUT -s 111.222.111.222/32 -p tcp -m state &amp;ndash;state NEW -m tcp &amp;ndash;dport 22 -j ACCEPT-
save configuration persistent #apt install iptables-persistent rule directory : /etc/iptables/rules.v4
#iptables-save &amp;gt; /etc/iptables/rules.v4</description></item><item><title>ftp server command</title><link>http://makerdark98.dev/wiki/ftp/</link><pubDate>Tue, 07 Apr 2020 20:35:51 +0900</pubDate><guid>http://makerdark98.dev/wiki/ftp/</guid><description> use vsftpd(Very Secure FTP Server Daemon) Installation # apt install vsftpd check vsftpd status # service vsftpd status check network port # netstat -natp | grep ftp Configuration vsftpd # vi /etc/vsftpd.conf #/etc/vsftpd.conf listen=YES listen_ipv6=NO anonymous_enable=NO port_enable=NO pasv_enable=YES local_enable=YES write_enable=YES use_localtime=YES xferlog_enable=YES chroot_local_user=YES allow_writeable_chroot=YES secure_chroot_dir=/var/run/vsftpd/empty pam_service_name=vsftpd ftpd_banner=Welcom to My FTP Server! ssl_enable=YES rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem rsa_private_key=/etc/ssl/private/ssl-cert-snakeoil.key listen_port=21 pasv_min_port=60020 pasv_max_port=60030 #utf8_filesystem=YES #local_umask=022</description></item><item><title>linux user command</title><link>http://makerdark98.dev/wiki/user/</link><pubDate>Tue, 07 Apr 2020 20:35:41 +0900</pubDate><guid>http://makerdark98.dev/wiki/user/</guid><description> check username
cat /etc/passwd | grep {username}
create user &amp;amp; select default shell
useradd {username} -m -s /bin/bash
password
echo {password} | passwd &amp;ndash;stdin {username}
home directory
mkhomedir_helper {username}</description></item><item><title>Brightness (화면 밝기 조절) command</title><link>http://makerdark98.dev/wiki/brightness/</link><pubDate>Tue, 07 Apr 2020 20:35:31 +0900</pubDate><guid>http://makerdark98.dev/wiki/brightness/</guid><description>echo 5000 | sudo tee /sys/class/backlight/intel_backlight/brightness</description></item><item><title>Wifi commands</title><link>http://makerdark98.dev/wiki/wifi-command-line/</link><pubDate>Tue, 07 Apr 2020 20:35:07 +0900</pubDate><guid>http://makerdark98.dev/wiki/wifi-command-line/</guid><description>Wifi Adapter 찾기
iw dev
Adapter status
ip link show wlp2s0
Adapter Start
ip link set wlp2s0 up
When Operation fail because of rfkill $rfkill list $sudo rfkill unblock wifi Wifi Adapter interface check
iw wlp2s0 link
Wifi Scan
iw wlp2s0 scan
Public Wifi Connect
sudo iw dev wlp2s0 connect iptime
WPA/WPA2 Wifi Connect
$ sudo wpa_passphrase ${SSID} &amp;gt; wpa_supplicant.</description></item><item><title>Linux Command 모음</title><link>http://makerdark98.dev/wiki/linux-command/</link><pubDate>Tue, 07 Apr 2020 20:34:57 +0900</pubDate><guid>http://makerdark98.dev/wiki/linux-command/</guid><description>command line [[wifi command line]] [[brightness]] [[rm]] [[tee]] [[glob]] [[free]] [[memory cache clean]] Server [[user]] [[ftp]] [[firewall]] [[ssh server]]</description></item><item><title>docker</title><link>http://makerdark98.dev/wiki/docker/</link><pubDate>Tue, 07 Apr 2020 20:34:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/docker/</guid><description>install
curl -fsSL https://get.docker.com/ | sudo sh
user 추가
sudo useradd {username} -m -s /bin/bash -G docker
docker container run
docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG&amp;hellip;]
-d : detached mode (background mode)
-p : port forwarding from host port to container
-v : mount host directory
-name : configure container name
-rm : remove automatically when process terminated
-it : -i + -t ⇒ interactive terminal</description></item><item><title>SQL</title><link>http://makerdark98.dev/wiki/sql/</link><pubDate>Tue, 07 Apr 2020 20:34:32 +0900</pubDate><guid>http://makerdark98.dev/wiki/sql/</guid><description>Mysql User Create create user 'username'@'localhost' identified by 'password' Grant privileges grant all privileges on *.* to 'username'@'localhost'; grant all privileges on 'DBname'.* to 'username'@'localhost'; Drop User drop user 'username'@'localhost'; Create Database CREATE DATABASE 'DBname'; Create Table CREATE TABLE table_name ( column1 data_type(size), column2 data_type(size), column3 data_type(size), ... )</description></item><item><title>Typescript/Function</title><link>http://makerdark98.dev/wiki/typescript/function/</link><pubDate>Tue, 07 Apr 2020 20:34:09 +0900</pubDate><guid>http://makerdark98.dev/wiki/typescript/function/</guid><description>Functions Types Typing the function function add(x: number, y: number): number { return x + y; } let myAdd = function(x: number, y: number): number { return x + y; }; Writing the function type let myAdd: (x: number, y: number) =&amp;gt; number = function (x: number, y: number): number { return x + y; }; let myAdd: (baseValue: number, increment: number) =&amp;gt; number = function(x: number y: number): number { return x + y; }; Inferring the types let myAdd = function(x: number, y: number): number { return x + y; }; let myAdd: (baseValue: number, increment: number) =&amp;gt; number = function(x, y) { return x + y; }; Optional and Default Parameters function buildName(firstName: string, lastName: string) { return firstName + &amp;quot; &amp;quot; + lastName; } let result1 = buildName(&amp;quot;Bob&amp;quot;); // Error let result2 = buildName(&amp;quot;Bob&amp;quot;, &amp;quot;Adams&amp;quot;, &amp;quot;Sr.</description></item><item><title>Typescript/Class</title><link>http://makerdark98.dev/wiki/typescript/class/</link><pubDate>Tue, 07 Apr 2020 20:33:57 +0900</pubDate><guid>http://makerdark98.dev/wiki/typescript/class/</guid><description>Class class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &amp;quot;Hello, &amp;quot; + this.greeting; } } let greeter = new Greeter(&amp;quot;world&amp;quot;); Inheritance class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log(&amp;quot;Woof! Woof!&amp;quot;); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark(); class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.</description></item><item><title>Typescript/Interface</title><link>http://makerdark98.dev/wiki/typescript/interface/</link><pubDate>Tue, 07 Apr 2020 20:33:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/typescript/interface/</guid><description>- duck typing structural subtyping
interface LabelledValue { label: string; }
function printLabel(labeledObj: LabelledValue) { console.log(labelledObj.label); }
let myObj = { size: 10, label: &amp;ldquo;Size 10 Object&amp;rdquo; }; printLabel(myObj);
Optional Properties interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { let newSquare = { color: &amp;quot;white&amp;quot;, area: 100 }; if (config.color) { newSquare.color = config.color; } if (config.</description></item><item><title>Typescript/Variable Declaration</title><link>http://makerdark98.dev/wiki/typescript/variable-declaration/</link><pubDate>Tue, 07 Apr 2020 20:33:29 +0900</pubDate><guid>http://makerdark98.dev/wiki/typescript/variable-declaration/</guid><description>var declarations var a = 10; function f() { var message = &amp;quot;Hello, world!&amp;quot;; return message; } function f() { var a = 10; return function g() { var b = a + 1; return b; } } var g = f(); g(); Scoping rules function f(suoldInitialize: boolean) { if (shouldInitialize) { var x = 10; } return x; } f(true); // return 10 f(false); // return undefined Variable capturing quirks for (var i = 0; i &amp;lt; 10; i++) { setTimeout(function() { console.</description></item><item><title>Typescript/Types</title><link>http://makerdark98.dev/wiki/typescript/types/</link><pubDate>Tue, 07 Apr 2020 20:33:02 +0900</pubDate><guid>http://makerdark98.dev/wiki/typescript/types/</guid><description>Boolean let isDone: boolean = false Number let decimal: number = 6; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744 String let color: string = &amp;quot;blue&amp;quot;; color = 'red'; let fullName: string = `Bob Bobbingto`; let age: number = 37; let sentence: string = `Hello, myname is ${ fullName }. I'll be ${ age + 1 } years old next month.`; Array let list: number[] = [1, 2, 3]; let list: Array&amp;lt;number&amp;gt; = [1, 2, 3]; Tuple let x: [string, number]; x = [&amp;quot;hello&amp;quot;, 10]; console.</description></item><item><title>Typescript</title><link>http://makerdark98.dev/wiki/typescript/</link><pubDate>Tue, 07 Apr 2020 20:32:54 +0900</pubDate><guid>http://makerdark98.dev/wiki/typescript/</guid><description>Syntax [[Typescript/Types]] [[Typescript/Variable Declaration]] [[Typescript/Interface]] [[Typescript/Class]] [[Typescript/Function]]</description></item><item><title>graphql typescript (deprecated)</title><link>http://makerdark98.dev/wiki/graphql-typescript/</link><pubDate>Tue, 07 Apr 2020 20:32:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/graphql-typescript/</guid><description> TOC {:toc} yarn add type-graphql yarn add typescript @types/node --dev yarn add reflect-metadata</description></item><item><title>winston</title><link>http://makerdark98.dev/wiki/winston/</link><pubDate>Tue, 07 Apr 2020 20:32:24 +0900</pubDate><guid>http://makerdark98.dev/wiki/winston/</guid><description>import * as config from &amp;ldquo;config&amp;rdquo;; import { Logger, LoggerInstance, LoggerOptions, transports } from &amp;quot;winston&amp;quot;; require(&amp;quot;winston-daily-rotate-file&amp;quot;); const defaultLevel = process.env.LOG_LEVEL; // We might want to do something on rotation? // rotateTransport.on(&amp;quot;rotate&amp;quot;, (oldFailename, newFilename) =&amp;gt; { // // do something fun // }); const options: LoggerOptions = { exitOnError: false, level: defaultLevel, transports: [ new transports.DailyRotateFile({ name: &amp;quot;info&amp;quot;, filename: config.logging.default, datePattern: &amp;quot;YYYY-MM-DD-HH&amp;quot;, zippedArchive: true, maxSize: &amp;quot;20m&amp;quot;, maxFiles: &amp;quot;14d&amp;quot;, showLevel: true, timestamp: true, level: &amp;quot;info&amp;quot;, // info and below to rotate }), new transports.</description></item><item><title>Jest</title><link>http://makerdark98.dev/wiki/jest/</link><pubDate>Tue, 07 Apr 2020 20:32:13 +0900</pubDate><guid>http://makerdark98.dev/wiki/jest/</guid><description># Installation yarn add --dev jest npm install --dev jest yarn add --dev @types/jest npm install --dev @types/jest Configuration &amp;quot;scripts&amp;quot;: { &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot; }, Write test code test(`test name`, () =&amp;gt; { expect(1).toBe(1); }); Test Matcher toEqual() test('return a user object', () =&amp;gt; { expect(getUser(1)).toEqual({ id: 1, email: 'user1@test.com' }); }); toBeTruthy(), toBeFalsy() test('number 0 is falsy but string 0 is truthy', () =&amp;gt; { expect(0).toBeFalsy(); expect('0').</description></item><item><title>Sequelize</title><link>http://makerdark98.dev/wiki/sequelize/</link><pubDate>Tue, 07 Apr 2020 20:31:57 +0900</pubDate><guid>http://makerdark98.dev/wiki/sequelize/</guid><description># Installation npm install --save sequelize # One of the following npm install --save pg pg-hstore # Postgres npm install -save mysql2 # mysql npm install --save mariadb # mariadb npm install --save sqlite3 # sqlite npm install --save tedious # Microsoft SQL Server Configuration (Typescript) Setting up a connection import { Sequelize } from 'sequelize'; interface DBConfituration { database: string; user: string; password: string; host: string; dialect: &amp;quot;mysql&amp;quot; | &amp;quot;postgres&amp;quot; | &amp;quot;sqlite&amp;quot; | &amp;quot;mariadb&amp;quot; | &amp;quot;msqle&amp;quot; | undefined; } const dbConfiguration : DBConfiguration = { database: &amp;quot;graph&amp;quot;, user: &amp;quot;graph&amp;quot;, password: &amp;quot;graph&amp;quot;, host: &amp;quot;localhost&amp;quot;, dialect: &amp;quot;mysql&amp;quot; }; const sequelize = new Sequelize( dbConfiguration.</description></item><item><title>Fetch 문법 간단 정리</title><link>http://makerdark98.dev/wiki/fetch/</link><pubDate>Tue, 07 Apr 2020 20:22:29 +0900</pubDate><guid>http://makerdark98.dev/wiki/fetch/</guid><description>Basic Usage const queryData = { query:` query { hello, persons { name, } }` }; const headers = new Headers({ &amp;quot;Accept&amp;quot; : &amp;quot;application/json&amp;quot;, &amp;quot;Content-Type&amp;quot; : &amp;quot;application/json&amp;quot; }); const fetchPromise = fetch('/graphql', { headers, method: &amp;quot;POST&amp;quot;, body: JSON.stringify(queryData), }); fetchPromise .then(response =&amp;gt; response.clone().json()) // avoid reponse lock .then(data =&amp;gt; console.log);</description></item><item><title>Promise 정리</title><link>http://makerdark98.dev/wiki/promise/</link><pubDate>Tue, 07 Apr 2020 20:22:09 +0900</pubDate><guid>http://makerdark98.dev/wiki/promise/</guid><description>## Synchronous vs Asynchronous Callback hell CallEndpoint(&amp;quot;api/getidbyusername/hotcakes&amp;quot;, function(result) { CallEndpoint(&amp;quot;api/getfollowersbyid/&amp;quot; + result.userID, function(result) { CallEndpoint(&amp;quot;api/someothercall/&amp;quot; + result.followers, function(result) { CallEndpoint(&amp;quot;api/someothercall/&amp;quot; + result, function(result) { // do something... }); }); }); }); Promise Async, Await References
The Great Escape from Callback Hell</description></item><item><title>JavaScript</title><link>http://makerdark98.dev/wiki/javascript/</link><pubDate>Tue, 07 Apr 2020 20:22:03 +0900</pubDate><guid>http://makerdark98.dev/wiki/javascript/</guid><description>Syntax [[Promise]] [[Fetch]] Library [[Sequelize]] [[Jest]] [[Winston]] [[graphql-typescript]]</description></item><item><title>Docker Volume</title><link>http://makerdark98.dev/wiki/docker-volume/</link><pubDate>Tue, 07 Apr 2020 20:21:35 +0900</pubDate><guid>http://makerdark98.dev/wiki/docker-volume/</guid><description>1. 데이터 볼륨 도커는 하나의 이미지로 부터 여러 컨테이너를 만들기 위해서
Union File system
을 사용한다. 유니온 파일 시스템은 원본 이미지에 변경된 내용(diff)를 추가하는 방식이므로, 다른 컨테이너에서 사용 할 수 없다. 애플리케이션에 따라서는 데이터를 다른 컨테이너와 공유 하거나 혹은 호스트에서 접근 할 수 있어야 하는 경우가 있는데, 이때 데이터 볼륨을 사용한다. 데이터 볼륨은 호스트의 파일 시스템을 컨테이너에서 마운트 하는 방식으로 사용한다. 아래와 같은 특징이 있다.
데이터 볼륨은 호스트 운영체제의 파일 시스템을 사용한다.</description></item><item><title>Nexus</title><link>http://makerdark98.dev/wiki/nexus/</link><pubDate>Tue, 07 Apr 2020 20:21:19 +0900</pubDate><guid>http://makerdark98.dev/wiki/nexus/</guid><description>docker 설치 sudo apt install apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&amp;quot; sudo apt update sudo apt install docker-ce -y nexus 실행 sudo docker volume create --name nexus-data sudo docker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3 nexus bash 실행 sudo docker exec -it 7f1dc6675c11 /bin/bash [[Docker Volume]]</description></item><item><title>SSD(Solid-State Drive)</title><link>http://makerdark98.dev/wiki/ssdsolid-state-drive/</link><pubDate>Tue, 07 Apr 2020 20:21:10 +0900</pubDate><guid>http://makerdark98.dev/wiki/ssdsolid-state-drive/</guid><description>1. SSD의 구조 1.1. SSD(Solid-State Drive) Flash Memory를 기반으로 한 저장 매체 비트들은 Floating-Gate Transistor로 구성된 Cell에 저장됨. 모든 컴포넌트가 전기 장치 대부분 NAND사용 (cf. NOR VS NAND) 1.1.1. NAND Flash Memory Property Lifecycle is wearing-off(수명이 제한적이다.) 이유 : P/E(Program &amp;amp; Erase) 사이클마다 일부 전자가 오류로 인해 쌓이게 되어 트랜지스터에 갇힘. 이로 인해 갇힌 전자가 일정 수준을 넘어가면 사용 불가해짐. 1.1.2. Cell의 종류 SLC(Single Level Cell) : 하나의 비트만 저장 가능, 긴 수명 MLC(Multiple Level Cell) : 2비트, 레이턴시가 높고 짧은 수명 TLC(Triple Level Cell) : 3비트, 레이턴시가 매우 높고 더 짧은 수명 쓰기가 많을 수록 SLC가 좋고, 읽기가 많을 수록 TLC가 좋음.</description></item><item><title>Pintos</title><link>http://makerdark98.dev/wiki/pintos/</link><pubDate>Tue, 07 Apr 2020 20:20:28 +0900</pubDate><guid>http://makerdark98.dev/wiki/pintos/</guid><description>설정하기 Configuration 프로젝트 기본 다운로드 대부분 우분투에서 설정할테니, 다른사람들이 잘 설정해좋은거 다운 받자 $ git clone https://github.com/kumardeepakr3/PINTOS-Ubuntu.git $ cd PINTOS-Ubuntu $ bash ./pintos_ubuntu.sh 여기서 9,10 작업은 필요가 없는 작업이니 다시 원복해주자 vim 설정하기 나는 vim(정확히는 neovim)으로 코딩할꺼니 자동완성 같은걸 설정해주자 여기서는 [[coc]], [[tagbar]], [[ALE]], [[cscope]]를 사용해서 설정했다. coc ccls 를 설치하고 CocLocalConfig를 명령어로 친뒤 { &amp;#34;languageserver&amp;#34;: { &amp;#34;ccls&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;ccls&amp;#34;, &amp;#34;filetypes&amp;#34;: [ &amp;#34;c&amp;#34;, &amp;#34;cpp&amp;#34;, &amp;#34;objc&amp;#34;, &amp;#34;objcpp&amp;#34; ], &amp;#34;rootPatterns&amp;#34;: [ &amp;#34;.</description></item><item><title>Bus 시간 메모</title><link>http://makerdark98.dev/wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/</link><pubDate>Tue, 07 Apr 2020 20:20:03 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/</guid><description>목요일 11월 28일 14시 900A 출발</description></item><item><title>5 articles per week</title><link>http://makerdark98.dev/wiki/5-articles-per-week/</link><pubDate>Tue, 07 Apr 2020 20:19:37 +0900</pubDate><guid>http://makerdark98.dev/wiki/5-articles-per-week/</guid><description># 하루 1개씩을 목표로, 하지만 못하는 날을 감안해서 일주일에 5개를 하는 것을 목표로 2020.01 Dec 29, 2019 11:17pm Tips I use to avoid burnout Tips I use to avoid burnout
순간 해커뉴스에서 보다가 눈길이 갔다. burnout은 항상 존재하는 두려움이다. 언제 추진력을 잃을지 걱정된다.
Tips I use to avoid burnout:
no 라고 자주 말해라. 너한테도 한계가 있다. 할수 있는 것까지만 하자 시간이 가장 소중하다. 더 중요한것에 사용해라 도와달라고 말해라. 협업하는 것을 고민하거나 혼자할지 결정하는 것도 포함해서 조언을 구해라 재충전할 짧은 시간을 가져라 Jan 01, 2020 1:11am The Old Internet Died And We Watched And Did Nothing The Old Internet Died And We Watched And Did Nothing</description></item><item><title>썩어버린 Query Language</title><link>http://makerdark98.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/</link><pubDate>Tue, 07 Apr 2020 20:18:38 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/</guid><description># 1. SQL (Structured Query Language)? 관계형 데이터베이스들에서 원하는 데이터를 가져오기 위한 언어 우리는 왜 이걸 사용하고 있을까? 데이터베이스의 역사 관계형 데이터베이스가 데이터베이스 전쟁의 승자이기 때문이다. 계층형 데이터베이스를 비롯한 수많은 종류들의 데이터베이스가 있었으나 문제들이 많아 점점 관계형 데이터베이스들만이 살아남았다. (대부분 성능상의 문제) 관계형이 살아남은 이유는 질의 최적화기 (query optimizer)이다. Query Optimizer 쿼리를 최적화해주는 무언가 이걸 발전시키기 위해 수많은 연구가 진행되어 현재의 성능을 가지게 된다. 그럴려면 구조화된 query 언어가 필요하고 이게 현재 사용하는 SQL이다.</description></item><item><title>회고 모음</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/</link><pubDate>Tue, 07 Apr 2020 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/</guid><description>2019년 [[회고/2019.09.18]] [[회고/2019.09.19]] [[회고/2019.10.19]] [[회고/2019.11.24~25]] 2020년 [[회고/2020.01.01]] [[회고/2020.01.17]] [[회고/3월]] [[회고/2020.04.08]] [[회고/2020.04.20]] [[회고/2020-05-30]] [[회고/2020-06-17]] [[회고/2020-06-21]]</description></item><item><title>UCPC 2018 예선</title><link>http://makerdark98.dev/wiki/ucpc_2018_%EC%98%88%EC%84%A0/</link><pubDate>Tue, 07 Apr 2020 20:17:47 +0900</pubDate><guid>http://makerdark98.dev/wiki/ucpc_2018_%EC%98%88%EC%84%A0/</guid><description>boj15894 - 수학은 체육과목 입니다. n*4를 출력하면 된다. #include &amp;lt;iostream&amp;gt; #define scl(n) scanf(&amp;#34;%lld&amp;#34;, &amp;amp;(n)) using lld = long long; using namespace std; int main(){ lld n; scl(n); printf(&amp;#34;%lld&amp;#34;, 4*n); return 0; } boj15903 - 카드 합체 놀이 현재 있는 세트에서 가장 작은 2개를 더해서 다음 세트에 넣는 구조이니 priority queue를 사용해서 문제를 해결할 수 있다. #include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #define sci(n) scanf(&amp;#34;%d&amp;#34;, &amp;amp;(n)) using namespace std; using lld = long long; int main() { int n, m; sci(n), sci(m); priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; q; for(int i=0;i&amp;lt;n;i++){ int t; sci(t); q.</description></item><item><title>Javascript Memory Leak</title><link>http://makerdark98.dev/wiki/memory_leak/</link><pubDate>Tue, 07 Apr 2020 20:16:46 +0900</pubDate><guid>http://makerdark98.dev/wiki/memory_leak/</guid><description>주제 후보 메모리 누수란 왜 일어나는가? - garbage collector의 동작방식, javascript 에서 메모리 누수 없이 코딩하는 습관 가지기 비동기처리하기 - javascript callback, promise, async-await 웹사이트에서 원하는 정보 추출하기 - 웹사이트 크롤링, 파싱하기 나무위키 유의어, 반의어 - Word2Vec를 통한 나무위키 데이터 학습 → 익명의 대학 동기에게 재밋는 주제를 고르라고 해서 진행되었습니다.
메모리 누수란 왜 일어나는가? 결론부터 말하자면 프로그래머의 실수. 코딩 습관을 잘 들이자. Garbage Collection 의 필요성 C언어에서 메모리를 직접 할당하고 해제하는 malloc, free 라는 방식을 사용하였다.</description></item><item><title>송편 생성기 (추석 대회)</title><link>http://makerdark98.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/</link><pubDate>Tue, 07 Apr 2020 20:16:06 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/</guid><description>추석을 맞아 송편을 창의적으로 출력하기 대회가 열렸다. 먼가 인공지능으로 가장 완벽한 송편을 출력해보고 싶어졌다. 0. Configuration 먼저 인공지능 스택으로 배운건 Tensorflow, Keras이기 때문에 언어는 편하게 모두 python으로 하기로 결정했다.
그렇게 언어를 정하고 과정을 다음과 같이 나눴다.
송편 이미지 크롤링 하기 Keras를 통해 GAN모델을 구현해서 한번 테스트 해보기 나온 결과를 확인하고 모델을 학습 데이터 특성에 맞춰서 재설계, 데이터 가공, 통계적으로 분석&amp;hellip; 등등 원하는 결과를 내도록 설계 이렇게 정하고 나니 필요한 라이브러리는 다음과 같았다.</description></item><item><title>Endurable Transient Inconsistency in Byte Addressable Persistent B+-Tree</title><link>http://makerdark98.dev/wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/</link><pubDate>Tue, 07 Apr 2020 20:15:43 +0900</pubDate><guid>http://makerdark98.dev/wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/</guid><description>논문을 고른 이유 : 2018, 2019, 2020 년도 FAST 학회의 모든 논문을 읽고 전역을 하는 게 목표인데 2018, 2019년도 FAST에 동일한 한국인이 실려서 관심이 가서 읽어보게 됨. Abstract Persistent Memory(이하 PM)의 byte 주소 기반 접근의 등장으로 데이터 전송 단위가 page→cache line이 됨.
쓰기 실패 원자성(Failure-Atomic Write Operation)는 8Bytes 씩 보장되지 cache line단위로는 보장되지 않는다.
B+-Tree는 Block 기반 데이터 구조이고, 재 디자인이 부상하게 된다.</description></item><item><title>SSD 공부 자료 모음</title><link>http://makerdark98.dev/wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/</link><pubDate>Tue, 07 Apr 2020 20:14:30 +0900</pubDate><guid>http://makerdark98.dev/wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/</guid><description>An In-Depth Study of Next Generation Interface for Emerging Non-Volatile Memories
F2FS: A New File System for Flash Storage
The new ext4 filesystem: current status and future plans
개발자를 위한 SSD (Coding for SSD) – Part 5 : 접근 방법과 시스템 최적화
개발자를 위한 SSD (Coding for SSD) - Part 5 : 접근 방법과 시스템 최적화
개발자를 위한 SSD (Coding for SSD) – Part 6 : A Summary – What every programmer should know about solid-state drives</description></item><item><title>개발 TODO</title><link>http://makerdark98.dev/wiki/%EA%B0%9C%EB%B0%9C_todo/</link><pubDate>Tue, 07 Apr 2020 20:13:56 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EA%B0%9C%EB%B0%9C_todo/</guid><description>shorter url todo list
offline editor with md &amp;amp; my page like blog hackernews articles
my favorite musics (includes video song, mp3 files and whatever)
diary
언제라도 내가 원하는 서비스를 바로 바로 찍어낼수 있게 디자인이 거의 다 되어있는 framework
golang으로 만드는 db</description></item><item><title>완벽한 삶</title><link>http://makerdark98.dev/wiki/%EC%99%84%EB%B2%BD%ED%95%9C%EC%82%B6/</link><pubDate>Tue, 07 Apr 2020 20:12:48 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%99%84%EB%B2%BD%ED%95%9C%EC%82%B6/</guid><description>회고를 하다가 갑자기 내가 생각한 완벽한 삶이 무엇인가가 주제로 나와서 이렇게 글을 쓰게된다.
결론부터 말하자면, 내가 생각한 완벽한 삶은 자살로 맺어지는 것이다.
사람은 완벽해질 수 없다. 왜냐하면 완벽이란 것은 사람마다 기준이 다르기 떄문이다. 누군가에게는 완벽이 누군가에게는 허점투성일 수 있다. 또한 누군가에게는 좋았던 일이 누군가에게는 안좋을 수도 있다. 그렇기 때문에 완벽하다라는 것은 존재할수 없다고 생각한다. 그렇기 떄문에 나는 내멋대로 완벽이라는 것을 정의해보는 게 어떤가라고 생각했고, 나름대로 정의하게 되었다.
완벽이란 계획적인 것이다. 물론 모든걸 계획하고 움직여야한다는 것이 아니다.</description></item><item><title>F2FS</title><link>http://makerdark98.dev/wiki/f2fs/</link><pubDate>Tue, 07 Apr 2020 00:01:51 +0900</pubDate><guid>http://makerdark98.dev/wiki/f2fs/</guid><description>논문 정리 [[f2fs-paper]]{F2FS: A New File System for Flash Storage} 코드 정리</description></item><item><title>사지방 개발기</title><link>http://makerdark98.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9_%EA%B0%9C%EB%B0%9C%EA%B8%B0/</link><pubDate>Mon, 06 Apr 2020 23:42:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9_%EA%B0%9C%EB%B0%9C%EA%B8%B0/</guid><description>TODO Lists [ ] API Server-authorization [ ] API Server-Short URL [ ] Deployment 자동화 [ ] SSR directory 정리 [ ] DB-mlab db connection test [ ] MongoDB offline에서 돌아가도록 세팅하기 [ ] Redux Component Test [ ] lets encrypt [ ] Code Splitting [O] makerdark98.dev [O] SSR [O] cloudatcost [O] API Server-Test-generateToken [O] API Server-jwt [O] API Server-Test-signup [O] API Server-Test-validateToken [O] koa routing [O] DB-User Schema [O] 성능 Issue - MUI의 chunk size가 너무 큼 [O] React Framework [O] API Server [O] DB [O] koa configuration [O] test code 작성</description></item><item><title/><link>http://makerdark98.dev/wiki/weekly/</link><pubDate>Sun, 05 Apr 2020 20:15:41 +0900</pubDate><guid>http://makerdark98.dev/wiki/weekly/</guid><description> TOC {:toc} Test</description></item><item><title>Daily Todo</title><link>http://makerdark98.dev/wiki/daily/</link><pubDate>Sun, 05 Apr 2020 19:32:46 +0900</pubDate><guid>http://makerdark98.dev/wiki/daily/</guid><description>TOC {:toc} Test [ ] 위키 만들기</description></item><item><title>Link Test</title><link>http://makerdark98.dev/wiki/links/</link><pubDate>Sun, 05 Apr 2020 15:23:05 +0900</pubDate><guid>http://makerdark98.dev/wiki/links/</guid><description>링크 테스트 하기 위함.</description></item><item><title/><link>http://makerdark98.dev/wiki/link/</link><pubDate>Sun, 05 Apr 2020 15:22:33 +0900</pubDate><guid>http://makerdark98.dev/wiki/link/</guid><description> TOC {:toc} Test</description></item><item><title>Test</title><link>http://makerdark98.dev/wiki/test/</link><pubDate>Sun, 05 Apr 2020 12:31:29 +0900</pubDate><guid>http://makerdark98.dev/wiki/test/</guid><description>Test Updated</description></item><item><title>설대회</title><link>http://makerdark98.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/</link><pubDate>Sun, 26 Jan 2020 23:57:47 +0900</pubDate><guid>http://makerdark98.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/</guid><description>1. 생각의 흐름 설 대회로는 설 그 자체를 표현하라고 했다. 사실 원래 계획은 Word2Vec를 통해서 9월 (혹은 10월) : 추석 = 1월 (혹은 2월) : 설 이라던가 송편과 떡국 간의 관계를 통해서 설이라는 단어를 결과값으로 뽑고 싶었다. 체계단 내에서 누군가가 konlpy로 무언가를 하고 있는 것을 봤다. NLP라는 영역이 겹치는 것 같아서 뭔가 아이디어가 겹친다고 생각되어 처음부터 다시 생각하기로 했다. 과연 설은 무엇일까? 구글 번역기에 영어로 돌려봤다. New Year&amp;rsquo;s Day라고 나온다.</description></item><item><title>회고/2020.01.01</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.01.01/</link><pubDate>Wed, 01 Jan 2020 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.01.01/</guid><description>Jan 01, 2020 1:42am 흐음&amp;hellip; 사실 지금 회고를 쓰는데 좀 졸린 부분이 있다. 신년이 밝아왔다. 사실 신년을 이렇게 보낼줄은 몰랐지만(지금 듣고 있는 음악은 강지가 커버한 레몬 - 유튜브 영상 제목은 감사했어오 앞으로&amp;hellip;.)이다.
오늘은 코딩으로 React Redux를 했다. 빨리 Redux-action을 익혀서 적용해야겠다.
요즘 다시 코딩 욕구? 동기부여가 됬다. 잘됬으면 좋겠다.
지금은 shorturl을 제일 먼저 만들어 보려고 하는데 일단 Page Layout 구성을 빠르게 해볼려고 한다.
React 의 유명한 Framework인 Material-UI를 사용해서 해봐야겠다.</description></item><item><title>회고/2020.01.17</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.01.17/</link><pubDate>Wed, 01 Jan 2020 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2020.01.17/</guid><description>Jan 17, 2020 11:48pm 화가 나서 머리를 비우고자 글을 쓴다. 담정너 진짜 너무 싫다. 정말 화가 치밀어 올라서 욕을 막 갈기고 싶은데 참는다.
먼저 화가 난 이유는 다음과 같다.
무언가 올바르지 않은 일에 대해서 어떻게 하는게 좋을지를 조언을 구하려고 왔다. 나는 성심성의껏 대답을 했는데, 결국 답정너라는 걸 알았다.
주 논리가 뭐였냐면, 연좌제라는게 잘못되었다고 나는 주장했고 그러니 어떠한 방법으로 하는게 좀더 올바른것 같다라고 말했는데
후&amp;hellip;. 군대니까 어쩔수 없다느니 왜 지난번 사례때는 아무말 안하고 나한테 이러냐느니 식으로 이야기했다.</description></item><item><title>회고/2019.11.24~25</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.11.24~25/</link><pubDate>Mon, 25 Nov 2019 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.11.24~25/</guid><description>Sunday~Monday, 24~25 November 휴가 나와서 이렇게 또다시 회고를 쓰게될 시간이 생겼다. 요즘은 훨씬 힘을 빼고 있는 중이다. 본호형이나 영서형, 재형이 형에게 크게 영향을 받았다. 특히 본호형의 영향을 많이 받게 되었다.
요즘 평일같은 경우 계속 같은 루틴으로 흘러가는데
6시 30분 기상 점호~7시 45분까지 다시 잠 8시 15분 상번 점심시간 노가리 혹은 휴식 일과 종료 후 휴대폰 7시 쯤 본호형과 안광은 병장님과 보드게임 9시부터 청소 10시부터 다시 보드게임(보통 마이티나 티츄) 자기 전에 TED나 3B1B 한마디로 공부란게 거의 없다.</description></item><item><title>회고/2019.10.19</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.10.19/</link><pubDate>Sat, 19 Oct 2019 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.10.19/</guid><description>Monday, 19 October 흐음 그냥 생각나서 회고를 쓰려고보니 딱 한달만에 회고를 쓰는게 됬다. 별생각은 없었는데ㅎㅎ
요즘 공부하는 거에 슬럼프가 왔다. 지금 하고 있는 공부가 과연 쓸모있는 공부인가에 대한 생각이 계속해서 든다. 그리고 과연 나는 뭘로 취직을 할것인데 이런 지식들을 배우고 있는가 괴리감이 드는 것도 사실이다.
예를 들어, 지금 공부하고 있는건 크게 3개? 4개 정도인데, React, 알고리즘, 운영체제(Pintos), 데이터중심 설계, Effective Debugging 이다.
Effective Debugging은 2회독 마치고 notion에 정리하면서 다시 3회독 하고 있는 중이라 사실 공부가 아니라 요약, 정리에 가까운 거지만 나머지들은 너무 다른 트렉인 느낌이 있다.</description></item><item><title>회고/2019.09.19</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.09.19/</link><pubDate>Thu, 19 Sep 2019 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.09.19/</guid><description>Thursday, 19 September 서희강 예비역님은 계룡 전산 한마당을 주로 추진하셨는데, 그 추진력에 놀랐다. 굉장히 깔끔한 진행이였고 준비기간이 짧았음에도 불구하고 높은 완성도를 이뤄내기 위해서 많은 노력을 하셨다. 정말 본받을 점이다. 또한 발표 내용도 인상 깊었는데, 목표를 이뤄내기 위해서 하신 노력들, 그 노력들을 위한 설계(만다라트 등) 본받을 점이 많았다. 일종의 뽕을 받고 만다라트를 만들려고 노력했는데 실패했지만 다시 한번 시도해볼것이다.
안상태 예비역님은 개발에 대한 열정에 관해 많은 영향을 받았다. 특히 상태형은 컴퓨터관련학과를 전공하지 않았지만, 복수전공으로 엄청난 열정을 가지고 공부했다고 느꼇다.</description></item><item><title>회고/2019.09.18</title><link>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.09.18/</link><pubDate>Wed, 18 Sep 2019 20:18:14 +0900</pubDate><guid>http://makerdark98.dev/wiki/%ED%9A%8C%EA%B3%A0/2019.09.18/</guid><description>## Wednesday, 18 September 이때까지 군 입대 이후를 간략하게 정리해보려고 한다.
먼저 입대는 2월 17일? 18일 월요일 입대했다. mysql코드를 계속보다가 입대했다.
기훈단에서는 육체적으로는 힘들었지만 정신적으로는 회복할수 있는 좋은 시기였다고 생각한다. 4주차때부터는 인편으로 백준 문제를 받아서 풀었다. 풀게 없었을때는 직전학기에 배운것중에서 가장 중요하다고 생각했던게 컴퓨터구조론이라서 CPU개략적 구조도를 외웠던 걸 계속 그렸다. 기훈단에서 배운것들은 솔직히 말해서 앞으로 써먹을게 없을 지식과 경험이라고 생각해서 리마인드를 의도적으로 안하기 위해서 최대한 안적겠다.
2박 3일로 수료외박을 나왔을때는 나와서 짜장면을 먹었고, 정통학교에서 필요한 기본적 물품(컵, 핫초코)을 샀고 둘쨰날에는 맘스터치에서 햄버거를 먹고 못했던 연락들을 하고 밀렸던 웹툰같은걸 봤다.</description></item></channel></rss>