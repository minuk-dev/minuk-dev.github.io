<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC For Microservices Service-mesh and Observability</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>gRPC For Microservices Service-mesh and Observability
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[kubecon]]</button></div></div></div><div><h2>gRPC For Microservices Service-mesh and Observability</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/grpc-for-microservices.md><h5>created : Tue, 02 Aug 2022 23:00:08 +0900</h5><h5>modified : Tue, 02 Aug 2022 23:16:55 +0900</h5></a><a href=https://minuk.dev/tags/kubecon><kbd class=item-tag>kubecon</kbd></a>
<a href=https://minuk.dev/tags/devops><kbd class=item-tag>devops</kbd></a>
<a href=https://minuk.dev/tags/grpc><kbd class=item-tag>grpc</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#intro-to-grpc>Intro to gRPC</a><ul><li><a href=#what-is-grpc>What is gRPC?</a></li><li><a href=#개인-정리>개인 정리</a></li></ul></li><li><a href=#protobuf>Protobuf</a></li><li><a href=#why-grpc>Why gRPC?</a></li><li><a href=#grpc-in-microservice--service-mesh>gRPC in Microservice & Service Mesh</a><ul><li><a href=#개인-정리-1>개인 정리</a></li></ul></li><li><a href=#so-whats-a-service-mesh>So What’s a Service Mesh?</a><ul><li><a href=#개인-정리-2>개인 정리</a></li></ul></li><li><a href=#service-mesh-with-xds>Service Mesh With xDS</a></li><li><a href=#security-in-the-service-mesh>Security In the Service Mesh</a></li><li><a href=#service-mesh-with-security>Service Mesh with Security</a></li><li><a href=#using-grpc-in-proxyless-service-mesh>Using gRPC in Proxyless Service Mesh.</a></li><li><a href=#grpc-microservices--observability>gRPC Microservices & Observability</a></li><li><a href=#grpc-observability>gRPC Observability</a></li><li><a href=#grpc-observability-aka-o11y>gRPC Observability aka O11y</a><ul><li><a href=#개인-생각>개인 생각</a></li></ul></li><li><a href=#grpc-observability-in-gcp>gRPC Observability in GCP</a><ul><li><a href=#grpc-observability-with-java>gRPC Observability with Java</a></li><li><a href=#grpc-observability-metrics--trace>gRPC Observability: Metrics & Trace</a></li><li><a href=#개인-생각-1>개인 생각</a></li></ul></li></ul><ul><li><a href=#새롭게-알게된-것>새롭게 알게된 것</a></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><ul><li><a href="https://www.youtube.com/watch?v=y2lKORewzJA">원본 영상</a></li><li>kubecon north america 2022 자료</li></ul><h2 id=intro-to-grpc>Intro to gRPC</h2><h3 id=what-is-grpc>What is gRPC?</h3><ul><li><p>Language & platform independent glue for microservices</p></li><li><p>Created by Google, as next version of Stubby</p><ul><li>Stubby connected large number of microservices at Google scale : O(10^10) RPCs per second</li></ul></li><li><p>Uses http2 and benefits from binary framing, multiplexing, streaming and HPACK compression</p></li><li><p>Generally used with Protocbuf for payload serialization</p></li><li><p>Use Protobuf IDL in .proto</p></li><li><p>Generate sever & client subs using protoc compiler</p></li><li><p>Extend server stub to add server logic</p></li><li><p>Use client stub to invoke methods</p></li><li><p>Note : protobuf is not mandatory to use gPRC</p><ul><li>There are other integrations like google/flatbuffers and Microsoft/bond</li></ul></li></ul><hr><h3 id=개인-정리>개인 정리</h3><ul><li><p>gRPC는 http2 위에서, binary, streaming 등의 특성을 가지고 있고 일반적으로는 Protobuf 로 직렬화한다.</p></li><li><p>궁금점 : http2 위인데 어떻게 양방향이 보장되지? 브라우저에서 동작하는 gRPC-web 은 단방향이라고 명시되어 있는데?:</p><ul><li>찾아본 결과 : http2 자체가 bidirectional flow 이다. <a href=https://datatracker.ietf.org/doc/html/rfc7540>출처 : RFC 7540</a></li><li>결론 : http2 에 대해서 제대로 모르는 것 같다. 이번주 중으로 http2 를 추가로 공부하자.</li></ul></li><li><p>공부하면서 추가적으로 알게 된 것 : gRPC는 http2 에서 동작하고 단일 http2 연결에서 stream이 너무 많으면 스트림 간의 쓰레드 경합이 발생하고 연결 패킷 손실로 인해서 결국에는 호출이 차단된다. <a href="https://docs.microsoft.com/ko-kr/aspnet/core/grpc/performance?view=aspnetcore-6.0">출처- msdn</a></p></li><li><p>protobuf 가 필수는 아니지만, 이미 많은 지원이 되어있다. 물론 flatbuffers, bond 와 같은 대체 프로젝트들도 있다.</p></li></ul><hr><h2 id=protobuf>Protobuf</h2><p>What’s Protobuf aka Protocol Buffers?</p><ul><li>Google’s Lingua Franca for serializing data : on the network and in storage</li><li>Strongly typed</li><li>Binary format</li><li>Extensibility and backward compatibility</li><li>Code generators for Java, C++, Go and many other languages</li></ul><h2 id=why-grpc>Why gRPC?</h2><ul><li>Multi-language</li><li>On every platform</li><li>Strict Service contracts</li><li>Performant & Efficient on wire</li><li>Extensible, Customizable</li><li>Easy to use</li><li>Streaming, BiDiStreaming APIs</li><li>Open & Standard compliant</li><li>Production Ready</li></ul><hr><h2 id=grpc-in-microservice--service-mesh>gRPC in Microservice & Service Mesh</h2><ul><li>New paradigm: convert a monolithic application into a mesh of microservices</li><li>In-process calls become gRPC calls between microservices over the network</li><li>Scaling involves new VMs/clusters/networks and RPCs crossing the boundaries</li><li>Need to manage traffic and security now!</li><li>Servie Mesh to the Rescue!</li></ul><hr><h3 id=개인-정리-1>개인 정리</h3><p>monolithic 에서 microservice 로, microservice의 복잡성을 해결하기 위해 mesh 로 패러다임이 변화하고 있고 이런 상황에서 gRPC는 아주 좋은 선택이다. 이제 트래픽과 보안을 관리하는 방법을 알아보자.</p><hr><h2 id=so-whats-a-service-mesh>So What’s a Service Mesh?</h2><ul><li>Policies for Traffic Management and Security</li><li>Control Plane (e.g. Istio) stores and manges policies</li><li>In the proxy mode transparent proxies enforce/implement politices</li><li>gRPC sends requests to the virtual IP of the service</li><li>Proxy interrupts requests, applies policies and forwards to local service instance</li><li>But with gRPC, there is proxyless mode!</li></ul><hr><h3 id=개인-정리-2>개인 정리</h3><ul><li><p>원본 영상에서는 performance 비교를 한다.</p></li><li><p>gRPC는 proxyless mode를 지원하고 이를 사용하게 되면 그렇지 않았을때(대조군 envoy)에 비해 자원 사용량과 성능 측면에서 장점을 보인다.</p></li><li><p>궁금점 : proxyless mode? 그게 어떻게 가능하지? 이렇게 되면 기껏 msa 복잡성을 낮추기 위해 mesh를 도입하고 endpoint를 추상화한게 다 무효 아닌가?:</p><ul><li>해결 : 찾아보니 Istio (일반적으로 kubernetes 에서 service mesh로 쓰는 프레임워크) 에서 지원해주는 것이였다. <a href=%5Bhttps://istio.io/v1.12/blog/2021/proxyless-grpc/%5D(https://istio.io/v1.12/blog/2021/proxyless-grpc/)>출처 - istio 공식 문서</a></li><li>구체적인 동작 방식은 <a href="%5Bhttps://www.youtube.com/watch?v=zOEtoHTEZWQ%5D(https://www.youtube.com/watch?v=zOEtoHTEZWQ)">Proxyless gRPC</a> 의 10분 20초 경 architecture 그림을 보면 빨리 다가온다.</li></ul></li></ul><hr><h2 id=service-mesh-with-xds>Service Mesh With xDS</h2><ul><li>xDS Data Plane APIs from Envoy: Open & Extensible</li><li>Right choice for gRPC Service Mesh!</li></ul><h2 id=security-in-the-service-mesh>Security In the Service Mesh</h2><p>Why is Security SO Important?</p><ul><li>Remember the paradigm shift of breaking a monolith into microservices?</li><li>In-process calls are now gRPC calls between microservices over the network</li><li>This is network traffic needs to be authenticated, encrypted and authority.</li></ul><h2 id=service-mesh-with-security>Service Mesh with Security</h2><ul><li>Security Infrastructure provides certificates and keys</li><li>Control plane configures mTCS in CDS(client side) or LDS(servce side)</li><li>gRPC uses provided certs and transport_socket configuration to create mTLS connections</li><li>mTLS gives you encryption + authentication + server authorization</li><li>Server uses “authorization policy” aka RBAC to autorize RPCs based on client identities</li></ul><h2 id=using-grpc-in-proxyless-service-mesh>Using gRPC in Proxyless Service Mesh.</h2><h2 id=grpc-microservices--observability>gRPC Microservices & Observability</h2><ul><li>Using gRPC, a monolith now split into microservices spread over diverse infrastructure</li><li>Behavior of the “system” now dependent on individual microservices, network, compute & other infrastructure</li><li>If an issue aries, how can we debug and fix it? needed to incrase reliability and efficiency of this new paradigm</li><li>We need an “observable’ system where internal state is visible or can be inferred</li><li>Can gRPC provide this “observability” into your microservices?</li></ul><h2 id=grpc-observability>gRPC Observability</h2><ul><li>3 traditional pillars of observability: logs, metrics and traces</li><li>Use gRPC’s “interceptor” framework to collect the raw data for the 3 pillars</li><li>Integrate with exporters and anlytics backends to provide end-to-end observability</li></ul><h2 id=grpc-observability-aka-o11y>gRPC Observability aka O11y</h2><hr><h3 id=개인-생각>개인 생각</h3><ul><li>grpc 를 사용하려면 결국에는 잘 확인할수 있어야한다. logs나 metrics 이나 어떻게 흘러갔는지 trace 같은 걸 말이다.</li><li>단적인 사례로 <a href=https://blog.banksalad.com/tech/production-ready-grpc-in-golang/>뱅크샐러드 기술블로그 - 프로덕션 환경에서 사용하는 golang과 gRPC</a> 를 읽어보면 얼마나 이를 위해서 노력하는지 알수 있다.</li><li>개인 생각 : HTTP는 아주 오랜기간 사용되었고, 정말 넓은 분야에서 사용되었기에 충분한 시각화, 질의 도구들이 있다. 하지만 gRPC가 이것들이 부족함을 지적하는 파트라고 생각한다.</li></ul><hr><h2 id=grpc-observability-in-gcp>gRPC Observability in GCP</h2><ul><li>gRPC library enhanced with necessary plugins for logging, metrics & traces</li><li>Raw data exported via Stackdriver exporters to Google CloudOps backend</li><li>Admin console to enable/administer feature</li><li>Consumer dashboard to visualize</li></ul><h3 id=grpc-observability-with-java>gRPC Observability with Java</h3><ul><li>grpc-gcp-observability artifact to be added to your application build</li><li>grpc-gcp-observability pulls in other required dependencies e.g. Stackdriver exporter</li><li>Call observability init() from the app</li><li>You get observability when application run in Google Cloud and with appropriate config</li></ul><h3 id=grpc-observability-metrics--trace>gRPC Observability: Metrics & Trace</h3><ul><li>Private Preview of Metrics & Traces coming soon- before end of Q2’22 for Java and Go</li><li>Integrated with Google Cloud Monitoring and Google Cloud Trace</li><li>Incorporate metrics views into Minotoring dashboards and charts</li><li>Trace Overview shows recent traces: select individual trace to see breakdown of traffic</li></ul><hr><h3 id=개인-생각-1>개인 생각</h3><ul><li>gcp 에서 사용하면 기본적으로 이런 도구들을 제공한다는 일종의 홍보라고 해석했다.</li><li>근데 proxyless 사용하면 이 기능 제한된다고 홈페이지에 나와있던데 … <a href="%5Bhttps://cloud.google.com/traffic-director/docs/limitations-proxyless?hl=ko%5D(https://cloud.google.com/traffic-director/docs/limitations-proxyless?hl=ko)">출처 - gcp Traffic Director 문서</a></li></ul><hr><h1 id=정리>정리</h1><h2 id=새롭게-알게된-것>새롭게 알게된 것</h2><ul><li>http2 가 양방향을 지원하고 이를 grpc가 적극 사용하고 있다.<ul><li>http2 에 대한 공부가 더 필요하다.</li></ul></li><li>istio 의 내부 동작 구조<ul><li>기존에는 proxy를 써서 어떻게 동작했는지, proxyless를 사용하려면 어떻게 동작해야하는지에 대해서 대략적으로 알게되었다.</li></ul></li><li>observability의 3가지: logs, metrics, traces<ul><li>대략 감만 있었는데 명확히 써놓으니까 더 잘 다가온다.</li></ul></li><li>뱅크샐러드가 프로덕션에서 grpc를 사용하기 위해서 노력한 것들:<ul><li>관련 자료 찾아보면서 글을 발견해서 찾아보게 되었다.</li></ul></li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>