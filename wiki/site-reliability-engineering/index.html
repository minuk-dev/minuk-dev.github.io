<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>사이트 신뢰성 엔지니어링 |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>사이트 신뢰성 엔지니어링 -
minuk dev wiki</div></header><main><aside class=sidebar><ul class=section-tree><li class="dir opened-dir"><span class=dir-text>Front Page</span><ul class=section-tree><li class=file><a href=https://minuk.dev/wiki/kubernetes-community-day-korea/ title=./wiki/kubernetes-community-day-korea/>Kubernetes Community Day 2024</a></li><li class=file><a href=https://minuk.dev/wiki/observability-engineering-kr/ title=./wiki/observability-engineering-kr/>Observability Engineering</a></li><li class=file><a href=https://minuk.dev/wiki/learning-opentelemetry/ title=./wiki/learning-opentelemetry/>Learning OpenTelemetry</a></li><li class=file><a href=https://minuk.dev/wiki/prometheus-native-histograms-in-production/ title=./wiki/prometheus-native-histograms-in-production/>prometheus-native-histograms-in-proudction</a></li><li class=file><a href=https://minuk.dev/wiki/making-sense-of-your-vital-signals-the-future-of-pod-and-containers-monitoring/ title=./wiki/making-sense-of-your-vital-signals-the-future-of-pod-and-containers-monitoring/>Making Sense of Your Vital Signals - The Future of Pod and Containers Monitoring</a></li><li class=file><a href=https://minuk.dev/wiki/defining-a-common-observability-query-language-and-other-observability-tag-updates/ title=./wiki/defining-a-common-observability-query-language-and-other-observability-tag-updates/>Defining A Common Observability Query Language and Other observability TAG Updates</a></li><li class=file><a href=https://minuk.dev/wiki/beyond-tracing-what-do-we-do-with-all-this-data/ title=./wiki/beyond-tracing-what-do-we-do-with-all-this-data/>Beyond Tracing - What do we do with all this data</a></li><li class=file><a href=https://minuk.dev/wiki/grafanacon/ title=./wiki/grafanacon/>grafanacon</a></li><li class=file><a href=https://minuk.dev/wiki/observability-engineering/ title=./wiki/observability-engineering/>Observability Engineering</a></li><li class=file><a href=https://minuk.dev/wiki/rust/ title=./wiki/rust/>rust</a></li><li class=file><a href=https://minuk.dev/wiki/opentelemetry-metrics-deep-dive/ title=./wiki/opentelemetry-metrics-deep-dive/>opentelemetry metrics deep dive</a></li><li class=file><a href=https://minuk.dev/wiki/armeria/ title=./wiki/armeria/>armeria</a></li><li class=file><a href=https://minuk.dev/wiki/kotlin/ title=./wiki/kotlin/>kotlin</a></li><li class=file><a href=https://minuk.dev/wiki/loki-best-practices/ title=./wiki/loki-best-practices/>loki label best practices</a></li><li class=file><a href=https://minuk.dev/wiki/loki/ title=./wiki/loki/>loki</a></li><li class=file><a href=https://minuk.dev/wiki/grafana-loki-like-prometheus-but-for-logs/ title=./wiki/grafana-loki-like-prometheus-but-for-logs/>Grafana Loki - Like Prometheus, But for logs.</a></li><li class=file><a href=https://minuk.dev/wiki/spring-boot-cli/ title=./wiki/spring-boot-cli/>spring boot cli</a></li><li class=file><a href=https://minuk.dev/wiki/autoconf/ title=./wiki/autoconf/>autoconf</a></li><li class=file><a href=https://minuk.dev/wiki/re-minuk-k8s/ title=./wiki/re-minuk-k8s/>다시 시작하는 쿠버네티스 세팅</a></li><li class=file><a href=https://minuk.dev/wiki/cloud-native-go/ title=./wiki/cloud-native-go/>Cloud Native Go</a></li><li class=file><a href=https://minuk.dev/wiki/overlayfs/ title=./wiki/overlayfs/>overlayfs</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/design-pattern/ title=./wiki/lectures/design-pattern/>lectures/design-pattern</a></li><li class=file><a href=https://minuk.dev/wiki/site-reliability-engineering/ title=./wiki/site-reliability-engineering/>사이트 신뢰성 엔지니어링</a></li><li class=file><a href=https://minuk.dev/wiki/to-ipv6-the-dual-stack-adoption-advisory-panel/ title=./wiki/to-ipv6-the-dual-stack-adoption-advisory-panel/>To IPv6 - The Dual-stack Adoption Advisory Panel</a></li><li class=file><a href=https://minuk.dev/wiki/prometheus-intro-and-deep-dive/ title=./wiki/prometheus-intro-and-deep-dive/>Prometheus Intro and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/cs/ title=./wiki/cs/>cs 기본</a></li><li class=file><a href=https://minuk.dev/wiki/coredns/ title=./wiki/coredns/>learning-coredns</a></li><li class=file><a href=https://minuk.dev/wiki/coredns-into-and-deep-dive/ title=./wiki/coredns-into-and-deep-dive/>CoreDNS - Intro and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/deep-dive-into-minikube/ title=./wiki/deep-dive-into-minikube/>Deep Dive into Minikube</a></li><li class=file><a href=https://minuk.dev/wiki/making-your-apps-and-infrastructure-services-failure-resilient-with-dapr/ title=./wiki/making-your-apps-and-infrastructure-services-failure-resilient-with-dapr/>Making Your Apps and Infrastructure Services Failure-Resilient with Dapr</a></li><li class=file><a href=https://minuk.dev/wiki/make-cloud-native-chaos-engineering-easier-deep-dive-into-chaos-mesh/ title=./wiki/make-cloud-native-chaos-engineering-easier-deep-dive-into-chaos-mesh/>Make Cloud Native Chaos Engineering Easier Deep Dive into Chaos Mesh</a></li><li class=file><a href=https://minuk.dev/wiki/selinux/ title=./wiki/selinux/>selinux</a></li><li class=file><a href=https://minuk.dev/wiki/http-go/ title=./wiki/http-go/>go snippet for go</a></li><li class=file><a href=https://minuk.dev/wiki/curl/ title=./wiki/curl/>curl</a></li><li class=file><a href=https://minuk.dev/wiki/volcano-intro-and-deep-dive/ title=./wiki/volcano-intro-and-deep-dive/>Volcano - Intro & Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/intro-to-kubernetes-gitops-and-observability-hands-on-tutorial/ title=./wiki/intro-to-kubernetes-gitops-and-observability-hands-on-tutorial/>Intro to Kubernetes, GitOps, and Observability Hands-On Tutorial</a></li><li class=file><a href=https://minuk.dev/wiki/kubespray/ title=./wiki/kubespray/>kubespray</a></li><li class=file><a href=https://minuk.dev/wiki/spark-on-kubernetes-the-elastic-story/ title=./wiki/spark-on-kubernetes-the-elastic-story/>Spark on Kubernetes - The Elastic Story</a></li><li class=file><a href=https://minuk.dev/wiki/devops%EC%99%80-se%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%9D%B4%EC%95%BC%EA%B8%B0/ title=./wiki/devops%EC%99%80-se%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%9D%B4%EC%95%BC%EA%B8%B0/>DevOps와 SE를 위한 리눅스 커널 이야기</a></li><li class=file><a href=https://minuk.dev/wiki/running-containerd-and-k3s-on-macos/ title=./wiki/running-containerd-and-k3s-on-macos/>Running Containerd and k3s on MacOS</a></li><li class=file><a href=https://minuk.dev/wiki/twelve-factor-app/ title=./wiki/twelve-factor-app/>12요소 어플리케이션</a></li><li class=file><a href=https://minuk.dev/wiki/vim-go/ title=./wiki/vim-go/>vim/vim-go</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-patterns/ title=./wiki/kubernetes-patterns/>쿠버네티스 패턴</a></li><li class=file><a href=https://minuk.dev/wiki/horizontalpodautoscaler/ title=./wiki/horizontalpodautoscaler/>Horizontal Pod AutoScaler</a></li><li class=file><a href=https://minuk.dev/wiki/what-if-kube-apiserver-could-be-extended-via-webassembly/ title=./wiki/what-if-kube-apiserver-could-be-extended-via-webassembly/>What If… Kube-Apiserver Could be Extended Via WebAssembly?</a></li><li class=file><a href=https://minuk.dev/wiki/the-future-of-reproducible-research-powered-by-kubeflow/ title=./wiki/the-future-of-reproducible-research-powered-by-kubeflow/>The Future Of Reproducible Research - Powered by Kubeflow</a></li><li class=file><a href=https://minuk.dev/wiki/this-is-the-way-a-crash-course-on-intricacies-of-managing-cpus/ title=./wiki/this-is-the-way-a-crash-course-on-intricacies-of-managing-cpus/>This is The Way- A Crash Course on the Intricacies of Managing CPUs in K8s</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-graceful-shutdown/ title=./wiki/kubernetes-graceful-shutdown/>kubernetes-graceful-shutdown</a></li><li class=file><a href=https://minuk.dev/wiki/dockerfile/ title=./wiki/dockerfile/>dockerfile</a></li><li class=file><a href=https://minuk.dev/wiki/automated-progressive-delivery-using-gitops-and-service-mesh/ title=./wiki/automated-progressive-delivery-using-gitops-and-service-mesh/>Automated Progressive Delivery Using GitOps and Service Mesh</a></li><li class=file><a href=https://minuk.dev/wiki/containerd-proejct-update-and-deep-dive/ title=./wiki/containerd-proejct-update-and-deep-dive/>containerd Project Update and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/http2/ title=./wiki/http2/>http2 탐구</a></li><li class=file><a href=https://minuk.dev/wiki/grpc-for-microservices/ title=./wiki/grpc-for-microservices/>gRPC For Microservices Service-mesh and Observability</a></li><li class=file><a href=https://minuk.dev/wiki/kubecon/ title=./wiki/kubecon/>kubecon</a></li><li class=file><a href=https://minuk.dev/wiki/go-http/ title=./wiki/go-http/>go-http</a></li><li class=file><a href=https://minuk.dev/wiki/go/ title=./wiki/go/>go</a></li><li class=file><a href=https://minuk.dev/wiki/cri/ title=./wiki/cri/>CRI(Container Runtime Interface)</a></li><li class=file><a href=https://minuk.dev/wiki/vagrant/ title=./wiki/vagrant/>vagrant</a></li><li class=file><a href=https://minuk.dev/wiki/jsonpath/ title=./wiki/jsonpath/>jsonpath</a></li><li class=file><a href=https://minuk.dev/wiki/systemctl/ title=./wiki/systemctl/>systemctl 중요한것만 정리</a></li><li class=file><a href=https://minuk.dev/wiki/init/ title=./wiki/init/>linux init 요약</a></li><li class=file><a href=https://minuk.dev/wiki/process-cli/ title=./wiki/process-cli/>process 관련된 명령어 모음</a></li><li class=file><a href=https://minuk.dev/wiki/process-status/ title=./wiki/process-status/>process-status</a></li><li class=file><a href=https://minuk.dev/wiki/teamnote-go/ title=./wiki/teamnote-go/>teamnote-go</a></li><li class=file><a href=https://minuk.dev/wiki/cgroups/ title=./wiki/cgroups/>cgroup</a></li><li class=file><a href=https://minuk.dev/wiki/namespaces/ title=./wiki/namespaces/>namespaces</a></li><li class=file><a href=https://minuk.dev/wiki/lxc/ title=./wiki/lxc/>LXC</a></li><li class=file><a href=https://minuk.dev/wiki/devops/ title=./wiki/devops/>devops</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/supply-and-demand/ title=./wiki/ringle/supply-and-demand/>Supply and Demand</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/the-metaverse/ title=./wiki/ringle/the-metaverse/>ringle/The metaverse</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/microsoft-x-activision-blizzard/ title=./wiki/ringle/microsoft-x-activision-blizzard/>ringle/Microsoft x Activision Blizzard</a></li><li class=file><a href=https://minuk.dev/wiki/topcit/ title=./wiki/topcit/>topcit 간략 공부</a></li><li class=file><a href=https://minuk.dev/wiki/software-engineering-at-google/ title=./wiki/software-engineering-at-google/>구글 엔지니어는 이렇게 일한다</a></li><li class=file><a href=https://minuk.dev/wiki/k8s-in-rpi/ title=./wiki/k8s-in-rpi/>k8s-in-rpi</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes/ title=./wiki/kubernetes/>kubernetes</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/numerical_analysis/ title=./wiki/lectures/numerical_analysis/>수치해석</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/information_security_theory/ title=./wiki/lectures/information_security_theory/>2022-1 정보보호이론</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/ title=./wiki/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/>제텔카스텐</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A7%81%EA%B8%80/autonomous/ title=./wiki/%EB%A7%81%EA%B8%80/autonomous/>링글/Autonomous</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A7%81%EA%B8%80/metaverse/ title=./wiki/%EB%A7%81%EA%B8%80/metaverse/>링글/Metaverse</a></li><li class=file><a href=https://minuk.dev/wiki/algorithm/ title=./wiki/algorithm/>algorithm</a></li><li class=file><a href=https://minuk.dev/wiki/study-note/ title=./wiki/study-note/>study-note</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/machine-learning/ title=./wiki/lectures/machine-learning/>2022 1학기 머신러닝</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-in-action/ title=./wiki/kubernetes-in-action/>Kubernetes in action</a></li><li class=file><a href=https://minuk.dev/wiki/effective-java/ title=./wiki/effective-java/>Effective Java</a></li><li class=file><a href=https://minuk.dev/wiki/kafka/ title=./wiki/kafka/>Kafka</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/ title=./wiki/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/>면접 준비 자료</a></li><li class=file><a href=https://minuk.dev/wiki/zsh/ title=./wiki/zsh/>zsh</a></li><li class=file><a href=https://minuk.dev/wiki/simple-file/ title=./wiki/simple-file/>Simple한 File Server</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-12-03/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-12-03/>회고/2021-12-03</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week3/ title=./wiki/lectures/bayesian/week3/>bayesian/week3</a></li><li class=file><a href=https://minuk.dev/wiki/jupyter/ title=./wiki/jupyter/>jupyter notebook</a></li><li class=file><a href=https://minuk.dev/wiki/ffmpeg/ title=./wiki/ffmpeg/>ffmpeg 를 사용한 convert 요약</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week2/ title=./wiki/lectures/bayesian/week2/>bayesian/week2</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week1/ title=./wiki/lectures/bayesian/week1/>bayesian/week1</a></li><li class=file><a href=https://minuk.dev/wiki/pdf-test/ title=./wiki/pdf-test/>pdf-test</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/automata/ title=./wiki/lectures/automata/>오토마타와 형식언어 정리</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/computer-communication/ title=./wiki/lectures/computer-communication/>컴퓨터통신</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/introduction-to-statistical-learning/ title=./wiki/lectures/introduction-to-statistical-learning/>통계학습개론(Introduction to statistical learnning) 수업 정리</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian-statistics/ title=./wiki/lectures/bayesian-statistics/>베이지안 통계학(Bayesian Statistics)</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/multi-variant-statistical-analysis/ title=./wiki/lectures/multi-variant-statistical-analysis/>Multi Variant Statistical Analysis</a></li><li class=file><a href=https://minuk.dev/wiki/comment/ title=./wiki/comment/>주석 관련 좋은 글</a></li><li class=file><a href=https://minuk.dev/wiki/ssh/ title=./wiki/ssh/>ssh 관련 명령어 모음</a></li><li class=file><a href=https://minuk.dev/wiki/msk/ title=./wiki/msk/>amazon msk 삽질</a></li><li class=file><a href=https://minuk.dev/wiki/keras-book/ title=./wiki/keras-book/>케라스 창시자에게 배우는 딥러닝 책 공부</a></li><li class=file><a href=https://minuk.dev/wiki/msa-from-ddd/ title=./wiki/msa-from-ddd/>도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-07-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-07-18/>2021-07-21 회고</a></li><li class=file><a href=https://minuk.dev/wiki/iamroot19/ title=./wiki/iamroot19/>아이엠루트 스터디 자료 정리</a></li><li class=file><a href=https://minuk.dev/wiki/boj-9019/ title=./wiki/boj-9019/>boj-9019</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-06-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-06-19/>2021년 6월 19일 회고</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%8F%85%EC%84%B1%EB%A7%90%ED%88%AC/ title=./wiki/%EB%8F%85%EC%84%B1%EB%A7%90%ED%88%AC/>독성말투</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/regression/ title=./wiki/lectures/regression/>Regression Analysis</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%94%BC%EC%8B%9C%EC%8B%A4/ title=./wiki/%ED%94%BC%EC%8B%9C%EC%8B%A4/>피시실</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/multicore/ title=./wiki/lectures/multicore/>Multicore Computing</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/ns3/ title=./wiki/lectures/ns3/>Network Simulator 3</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/nonparametric-statistic/ title=./wiki/lectures/nonparametric-statistic/>비모수 통계학</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/wireless/ title=./wiki/lectures/wireless/>wireless 무선이동통신 수업</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/database_system/ title=./wiki/lectures/database_system/>Database System</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/ title=./wiki/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/>카카오워크</a></li><li class=file><a href=https://minuk.dev/wiki/soma/ title=./wiki/soma/>소프트웨어 마에스트로</a></li><li class=file><a href=https://minuk.dev/wiki/linux_kakaotalk/ title=./wiki/linux_kakaotalk/>리눅스 카카오톡</a></li><li class=file><a href=https://minuk.dev/wiki/latina/ title=./wiki/latina/>라틴어</a></li><li class=file><a href=https://minuk.dev/wiki/blk-mq/ title=./wiki/blk-mq/>Multi-Queue Block IO Queueing (blk-mq)</a></li><li class=file><a href=https://minuk.dev/wiki/linux-study/ title=./wiki/linux-study/>linux-study</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-12-20/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-12-20/>2020-12-20 회고</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/scheduling/ title=./wiki/linux-debug/scheduling/>linux-debug/scheduling</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/synchronization/ title=./wiki/linux-debug/synchronization/>linux-debug/synchronization</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/timer/ title=./wiki/linux-debug/timer/>linux-debug/timer</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/workqueue/ title=./wiki/linux-debug/workqueue/>linux-debug/workqueue</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/interrupt/ title=./wiki/linux-debug/interrupt/>linux-debug/interrupt</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/process/ title=./wiki/linux-debug/process/>linux-debug/process</a></li><li class=file><a href=https://minuk.dev/wiki/input-method/ title=./wiki/input-method/>linux input-method 삽질</a></li><li class=file><a href=https://minuk.dev/wiki/assembly/ title=./wiki/assembly/>assembly</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-10-24/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-10-24/>2020-10-24 회고</a></li><li class=file><a href=https://minuk.dev/wiki/contextmenu/ title=./wiki/contextmenu/>contextmenu</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-10-09/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-10-09/>2020-10-09 회고</a></li><li class=file><a href=https://minuk.dev/wiki/others/ title=./wiki/others/>others</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-09-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-09-18/>2020-09-18 회고</a></li><li class=file><a href=https://minuk.dev/wiki/seccomp/ title=./wiki/seccomp/>seccomp</a></li><li class=file><a href=https://minuk.dev/wiki/debug-linux/ title=./wiki/debug-linux/>디버깅을 통해 배우는 리눅스 커널의 구조와 원리</a></li><li class=file><a href=https://minuk.dev/wiki/fuse/ title=./wiki/fuse/>Filesystem in Userspace</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-08-30/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-08-30/>회고/2020-08-30</a></li><li class=file><a href=https://minuk.dev/wiki/raid/ title=./wiki/raid/>RAID(Redundant Array of Independent Disks)</a></li><li class=file><a href=https://minuk.dev/wiki/storage/ title=./wiki/storage/>Storage</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-08-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-08-17/>2020-08-17 회고</a></li><li class=file><a href=https://minuk.dev/wiki/teamnote/ title=./wiki/teamnote/>teamnote</a></li><li class=file><a href=https://minuk.dev/wiki/git/ title=./wiki/git/>git</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-07-31/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-07-31/>2020년 7월 31일자 회고</a></li><li class=file><a href=https://minuk.dev/wiki/3%EA%B3%B5%EB%85%B8%ED%8A%B8/ title=./wiki/3%EA%B3%B5%EB%85%B8%ED%8A%B8/>3공 노트</a></li><li class=file><a href=https://minuk.dev/wiki/nas/ title=./wiki/nas/>NAS</a></li><li class=file><a href=https://minuk.dev/wiki/lfs/ title=./wiki/lfs/>LFS Paper</a></li><li class=file><a href=https://minuk.dev/wiki/ftl/ title=./wiki/ftl/>Flash Translation Layer</a></li><li class=file><a href=https://minuk.dev/wiki/ppn/ title=./wiki/ppn/>PPN(Physical Page Number)</a></li><li class=file><a href=https://minuk.dev/wiki/lpn/ title=./wiki/lpn/>LPN(Logical Page Number)</a></li><li class=file><a href=https://minuk.dev/wiki/load-balance/ title=./wiki/load-balance/>Load Balance</a></li><li class=file><a href=https://minuk.dev/wiki/cache/ title=./wiki/cache/>Cache</a></li><li class=file><a href=https://minuk.dev/wiki/uart/ title=./wiki/uart/>UART (Universal asynchronous receiver/transmitter)</a></li><li class=file><a href=https://minuk.dev/wiki/vhdci/ title=./wiki/vhdci/>VHDCI (Very-high-dencity cable interconnect)</a></li><li class=file><a href=https://minuk.dev/wiki/boxplot/ title=./wiki/boxplot/>boxplot</a></li><li class=file><a href=https://minuk.dev/wiki/quartile/ title=./wiki/quartile/>quartile (사분위수)</a></li><li class=file><a href=https://minuk.dev/wiki/statistics/ title=./wiki/statistics/>statistics</a></li><li class=file><a href=https://minuk.dev/wiki/fsm/ title=./wiki/fsm/>FSM (Finite State machine)</a></li><li class=file><a href=https://minuk.dev/wiki/open-nvm/ title=./wiki/open-nvm/>open-nvm</a></li><li class=file><a href=https://minuk.dev/wiki/mram/ title=./wiki/mram/>MRAM (Magnetic Random Access Memory)</a></li><li class=file><a href=https://minuk.dev/wiki/file/ title=./wiki/file/>vfs - file</a></li><li class=file><a href=https://minuk.dev/wiki/kiocb/ title=./wiki/kiocb/>kiocb</a></li><li class=file><a href=https://minuk.dev/wiki/vfs/ title=./wiki/vfs/>VFS-Virtual File System</a></li><li class=file><a href=https://minuk.dev/wiki/linux/ title=./wiki/linux/>linux</a></li><li class=file><a href=https://minuk.dev/wiki/f2fs-paper/ title=./wiki/f2fs-paper/>F2FS- A New File System for Flash Storage</a></li><li class=file><a href=https://minuk.dev/wiki/english/proverb/ title=./wiki/english/proverb/>english/proverb</a></li><li class=file><a href=https://minuk.dev/wiki/english/ title=./wiki/english/>english</a></li><li class=file><a href=https://minuk.dev/wiki/tool/ title=./wiki/tool/>tool</a></li><li class=file><a href=https://minuk.dev/wiki/verilog/ title=./wiki/verilog/>verilog (베릴로그)</a></li><li class=file><a href=https://minuk.dev/wiki/iommu/ title=./wiki/iommu/>IOMMU (Input Output Memory Management Unit)</a></li><li class=file><a href=https://minuk.dev/wiki/delayed_work/ title=./wiki/delayed_work/>delayed work</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/>회고/2020-06-21</a></li><li class=file><a href=https://minuk.dev/wiki/jwt/ title=./wiki/jwt/>json web token(jwt)</a></li><li class=file><a href=https://minuk.dev/wiki/tmuxinator/ title=./wiki/tmuxinator/>tmuxinator</a></li><li class=file><a href=https://minuk.dev/wiki/vim-staritfy/ title=./wiki/vim-staritfy/>vim-startify</a></li><li class=file><a href=https://minuk.dev/wiki/my-page/ title=./wiki/my-page/>my-page (나만의 홈페이지 만들기)</a></li><li class=file><a href=https://minuk.dev/wiki/blk_mq/ title=./wiki/blk_mq/>blk_mq</a></li><li class=file><a href=https://minuk.dev/wiki/prp/ title=./wiki/prp/>PRP (Physical Region Page)</a></li><li class=file><a href=https://minuk.dev/wiki/numa/ title=./wiki/numa/>NUMA</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/>회고/2020-06-17</a></li><li class=file><a href=https://minuk.dev/wiki/block-layer/ title=./wiki/block-layer/>block layer</a></li><li class=file><a href=https://minuk.dev/wiki/workqueue/ title=./wiki/workqueue/>workqueue</a></li><li class=file><a href=https://minuk.dev/wiki/nvme/ title=./wiki/nvme/>nvme</a></li><li class=file><a href=https://minuk.dev/wiki/gem5/ title=./wiki/gem5/>gem5</a></li><li class=file><a href=https://minuk.dev/wiki/simplessd/ title=./wiki/simplessd/>simple-ssd</a></li><li class=file><a href=https://minuk.dev/wiki/mmap/ title=./wiki/mmap/>mmap</a></li><li class=file><a href=https://minuk.dev/wiki/b+tree/ title=./wiki/b+tree/>B+ Tree</a></li><li class=file><a href=https://minuk.dev/wiki/database/ title=./wiki/database/>Database</a></li><li class=file><a href=https://minuk.dev/wiki/memory-cache-clean/ title=./wiki/memory-cache-clean/>memory cache 비우기 (linux command)</a></li><li class=file><a href=https://minuk.dev/wiki/free/ title=./wiki/free/>free (linux command)</a></li><li class=file><a href=https://minuk.dev/wiki/clflush/ title=./wiki/clflush/>clflush (cache line flush)</a></li><li class=file><a href=https://minuk.dev/wiki/c++/ title=./wiki/c++/>C++ Language</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/ title=./wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/>사지방</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/ title=./wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/>2020년 3월 회고</a></li><li class=file><a href=https://minuk.dev/wiki/mysql/ title=./wiki/mysql/>mysql (storage engine)</a></li><li class=file><a href=https://minuk.dev/wiki/block-group/ title=./wiki/block-group/>block group</a></li><li class=file><a href=https://minuk.dev/wiki/journal/ title=./wiki/journal/>journal(journaling)</a></li><li class=file><a href=https://minuk.dev/wiki/group-descriptor-table/ title=./wiki/group-descriptor-table/>group descriptor table</a></li><li class=file><a href=https://minuk.dev/wiki/inode/ title=./wiki/inode/>inode</a></li><li class=file><a href=https://minuk.dev/wiki/superblock/ title=./wiki/superblock/>Superblock</a></li><li class=file><a href=https://minuk.dev/wiki/ext4/ title=./wiki/ext4/>The new ext4 filesystem: current status and future plans</a></li><li class=file><a href=https://minuk.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/ title=./wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/>계룡 개발 모임</a></li><li class=file><a href=https://minuk.dev/wiki/ssd/ title=./wiki/ssd/>SSD</a></li><li class=file><a href=https://minuk.dev/wiki/gutentags/ title=./wiki/gutentags/>gutentags</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-18--%EB%A9%94%EB%A9%98%ED%86%A0/ title=./wiki/modern-c++-design-pattern/chapter-18--%EB%A9%94%EB%A9%98%ED%86%A0/>Modern C++ Design Pattern/Chatper 18. 메멘토</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-17--%EB%A7%A4%EA%B0%9C%EC%9E%90/ title=./wiki/modern-c++-design-pattern/chapter-17--%EB%A7%A4%EA%B0%9C%EC%9E%90/>Modern C++ Design Pattern/Chatper 17. 매개자</a></li><li class=file><a href=https://minuk.dev/wiki/boj/ title=./wiki/boj/>boj</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-16--%EB%B0%98%EB%B3%B5%EC%9E%90/ title=./wiki/modern-c++-design-pattern/chapter-16--%EB%B0%98%EB%B3%B5%EC%9E%90/>Modern C++ Design Pattern/Chatper 16. 반복자</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-04-20/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-04-20/>회고/2020.04.20</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-15--%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-15--%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/>Modern C++ Design Pattern/Chatper 15. 인터프리터</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-14--%EC%BB%A4%EB%A7%A8%EB%93%9C/ title=./wiki/modern-c++-design-pattern/chapter-14--%EC%BB%A4%EB%A7%A8%EB%93%9C/>Modern C++ Design Pattern/Chatper 14. 커맨드</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-13--%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/ title=./wiki/modern-c++-design-pattern/chapter-13--%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/>Modern C++ Design Pattern/Chatper 13. 책임사슬(Chain of Responsibility)</a></li><li class=file><a href=https://minuk.dev/wiki/coc/ title=./wiki/coc/>coc (vim plugin coc)</a></li><li class=file><a href=https://minuk.dev/wiki/regex/ title=./wiki/regex/>Regular Expression (regex)</a></li><li class=file><a href=https://minuk.dev/wiki/glob/ title=./wiki/glob/>glob</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-12--%ED%94%84%EB%A1%9D%EC%8B%9C/ title=./wiki/modern-c++-design-pattern/chapter-12--%ED%94%84%EB%A1%9D%EC%8B%9C/>Modern C++ Design Pattern/Chapter 12. 프록시</a></li><li class=file><a href=https://minuk.dev/wiki/hugo/ title=./wiki/hugo/>hugo</a></li><li class=file><a href=https://minuk.dev/wiki/tee/ title=./wiki/tee/>tee (Linux Command)</a></li><li class=file><a href=https://minuk.dev/wiki/rm/ title=./wiki/rm/>rm (Linux Command)</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-11--%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/ title=./wiki/modern-c++-design-pattern/chapter-11--%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/>Modern C++ Design Pattern/Chapter 11. 플라이웨이트</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-10--%ED%8D%BC%EC%82%AC%EB%93%9C/ title=./wiki/modern-c++-design-pattern/chapter-10--%ED%8D%BC%EC%82%AC%EB%93%9C/>Modern C++ Design Pattern/Chapter 10. 퍼사드</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-7--%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-7--%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chatper 7. 컴파일 시간 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-8--%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/ title=./wiki/effective-debugging/chapter-8--%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/>Effective Debugging/Chatper 8. 멀티스레드 코드 디버깅</a></li><li class=file><a href=https://minuk.dev/wiki/todo/ title=./wiki/todo/>TODO Lists</a></li><li class=file><a href=https://minuk.dev/wiki/vim/ title=./wiki/vim/>vim</a></li><li class=file><a href=https://minuk.dev/wiki/vimwiki/ title=./wiki/vimwiki/>vimwiki</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-04-08/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-04-08/>회고/2020-04-08</a></li><li class=file><a href=https://minuk.dev/wiki/cloudatcost/ title=./wiki/cloudatcost/>cloudatcost</a></li><li class=file><a href=https://minuk.dev/wiki/web/ title=./wiki/web/>web</a></li><li class=file><a href=https://minuk.dev/wiki/nginx/ title=./wiki/nginx/>nginx</a></li><li class=file><a href=https://minuk.dev/wiki/understanding-linux-kernel/ title=./wiki/understanding-linux-kernel/>Understanding Linux Kernel</a></li><li class=file><a href=https://minuk.dev/wiki/mathematical-statistics/ title=./wiki/mathematical-statistics/>Mathematical Statistics</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/ title=./wiki/effective-debugging/>Effective Debugging</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-1--%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/ title=./wiki/effective-debugging/chapter-1--%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/>Effective Debugging/Chapter 1. 고차원 전략</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-2--%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-2--%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 2. 범용적인 디버깅 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-3--%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-3--%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 3. 범용 도구를 활용한 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-5--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-5--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 5. 프로그래밍 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chatper-4--%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/ title=./wiki/effective-debugging/chatper-4--%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/>Effective Debugging/Chatper 4. 디버거 활용법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chatper-6--%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chatper-6--%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chatper 6. 컴파일 시간 기법</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/ title=./wiki/modern-c++-design-pattern/>Modern C++ Design Pattern</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-1--%EA%B0%9C%EC%9A%94/ title=./wiki/modern-c++-design-pattern/chapter-1--%EA%B0%9C%EC%9A%94/>Modern C++ Design Pattern/Chatper 1. 개요</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-2--%EB%B9%8C%EB%8D%94/ title=./wiki/modern-c++-design-pattern/chapter-2--%EB%B9%8C%EB%8D%94/>Modern C++ Design Pattern/Chatper 2. 빌더</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-4--%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/ title=./wiki/modern-c++-design-pattern/chapter-4--%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/>Modern C++ Design Pattern/Chatper 4. 프로토타입</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-5--%EC%8B%B1%EA%B8%80%ED%84%B4/ title=./wiki/modern-c++-design-pattern/chapter-5--%EC%8B%B1%EA%B8%80%ED%84%B4/>Modern C++ Design Pattern/Chatper 5. 싱글턴</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-6--%EC%96%B4%EB%8C%91%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-6--%EC%96%B4%EB%8C%91%ED%84%B0/>Modern C++ Design Pattern/Chatper 6. 어댑터</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-7--%EB%B8%8C%EB%A6%BF%EC%A7%80/ title=./wiki/modern-c++-design-pattern/chapter-7--%EB%B8%8C%EB%A6%BF%EC%A7%80/>Modern C++ Design Pattern/Chatper 7. 브릿지</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-8--%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/ title=./wiki/modern-c++-design-pattern/chapter-8--%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/>Modern C++ Design Pattern/Chatper 8. 컴포지트</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-9--%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-9--%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/>Modern C++ Design Pattern/Chatper 9. 데코레이터</a></li><li class=file><a href=https://minuk.dev/wiki/book-reviews/ title=./wiki/book-reviews/>Book Review</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/algorithm/ title=./wiki/lectures/algorithm/>lectures/algorithm</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/computer-architecture/ title=./wiki/lectures/computer-architecture/>lectures/computer architecture</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/image-processing/ title=./wiki/lectures/image-processing/>lectures/image processing</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/ title=./wiki/lectures/>학교 수업</a></li><li class=file><a href=https://minuk.dev/wiki/tool-configuration/ title=./wiki/tool-configuration/>Tool configuration</a></li><li class=file><a href=https://minuk.dev/wiki/ssh-server/ title=./wiki/ssh-server/>SSH Server Configuration</a></li><li class=file><a href=https://minuk.dev/wiki/firewall/ title=./wiki/firewall/>Firewall (방화벽) Configuration</a></li><li class=file><a href=https://minuk.dev/wiki/ftp/ title=./wiki/ftp/>ftp server command</a></li><li class=file><a href=https://minuk.dev/wiki/user/ title=./wiki/user/>linux user command</a></li><li class=file><a href=https://minuk.dev/wiki/brightness/ title=./wiki/brightness/>Brightness (화면 밝기 조절) command</a></li><li class=file><a href=https://minuk.dev/wiki/wifi-command-line/ title=./wiki/wifi-command-line/>Wifi commands</a></li><li class=file><a href=https://minuk.dev/wiki/wifi/ title=./wiki/wifi/>Wifi commands</a></li><li class=file><a href=https://minuk.dev/wiki/linux-command/ title=./wiki/linux-command/>Linux Command 모음</a></li><li class=file><a href=https://minuk.dev/wiki/docker/ title=./wiki/docker/>docker</a></li><li class=file><a href=https://minuk.dev/wiki/sql/ title=./wiki/sql/>SQL</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/function/ title=./wiki/typescript/function/>Typescript/Function</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/class/ title=./wiki/typescript/class/>Typescript/Class</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/interface/ title=./wiki/typescript/interface/>Typescript/Interface</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/variable-declaration/ title=./wiki/typescript/variable-declaration/>Typescript/Variable Declaration</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/types/ title=./wiki/typescript/types/>Typescript/Types</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/ title=./wiki/typescript/>Typescript</a></li><li class=file><a href=https://minuk.dev/wiki/graphql-typescript/ title=./wiki/graphql-typescript/>graphql typescript (deprecated)</a></li><li class=file><a href=https://minuk.dev/wiki/winston/ title=./wiki/winston/>winston</a></li><li class=file><a href=https://minuk.dev/wiki/jest/ title=./wiki/jest/>Jest</a></li><li class=file><a href=https://minuk.dev/wiki/sequelize/ title=./wiki/sequelize/>Sequelize</a></li><li class=file><a href=https://minuk.dev/wiki/fetch/ title=./wiki/fetch/>Fetch 문법 간단 정리</a></li><li class=file><a href=https://minuk.dev/wiki/promise/ title=./wiki/promise/>Promise 정리</a></li><li class=file><a href=https://minuk.dev/wiki/javascript/ title=./wiki/javascript/>JavaScript</a></li><li class=file><a href=https://minuk.dev/wiki/nexus/ title=./wiki/nexus/>Nexus</a></li><li class=file><a href=https://minuk.dev/wiki/ssdsolid-state-drive/ title=./wiki/ssdsolid-state-drive/>SSD(Solid-State Drive)</a></li><li class=file><a href=https://minuk.dev/wiki/pintos/ title=./wiki/pintos/>Pintos</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/ title=./wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/>Bus 시간 메모</a></li><li class=file><a href=https://minuk.dev/wiki/5-articles-per-week/ title=./wiki/5-articles-per-week/>5 articles per week</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/ title=./wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/>썩어버린 Query Language</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/ title=./wiki/%ED%9A%8C%EA%B3%A0/>회고 모음</a></li><li class=file><a href=https://minuk.dev/wiki/memory_leak/ title=./wiki/memory_leak/>Javascript Memory Leak</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/ title=./wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/>송편 생성기 (추석 대회)</a></li><li class=file><a href=https://minuk.dev/wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/ title=./wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/>Endurable Transient Inconsistency in Byte Addressable Persistent B+-Tree</a></li><li class=file><a href=https://minuk.dev/wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/ title=./wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/>SSD 공부 자료 모음</a></li><li class=file><a href=https://minuk.dev/wiki/%EA%B0%9C%EB%B0%9C_todo/ title=./wiki/%EA%B0%9C%EB%B0%9C_todo/>개발 TODO</a></li><li class=file><a href=https://minuk.dev/wiki/f2fs/ title=./wiki/f2fs/>F2FS</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/ title=./wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/>설대회</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-01-01/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-01-01/>회고/2020-01-01</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-01-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-01-17/>회고/2020-01-17</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-11-24/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-11-24/>회고/2019.11.24</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-10-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-10-19/>회고/2019.10.19</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-09-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-09-19/>회고/2019.09.19</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-09-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-09-18/>회고/2019.09.18</a></li><li class=file><a href=https://minuk.dev/wiki/2024-12-23/ title=./wiki/2024-12-23/></a></li><li class=file><a href=https://minuk.dev/wiki/2025-01-05/ title=./wiki/2025-01-05/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/2025-01-10/ title=./wiki/daily/2025-01-10/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.41.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.41.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.49.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.49.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.59.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.59.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-05-05.12.23.excalidraw/ title=./wiki/drawings/drawing-2025-01-05-05.12.23.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-05-05.54.32.excalidraw/ title=./wiki/drawings/drawing-2025-01-05-05.54.32.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/excalidraw/test-draw/ title=./wiki/excalidraw/test-draw/></a></li><li class=file><a href=https://minuk.dev/wiki/ipad/ title=./wiki/ipad/></a></li><li class=file><a href=https://minuk.dev/wiki/jekyll-%EA%B8%B0%EB%B0%98-wiki-%EC%97%90%EC%84%9C-hugo-%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EA%B8%B0/ title=./wiki/jekyll-%EA%B8%B0%EB%B0%98-wiki-%EC%97%90%EC%84%9C-hugo-%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EA%B8%B0/></a></li><li class=file><a href=https://minuk.dev/wiki/lectures/compiler/ title=./wiki/lectures/compiler/></a></li><li class=file><a href=https://minuk.dev/wiki/lectures/signal_and_system/ title=./wiki/lectures/signal_and_system/></a></li><li class=file><a href=https://minuk.dev/wiki/macos-initialization/ title=./wiki/macos-initialization/></a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-3--%ED%8C%A9%ED%86%A0%EB%A6%AC/ title=./wiki/modern-c++-design-pattern/chapter-3--%ED%8C%A9%ED%86%A0%EB%A6%AC/></a></li><li class=file><a href=https://minuk.dev/wiki/test.excalidraw/ title=./wiki/test.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/test/ title=./wiki/test/></a></li><li class=file><a href=https://minuk.dev/wiki/ucpc_2018_%EC%98%88%EC%84%A0/ title=./wiki/ucpc_2018_%EC%98%88%EC%84%A0/></a></li><li class=file><a href=https://minuk.dev/wiki/%EB%8D%B0%EC%A4%91%EC%96%B4%EC%84%A4/ title=./wiki/%EB%8D%B0%EC%A4%91%EC%96%B4%EC%84%A4/></a></li><li class=file><a href=https://minuk.dev/wiki/%EC%9D%98%EA%B2%AC-%EB%A9%94%EB%AA%A8/ title=./wiki/%EC%9D%98%EA%B2%AC-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%EC%A3%BC%EC%9E%A5-%EB%A9%94%EB%AA%A8/ title=./wiki/%EC%A3%BC%EC%9E%A5-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%A9%94%EB%AA%A8/ title=./wiki/%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9/ title=./wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/></a></li><li class=file><a href=https://minuk.dev/wiki/tags/ title=./wiki/tags/>tag page</a></li></ul></li><li class=file><a href=https://minuk.dev/about/ title=./about/>about</a></li></ul></aside><aside class=exapandable></aside><article class=main><button class=sidebar-toggle-btn type=menu aria-expanded=false aria-haspopup=true>
<i class="bi bi-list"></i></button><div class=title><h1 class=title-header>사이트 신뢰성 엔지니어링</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/site-reliability-engineering.md><h5>created : Sun, 16 Oct 2022 17:00:35 +0900</h5><h5>modified : Sun, 03 Dec 2023 22:26:48 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
Front Page
[[Book reviews]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i>
<a href=/tags/sre class=tag-btn>sre</a></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#1-소개>1. 소개</a><ul><li><a href=#서비스-관리에-대한-구글의-해법-사이트-신뢰성-엔지니어링>서비스 관리에 대한 구글의 해법: 사이트 신뢰성 엔지니어링</a></li><li><a href=#sre의-신조>SRE의 신조</a></li></ul></li><li><a href=#2-sre-관점에서-바라본-구글의-프로덕션-환경>2. SRE 관점에서 바라본 구글의 프로덕션 환경</a><ul><li><a href=#하드웨어>하드웨어</a></li><li><a href=#하드웨어를-조율하는-시스템-소프트웨어>하드웨어를 조율하는 시스템 소프트웨어</a></li><li><a href=#기타-시스템-소프트웨어>기타 시스템 소프트웨어</a></li><li><a href=#소프트웨어-인프라스트럭처>소프트웨어 인프라스트럭처</a></li><li><a href=#개발-환경>개발 환경</a></li></ul></li></ul><ul><li><a href=#3-위험-요소-수용하기>3. 위험 요소 수용하기</a><ul><li><a href=#위험-요소-관리하기>위험 요소 관리하기</a></li><li><a href=#서비스-위험-측정하기>서비스 위험 측정하기</a></li><li><a href=#서비스의-위험-수용도>서비스의 위험 수용도</a></li><li><a href=#인프라스트럭처-서비스의-위험-수용도-정의하기>인프라스트럭처 서비스의 위험 수용도 정의하기</a></li><li><a href=#에러-예산-활용해보기>에러 예산 활용해보기</a></li></ul></li><li><a href=#4-서비스-수준-목표>4. 서비스 수준 목표</a><ul><li><a href=#서비스-수준-관련-용어>서비스 수준 관련 용어</a></li><li><a href=#지표-설정>지표 설정</a></li><li><a href=#척도의-표준화>척도의 표준화</a></li><li><a href=#목표-설정에-대한-실습>목표 설정에 대한 실습</a></li></ul></li><li><a href=#5-삽질은-이제-그만>5. 삽질은 이제 그만</a><ul><li><a href=#삽질의-정의>삽질의 정의</a></li><li><a href=#삽질이-줄어들면-좋은-이유>삽질이 줄어들면 좋은 이유</a></li><li><a href=#엔지니어링에-해당하는-업무>엔지니어링에 해당하는 업무</a></li><li><a href=#삽질은-무조건-나쁜-것일까>삽질은 무조건 나쁜 것일까?</a></li></ul></li><li><a href=#6-분산-시스템-모니터링>6. 분산 시스템 모니터링</a><ul><li><a href=#정의>정의</a></li><li><a href=#왜-모니터링해야-하는가>왜 모니터링해야 하는가?</a></li><li><a href=#모니터링에-대한-적절한-기대치-설정하기>모니터링에 대한 적절한 기대치 설정하기</a></li><li><a href=#증상과-원인>증상과 원인</a></li><li><a href=#블랙박스와-화이트-박스>블랙박스와 화이트 박스</a></li><li><a href=#네가지-결정적인-지표>네가지 결정적인 지표</a></li><li><a href=#마지막-요청혹은-실행과-성능에-대한-고려>마지막 요청(혹은 실행과 성능)에 대한 고려</a></li><li><a href=#적당한-측정-방법-선택하기>적당한 측정 방법 선택하기</a></li><li><a href=#더욱-단순하게가-아니라-최대한-단순하게>더욱 단순하게가 아니라 최대한 단순하게</a></li><li><a href=#지금까지-살펴본-원리들을-결합하기>지금까지 살펴본 원리들을 결합하기</a></li><li><a href=#장기적-모니터링>장기적 모니터링</a></li></ul></li><li><a href=#7-구글의-발전된-자동화>7. 구글의 발전된 자동화</a><ul><li><a href=#자동화의-가치>자동화의 가치</a></li><li><a href=#구글-sre의-가치>구글 SRE의 가치</a></li><li><a href=#스스로를-이롭게-하라-몽땅-자동화하자>스스로를 이롭게 하라: 몽땅 자동화하자!</a></li><li><a href=#신의-한-수-클러스터-턴업의-자동화>신의 한 수: 클러스터 턴업의 자동화</a></li><li><a href=#신뢰성은-근본적인-기능이다>신뢰성은 근본적인 기능이다</a></li></ul></li><li><a href=#8-릴리즈-엔지니어링>8. 릴리즈 엔지니어링</a><ul><li><a href=#릴리즈-엔지니어의-역할>릴리즈 엔지니어의 역할</a></li><li><a href=#릴리즈-엔지니어링의-철학>릴리즈 엔지니어링의 철학</a></li><li><a href=#지속적-빌드와-배포>지속적 빌드와 배포</a></li><li><a href=#설정-관리-기법>설정 관리 기법</a></li><li><a href=#릴리즈-엔지니어링을-처음부터-도입하라>릴리즈 엔지니어링을 처음부터 도입하라</a></li></ul></li><li><a href=#9-간결함>9. 간결함</a><ul><li><a href=#시스템의-안정성-vs-신속함>시스템의 안정성 vs. 신속함</a></li><li><a href=#지루함의-미덕>지루함의 미덕</a></li><li><a href=#내-코드는-절대-포기하지-않을꺼야>내 코드는 절대 포기하지 않을꺼야!</a></li><li><a href=#부정적-영향을-미치는-코드의-지표>부정적 영향을 미치는 코드의 지표</a></li><li><a href=#최소한의-api>최소한의 API</a></li><li><a href=#모듈화>모듈화</a></li><li><a href=#릴리즈의-간소화>릴리즈의 간소화</a></li></ul></li></ul><ul><li><a href=#10-시계열-데이터에-대한-실용적인-알림>10. 시계열 데이터에 대한 실용적인 알림</a><ul><li><a href=#시계열-데이터를-위한-저장소>시계열 데이터를 위한 저장소</a></li><li><a href=#모니터링-토폴로지의-샤딩>모니터링 토폴로지의 샤딩</a></li><li><a href=#블랙박스-모니터링>블랙박스 모니터링</a></li><li><a href=#설정의-유지보수>설정의 유지보수</a></li></ul></li><li><a href=#11-비상대기>11. 비상대기</a><ul><li><a href=#비상-대기-엔지니어의-삶>비상 대기 엔지니어의 삶</a></li><li><a href=#비상-대기-업무의-균형-맞추기>비상 대기 업무의 균형 맞추기</a></li><li><a href=#품질-균형>품질 균형</a></li><li><a href=#보상>보상</a></li><li><a href=#안전에-대해-고려하기>안전에 대해 고려하기</a></li><li><a href=#부적절한-운영-부하에서-벗어나기>부적절한 운영 부하에서 벗어나기</a></li></ul></li><li><a href=#12-효과적인-장애-조치>12. 효과적인 장애 조치</a><ul><li><a href=#이론>이론</a></li><li><a href=#실전>실전</a></li><li><a href=#부정적인-결과의-마법>부정적인 결과의 마법</a></li><li><a href=#처방>처방</a></li><li><a href=#조금-더-수월하게-장애를-조치하기>조금 더 수월하게 장애를 조치하기</a></li></ul></li><li><a href=#13-긴급-대응>13. 긴급 대응</a><ul><li></li></ul></li><li><a href=#14-장애-관리하기>14. 장애 관리하기</a><ul><li><a href=#미흡한-장애-처리>미흡한 장애 처리</a></li><li><a href=#장애-관리-절차의-기본-요소들>장애 관리 절차의 기본 요소들</a></li><li><a href=#언제-장애를-선언할-것인가>언제 장애를 선언할 것인가?</a></li><li><a href=#요약>요약</a></li></ul></li><li><a href=#15-포스트모텀-문화-실패로부터-배우기>15. 포스트모텀 문화: 실패로부터 배우기</a></li><li><a href=#16-시스템-중단-추적하기>16. 시스템 중단 추적하기</a></li><li><a href=#17-신뢰성을-위한-테스트>17. 신뢰성을 위한 테스트</a><ul><li><a href=#전통적인-테스트>전통적인 테스트</a></li><li><a href=#프로덕션-테스트>프로덕션 테스트</a></li><li><a href=#테스트-및-빌드-환경-구성하기>테스트 및 빌드 환경 구성하기</a></li><li><a href=#대규모-환경에서의-테스트>대규모 환경에서의 테스트</a></li><li><a href=#재해-테스트>재해 테스트</a></li><li><a href=#지금-필요한것은-스피드>지금 필요한것은 스피드</a></li><li><a href=#프로덕션-환경에-배포하기>프로덕션 환경에 배포하기</a></li><li><a href=#테스트는-얼마든지-실패할-수-있다>테스트는 얼마든지 실패할 수 있다.</a></li><li><a href=#통합>통합</a></li><li><a href=#프로덕션-환경-조사하기>프로덕션 환경 조사하기</a></li></ul></li><li><a href=#18-sre-조직의-소프트웨어-엔지니어링>18. SRE 조직의 소프트웨어 엔지니어링</a><ul><li><a href=#sre-조직의-소프트웨어-엔지니어링-역량이-중요한-이유>SRE 조직의 소프트웨어 엔지니어링 역량이 중요한 이유</a></li><li><a href=#전통적인-수용량-계획>전통적인 수용량 계획</a></li><li><a href=#의도-기반-수용량-계획>의도 기반 수용량 계획</a></li><li><a href=#sre-조직에서-소프트웨어-엔지니어링을-육성하는-방법>SRE 조직에서 소프트웨어 엔지니어링을 육성하는 방법</a></li><li><a href=#목표-이루기>목표 이루기</a></li></ul></li><li><a href=#19-프론트엔드의-로드밸런싱>19. 프론트엔드의 로드밸런싱</a><ul><li><a href=#모든-일을-힘으로만-해결할-수는-없는-법>모든 일을 힘으로만 해결할 수는 없는 법</a></li><li><a href=#dns-를-이용한-로드밸런싱>DNS 를 이용한 로드밸런싱</a></li><li><a href=#가상-ip-주소를-이용한-로드밸런싱>가상 IP 주소를 이용한 로드밸런싱</a></li></ul></li><li><a href=#20-데이터센터의-로드밸런싱>20. 데이터센터의 로드밸런싱</a><ul><li><a href=#이상적인-사례>이상적인 사례</a></li><li><a href=#양호하지-않은-태스크-구별하기-흐름-제어와-레임덕>양호하지 않은 태스크 구별하기: 흐름 제어와 레임덕</a></li><li><a href=#서브셋을-이용한-연결-풀-제한하기>서브셋을 이용한 연결 풀 제한하기</a></li><li><a href=#로드밸런싱-정책>로드밸런싱 정책</a></li></ul></li><li><a href=#21-과부하-처리하기>21. 과부하 처리하기</a><ul><li><a href=#초당-쿼리-수의-함정>초당 쿼리 수의 함정</a></li><li><a href=#사용자별-제한>사용자별 제한</a></li><li><a href=#클라이언트-측에서의-사용량-제한>클라이언트 측에서의 사용량 제한</a></li><li><a href=#중요도>중요도</a></li><li><a href=#활용도에-대한-신호들>활용도에 대한 신호들</a></li><li><a href=#과부하-오류-처리하기>과부하 오류 처리하기</a></li><li><a href=#재시도-여부-결정하기>재시도 여부 결정하기</a></li><li><a href=#연결에-대한-부하>연결에 대한 부하</a></li></ul></li></ul><ul><li><a href=#연속적-장애의-원인과-그-대책>연속적 장애의 원인과 그 대책</a><ul><li><a href=#서버-과부화>서버 과부화</a></li><li><a href=#자원의-부족>자원의 부족</a></li><li><a href=#서비스-이용-불가>서비스 이용 불가</a></li><li><a href=#서버-과부하-방지하기>서버 과부하 방지하기</a></li><li><a href=#큐-관리하기>큐 관리하기</a></li><li><a href=#부하-제한과-적절한-퇴보>부하 제한과 적절한 퇴보</a></li><li><a href=#재시도>재시도</a></li><li><a href=#지연응답과-마감기한>지연응답과 마감기한</a></li><li><a href=#느긋한-시작과-콜드-캐싱>느긋한 시작과 콜드 캐싱</a></li><li><a href=#항상-스택의-아래쪽을-살펴보자>항상 스택의 아래쪽을 살펴보자</a></li><li><a href=#연속적-장애의-발생-요인>연속적 장애의 발생 요인</a></li><li><a href=#연속적-장애-테스트하기>연속적 장애 테스트하기</a></li><li><a href=#사용량이-높은-클라이언트-테스트하기>사용량이 높은 클라이언트 테스트하기</a></li><li><a href=#상대적으로-덜-중요한-백엔드-테스트>상대적으로 덜 중요한 백엔드 테스트</a></li><li><a href=#연속적-장애를-처리하기-위한-즉각적인-대처>연속적 장애를 처리하기 위한 즉각적인 대처</a></li></ul></li><li><a href=#23-치명적인-상태-관리하기-신뢰성을-위한-분산에-대한-합의>23. 치명적인 상태 관리하기: 신뢰성을 위한 분산에 대한 합의</a><ul><li><a href=#합의는-왜-필요할까-분산-시스템-감-협업의-실패>합의는 왜 필요할까: 분산 시스템 감 협업의 실패</a></li><li><a href=#분산에-대한-합의가-동작하는-방식>분산에 대한 합의가 동작하는 방식</a></li><li><a href=#분산-합의를-위한-시스템-아키텍처-패턴>분산 합의를 위한 시스템 아키텍처 패턴</a></li><li><a href=#신뢰할-수-있는-복제된-상태-머신>신뢰할 수 있는 복제된 상태 머신</a></li><li><a href=#분산-합의의-성능>분산 합의의 성능</a></li><li><a href=#읽기-작업-부하의-확장>읽기 작업 부하의 확장</a></li><li><a href=#분산-합의-기반-시스템의-배포>분산 합의 기반 시스템의 배포</a></li><li><a href=#분산합의-시스템-모니터링>분산합의 시스템 모니터링</a></li></ul></li><li><a href=#24-크론을-이용한-분산된-주기적-스케줄링>24. 크론을 이용한 분산된 주기적 스케줄링</a><ul><li><a href=#크론>크론</a></li><li><a href=#대용량-시스템-내에서의-크론>대용량 시스템 내에서의 크론</a></li><li><a href=#구글에서-구현한-크론-서비스>구글에서 구현한 크론 서비스</a></li></ul></li><li><a href=#25-데이터-처리-파이프라인>25. 데이터 처리 파이프라인</a><ul><li><a href=#파이프라인-디자인-패턴의-기원>파이프라인 디자인 패턴의 기원</a></li><li><a href=#단순한-파이프라인-패턴을-적용한-빅데이터의-기본적인-효과>단순한 파이프라인 패턴을 적용한 빅데이터의 기본적인 효과</a></li><li><a href=#정기적-파이프라인-패턴의-과제>정기적 파이프라인 패턴의 과제</a></li><li><a href=#작업의-불균형-분산으로-인해-발생하는-문제>작업의 불균형 분산으로 인해 발생하는 문제</a></li><li><a href=#분산-환경에서-정기적-파이프라인의-단점>분산 환경에서 정기적 파이프라인의 단점</a></li><li><a href=#정기적-파이프라인의-문제점-모니터링하기>정기적 파이프라인의 문제점 모니터링하기</a></li><li><a href=#천둥-소리-문제>&lsquo;천둥 소리&rsquo; 문제</a></li><li><a href=#모이어-부하-패턴>모이어 부하 패턴</a></li><li><a href=#구글-워크플로우>구글 워크플로우</a></li><li><a href=#비지니스의-지속성-보장하기>비지니스의 지속성 보장하기</a></li></ul></li><li><a href=#chatper-26-데이터-무결성-내가-기록한-그대로-읽을수-있어야한다>Chatper 26. 데이터 무결성: 내가 기록한 그대로 읽을수 있어야한다.</a><ul><li><a href=#데이터-무결성의-중요한-조건>데이터 무결성의 중요한 조건</a></li><li><a href=#최상의-데이터-무결성을-위한-전략의-수집>최상의 데이터 무결성을 위한 전략의 수집</a></li><li><a href=#데이터-무결성과-가용성을-유지하기-위한-구글-sre의-목표>데이터 무결성과 가용성을 유지하기 위한 구글 SRE의 목표</a></li><li><a href=#구글이-데이터-무결성의-문제를-해결하는-방법>구글이 데이터 무결성의 문제를 해결하는 방법</a></li><li><a href=#데이터-무결성과-관련된-sre의-일반-원리들>데이터 무결성과 관련된 SRE의 일반 원리들</a></li><li><a href=#결론>결론</a></li></ul></li><li><a href=#27-대용량-환경에서의-신뢰할-수-있는-제품-출시>27. 대용량 환경에서의 신뢰할 수 있는 제품 출시</a><ul><li><a href=#출시-조율-엔지니어링>출시 조율 엔지니어링</a></li><li><a href=#제품-출시에-대한-lce팀의-역할>제품 출시에 대한 LCE팀의 역할</a></li><li><a href=#출시-절차-마련하기>출시 절차 마련하기</a></li><li><a href=#출시-확인목록>출시 확인목록</a></li><li><a href=#집중과-간소화-진행하기>집중과 간소화 진행하기</a></li><li><a href=#예상치-못한-제품의-출시>예상치 못한 제품의 출시</a></li><li><a href=#출시-확인목록-개발하기>출시 확인목록 개발하기</a></li><li><a href=#안정적인-출시를-위한-기법들>안정적인 출시를 위한 기법들</a></li></ul></li></ul></nav></aside><div class=content><h2 id=1-소개>1. 소개</h2><ul><li>직접 비용, 간접 비용</li></ul><h3 id=서비스-관리에-대한-구글의-해법-사이트-신뢰성-엔지니어링>서비스 관리에 대한 구글의 해법: 사이트 신뢰성 엔지니어링</h3><ul><li>SRE 중 50~60% 는 구글의 소프트웨어 엔지니어다.</li><li>SRE팀은 반드시 50%의 시간을 오롯이 개발을 위해 활용해야한다.:<ul><li>만약 이에 미치지 못한다면, 운영에 대한 부담이 개발팀에 전가되거나 혹은 운영 책임이 없음에도 새로운 팀원이 팀에 배정되는 현상이 발생하고 있음을 암시하고 있다.</li></ul></li></ul><h3 id=sre의-신조>SRE의 신조</h3><ul><li>Availability, Latency, Performance, Efficiency, Change Management, Monitoring, Emergency response, capacity planning</li></ul><h4 id=지속적으로-엔지니어링에-집중한다>지속적으로 엔지니어링에 집중한다.</h4><ul><li>모든 심각한 장애에 대해서는 알림 여부를 떠나 반드시 포스트모텀을 작성해야한다.:<ul><li>모니터링되지 않고 있는 부분을 알 수 있기 때문이다.</li></ul></li></ul><h4 id=서비스의-안정성을-유지하면서-변화를-최대한-수용한다>서비스의 안정성을 유지하면서 변화를 최대한 수용한다.</h4><ul><li>에러 예산:<ul><li>더 이상 무정지 시스템 같은 목표를 세우지 않는다.</li><li>예측 가능한 시스템 정지</li></ul></li></ul><h4 id=모니터링>모니터링</h4><ul><li>알림(alert) : 어떤 문제가 발생했거나 발생하려고 할 때 상황을 개선하기 위해 사람이 즉각적으로 어떤 대응을 취해야 한다는 것을 알린다.</li><li>티켓(tickets) : 사람의 대응이 필요하지만 즉가적인 대응이 필요하지는 않는 상황을 의미한다.</li><li>로깅(logging) : 누군가 이 정보를 반드시 확인해야 할 필요는 없지만 향후 분석이나 조사를 위해 기록되는 내용이다.</li></ul><h4 id=긴급-대응>긴급 대응</h4><ul><li>MTTF(Mean Time To Failure)</li><li>MTTR(Mean Time To Repair)</li><li>MTTR을 줄이기 위해서는 잘 정리된 포괄적인 행동 지침이 큰 역할을 할 수 있다. (장애 대응 지침)</li></ul><h4 id=변화-관리>변화 관리</h4><ul><li>제품의 단계적 출시</li><li>문제를 빠르고 정확하게 도출하기</li><li>문제 발생 시 안전하게 이전 버전으로 되돌리기</li></ul><h4 id=수요-예측과-수용-계획>수요 예측과 수용 계획</h4><ul><li>자연적 수요에 대한 정확한 예측. 필요한 수용력을 확보하기까지의 시간에 대한 예측을 이끌어낼 수 있다.</li><li>자연적 수요와 인위적 수요를 정확하게 합산하기</li><li>원천적인 수용력(서버, 디스크 등)을 바탕으로 서비스의 수용력을 측정하기 위한 통상의 시스템 부하 테스트</li></ul><h4 id=프로비저닝>프로비저닝</h4><ul><li>프로비저닝 : 변화 관리와 수용 계획을 합한 개념</li></ul><h4 id=효율성과-성능>효율성과 성능</h4><ul><li>서비스의 효율성을 결정짓는 중요한 요소들 : 수요(부하), 수용력, 소프트웨어의 효율성</li></ul><h2 id=2-sre-관점에서-바라본-구글의-프로덕션-환경>2. SRE 관점에서 바라본 구글의 프로덕션 환경</h2><h3 id=하드웨어>하드웨어</h3><ul><li>머신(Machine) : 하드웨어(혹은 가상머신, Virtual Machine)을 의미한다.</li><li>서버(server) : 서비스를 구현하는 소프트웨어를 의미한다.</li></ul><h3 id=하드웨어를-조율하는-시스템-소프트웨어>하드웨어를 조율하는 시스템 소프트웨어</h3><ul><li>하드웨어 결함도 소프트웨어로 관리할 수 있다.</li></ul><h4 id=머신-관리하기>머신 관리하기</h4><ul><li>보그(Borg) : 오늘날의 쿠버네티스</li></ul><h4 id=저장소>저장소</h4><ul><li>저장소는 여러 계층으로 구성된다.:<ul><li>가장 낮은 계층은 D 계층</li><li>Colossus, 구글 파일 시스템의 후속 제품이다.</li><li>콜로서스를 바탕으로 데이터베이스와 유사한 서비스들이 존재한다.:<ul><li>Spanner, Bigtable, Blobstore</li></ul></li></ul></li></ul><h4 id=네트워킹>네트워킹</h4><ul><li>GSLB(Global Software Load Balancer):<ul><li>DNS 요청에 대한 지역적 로드밸렁싱</li><li>사용자 서비스 수준에서의 로드밸런싱</li><li>원격 프로시저 호출(RPC) 수준에서의 로드밸런싱</li></ul></li></ul><h3 id=기타-시스템-소프트웨어>기타 시스템 소프트웨어</h3><h4 id=잠금-서비스>잠금 서비스</h4><ul><li>처비(Chubby), Paxos 프로토콜</li><li>요즘 널리사용되는 오픈소스(k8s, kafka 등)은 etcd, zookeeper를 사용하고 이들은 raft 알고리즘으로 동작한다.</li></ul><h4 id=모니터링과-알림>모니터링과 알림</h4><ul><li>치명적인 문제점에 대한 알림 설정</li><li>행동 비교: 소프트웨어 업데이트 이후 서버가 빨라졌는가?</li><li>수용 계획을 위한 가장 기본적인 지표인 시간의 흐름에 따른 자원 소비 행위의 개선 여부 확인하기</li></ul><h3 id=소프트웨어-인프라스트럭처>소프트웨어 인프라스트럭처</h3><ul><li>Protocol buffers:<ul><li>오늘날에는 gRPC를 사용하고 gRPC 는 대부분 Protocol Buffers 를 사용한다.</li></ul></li></ul><h3 id=개발-환경>개발 환경</h3><ul><li>구글에서의 업무 흐름 중 중요한 암묵적인 합의:<ul><li>프로젝트 외부의 컴포넌트에서 문제가 발생하면 엔지니어는 문제를 해결하고, 변경사항(cahgnelist, CL)을 소유자에게 보내서 리뷰를 요청한 후 변경된 코드를 제출할 수 있다.</li><li>엔지니어가 소속된 프로젝트의 소스 코드 변경은 반드시 리뷰를 거쳐야 한다. 모든 소프트웨어는 제출되기 전에 리뷰를 받아야 한다.</li></ul></li></ul><h1 id=ii-원리와-원칙들>II. 원리와 원칙들</h1><h2 id=3-위험-요소-수용하기>3. 위험 요소 수용하기</h2><ul><li>사용자의 스마트폰이 99% 의 신뢰성을 가진다면, 99.99%와 99.999% 서비스는 사용자가 구별할수 없다.</li><li>SRE는 이 점을 이용해서 위험요소, 빠른 혁신, 효과적인 서비스 운영의 균형을 잡는다. (기능, 서비스, 성능)</li></ul><h3 id=위험-요소-관리하기>위험 요소 관리하기</h3><ul><li>신뢰성을 향상시킬수는 있지만 비용이 증가하는 요소들:<ul><li>여분의 머신/컴퓨트 자원 비용</li><li>기회 비용</li></ul></li><li>가용성 목표치를 초과 달성하려고 노력은 하되, 넘치게 초과하려고는 하지 않는다.</li><li>가용성 목표치를 초과 달성했다면, 기술부채를 줄이거나 윤영비용을 줄이려고 시도해야한다.</li></ul><h3 id=서비스-위험-측정하기>서비스 위험 측정하기</h3><ul><li>시간 기준 가용성 : 가용성 = 업타임 / (업타임 + 다운타임)</li><li>종합 가용성 : 가용성 = 성공한 요청 수 / 전체 요청수</li><li>널리 사용되는 가용성 지표를 측정하는 방법:<ul><li>주 단위 혹은 일 단위로 목표치에 대한 성능을 측정한다.</li></ul></li></ul><h3 id=서비스의-위험-수용도>서비스의 위험 수용도</h3><h4 id=소비자-대상-서비스의-위험-수용도-정의하기>소비자 대상 서비스의 위험 수용도 정의하기</h4><ul><li><p>위험 수용도를 결정하기 위해서 고려해야 하는 요소:</p><ul><li>어느 정도 수준의 위험 수용도가 요구되는가?</li><li>장애의 종류에 따라 서비스에 미치는 영향이 달라지는가?</li><li>지속적으로 발생하는 위험 중 어느 지점에 서비스 비용을 투입할 것인가?</li><li>중요하게 고려해야 할 다른 서비스 지표로는 어떤 것들이 있는가?</li></ul></li><li><p>목표 가용성 수준:</p><ul><li>사용자는 어느 정도 수준의 서비스를 기대하는가?</li><li>이 서비스가 수익과 직접적으로 연관이 있는가?</li><li>유료 서비스인가? 무료 서비스인가?</li><li>시장에 경쟁자가 있다면 경쟁자는 어느 정도 수준의 가용성을 제공하는가?</li><li>이 서비스는 개인 사용자를 위한 서비스인가? 기업 사용자를 위한 서비스인가?</li></ul></li><li><p>장애의 종류:</p><ul><li>낮은 비율로 장애가 지속적으로 발생</li><li>가끔이지만 전체 사이트가 다운되는 장애</li></ul></li><li><p>비용:</p><ul><li>목표 가용성 수준을 높이려고 한다면 수익에 어떤 긍정적 역향이 미치는가?</li><li>발생 가능한 추가 수익이 목표한 가용성 수준에 도달하기 위한 비용을 상쇄할 수 있는가?</li></ul></li><li><p>기타 서비스 비용</p></li></ul><h3 id=인프라스트럭처-서비스의-위험-수용도-정의하기>인프라스트럭처 서비스의 위험 수용도 정의하기</h3><ul><li>목표 가용성 수준, 장애의 종류, 비용</li></ul><h3 id=에러-예산-활용해보기>에러 예산 활용해보기</h3><ul><li>소프트웨어 결함 허용, 테스트, 출시 빈도, 카나리 테스트 빈도와 규모</li></ul><h4 id=에러-예산-산정하기>에러 예산 산정하기</h4><ul><li><p>SLO(Service Lead Objectives, 서비스 수준 목표)</p></li><li><p>제품 관리자들이 서비스의 분기별 예상 업타임을 의미하는 SLO를 산정한다.</p></li><li><p>실제 업타임은 제3자, 즉 우리가 보유한 모니터링 시스템으로 측정한다.</p></li><li><p>이 두 숫자 사이의 차이점이 분기별로 얼마만큼의 &lsquo;불안정성&rsquo;을 허용할 것인지를 의미하는 &lsquo;예산&rsquo;이 된다.</p></li><li><p>업타임이 SLO를 초과한다면(다시 말해, 에러 예산이 아직 남아있다면) 새로운 릴리즈를 출시할 수 있다.</p></li></ul><h4 id=장점>장점</h4><ul><li>제품 개발팀과 SRE팀이 혁신과 신뢰성 사이의 올바른 균형을 찾는데 필요한 기준을 제공한다.</li></ul><h4 id=핵심-인사이트>핵심 인사이트</h4><ul><li>서비스의 신뢰성을 관리하는 것은 위험을 관리하는 것이며, 위험을 관리하기 위해서는 비용이 소비될 수 있다.</li><li>100%는 절대로 올바른 신뢰성 목표치가 될 수 없다.</li><li>에러 예산은 SRE와 제품 개발팀 사이의 공동 소유권을 강조하며 각자의 역할을 명료하게 한다.</li></ul><h2 id=4-서비스-수준-목표>4. 서비스 수준 목표</h2><h3 id=서비스-수준-관련-용어>서비스 수준 관련 용어</h3><ul><li>SLI(Service Level Indicator):<ul><li>응답 속도, 에러율, 시스템 처리량</li><li>일반적으로 비율, 평균, 백분율로 계산</li><li>가용성</li></ul></li><li>SLO(Service Level Objectives):<ul><li>SLI &lt;= 목표치</li><li>최솟값 &lt;= SLI &lt;= 최대값</li><li>명확한 SLO 가 설정되어 있지 않다면 서비스를 디자인하고 운영하는 사람들의 생각과는 전혀 다른, 자신들이 희망하는 성능을 기대하곤 하다.</li></ul></li><li>SLA(Serivice Level Agreements):<ul><li>SLO 를 만족했을 경우(또는 반대의 경우)의 댓가에 대한 사용자와의 명시적 혹은 암묵적인 곙약을 의미한다.</li></ul></li></ul><h3 id=지표-설정>지표 설정</h3><ul><li>가용성, 응답시간, 처리량, 내구성, 정확성</li></ul><h4 id=척도-수집하기>척도 수집하기</h4><ul><li>서버사이드 vs 클라이언트 사이드</li></ul><h4 id=합산하기>합산하기</h4><ul><li>단순함과 유용함을 위해 측정된 원본 데이터를 합산하는 경우도 있다. 다만, 이 경우 상당한 주의를 기울여야한다.</li><li>대부분의 지표들은 평균보다는 분포가 더 중요하다.</li><li>99.9 등 더 높은 백분위 수 값들에 더 주목한다.</li></ul><h3 id=척도의-표준화>척도의 표준화</h3><ul><li>일반적인 정의를 표준화하기를 권장한다.:<ul><li>집계 간격: 평균 1분</li><li>집계 범위: 하나의 클러스터에서 수행되는 모든 테스크들</li><li>측정 빈도: 매 10초</li><li>집계에 포함할 요청들: 블랙박스 모니터링 잡이 수집한 HTTP GET 요청들</li><li>데이터의 수집 방식: 모니터리링 시스템에 의해 서버에서 수집</li><li>데이터 액세스 응답 시간: 데이터의 마지막 바이트가 전송된 시간</li></ul></li></ul><h3 id=목표-설정에-대한-실습>목표 설정에 대한 실습</h3><h4 id=목표-설정하기>목표 설정하기</h4><ul><li>SLO를 100% 만족하는 것은 현실성이 없는 것은 물론이거니와 기대할 수도 없는 상황이다.</li></ul><h4 id=목표치-선택하기>목표치 선택하기</h4><ul><li>현재의 성능을 기준으로 목표치를 설정하지 말것</li><li>최대한 단순하게 생각할 것</li><li>자기 만족에 얽매이지 말 것</li><li>가능한 적은 수의 SLO를 설정할 것</li><li>처음부터 완벽하게 하려고 하지 말 것</li></ul><h4 id=측정하기>측정하기</h4><ul><li>기본 루프:<ul><li>시스템의 SLI들을 모니터하고 측정하기</li><li>SLI를 SLO와 비교해서 별도의 대응이 필요한지 판단하기</li><li>대응이 필요한 경우 목표치를 달성하기 위해 어떻게 대응할지 파악하기</li><li>대응하기</li></ul></li></ul><h4 id=slo는-기대치를-설정하는-것>SLO는 기대치를 설정하는 것</h4><ul><li>안전 제한선을 지킬것</li><li>지나친 목표를 설정하지 말 것</li></ul><h2 id=5-삽질은-이제-그만>5. 삽질은 이제 그만</h2><h3 id=삽질의-정의>삽질의 정의</h3><ul><li>수작업을 필요로 한다.</li><li>반복적이다.</li><li>자동화가 가능하다.</li><li>사후 대처가 필요하다</li><li>가치가 지속되지 않는다.</li><li>서비스의 성장에 따라 O(n)으로 증가한다</li></ul><h3 id=삽질이-줄어들면-좋은-이유>삽질이 줄어들면 좋은 이유</h3><ul><li>서비스의 크기를 부선형적으로 확장하고 순수한 개발팀이나 순수한 운영팀보다 더 효율적으로 서비스를 관리한다.</li></ul><h3 id=엔지니어링에-해당하는-업무>엔지니어링에 해당하는 업무</h3><ul><li>소프트웨어 엔지니어링</li><li>시스템 엔지니어링</li><li>삽질</li><li>부하</li></ul><h3 id=삽질은-무조건-나쁜-것일까>삽질은 무조건 나쁜 것일까?</h3><ul><li>경력 개발이 침체된다</li><li>의욕이 저하된다</li><li>혼란이 가중된다</li><li>성장이 저하된다</li><li>좋지 않은 선례를 남기게 된다</li><li>인력 유출이 발생한다</li><li>신뢰에 문제가 생긴다</li></ul><h2 id=6-분산-시스템-모니터링>6. 분산 시스템 모니터링</h2><h3 id=정의>정의</h3><ul><li>모니터링: 쿼리의 수와 종류, 에러의 수와 종류, 처리 시간 및 서버의 활동 시간 등 시스템에 대한 정량적 실시간 데이터를 모으고 처리하고 집계해서 보여주는 것을 말한다.</li><li>화이트박스 모니터링: 로그나 JVM 프로파일링 인터페이스 또는 내부 통계 지표를 제공하는 HTTP 핸들러 등을 이용해서 얻은 시스템의 내부 지표들을 토대로 하는 모니터링을 의미한다.</li><li>블랙박스 모니터링: 사용자가 보게 되는 확인 가능한 동작들을 외부에서 테스트하는 과정</li><li>대시보드: 서비스의 핵심 지표에 대한 요약된 뷰를 보여주는 애플리케이션</li><li>알림(alert): 사람이 읽을 수 있도록 작성된 Notifation</li><li>근본 원인: 고친다면 재발하지 않는다고 확신하는 원인</li><li>노드와 머신</li><li>푸쉬: 서비스가 실행하는 소프트웨어나 관련된 설정에 대한 모든 변경사항을 의미한다</li></ul><h3 id=왜-모니터링해야-하는가>왜 모니터링해야 하는가?</h3><ul><li><p>장기적인 트렌드 분석</p></li><li><p>시간순 혹은 실험 그룹에 대한 비교</p></li><li><p>알림</p></li><li><p>대시보드</p></li><li><p>임시적인 회고 분석의 수행</p></li><li><p>사람을 호출하는 것은 직원들의 시간을 고려하면 매우 비용이 많이 드는 일이다.</p></li></ul><h3 id=모니터링에-대한-적절한-기대치-설정하기>모니터링에 대한 적절한 기대치 설정하기</h3><ul><li>잘못된 알림 비율을 낮게 유지하고, 올바른 알림의 비율을 높게 유지하기 위해서는 호출을 담당하는 모니터링 시스템은 반드시 간결하면서도 안정적이여야 한다.</li></ul><h3 id=증상과-원인>증상과 원인</h3><ul><li>모니터링 시스템은 어떤 장애가 왜 발생했는지에 대한 질문에 답을 제시할 수 있어야한다.</li></ul><h3 id=블랙박스와-화이트-박스>블랙박스와 화이트 박스</h3><ul><li>디버깅을 수행할 때는 화이트박스 모니터링이 필수적이다.</li><li>블랙박스 모니터링은 이미 문제가 발생했거나 혹은 실제 증상의 원인이 된 경우에만 사람을 호출하는 원칙을 강제할 수 있다.</li></ul><h3 id=네가지-결정적인-지표>네가지 결정적인 지표</h3><ul><li>지연응답</li><li>트래픽</li><li>에러</li><li>서비스 포화 상태</li></ul><h3 id=마지막-요청혹은-실행과-성능에-대한-고려>마지막 요청(혹은 실행과 성능)에 대한 고려</h3><ul><li>전체 요청에 대한 평균 응답 시간이 느려지는 것과 tail of requests이 아주 느려지는 것을 구분하는 방법:<ul><li>전체 요청 수와, 전체 지연 응답을 수집하여 분포를 확인하는 것이다.</li></ul></li></ul><h3 id=적당한-측정-방법-선택하기>적당한 측정 방법 선택하기</h3><ul><li>적당한 측정 방법 예시(CPU):<ul><li>매 초마다 현재 CPU의 사용량을 기록한다.</li><li>5% 단위로 bucket 을 구성하고, 매 초당 CPU 사용량을 측정하여 적절한 버킷의 값을 증가시킨다.</li><li>분 단위로 이 값들을 집계한다.</li></ul></li></ul><h3 id=더욱-단순하게가-아니라-최대한-단순하게>더욱 단순하게가 아니라 최대한 단순하게</h3><ul><li>가장 빈번하게 발생하는 사건/사고를 탐지 하기 위한 규칙은 최대한 간결하고 예측 가능하며 확실해야 한다.</li><li>수정 빈도가 높지 않은 데이터의 수집, 집계 그리고 알림에 관련된 설정은 제거하는 것이 좋다.</li><li>수집은 되지만 대시보드에 노출되지도 않고 알림에 사용되지도 않는 데이터는 역시 제거하는 것이 좋다.</li></ul><h3 id=지금까지-살펴본-원리들을-결합하기>지금까지 살펴본 원리들을 결합하기</h3><ul><li><p>이 규칙은 해당 규칙이 존재하지 않는다면 알아챌 수 없는 긴급하고, 대처가 가능하며 즉각적으로 사용자가 인지할 수 있는 상태를 탐지할 수 있는가?</p></li><li><p>긴급하지 않은 알림이라면 무시할 수 있는 알림인가? 언제, 왜 이 알림을 무시할 수 있으며, 이런 알림을 받지 않으려면 어떻게 해야 할까?</p></li><li><p>이 알림은 분명히 사용자에게 좋지 않은 영향을 미치는 상황에 대한 알림인가? 가용 트래픽이 모두 소모되었거나 테스트 배포처럼 사용자에게 부정적인 영향을 미치지 않는 경우에는 알림이 발생하지는 않았는가?</p></li><li><p>이 알림에 대해 대응이 가능한가? 이 알림은 긴급한 것인가 아니면 내일 아침까지 기다려도 되는 것인가? 대응책은 안전하게 자동화가 가능한가? 알림에 대한 대응은 장기적인 수정이 될 것인가 아니면 단기적인 우회책이 될 것인가?</p></li><li><p>다른 사람들이 이 이슈에 대한 호출을 받아서 적어도 하나 이상의 불필요한 호출이 발생힜는가?</p></li><li><p>기본 철학:</p><ul><li>매번 호출기가 울릴 때마다 긴급한 상황임을 인지하고 그에 대응할 수 있어야 한다. 이러한 긴급 호출은 빈번한 호출로 인한 피로를 느끼지 않도록 하루에 단 몇 번정도만 발생해야한다.</li><li>모든 호출은 대응이 가능해야 한다.</li><li>호출에 대한 모든 대응은 이성적이어야 한다. 만일 호출이 자동화된 응답에 대해서만 가치가 있다면 이 호출은 전파되어서는 안된다.</li><li>호출은 새로운 문제나 지금까지 보지 못한 사건에 대한 것이어야 한다.</li></ul></li></ul><h3 id=장기적-모니터링>장기적 모니터링</h3><ul><li>모니터링 시스템에 대한 의사 결정은 장기적인 목표에 기초해서 판단하는 것이 중요하다.</li><li>장애 호출에 대해 이미 정해진 규칙에 의해 대응하는 것은 위험한 신호이다. 팀의 그 누구도 이런 호출에 대해 자동화를 할 의지가 없다는 것은 팀이 스스로 만든 기술 부채를 해소하는 데 자신이 없다는 것을 암시한다.</li></ul><h2 id=7-구글의-발전된-자동화>7. 구글의 발전된 자동화</h2><h3 id=자동화의-가치>자동화의 가치</h3><ul><li>일관성</li><li>플랫폼</li><li>더 신속한 수리</li><li>더 신속한 조치</li><li>시간 절감</li></ul><h3 id=구글-sre의-가치>구글 SRE의 가치</h3><ul><li>자동화 클래스의 계층구조:<ol><li>자동화를 하지 않는 단계</li><li>별도로 관리되며 시스템에 특화된 자옫화를 수행하는 단계</li><li>별도로 관리되는 범용 자동화를 수행하는 단계</li><li>내재화되었지만 시스템에 특화된 자동화를 수행하는 단계</li><li>개입이 불필요한 시스템을 도입하는 단계</li></ol></li></ul><h3 id=스스로를-이롭게-하라-몽땅-자동화하자>스스로를 이롭게 하라: 몽땅 자동화하자!</h3><h3 id=신의-한-수-클러스터-턴업의-자동화>신의 한 수: 클러스터 턴업의 자동화</h3><ul><li>Prodtest를 이용한 모순의 발견</li><li>멱등성을 이용한 모순의 해결</li><li>특화된 자동화로의 발전:<ul><li>자동화의 세가지 관점:<ul><li>적합성, 지연시간, 자동화와 실제 세계 사이의 연관성</li></ul></li><li>장려 정책:<ul><li>스크립트의 속도를 높이는 것이 주요 임무인 곳은, 팀의 기술 부채를 해소해야할 의미가 없다.</li><li>자동화 스크립트를 실행하지 않은 팀은, 손쉽게 자동화할 수 있는 시스템을 구축해야할 의무가 없다.</li><li>자동화 스크트의 품질이 낮더라도, 영향을 받지 않는 제품 관리자는 새로운 기능에 더 높은 우선순위를 둔다.</li></ul></li></ul></li></ul><h3 id=신뢰성은-근본적인-기능이다>신뢰성은 근본적인 기능이다</h3><h2 id=8-릴리즈-엔지니어링>8. 릴리즈 엔지니어링</h2><h3 id=릴리즈-엔지니어의-역할>릴리즈 엔지니어의 역할</h3><ul><li>일관되고 반복 가능한 방법을 통해 프로젝트를 릴리즈하기 위한 최선의 방법들을 정의한다.</li></ul><h3 id=릴리즈-엔지니어링의-철학>릴리즈 엔지니어링의 철학</h3><ul><li>자기 주도 서비스 모델</li><li>빠른 릴리즈 주기</li><li>밀폐된 빌드</li><li>원리와 절차의 강제</li></ul><h3 id=지속적-빌드와-배포>지속적 빌드와 배포</h3><ul><li>빌드</li><li>브랜칭</li><li>테스트</li><li>패키징</li><li>배포</li></ul><h3 id=설정-관리-기법>설정 관리 기법</h3><ul><li>주 저장소에 관리하는 방법</li><li>설정 파일과 바이너리를 동일한 패키지에 묶는 방법</li><li>설정 패키지에 설정파일을 추가하는 방법(바이너리 빌드와 분리하는 방법)</li><li>설정을 외부 저장소에서 읽는 방법</li></ul><h3 id=릴리즈-엔지니어링을-처음부터-도입하라>릴리즈 엔지니어링을 처음부터 도입하라</h3><ul><li>릴리즈 엔지니어링 자원에 대한 여유를 확보해야한다.</li></ul><h2 id=9-간결함>9. 간결함</h2><h3 id=시스템의-안정성-vs-신속함>시스템의 안정성 vs. 신속함</h3><ul><li>실험적 코딩: 실패할 것을 어느정도 예상하고 코드를 작성해 보는 것이다.</li><li>유효날자를 명시하고, 이러한 코드는 테스트 커버리지와 릴리즈 관리에서 조금 더 자유로울수 있다.</li></ul><h3 id=지루함의-미덕>지루함의 미덕</h3><ul><li>책임지고 있는 시스템에 있는 돌발적인 복잡성을 야기하는 요소는 과감히 밀쳐낸다.</li><li>자신이 담당하고 운영 책임을 지고 있는 시스템의 복잡도를 제거하기 위해 지속적으로 노력한다.</li></ul><h3 id=내-코드는-절대-포기하지-않을꺼야>내 코드는 절대 포기하지 않을꺼야!</h3><ul><li>전혀 실행 된적이 없는 코드나 항상 비활성화 상태의 플래그가 설정된 코드는 마치 시한 폭탄 같은 것이다.</li><li>극단적으로, 분명한 목적이 있는 코드 이외에는 모두 부채라고 생각해야한다.</li></ul><h3 id=부정적-영향을-미치는-코드의-지표>부정적 영향을 미치는 코드의 지표</h3><ul><li>소프트웨어 팽창: 소프트웨어가 시간이 지나면서 계속 추가되는 새 기능 때문에 점차 느려지고 비대해지는 현상</li></ul><h3 id=최소한의-api>최소한의 API</h3><ul><li>API를 최소화하는 것은 소프트웨어 시스템의 간결함을 추구하기 위한 가장 기본적인 관점이다.</li></ul><h3 id=모듈화>모듈화</h3><h3 id=릴리즈의-간소화>릴리즈의 간소화</h3><h1 id=iii-사례>III. 사례</h1><ul><li>모니터링</li><li>장애대응</li><li>포스트모텀과 주요 원인 분석:<ul><li>테스트</li><li>수용 계획</li><li>개발</li><li>제품</li></ul></li></ul><h2 id=10-시계열-데이터에-대한-실용적인-알림>10. 시계열 데이터에 대한 실용적인 알림</h2><ul><li>분석해야할 컴포넌트의 수를 정확히 파악해야 한다.</li><li>각 시스템에 대한 엔지니어들의 책임 부담을 최대한 낮추어야한다.</li></ul><h3 id=시계열-데이터를-위한-저장소>시계열 데이터를 위한 저장소</h3><ul><li>레이블과 벡터</li><li>알림:<ul><li>일정 시간 동안 참아야하는 조건</li><li>다른 알림이 활성화된 상태일때 특정 알림을 억제한다.</li><li>동일한 레이블셋을 가진 여러 개의 달느 중복된 알림을 제거한다.</li><li>유사한 레이블셋으로부터 여러 개의 알림이 전송된 경우 레이블셋에 딸 ㅏ알림을 축소하거나 확대한다.</li></ul></li></ul><h3 id=모니터링-토폴로지의-샤딩>모니터링 토폴로지의 샤딩</h3><ul><li>수집 전용 계층, 데이터 집계를 위한 계층, 장기보관 시키는 계층</li></ul><h3 id=블랙박스-모니터링>블랙박스 모니터링</h3><ul><li>prober 를 통해 블랙박스로 검사한다.</li></ul><h3 id=설정의-유지보수>설정의 유지보수</h3><ul><li>데이터 자체에 대한 구분을 정희하는 레이블</li><li>데이터의 원본을 정의하는 레이블</li><li>장소나 서비스 내에서 데이터의 집계가 발생한 지점을 의미하는 레이블</li></ul><h2 id=11-비상대기>11. 비상대기</h2><h3 id=비상-대기-엔지니어의-삶>비상 대기 엔지니어의 삶</h3><ul><li>비상 대기 시에 엔지니어는 수 분 이내에 프로덕션 환경에서 필요한 운영 작업을 수행할 수 있어야한다.</li><li>사용자에게 노출되는 서비스의 경우 분기별로 99.99%의 가용성을 반드시 확보해야한다.:<ul><li>분기별로 약 13분 정도</li></ul></li></ul><h3 id=비상-대기-업무의-균형-맞추기>비상 대기 업무의 균형 맞추기</h3><ul><li>단일 사이트 팀의 규모가 커진다면, 다중 사이트 팀으로 분리 구성하는 것이 선호된다:<ul><li>야간에 업무를 교대하는 것은 건강에 좋지 않은 영향을 미치므로, 다중 사이트 팀의 해 뜰때 교대하는 방식은 팀 전체가 야간 교대로부터 벗어날 수 있다.</li><li>비상 대기 업무에 참여하는 엔지니어의 수를 제한함으로써 엔지니어들이 프로덕션 시스템에 대한 관심을 지속할 수 있다.</li></ul></li></ul><h3 id=품질-균형>품질 균형</h3><ul><li>비상 대기 시 장애의 주요 원인 분석과 개선, 포스트모텀 작성, 버그 수정 등 후속 작업에 평균 6시간이 소모된다.</li></ul><h3 id=보상>보상</h3><h3 id=안전에-대해-고려하기>안전에 대해 고려하기</h3><ul><li>일반적으로 취하는 두가지 방식<ul><li>직관적, 자동화적, 그리고 신속한 대응</li><li>합리적, 집중적, 그리고 계획적이며 경험에 기반한 행위</li></ul></li><li>비상 대기 업무는 두 번째 방식이 더 나은 결과를 도출해내며 계획에 따른 장애 조치가 가능하다.</li><li>비상 대기에 활용할 수 있는 가장 중요한 자원들:<ul><li>분명한 장애 전파 경로</li><li>잘 정의된 장애 관리 프로세스</li><li>비난 없는 포스트모텀 문화</li></ul></li><li>동일한 에러가 다시 반복되지 않도록 하는 것이 무엇보다 중요하다.</li></ul><h3 id=부적절한-운영-부하에서-벗어나기>부적절한 운영 부하에서 벗어나기</h3><ul><li>호출 알림은 서비스의 SLO를 위협하는 증상이 발생하는 경우에만 보내져야 한다.</li><li>모든 호출 알림은 그에 대한 대응 조치가 가능한 것들이어야 한다.</li></ul><h2 id=12-효과적인-장애-조치>12. 효과적인 장애 조치</h2><h3 id=이론>이론</h3><ul><li>가설 연역방법: 시스템의 문제에 대한 원인을 가설을 세운뒤 확인ㅅ하는 방식으로 검증:<ul><li>관련 없는 증상을 들여다보거나 시스템의 지표의 의미를 잘못 이해하는 경우, 멍청하게 결과만 쫓는 행동일 뿐이다.</li><li>시스템의 변경이나 입력 값 혹은 환경에 대한 잘못된 이해는 안전하고 효과적인 가설의 검증에 방해가 된다.</li><li>장애 원인에 대한 가능성이 희박한 가설을 세우거나 과거에 발생한 문제의 원인과 결부시켜 한 번 발생한 문제는 다시 발생할 것이라고 결부해보리는 행위</li><li>사실은 우연히 발생했거나 혹은 동일한 원인에 의해 발생한 관련 현상들을 계속해서 쫓아다니는 행위</li></ul></li></ul><h3 id=실전>실전</h3><ul><li>문제 보고</li><li>문제의 우선순위 판단</li><li>문제를 관찰하기</li><li>진단<ul><li>단순화하기와 범위를 좁히기</li><li>무엇이, 어디서, 왜를 고민하기</li><li>가장 마지막으로 수정된 부분에 주목하자</li><li>서비스에 특화된 진단</li></ul></li><li>테스트와 조치:<ul><li>이상적인 테스트는 상호 배타적이여서 가설의 어느 한 집합을 검증함으로써 다른 가설의 가능성이 없음을 밝혀낼 수 있어야한다.</li><li>가장 명확한 것을 최우선으로 고려해야한다.: 가능성이 큰 테스트부터 순차적으로 진행하면서 테스트로 인해 시스템에 발생할 수 있는 위험에 대해서도 고려해야 한다.</li><li>혼란 요소로 인해 특정 실험이 잘못된 결과를 도출하게 될 수도 있다.</li><li>적극적인 테스트가 나중에 실행할 테스트의 결과에 부작용을 초래할 수도 있다.</li><li>일부 테스트는 설득력이 떨어질 수도 있다.</li></ul></li></ul><h3 id=부정적인-결과의-마법>부정적인 결과의 마법</h3><ul><li>부정적인 결과는 무시해서도 안되고 평가절하 해서도 안된다.</li><li>부정적인 결과로 끝난 실험 역시 결론이다.</li><li>도구와 방법은 실험의 결과와는 무관하며 향후의 작업에 대한 단서가 된다.</li><li>부정적인 결과를 공표하는 것은 업계의 데이터 주도 성향을 증진시킨다.</li><li>자신의 결과를 공표하자.</li></ul><h3 id=처방>처방</h3><ul><li>시스템은 복잡하다.</li><li>운영 중인 프로덕션 시스템에서 문제를 재현하는 것은 피해야 한다.</li></ul><h3 id=조금-더-수월하게-장애를-조치하기>조금 더 수월하게 장애를 조치하기</h3><ul><li>화이트박스 지표와 구조화된 로그를 모두 활용해서 처음부터 각 컴포넌트를 관찰할 수 있는 방법을 마련한다.</li><li>시스템을 디자인할 때 컴포넌트 간에 이해가 쉽고 관찰이 가능한 인터페이스를 마련한다.</li></ul><h2 id=13-긴급-대응>13. 긴급 대응</h2><ul><li>테스트로 인한 장애</li><li>변경으로 인한 장애</li><li>절차에 의한 장애</li></ul><h4 id=지난일로부터-배우기-그리고-반복하지-않기>지난일로부터 배우기. 그리고 반복하지 않기</h4><ul><li>장애에 대한 기록을 남기자</li><li>커다란, 어쩌면 불가능할지도 모를 것에 대한 질문을 던지자: 만약 &mldr;라면?</li><li>사전 테스트 장려하기</li></ul><h2 id=14-장애-관리하기>14. 장애 관리하기</h2><h3 id=미흡한-장애-처리>미흡한 장애 처리</h3><ul><li>기술적인 문제에 대한 날카로운 집중</li><li>소통의 부재</li><li>프리랜서의 고용</li></ul><h3 id=장애-관리-절차의-기본-요소들>장애 관리 절차의 기본 요소들</h3><ul><li>책임에 대한 재귀적인 분리:<ul><li>장애 제어</li><li>운영 업무</li><li>의사소통</li><li>계획</li></ul></li><li>확실한 컨트롤 타워</li><li>실시간 장애 조치 문서</li><li>명확하고 즉각적인 업무 이관</li></ul><h3 id=언제-장애를-선언할-것인가>언제 장애를 선언할 것인가?</h3><ul><li>아래 조건중 하나라도 만족할시:<ul><li>문제를 해결하기 위해 다른 팀의 도움이 필요한가?</li><li>문제가 사용자에게 영향을 미쳤는가?</li><li>문제 발생 이후 한 시간 동안 집중적으로 분석했는데도 문제가 해결되지 않았는가?</li></ul></li></ul><h3 id=요약>요약</h3><ul><li>장애 조치에 대한 모범 사례:<ul><li>우선순위: 우선 출혈을 막고 서비스를 되살린 후에 근본 원인에 대한 증거를 찾자.</li><li>사전 준비: 장애 조치에 참여한 사람들의 자문을 받아 장애 관리 절차를 미리 개발하고 문서화 해두자.</li><li>신뢰: 장애 조치에 참여 중인 모든 사람들에게 충분한 자율권을 보장하자.</li><li>감정 조절: 장애를 조치하는 동안 스스로의 감정적 상태에 주의를 기울이자. 만일 너무 부담이 된다면 다른 이에게 도움을 청하자.</li><li>대체 방안에 대한 모색: 주기적으로 현재 선택할 수 있는 방법에 대해 다시 생각하고 이 방법이 여전히 유효한지, 아니면 다른 방법을 찾아야 하는지를 판단하자.</li><li>실습: 이 과정을 정기적으로 수행해서 자연스럽게 활용할 수 있는 수준으로 만들자.</li><li>개선: 계속해서 개선하자. 모든 팀 구성원들이 모든 역할에 익숙해질 수 있도록 독려하자.</li></ul></li></ul><h2 id=15-포스트모텀-문화-실패로부터-배우기>15. 포스트모텀 문화: 실패로부터 배우기</h2><ul><li>비난보다는 생산적인 포스트모텀 문서를 작성해야한다.</li><li>모든 포스트모텀 문서는 반드시 리뷰를 거쳐야한다.</li><li>올바른 일을 한 사람에게 눈에 보이는 보상을 지급하자.</li><li>포스트모텀의 효과에 대한 피드백을 구하자</li></ul><h2 id=16-시스템-중단-추적하기>16. 시스템 중단 추적하기</h2><h2 id=17-신뢰성을-위한-테스트>17. 신뢰성을 위한 테스트</h2><ul><li>사이트는 반드시 소프트웨어 변경이나 서버군의 변경이 없는 완전히 동일한 상태여야한다. 따라서 향후 시스템의 동작이 과거의 동작과 유사하게 된다.</li><li>시스템의 각 변경사항에 의한 불확실성을 고려한다면 사이트에 가해진 모든 변경 사항에 대해 확실하게 설명할 수 있어야 한다.</li></ul><h3 id=전통적인-테스트>전통적인 테스트</h3><ul><li>단위테스트</li><li>통합테스트</li><li>시스템 테스트:<ul><li>스모크 테스트</li><li>성능 테스트</li><li>회귀 테스트</li></ul></li></ul><h3 id=프로덕션-테스트>프로덕션 테스트</h3><ul><li>설정 테스트:<ul><li>아래 환경에서 설정테스트는 어려워진다.:<ul><li>암묵적으로 바이너리에 내장된 기본 값을 사용하는 경우: 이 경우 테스트의 결과는 별개의 버전이 된다.</li><li>쉘의 명령 줄 플레그 같은 전처리기가 명시된 경우</li><li>공용 런타임에 대해 문맥에 의존적인 동작을 명시적으로 제어하는 경우: 테스트가 런타임의 릴리즈 일정에 의존성을 갖게 된다.</li></ul></li></ul></li><li>스트레스 테스트</li><li>카나리 테스트</li></ul><h3 id=테스트-및-빌드-환경-구성하기>테스트 및 빌드 환경 구성하기</h3><ul><li><p>최소한의 노력으로 최상의 효과를 낼수 있는 테스트를 수행해야 한다.:</p><ul><li>어떤 형태로든 기반 코드의 우선순위를 결정할 수 있는가? 기능 개발과 프로젝트 관리 기법을 고려해볼 때 모든 태스크가 높은 우선순위를 가지고 있다면, 그 어떤 태스크도 우선순위가 높다고 할 수 없다. 어떤 식으로든 중요도를 측정해서 시스템 컴포넌트들의 순서를 결정할 수 있는가?</li><li>정말로 사활이 걸려있거나 비지니스 관점에서 중요한 기능이나 클래스르 특정할 수 있는가?</li><li>다른 팀들이 통합해서 사용하는 API 들이 있는가? 지금까지의 릴리즈 테스트에서 아무런 문제가 없었던 API 들이라 하더라도 다른 개발팀이 제대로 이해하지 못한다면 우리 팀의 API 에 대한 클라이언트를 잘못 작성하거나 혹은 최적의 상태로 구현하지 못할 수도 있다.</li></ul></li><li><p>문제가 발생한 코드를 보고받으면, 지금 당장 하던 일을 멈추고 문제를 해겷해야한다.:</p><ul><li>결함을 발견한 후에 변경된 코드의 어느 부분에서 문제가 생겼는지를 찾아내는 것이 더 어렵다.</li><li>소프트웨어에 결함이 발견되면 그에 대한 우회 조치를 취해야 하므로 팀의 업무 수행 속도가 감소한다.</li><li>나이틀리 빌드나 위클리 빌드 같은 릴리즈들이 그 가치를 잃게 된다.</li><li>긴급 릴리즈에 대한 팀의 대처 능력이 더 복잡하고 어려워진다.</li></ul></li></ul><h3 id=대규모-환경에서의-테스트>대규모 환경에서의 테스트</h3><ul><li>테스트 소프트웨어<ul><li>수행해야하는 일반적인 동작:<ul><li>데이터베이스 성능 지표의 조회 및 배포</li><li>가용성 위험에 대한 계획 수립을 위한 사용량 예측</li><li>사용자가 접근할 수 없는 서비스 복제본의 데이터 리팩토링</li><li>서버 상의 파일 변경</li></ul></li><li>추가적인 특징:<ul><li>도구들의 부작용이 테스트를 수행한 메인스트림 API 에 그대로 남는다.</li><li>유효성 검사 및 릴리즈 장벽으로 인해 사용자가 직접 접근하는 프로덕션 환경과는 격리된 환경에서 실행된다.</li></ul></li></ul></li><li>자동화 도구:<ul><li>수행해야하는 일반적인 동작:<ul><li>데이터베이스 인덱스 선택</li><li>데이터센터 간의 로드밸런싱</li><li>신속한 리마스터링을 위한 릴레이 로그 혼합</li></ul></li><li>추가적인 특징:<ul><li>실제로 작업은 주로 견고하고, 예측 가능하며, 충분히 테스트된 API들을 대상으로 수행된다.</li><li>수행되는 작업의 목적에 따라 작업 수행 도중 다른 API 클라이언트들에게서 알수 없는 중단 현상이 발생할 수 있다.</li></ul></li></ul></li></ul><h3 id=재해-테스트>재해 테스트</h3><ul><li>재해 복구 도구는 오프라인 상태에서도 동작할수 있도록 세심한 주의를 기울여 만들어져야한다.</li><li>재해 복구 도구의 수행동작:<ul><li>서비스를 깨끗하게 정지시킨 상태와 동일한 체크포인트 상태를 계산한다.</li><li>계산된 체크포인트 상태를 기존의 재해 무결성 검사 도구들이 사용할 수 있는 적재 가능한 상태로 만든다.</li><li>재시작 절차를 수행하는 릴리즈 경계 도구들을 지원한다.</li></ul></li></ul><h3 id=지금-필요한것은-스피드>지금 필요한것은 스피드</h3><h3 id=프로덕션-환경에-배포하기>프로덕션 환경에 배포하기</h3><ul><li>버전 관리 시스템에 대한 커밋의 경쟁으로 인해 프로젝트의 수행 속도 역시 어느 한계 이상으로 좋아지지 않는다.</li><li>테스트 인프라스트럭처와 프로덕션 환경이:<ul><li>완전히 분리되었을때:<ul><li>개발시스템 아키텍처를 보호할수 있다.</li><li>개발 속도가 일부 저하될수 있다.</li></ul></li><li>완전히 분리되지 않았을때:<ul><li>마이그레이션 위험을 완전하게 제거할 수 없다.</li><li>테스트를 실제 환경에서 할 수 있다.</li><li>위험도가 굉장히 높을 수 있다.</li></ul></li></ul></li></ul><h3 id=테스트는-얼마든지-실패할-수-있다>테스트는 얼마든지 실패할 수 있다.</h3><ul><li>과거에는 릴리즈 주기가 굉장히 길어서, 사용자가 인지할 수 있을만한 문제점이 숨어있는 경우가 많았다.</li><li>릴리즈 주기가 짧아지면서, 중간 산출물 마저도 모두 테스트 되기 때문에, 자동화된 테스트 커버리지의 효율성을 온전히 얻을 수 있다.</li><li>신뢰성을 관리하여야한다.</li><li>목표 릴리즈 주기에 맞추면서 불확실성 수준을 조절해야 한다.</li><li>적절한 수준의 신뢰성을 유지하기 위해서는 프로덕션 환경이 거의 자동화되어야 한다.</li><li>설정 파일의 신뢰성 관점에서:<ul><li>각 설정 파일은 통상적인 수정에 대해 충분한 테스트 커버리지를 확보해야 한다.</li><li>릴리즈에 앞서 릴리즈 테스트를 수행한 후에 파일의 수정이 이루어져야 한다.</li><li>유리 깨기 메커니즘(break-glass mechanism)을 통해 테스트가 완료되기 전에 파일을 밀어넣을 수 있는 방법을 제공해야 한다. 이 방법은 신뢰성을 떨어뜨릴 수 있으므로 나중을 위해 발견된 버그에 대해서는 되도록 문제를 크게 부풀려서 더욱 확실하게 해결할 수 있도록 하는 것이 좋다.</li></ul></li></ul><h3 id=통합>통합</h3><ul><li>설정파일에 대한 통합테스트를 고려해야한다.</li><li>설정파일은 임의의 문법을 사용한다. YAML, JSON 등 런타임에 대한 의존성을 갖지 않아야한다.</li><li>프로토콜 버퍼를 사용해서, 런타임에 한정적으로 사용할 수 있다는 장점이 있다.</li></ul><h3 id=프로덕션-환경-조사하기>프로덕션 환경 조사하기</h3><ul><li>요청의 종류:<ul><li>이미 문제가 있는 것으로 판명된 요청</li><li>문제가 없는 것으로 판명되었으며 프로덕션에 대해 테스트가 가능한 요청</li><li>문제가 없는 것으로 판명되었지만 프로덕션에 대해 테스트가 불가능한 요청</li></ul></li></ul><h2 id=18-sre-조직의-소프트웨어-엔지니어링>18. SRE 조직의 소프트웨어 엔지니어링</h2><h3 id=sre-조직의-소프트웨어-엔지니어링-역량이-중요한-이유>SRE 조직의 소프트웨어 엔지니어링 역량이 중요한 이유</h3><ul><li>확장성이나 장애 발생 시 자연스러운 종료 처리 그리고 다른 인프라스트럭처나 도구들을 쉽게 활용할수 있는 능력 을 통해 소프트웨어를 디자인하고 개발</li><li>SRE 들이 중요한 사안에는 모두 참여하므로 개발할 도구의 목적과 요구사항을 손쉽게 이해한다.</li><li>개발하는 도구를 직접 사용할 사용자와의 관계가 직접적이기 때문에 솔직하고 신속한 사용자 피드백을 기대할 수 있다.</li></ul><h3 id=전통적인-수용량-계획>전통적인 수용량 계획</h3><ol><li>수요 예측의 수집</li><li>빌드 및 할당 계획의 수립</li><li>리뷰 및 계획의 승인</li><li>배포 및 자원 설정</li></ol><ul><li>장단점:<ul><li>본질적으로 불안정하다:<ul><li>서비스의 효율성이 떨어져서 동일한 양의 수요를 감당하기 위해 더 많은 자원을 필요로 하게 되는 경우</li><li>고객의 유입률이 증가하여 그에 따라 수요가 증가하는 경우</li><li>클러스터의 새로운 컴퓨트 자원에 대한 배송이 지연되는 경우</li><li>제품의 성능 목표가 변경되어 서비스 배포 형태와 필요한 자원의 양이 바뀌는 경우</li></ul></li><li>노동집약적이며 모호하다</li></ul></li></ul><h3 id=의도-기반-수용량-계획>의도 기반 수용량 계획</h3><ul><li>구현이 아닌 요구사항을 명확히 하자</li></ul><h4 id=의도를-파악하기-위한-선행-작업>의도를 파악하기 위한 선행 작업</h4><ul><li>의존성</li><li>성능 지표</li><li>우선순위 결정</li></ul><h4 id=인식의-제고-및-도입의-촉진>인식의 제고 및 도입의 촉진</h4><ul><li><p>일관적이고 긴밀한 접근법</p></li><li><p>사용자에 대한 지원</p></li><li><p>제품의 활용성을 알리기 위한 선임 개발자와 관리자의 전폭적인 지원</p></li><li><p>기대치 설정하기</p></li><li><p>적절한 사용자층 정의하기</p></li><li><p>고객 서비스</p></li><li><p>적절한 수준의 디자인</p></li></ul><h3 id=sre-조직에서-소프트웨어-엔지니어링을-육성하는-방법>SRE 조직에서 소프트웨어 엔지니어링을 육성하는 방법</h3><ul><li>인력 수급과 개발 시간:<ul><li>엔지니어가 남는 시간에 개발하는 프로젝트로 남는다.</li><li>제대로 된 절차를 거쳐 정식 프로젝트로 승격한다.</li><li>SRE 의 지휘 아래 적절한 소프트웨어 개발 역량을 투입할 수 있도록 행정적 지원을 받는다.</li></ul></li></ul><h3 id=목표-이루기>목표 이루기</h3><ul><li>명확한 메시지로 소통하라:<ul><li>일관적이고 충분한 지원을 받은 소프트웨어 솔루션은 신입 SRE들이 업무에 더 빠르게 적응하는 데 도움이 된다.</li><li>어떤 작업을 수행할 수 있는 방법들을 몇가지로 제한하면, 전체 부서가 한 팀이 개발한 기술의 혜택을 받게 되고, 그 지식과 인적 자원이 여러 팀으로 옮겨 다니기가 쉬워진다.</li></ul></li><li>조직의 역량을 평가하라</li><li>출시하고 반복하라</li><li>자신의 기준을 낮추지마라</li></ul><h2 id=19-프론트엔드의-로드밸런싱>19. 프론트엔드의 로드밸런싱</h2><h3 id=모든-일을-힘으로만-해결할-수는-없는-법>모든 일을 힘으로만 해결할 수는 없는 법</h3><h3 id=dns-를-이용한-로드밸런싱>DNS 를 이용한 로드밸런싱</h3><ul><li>클라이언트의 행동을 넘어서는 수준의 제어는 거의 가능하지 않다는 점이다.</li><li>클라이언트가 가장 가까운 주소를 결정할 수 없다.</li></ul><h3 id=가상-ip-주소를-이용한-로드밸런싱>가상 IP 주소를 이용한 로드밸런싱</h3><ul><li>sticky session:<ul><li>id 기반의 sticky session</li><li>consitent hashing</li></ul></li><li>DSR(Direct Server Reply)</li></ul><h2 id=20-데이터센터의-로드밸런싱>20. 데이터센터의 로드밸런싱</h2><h3 id=이상적인-사례>이상적인 사례</h3><ul><li>특정 시점에, 가장 많은 부하를 처리하는 백엔드와 가장 적은 부하를 처리하는 백엔드의 CPU 사용률이 완전히 일치해야한다.</li></ul><h3 id=양호하지-않은-태스크-구별하기-흐름-제어와-레임덕>양호하지 않은 태스크 구별하기: 흐름 제어와 레임덕</h3><h4 id=양호하지-않은-태스크를-식별하는-간단한-방법-흐름-제어>양호하지 않은 태스크를 식별하는 간단한 방법: 흐름 제어</h4><h4 id=양호하지-않은-태스크를-식별하는-확실한-방법-레임덕-상태>양호하지 않은 태스크를 식별하는 확실한 방법: 레임덕 상태</h4><ul><li>양호함: 백엔드 태스크가 올바르게 초기화되어 요청들을 처리 중인 상태</li><li>연결 거부: 백엔드 태스크가 응답이 불가능한 상태. 이 상태가 나타나는 이유는 태스크가 시작 중 혹은 셧다운 중이거나 아니면 백엔드가 정상적이지 않은 상태이기 떄문이다.</li><li>레임덕(Lame duck): 백엔드 태스크가 포트를 리스닝 중이고 서비스를 제공할 수 있지만 명시적으로 클라이언트에게 요청의 전달을 중단할 것을 요구하는 상태</li></ul><h3 id=서브셋을-이용한-연결-풀-제한하기>서브셋을 이용한 연결 풀 제한하기</h3><h4 id=적절한-서브셋-선택하기>적절한 서브셋 선택하기</h4><ul><li>클라이언트의 수가 백엔드의 수보다 훨씬 적은 경우, 이 경우에는 클라이언트당 백엔드의 수를 크게 해서 백엔드 태스크가 트래픽을 전혀 수용하지 못하는 경우를 방지할 수 있다.</li><li>클라이언트의 작업 내에서 부하의 불일치가 빈번하게 발생하는 경우, 이 시나리오는 클라이언트가 자주 많은 양의 요청을 보내는 상황에서 발생한다. 많은 수의 요청은 클라이언트에 할당된 서브셋에 집중되므로 서브셋의 크기를 크게 해서 부하가 최대한 많은 백엔드 태스크로 퍼져나가도록 해야한다.</li></ul><h4 id=서브셋-선택-알고리즘-랜덤-서브셋>서브셋 선택 알고리즘: 랜덤 서브셋</h4><h3 id=로드밸런싱-정책>로드밸런싱 정책</h3><ul><li>로드밸런싱에서 고려해야하는 것들:<ul><li>작은 크기의 서브셋</li><li>다양한 쿼리 비용</li><li>머신의 다양성</li><li>예측 불가능한 성능 요인들:<ul><li>정반대의 이웃들, 태스크 재시작</li></ul></li></ul></li><li>간단한 라운드로빈</li><li>최소 부하 라운드로빈:<ul><li>가장 적은수의 활성화된 요청을 처리하기</li><li>특정 백엔드의 용량을 파악하기에 가장 좋은 방법이 아닐 수도 있다.</li><li>각 클라이언트의 활성화된 요청의 수는 다른 클라이언트가 같은 백엔드에 할당한 요청의 수를 포함하지는 않는다.</li></ul></li><li>가중 라운드로빈</li></ul><h2 id=21-과부하-처리하기>21. 과부하 처리하기</h2><h3 id=초당-쿼리-수의-함정>초당 쿼리 수의 함정</h3><ul><li>가비지 컬렉션을 수행하는 플랫폼의 경우, 메모리에 대한 부하는 본질적으로 CPU 사용률의 증가를 동반한다.</li><li>다른 플랫폼의 경우, 나머지 자원이 CPU보다 먼저 바닥나는 경우는 극히 드물기 때문에 해당 자원을 준비할 여력이 충분하다.</li></ul><h3 id=사용자별-제한>사용자별 제한</h3><ul><li>서비스 소유자는 모든 고객들이 자신의 자원을 지속적으로 한계치까지 사용하지 않는다는 사실에 기초해 계획을 수립한다.</li></ul><h3 id=클라이언트-측에서의-사용량-제한>클라이언트 측에서의 사용량 제한</h3><ul><li>요청을 거부하더라도 자원을 전혀 소비하지 않는건 아니다.</li><li>즉, 요청을 거부하는 것도 과부하 상태에 놓이는 것을 완전히 해결하지는 못한다.</li><li>클라이언트 측에서 사용량을 제한해야한다.</li><li>할당량 초과 에러로 인해 거부되는 것을 인지하면, 자체 조정을 통해 외부로 발신되는 트래픽을 제한한다.</li><li>실제로 허용된 수보다 더 많은 요청이 백엔드로 전달되게 되면, 백엔드가 더 많은 자원을 소비하게 되지만, 모든 클라이언트가 이 상태를 인지하기까지의 시간이 더 짧아진다.</li></ul><h3 id=중요도>중요도</h3><ul><li>criticality:<ul><li>CRITICAL_PLUS: 가장 중요한 요청 값, 실패시 사용자에게 직접적인 영향을 미치게 된다.</li><li>CRITICAL: 프로덕션 환경에서 전달되는 모든 요청들이 기본적으로 사용하는 값, 사용자에게 영향을 미치지만, CRITICAL_PLUS 보다 영향도가 낮다.</li><li>SHEDDABLE_PLUS: 어느정도 실패가 용인할수 있는 트래팩을 위한 값. batch 작업들의 기본값</li><li>SHEDDABLE: 부분적 실패가 발생하거나 간혹 아예 사용이 불가능할 것으로 예상되는 작업들을 위한 값.</li></ul></li><li>요청의 중요도는 지연응답 요구사항에 정비례한다.</li></ul><h3 id=활용도에-대한-신호들>활용도에 대한 신호들</h3><h3 id=과부하-오류-처리하기>과부하 오류 처리하기</h3><ul><li>데이터센터 내에 대량의 백엔드 태스크에 과부하가 걸리는 상황:<ul><li>데이터센터 간 로드밸런싱 시스템이 완벽하게 동작한다면 이 상황은 발생하지 않는다.</li></ul></li><li>데이터센터 내의 일부 백엔드 태스크에 과부하가 걸리는 상황:<ul><li>대부분의 경우 데이터센터는 충분한 수용량이 있지만, 로드밸런싱이 완벽하지 않기 때문에 발생한다.</li></ul></li><li>데이터센터 내의 백엔드 태스크에 광범위하게 과부하가 발생하면 요청의 처리를 재시도해서는 안 된다.</li><li>로드밸런싱 정책의 관점에서 재시도 요청과 새로운 요청은 구분되지 않는다. 이렇게 하는게 자연스럽게 부하를 분산하게 된다.</li></ul><h3 id=재시도-여부-결정하기>재시도 여부 결정하기</h3><ul><li>재시도 허용 수준(per-request retry budget):<ul><li>e.g. 최대 3회 재요청한다.</li></ul></li><li>클라이언트별 재시도(per-client retry budget):<ul><li>e.g. 10% 이상의 요청이 실패할경우 재시도하지 않는다.</li></ul></li><li>클라이언트가 요청의 메타데이터 내에 해당 요청에 대한 처리 시도가 몇번이었었는지 기록한다.:<ul><li>백엔드가 이 값의 변화로 자신의 상태를 알아낸다.</li></ul></li></ul><h3 id=연결에-대한-부하>연결에 대한 부하</h3><ul><li>데이터센터 간 로드밸런싱 알고리즘을 통해 부하를 관리한다. 이렇게 하면 요청에 따른 부하를 여력이 있는 다른 데이터센터로 효율적으로 배분할 수 있다.</li><li>일괄 클라이언트 작업은 요청을 기반 백엔드로 전달하고 그 결괄르 다시 클라이언트에게 전달하는 것 외에는 아무런 추가 작업을 수행하지 않는 별도의 일괄 프록시 백엔드 태스크들을 사용하도록 위임한다.:<ul><li>프록시가 일종의 퓨즈를 맞게 된다.</li><li>백엔드에 대한 연결의 수를 절감할 수 있어 로드밸런싱을 개선하는 효과를 얻을 수 있다</li></ul></li></ul><h1 id=22-연속적-장애-다루기>22. 연속적 장애 다루기</h1><h2 id=연속적-장애의-원인과-그-대책>연속적 장애의 원인과 그 대책</h2><h3 id=서버-과부화>서버 과부화</h3><h3 id=자원의-부족>자원의 부족</h3><ul><li>CPU 자원이 부족한 경우:<ul><li>처리 중인 요청 수의 증가</li><li>비정상적으로 증가하는 큐의 크기</li><li>스레드 기아</li><li>CPU 혹은 요청 기아</li><li>RPC 시간 초과</li><li>CPU 캐시 이점의 감소</li></ul></li><li>메모리:<ul><li>태스크 종료</li><li>자바의 가비지 컬렉션 수행률 증가로 인한 CPU 사용률 증가</li><li>캐시 활용률의 감소</li></ul></li><li>쓰레드</li><li>파일 서술자</li><li>자원 간의 의존성:<ul><li>장애가 발생한 동안 그 인과관계를 정확하게 파악하기 어렵다.</li></ul></li></ul><h3 id=서비스-이용-불가>서비스 이용 불가</h3><ul><li>충돌이 발생하기 시작하면, 다른 서버에도 충돌이 퍼지게 되고, 최초 충돌이 발생한 서버가 복구되더라도 상황이 해소되지 않는다.</li></ul><h3 id=서버-과부하-방지하기>서버 과부하 방지하기</h3><ul><li>서버 수용량 한계에 대한 부하 테스트 및 과부하 상태에서의 실패에 대한 테스트</li><li>경감된 응답 제공하기</li><li>과부하 상태에서 요청을 거부하도록 서비스를 구현하기</li><li>고수준의 시스템이 서버에 과부하를 유발하지 않고 요청을 거부하도록 구현하기:<ul><li>리버스 프록시의 경우 IP 주소 조건</li><li>로드밸런서는 서비스가 전체적인 과부하 상태일 떄 요청을 스스로 차단한다.</li><li>개별 작업들은 로드밸런서가 보내요는 요청의 변화에 의해 서버게 갑작스럽게 많은 요청이 몰리지 않도록 이를 제한한다.</li></ul></li><li>수용량 계획을 실행하기</li></ul><h3 id=큐-관리하기>큐 관리하기</h3><ul><li>쓰레드 풀 크기에 비해 짧은 길이의 큐를 배치해서 서버가 감당할 수 없는 수준의 요청이 유입되는 경우 최대한 이른 시점에 이를 거부하게 하는 것이 좋다.</li></ul><h3 id=부하-제한과-적절한-퇴보>부하 제한과 적절한 퇴보</h3><ul><li>부하를 배분하는 가장 직관적인 방법은 CPU, 메모리 혹은 큐의 길이에 따라 태스크별로 제한을 두는 것이다.</li><li>적절한 퇴보:<ul><li>어떤 지표를 활용해서 부하 제한이나 적절한 퇴보의 적용 여부를 결정할 것인가?</li><li>서버가 퇴보 모드로 동작하게 되면 어떤 조치를 취해야하는 가?</li><li>부하 제한이나 적절한 퇴보는 어느 계층에서 구현해야 하는가? 스택 내의 모든 계층에서 구현해야할까? 아니면 상대적으로 높은 수준의 병목 구간에서만 적용해도 충분할까?</li></ul></li><li>적절한 퇴보는 너무 자주 발생해서는 안된다.</li><li>어떤 코드 경로가 한번도 사용된 적이 없다면 이 코드 경로는 동작하지 않을 것이라는 점을 지지 말자. 퇴보 모드에서의 운영 경험을 쌓을 수 없어 오히려 위험 수위가 높아진다.</li><li>이 모드에서 동작하는 서버가 너무 많아지지는 않는지 적절히 모니터링하고 경고를 발송해야한다.</li><li>부하 제한과 적절한 퇴보를 구현하는 로직이 복잡해지면 그 자체에 문제가 발생할 수 있다.</li></ul><h3 id=재시도>재시도</h3><ul><li>자동 재시도를 수행할 때:<ul><li>적절한 퇴보를 통해 백엔드에 대한 재시도의 영향을 줄일수 있다.</li><li>임의의 값을 이용해 지수적으로 간격을 두어야한다. + 지터</li><li>요청당 재시도 횟수에 제한을 둔다. 무한정 요청을 재시도하면 안 된다.</li><li>서버 수준에서 재시도에 대한 한계 수치를 책정한다.</li><li>서비스 전체를 살펴보고 특정 수준의 재시도가 정말로 필요한 것인지를 결정해야 한다.</li><li>명확한 응답코드를 사용하고 각기 다른 실패 모드를 어떻게 처리할 것인지를 생각해야 한다.</li></ul></li></ul><h3 id=지연응답과-마감기한>지연응답과 마감기한</h3><ul><li>마감기한의 결정:<ul><li>대부분 마감기한을 설정하는 것이 바람직하다.</li><li>마감기한이 너무 길면 스택의 상위 계층이 자원을 너무 많이 소비해서 스택의 하위 계층에서 문제가 발생한다.</li></ul></li><li>마감기한의 상실:<ul><li>서버가 클라이언트의 마감기한을 넘긴 요청들을 계속 처리하느라 자원을 소비하고 있는 현상이다.</li><li>각 요청을 위해 다른 작업을 수행하기에 앞서 각 단계의 마감기한이 얼마나 남았는지를 먼저 확인해야 한다.</li></ul></li><li>마감기한의 전파</li><li>이중 지연응답:<ul><li>일시적인 지연응답 현상이 발생했을 때 이 장애의 원인이 이중 지연응답이라는 것이 명확하게 드러나지 않는다. 평균값과 더불어 지연응답의 분포 역시 살펴보아야한다.</li><li>요청이 마감기한까지 기다리지 않고 일찌감치 에러를 리턴하면 이 문제는 자연스럽게 피해갈 수 있다.</li><li>통상적인 요청의 지연응답에 비해 몇 배나 긴 마감기한을 설정하는 것은 좋지 않은 방법이다.</li><li>공유 자원을 사용할 때는 일부 키 공간에 의해 해당 자원들이 고갈될 수 있다.</li></ul></li></ul><h3 id=느긋한-시작과-콜드-캐싱>느긋한 시작과 콜드 캐싱</h3><ul><li>초기화가 필요한 경우:<ul><li>첫 번쨰 요청을 받을 때 필요한 백엔드와의 연결을 설정해야 하는 경우</li></ul></li><li>일부 언어, 특히 자바의 경우 런타임 성능 향상을 위한 추가 작업이 실행되는 경우:<ul><li>JIT(Just-In-Time) 컴파일, 핫스팟(hotspot) 최적화 및 지연된 클래스 로딩 등이 수행되는 경우</li></ul></li><li>콜드 캐시를 갖게 되는 경우:<ul><li>새로운 클러스터를 켜는경우</li><li>유지보수 작업 후 클러스터를 서비스에 제공하는 경우</li><li>서비스 재시작</li></ul></li><li>캐시가 서비스에 중요한 영향을 미친다면:<ul><li>서비스를 오버프로비전한다. 지연응답 캐시와 용량 캐시를 구분하는 것이 중요하다 지연응답 캐시를 사용하게 되면 서비스는 캐시가 비어 있더라도 필요한 부하를 감당할 수 있지만 용량 캐시를 사용하면 캐시가 비어있느 ㄴ경우에는 필요한 부하를 감당할 수 없다. 서비스 소유자는 서비스에 캐시를 추가하는 것에 대해 충분히 주의를 기울여야 하며, 새로 투입되는 캐시가 지연응답 캐시인지 아니면 용량캐시로서 안전하게 잘 동작할 수 있도록 잘 구현된 캐시인지를 확인해야한다. 간혹 서비스의 성능 향상을 위해 투입한 캐시 때문에 의존성 관리만 어려워지기도 한다.</li><li>일반적인 연속적 장애 방지 기법을 적용한다.</li><li>클러스터에 부하를 위임할 때는 부하의 크기를 천천히 늘려야 한다.</li></ul></li></ul><h3 id=항상-스택의-아래쪽을-살펴보자>항상 스택의 아래쪽을 살펴보자</h3><ul><li>내부 계층 간의 통신은 여러 이유로 문제가 될 수 있다.:<ul><li>분산 데드락의 영향을 받기 쉽다.</li><li>어떤 장애나 과부하로 인해 내부 계층 간의 통신이 증가하는 경우 어느 수준 이상으로 부하가 증가하면 내부 계층 간 요청이 빠르게 증가할 수 있다.</li><li>계층 간의 통신의 중요도에 따라 시스템의 부트스트랩이 더 복잡해질 수 있다. 일반적으로 계층 간 통신(특히 통신의 경로가 계속 반복되는 경우)은 지양하는 것이 좋다. 클라이언트가 통신을 하도록 주도해야한다.</li></ul></li></ul><h3 id=연속적-장애의-발생-요인>연속적 장애의 발생 요인</h3><ul><li>프로세스 중단</li><li>프로세스 업데이트</li><li>새로운 배포</li><li>유기적 성장</li><li>계획에 의한 변경, 자원의 감ㅅ소 혹은 서버의 종료:<ul><li>요청 프로파일의 변화</li><li>자원의 제한</li></ul></li></ul><h3 id=연속적-장애-테스트하기>연속적 장애 테스트하기</h3><ul><li>장애가 발생할 때까지 테스트하고 조치하기:<ul><li>만약 컴포넌트가 과부하 상태에서 퇴보 모드에 들어간다면 사람의 개입 없이 퇴보모드에서 원래의 동작에서 돌아올 수 있는가?</li><li>과부화 상태에서 몇 개의 서버에서 충돌이 발생한다면 시스템을 안정화시키기 위해서는 어느 정도의 부하가 절감 되어야 하는가?</li></ul></li><li>테스트 예시:<ul><li>예상되는 트래픽 패턴과 더불어 태스크의 수를 빠르게 혹은 천천히 줄여본다.</li><li>클러스터의 수용량을 신속하게 줄여본다.</li><li>다양한 백엔드를 시스템에서 감춰본다.</li></ul></li></ul><h3 id=사용량이-높은-클라이언트-테스트하기>사용량이 높은 클라이언트 테스트하기</h3><ul><li>확인해야 하는 내용:<ul><li>서비스가 다운된 동안 클라이언트는 얼마나 빠르게 작업을 처리하는가?</li><li>에러 상황에서 클라이언트가 임의의 지수 백오프를 사용하는가?</li><li>클라이언트가 대량의 부하를 유발하는 취약점을 가지고 있는가?</li></ul></li></ul><h3 id=상대적으로-덜-중요한-백엔드-테스트>상대적으로 덜 중요한 백엔드 테스트</h3><ul><li>중요한 컴포넌트들이 그에 따른 간섭을 받는지 확인해야한다.</li></ul><h3 id=연속적-장애를-처리하기-위한-즉각적인-대처>연속적 장애를 처리하기 위한 즉각적인 대처</h3><ul><li>자원의 추가투입</li><li>건강 상태 점검의 중지</li><li>서버의 재시작: 죽음의 gc 소용돌이, 특별한 마감기한 없이 자원을 소비중인 요청이 있을때, 데드락 등 (반드시 일부 서버만을 재시작하고 천천히 진행해야한다.)</li><li>트래픽의 경감</li><li>퇴보 모드로 들어가기</li><li>일괄 작업 부하 배제하기</li><li>문제가 있는 트래픽 배제하기</li></ul><h2 id=23-치명적인-상태-관리하기-신뢰성을-위한-분산에-대한-합의>23. 치명적인 상태 관리하기: 신뢰성을 위한 분산에 대한 합의</h2><ul><li>프로세스의 그룹은 아래 질문에 명확한 답이 있어야한다.:<ul><li>프로세스 그룹에서 어떤 프로세스가 리더 역할을 수행하는가?</li><li>프로세스 그룹에서 프로세스의 집합은 무엇인가?</li><li>메시지가 분산 큐에 정상적으로 추가되었는가?</li><li>프로세스가 임대한 자원을 계속해서 보유하고 있지는 않는가?</li><li>주어진 키로 데이터 저장소에 저장된 값은 무엇인가?</li></ul></li><li>ACID(Atomicity, Consistency, Isolation, Durability), BASE(Bascially Available, Soft state and Eventual concistency)</li><li>결과적 인과성을 개발자들이 직접 처리하도록 하는 것은 너무나도 어려운 일이며 일관성의 문제는 반드시 데이터베이스 수준에서 해결되어야 한다.</li></ul><h3 id=합의는-왜-필요할까-분산-시스템-감-협업의-실패>합의는 왜 필요할까: 분산 시스템 감 협업의 실패</h3><ul><li>split-brain</li><li>사람이 개입해야하는 장애 조치</li><li>그룹-멤버십 알고리즘의 오류</li></ul><h3 id=분산에-대한-합의가-동작하는-방식>분산에 대한 합의가 동작하는 방식</h3><ul><li>비동기 분산 합의 vs 동기 합의</li><li>crash-fail vs crash-recover:<ul><li>상대적으로 충돌 복구(crash-recover) 알고리즘이 더 유용한다.</li></ul></li><li>Byzantine failure vs non-Byzantine failure</li></ul><h3 id=분산-합의를-위한-시스템-아키텍처-패턴>분산 합의를 위한 시스템 아키텍처 패턴</h3><ul><li>저수준이며 원시적이기 때문에 현실적으로 추상화 된것을 사용해야한다.</li><li>Zookeeper, Consul, etcd</li></ul><h3 id=신뢰할-수-있는-복제된-상태-머신>신뢰할 수 있는 복제된 상태 머신</h3><ul><li>복제된 상태 머신:<ul><li>슬라이딩 윈도우 프로토콜(sliding-window protocol)</li></ul></li><li>신뢰할 수 있는 복제된 데이터 저장소와 설정 저장소<ul><li>분산 시스템에서는 타임스템프의 사용은 문제가 많다. 여러 머신 사이 시간을 정확하게 동기화하는 것이 불가능하기 때문이다.</li></ul></li><li>리더 선출을 이용한 고가용성 프로세싱</li><li>분산 조정과 잠금 서비스</li><li>신뢰할 수 있는 분산 큐와 메시지</li></ul><h3 id=분산-합의의-성능>분산 합의의 성능</h3><ul><li>작업의 부하를 결정하는 요소:<ul><li>처리량: 부하가 최대치일 때 단위 시간에 만들어진 제안의 수</li><li>요청의 종류: 상태를 변경하는 작업의 분량</li><li>읽기 작업에 필요한 일관성의 정도</li><li>데이터 페이로드의 크기가 다양한 경우 요청의 크기</li></ul></li><li>배포 전략:<ul><li>배포가 지역적으로 진행되는지 전역적으로 진행되는지 여부</li><li>과반수를 결정하는 알고리즘은 무엇인지, 그리고 대부분의 프로세스들은 어디에 위치하는지</li><li>시스템이 샤딩, 파이프라이닝, 일괄 작업을 사용하는지</li></ul></li></ul><h3 id=읽기-작업-부하의-확장>읽기 작업 부하의 확장</h3><ul><li>많은 부하가 읽기 작업을 주로 수행하기 때문이다.</li><li>읽기 일관성을 위해:<ul><li>읽기 전용 합의 작업을 수행한다.</li><li>가장 최신 데이터를 보장하는 복제 서버로부터 데이터를 읽는다. 안정적인 리더 프로세스를 사용하는 시스템이라면 리더가 이를 보장한다.</li><li>과반수 임대를 사용한다.</li></ul></li></ul><h4 id=과반수-임대>과반수 임대</h4><ul><li>읽기 작업이 많은 부하에 특히 유용하다.</li></ul><h4 id=분산-합의-성능과-네트워크-지연응답>분산 합의 성능과 네트워크 지연응답</h4><ul><li>합의 시스템의 두가지 무리적 제약:<ul><li>네트워크 라운드 트립 시간</li><li>영속 저장소에 데이터를 기록하는 시간</li></ul></li><li>많은 합의 시스템이 TCP/IP 를 지양하며, 메시지의 FIFO를 강한 신뢰성을 보장한다.</li><li>느린 초기 대역폭</li><li>모든 클라이언트가 합의 클러스트에 대한 연결을 영구적으로 열어두는 것은 실용적이지 못하다.</li><li>프록시는 샤딩과 로드밸런싱 전략을 캡슐화 하는 것은 물론 클러스터 맴버와 리더들의 발견 측면에서도 좋은 방법이다.</li></ul><h4 id=성능에-대한-고려-fast-paxos>성능에 대한 고려: Fast Paxos</h4><ul><li>클라이언트로부터 모든 수락자에게 전달되는 하나의 병렬 메시지로 대체한다.</li><li>많은 시스템들이 처리량을 향상시키기 위해 일괄 작업을 통해 여러 작업을 수락자 내의 하나의 트랜잭션으로 처리한다.</li></ul><h5 id=안정적-리더>안정적 리더</h5><ul><li>상태를 변경하는 모든 작업은 리더를 통해 보내져야 하며, 리더와 가까이 있지 않은 클라이언트에서는 추가적인 네트워크 지연응답이 있을 수 있다.</li><li>리더 프로세스에서 외부로 나가는 네트워크 대역폭은 시스템에 있어서는 병목지점이다., 그 이유는 다른 메시지들은 처리된 트랜잭션 수 외에 다른 데이터 페이로드를 포함하지 않지만 리더의 수락 메시지는 제안과 관련된 모든 데이터를 가지고 있기 때문이다.</li><li>리더가 성능에 문제가 있는 머신에서 동작한다면 전체 시스템의 처리량이 감소하게 된다.</li></ul><h5 id=일괄처리>일괄처리</h5><ul><li>파이프라이닝</li></ul><h5 id=디스크-접근>디스크 접근</h5><ul><li>하나의 합의 작업에 대한 지연응답에 포함되는 내용:<ul><li>제안자가 한 번의 디스크 쓰기 작업을 수행하는 시간</li><li>수락자에게 병렬로 메시지를 보내는 시간</li><li>수락자들이 병렬로 디스크에 기록하는 시간</li><li>리턴 메시지를 보내는 시간</li></ul></li></ul><h3 id=분산-합의-기반-시스템의-배포>분산 합의 기반 시스템의 배포</h3><h4 id=복제-서버의-수>복제 서버의 수</h4><ul><li>복제 서버의 수에 대한 결정:<ul><li>신뢰성에 대한 수요</li><li>시스템에 영향을 미치는 계획된 유지보수의 빈도</li><li>각종 위험 요소</li><li>성능</li><li>비용</li></ul></li></ul><h4 id=복제-서버의-위치>복제 서버의 위치</h4><ul><li>장애 도메인(failure domain): 하나의 장애가 발생했을 때 사용이 불가능한 상태가 되는 시스템 컴포넌트의 집합</li><li>예시:<ul><li>하나의 물리적 머신</li><li>한 데이터센터 내에서 하나의 전원 공급기를 통해 서비스되는 랙(rack)</li><li>한 데이터센터 내에서 하나의 네트워크 장비에 의해 서비스되는 여러 개의 랙들</li><li>태풍 같은 자연재해에 영향을 받을 수 있는 동일 지역 내의 여러 데이터센터들</li></ul></li><li>시스템이 손실을 감당할 수 있다고 해서 장애 도메인을 지속적으로 늘리는 것이 항상 바람직하지는 않다.:<ul><li>현실적으로 지연응답, 처리량, 컴퓨팅 자원 측면에서 아무런 이익이 없다.</li></ul></li></ul><h4 id=수용량과-로드밸런싱>수용량과 로드밸런싱</h4><ul><li>샤드에 대한 배포</li><li>리더 프로세스의 위치에 따라 대역폭을 골고루 활용하지 못하게 될 수도 있다.</li><li>한 곳의 리더에서 집단적으로 장애 조치가 실행되면 네트워크 활용 패턴이 극적으로 변화하게 된다.</li><li>예상치 못한 패턴 예시:</li><li>리더에 가까이 위치한 클라이언트는 리더를 통해 수행하는 작업들의 지연응답이 훨씬 나아지는 것을 경험할 수 있다. 가까운 리더를 선택하는 알고리즘에 의해 많은 클라이언트가 혜택을 받게 된다.</li><li>이 알고리즘은 최상의 성능을 발휘하는 머신의 리더를 선택하려고 한다. 하지만 여기에는 세 데이터센터 중 한 곳이 더 빠른 머신을 보유하고 있다면 불균형적인 양의 트래픽이 해당 데이터 센터로 보내지고, 트래픽의 극적인 변화로 인해 데이터센터에 장애가 발생할 수 있다.</li><li>리더 선출 알고리즘으로 인해 프로세스의 실행시간이 길어질 수 있다.
= - 과반수 조합 =</li></ul><h3 id=분산합의-시스템-모니터링>분산합의 시스템 모니터링</h3><ul><li><p>각 합의 그룹 내에서 실행중인 맴버의 수와 각 프로세스의 상태</p></li><li><p>지속적으로 지연이 발생하는 복제 서버</p></li><li><p>리더의 존재 여부</p></li><li><p>리더의 변경 횟수</p></li><li><p>합의 트랜잭션 횟수</p></li><li><p>확인된 제안의 횟수 및 합의된 제안의 횟수</p></li><li><p>처리량과 지연응답</p></li><li><p>성능이슈 관련:</p><ul><li>제안의 수락과 관련된 지연응답의 분산 정도</li><li>지리적으로 떨어진 시스템들의 네트워크 지연응답의 분산 정도</li><li>수락자들이 안정적인 로그를 작성하는 데 걸리는 시간</li><li>시스템이 초당 받아들이는 전체 바이트</li></ul></li></ul><h2 id=24-크론을-이용한-분산된-주기적-스케줄링>24. 크론을 이용한 분산된 주기적 스케줄링</h2><h3 id=크론>크론</h3><h4 id=신뢰성-관점에서의-크론>신뢰성 관점에서의 크론</h4><ul><li>크론의 장애 도메인: 하나의 머신</li><li>crond 의 영구적 상태는 crontab 설정이며, (fire-and-forget) 형태로 실행한다.</li><li>anacron 은 시스템이 다운되었을때 지금까지 실행했던 작업들을 다시 실행한다.</li></ul><h4 id=크론-작업과-멱등성>크론 작업과 멱등성</h4><ul><li>가비지 컬렉션은 멱등성을 가진다.</li><li>정확한 정답은 없지만, 두번 실행되었던 작업을 되돌리는 것은 어렵거나 불가능하다. 변경 없이 실패 방식을 선호한다.</li></ul><h3 id=대용량-시스템-내에서의-크론>대용량 시스템 내에서의 크론</h3><h4 id=인프라스트럭처의-확장>인프라스트럭처의 확장</h4><h4 id=요구사항의-확장>요구사항의 확장</h4><ul><li>부분적인 시작 실패가 발생했을 때, 복구되는 복구 절차 역시 수집해야한다.</li></ul><h3 id=구글에서-구현한-크론-서비스>구글에서 구현한 크론 서비스</h3><h4 id=크론-작업의-상태-주적하기>크론 작업의 상태 주적하기</h4><ul><li>데이터를 분산 저장소에 저장하는 방법</li><li>크론 서비스 자체에 상태의 일부를 저장하는 서비스를 덧붙이는 방법:<ul><li>GFS 나 HDFS 는 매우 큰 파일에 적합하지만, 매우 작은 크기의 크론 작업을 저장해야 할 경우 지연응답이 높아진다.</li><li>장애의 영향이 큰 기반 서비스는 다른 서비스에 대한 의존도를 최소화 해야한다.</li></ul></li></ul><h2 id=25-데이터-처리-파이프라인>25. 데이터 처리 파이프라인</h2><h3 id=파이프라인-디자인-패턴의-기원>파이프라인 디자인 패턴의 기원</h3><ul><li>데이터 파이프라인:<ul><li>코루틴, DTSS 커뮤니케이션 파일, 유닉스 파이프, ETL 파이프라인</li></ul></li></ul><h3 id=단순한-파이프라인-패턴을-적용한-빅데이터의-기본적인-효과>단순한 파이프라인 패턴을 적용한 빅데이터의 기본적인 효과</h3><ul><li>복합 단계 파이프라인</li></ul><h3 id=정기적-파이프라인-패턴의-과제>정기적 파이프라인 패턴의 과제</h3><ul><li>정기적 파이프라인은 일반적으로 데이터를 처리할 충분한 작업자가 있으며, 처리에 대한 수요를 연산 능력으로 감당할 수 있을때 안정적으로 동작한다.</li><li>정기적 파이프라인은 맵리듀스와 플럼 과 같은 프레임워크들을 기반으로 작성된다.</li></ul><h3 id=작업의-불균형-분산으로-인해-발생하는-문제>작업의 불균형 분산으로 인해 발생하는 문제</h3><ul><li>빅데이터의 핵심은 무조건적 병렬 알고리즘을 이용해 대용량 부하를 개별 머신으로 처리할 수 있을 정도의 청크로 나누어 애플리케이션에 전달하는 기법</li><li>파이프라인은 대부분 체크포인트 기능을 구현하지 않아, 데이터 청크를 다시 처리하게 될때 자원을 낭비하게 된다.</li></ul><h3 id=분산-환경에서-정기적-파이프라인의-단점>분산 환경에서 정기적 파이프라인의 단점</h3><ul><li>몇 시간 정도의 지연은 매일 실행되는 파이프라인에서는 용인할 수 있는 부분이다.</li><li>개발팀은 자원이 공용 풀에 의해 관리되거나 공유되는 경우 이 자원을 확보하는 단계를 거치는 것을 별로 내켜하지 않는 경향이 있다.</li><li>일괄 처리 예약 자원과 서비스에 우선순위를 두는 자원을 구별함으로써 합리적인 비용으로 자원을 획득할 수 있다.</li></ul><h3 id=정기적-파이프라인의-문제점-모니터링하기>정기적 파이프라인의 문제점 모니터링하기</h3><ul><li>정기적 파이프라인 안에서는 모니터링으로 인한 문제가 발생해서는 안되지만 이 둘 사이에는 강력한 연관성이 존재한다.</li></ul><h3 id=천둥-소리-문제>&lsquo;천둥 소리&rsquo; 문제</h3><ul><li>작업자 프로세스가 너무 많거나 설정이 잘모소디었거나, 재시도 로직이 오작동한다면 서버에 많은 부하를 발생시키고 결국 네트워크 인프라스트럭쳐까지 영향을 받게 된다.</li><li>사람의 개입이 있다면 더 심화될수 있다.:<ul><li>원하는 시간 내에 종료되지 않는다면 프로세스를 추가해서 문제를 확대시키는 경향이 있다.</li></ul></li></ul><h3 id=모이어-부하-패턴>모이어 부하 패턴</h3><ul><li>두개 혹은 그 이상의 파이프라인이 동시에 실행되면서 실행 순서가 겹쳐서 공용자원을 동시에 소비하게 되는 문제</li></ul><h3 id=구글-워크플로우>구글 워크플로우</h3><h4 id=모델-뷰-컨트롤러-패턴에-응용>모델-뷰-컨트롤러 패턴에 응용</h4><ul><li><p>태스크 마스터(모델) -> 작업자(뷰) 에게 작업단위 넘기기</p></li><li><p>작업자(뷰)는 완료된 작업단위를 태스크 마스터에게 반환</p></li><li><p>컨트롤러는 작업 사이클, 확장 혹은 스냅샷 생성을 태스크마스터에게 전달</p></li><li><p>워크플로우가 보장하는 4가지 정확성:</p><ul><li>설정 작업을 통한 작업자의 출력은 작업을 예측하기 위한 영역을 만든다.</li><li>작업자가 작업을 완료하기 위해서는 반드시 유효한 임대 기록을 보유하고 있어야한다.</li><li>출력 파일은 작업자마다 고유한 이름의 파일에 기록된다.</li><li>클라이언트와 서버는 모든 작업마다 서버 토큰을 검사하여 태스크 마스터에 대한 유효성을 판단한다.</li></ul></li></ul><h3 id=비지니스의-지속성-보장하기>비지니스의 지속성 보장하기</h3><ul><li>빅데이터 파이프라인은 광섬유의 단절, 기후로 인한 사고, 연속적인 전력 공급 문제 등 어떤 종류의 장애가 발생하더라도 계쏙 동작해야한다.</li><li>워크플로우는 전역적인 일관성을 확보하기 위해 태스크마스터는 저널을 스패너에 저장한다.
-스패너는 처리량이 높은 파일시스템을 제공하지 못하므로, 워크플로우 시스템은 태스크에 대한 참조는 전역 워크플로우에 저장하되, 고유의 클러스터에서 실행한다.</li></ul><h2 id=chatper-26-데이터-무결성-내가-기록한-그대로-읽을수-있어야한다>Chatper 26. 데이터 무결성: 내가 기록한 그대로 읽을수 있어야한다.</h2><ul><li>데이터 무결성에 대한 엄밀한 정의가 필요하다.</li></ul><h3 id=데이터-무결성의-중요한-조건>데이터 무결성의 중요한 조건</h3><ul><li>데이터 무결성: 클라우드 상의 서비스들이 사용자들이 계속 사용할 수 있는 상태를 유지하는 것이며, 특히 데이터에 대한 사용자의 접근이 완벽하게 동작해야한다.</li></ul><h3 id=최상의-데이터-무결성을-위한-전략의-수집>최상의 데이터 무결성을 위한 전략의 수집</h3><ul><li><p>업타임: 가용성, 사용자들이 서비스를 정상적으로 사용하는 시간의 비율을 의미한다.</p></li><li><p>지연응답: 사용자에 대한 서비스의 응답성을 의미한다.</p></li><li><p>확장: 서비스의 지연응답이 증가하기 전까지 서비스가 감당할 수 있는 사용자의 규모와 작업 부하를 의미한다.</p></li><li><p>속도: 합리적인 비용으로 최상의 가치를 사용자에게 제공하기 위해 서비스를 얼마나 빨리 혁신 할 수 있는지를 의미한다.</p></li><li><p>정보보안: 복합적이지만, 한정적 의미로 데이터는 사용자가 삭제한 후 적절한 시간 내에 반드시 파기되어야 한다.</p></li><li><p>무결성은 데이터들이 복잡하게 엮이면서 각종 과제에 부딪히게 된다.:</p><ul><li>스키마 변경</li><li>데이터 마이그레이션</li><li>기존 기능을 바탕으로 새로운 기능을 쌓아 올리는 습관</li><li>코드의 재작성</li></ul></li></ul><h4 id=백업과-보관>백업과 보관</h4><ul><li>백업과 보관을 구분해야한다.</li><li>보관: 감사, 발견 등 법적 준수 사항을 만족하기 위해 장기간 데이터를 안전하게 보관하는 것. 업타임 요구사항을 만족할 필요가 없다.</li><li>백업 전략 수집:<ul><li>얼마나 신속하게 복구할 수 있는지, 가장 최신의 데이터에 대한 유실은 어느정도 감수할 것인지</li></ul></li></ul><h4 id=클라우드-환경에-대한-거시적-요구사항>클라우드 환경에 대한 거시적 요구사항</h4><ul><li><p>운영 환경에서 트랜잭션을 지원하는 백업 및 복구 솔루션과 트랜잭션을 지원하지 않는 솔루션을 혼합해서 사용하고 있다면 복구된 데이터가 반드시 올바르지는 않다.</p></li><li><p>만약 서비스가 무중단 운영을 지원해야 한다면 각기 다른 버전의 비지니스 로직이 병렬로 데이터를 조작할 수 있다.</p></li><li><p>서비스와 함께 동작하는 다른 외부 서비스가 독자적으로 버전을 관리하고 있다면 잠시 동안이라도 외부 서비스의 불완전한 버전이 동작하게 되어 데이터의 변조나 유실이 발생할 수 있다.</p></li><li><p>고려해야할 사항:</p><ul><li>데이터의 위치와 캐시</li><li>지역 및 전역 데이터 분산</li><li>갇력한 일관성 및 혹은 최종적 일관성</li><li>데이터의 내구성, 백업 및 복구</li></ul></li></ul><h3 id=데이터-무결성과-가용성을-유지하기-위한-구글-sre의-목표>데이터 무결성과 가용성을 유지하기 위한 구글 SRE의 목표</h3><h4 id=데이터-무결성은-의미이며-데이터-가용성은-목표이다>데이터 무결성은 의미이며, 데이터 가용성은 목표이다.</h4><ul><li>데이터 무결성: 데이터의 생명 주기 동안의 정확성과 일관성:<ul><li>사용자의 관점에서 볼 때 일정 수준 이상의 데이터 가용성을 제공할수 없는 데이터 무결성은 데이터가 전혀 존재하지 않는 것이나 다름이 없다는 점이다.</li></ul></li></ul><h4 id=백업-시스템보다-복구-시스템을-제공하자>백업 시스템보다 복구 시스템을 제공하자</h4><ul><li>팀은 다양한 형태의 장애를 고려하여 데이터 가용성에 대한 서비스 수준 목표를 정의해야 한다.</li><li>팀은 SLO를 만족시킬 수 있는 능력을 지속적으로 연습하고 입증해야 한다.</li></ul><h4 id=데이터-유실을-유발하는-장애의-종류들>데이터 유실을 유발하는 장애의 종류들</h4><ul><li><p>근본 원인:</p><ul><li>사용자의 행위, 운영자의 실수, 애플리케이션의 벅, 인프라스트럭처의 결함, 특정 지역의 장애</li></ul></li><li><p>범위</p></li><li><p>비율</p></li><li><p>시점 기반 복구(또는 시간 여행)이라 불리는 것을 제공하고 싶지만, 비용 목표를 만족시키면서 이를 제공하는 것은 망상이다.</p></li><li><p>속도를 희생시키는 것이 가장 현실적이며, 비용적인 부분을 감안하여 스내뱟ㅅ을 적당한 기간 보관해야한다.</p></li></ul><h4 id=더-깊고-폭넓은-데이터-무결성-관리의-어려움>더 깊고 폭넓은 데이터 무결성 관리의 어려움</h4><ul><li>복제와 다중화는 회복성이 아니다.</li><li>확장성 이슈: 전체, 증분 백업의 경쟁 세력과 복구:<ul><li>데이터의 복사본을 서비스에서는 사용하지 않되, 다른 형태로 만들어 보관한다.:<ul><li>복제로 해결하지 못하는 에러로부터 보호할수 있다.</li><li>의미적으로 일치하지 않거나, 각정 기술 스택의 문제로 데이터 유실을 방지하지는 못한다.</li></ul></li></ul></li><li>데이터 보존</li></ul><h3 id=구글이-데이터-무결성의-문제를-해결하는-방법>구글이 데이터 무결성의 문제를 해결하는 방법</h3><h4 id=데이터-무결성-장애가-발생할-수-있는-24가지-조합>데이터 무결성 장애가 발생할 수 있는 24가지 조합</h4><ul><li>1 계층: 소프트 삭제 - 부주의로 인한 데이터의 삭제에 효과적으로 대응할 수 있다.</li><li>2 계층: 백업 및 그와 관련된 복구 방법들</li><li>3 계층: 규칙적인 데이터의 검증</li></ul><h4 id=첫-번째-계층-소프트-삭제>첫 번째 계층: 소프트 삭제</h4><ul><li>고객 지원 문제는 소프트 삭제를 지원하면 현저히 혹은 완전히 해결할 수 있다.</li><li>소프트 삭제 이후 일정 시간 이후 실제로 파기된다.</li><li>보통 60일 정도가 적합하다.</li><li>데이터 보호의 첫번째 계층에서 고려할 사항:<ul><li>휴지통 폴더를 이용해 데이터 삭제를 취소할 수 있게 함으로써 사용자의 실수로부터 데이터를 보호한다.</li><li>소프트 삭제는 개발자의 실수에 대한 일차적 방어선인 동시에 사용자의 실수에 대한 이차적 방어선 역할을 수행한다.</li><li>개발자의 입장에서는 지연 삭제는 내부 개발자의 실수에 대한 일차적 방어선이자 외부 개발자의 실수에 대한 이차적 방어선이 될 수 있다.</li></ul></li><li>수정 기록:<ul><li>데이터가 변조 되었을때 이전의 상태로 복구하는 것은 유용하다.</li><li>데이터 유실에 대해서는 그다지 유용하지 않는다.</li></ul></li></ul><h4 id=두-번째-계층-백업-및-그와-관련된-복구-방법들>두 번째 계층: 백업 및 그와 관련된 복구 방법들</h4><ul><li>백업을 통해 데이터를 복구하기 위해서 고려할 사항:<ul><li>사용할 백업 및 복구 방법</li><li>데이터의 전체 및 증분 백업을 통한 복구 지점의 생성 빈도</li><li>백업 저장 위치</li><li>백업의 보관 기간</li></ul></li><li>백업을 가장 오랜 기간 동안 보관해야두어야 하는 경우는 애플리케이션 코드에 비교적 덜 심각한 데이터 변경 혹은 삭제의 버그가 있고, 몇달이 지난 뒤에 발견되는 경우다.</li><li>합리적인 비용으로 여러가지 실패 시나리오를 처리하기 위해 단계적 백업 전략이 필요하다.</li><li>특정 지역의 임의 분산 파일 시스템에 10일 혹은 15일 미만의 기간에 백업을 보관한다.</li></ul><h4 id=가장-중요한-단계-복제>가장 중요한 단계: 복제</h4><ul><li>이상적으로, 백업을 저장하고 있는 저장소를 포함한 모든 저장소 인스턴스는 복제가 되어야한다.</li><li>RAID, 리드-솔로몬 소거, GFS 형식의 복제</li><li>이중화 시스템을 선택할때는 테스트 용도만 복구를 수행하는 사용 빈도가 낮은 스키마가 아닌 지속적으로 사용하는 빈도 높은 스키마를 선택해야한다.</li></ul><h4 id=1t-vs-비교-단순히-더-큰-백업만을-의미하지-않는다>1T vs. 비교: &lsquo;단순히&rsquo; 더 큰 백업만을 의미하지 않는다.</h4><ul><li>데용량 데이터를 백업하는 데 가장 자주 사용되며 효과적인 기법은 데이터에 대한 신뢰지점을 수립하는 것이다.</li><li>신뢰지점: 저장된 데이터 중 시간의 추이에 따라 더 이상의 변경이 발생하지 않은 후로 검증이 완료된 부분을 일컫는다.</li><li>백업이 아니라 복구가 중요하다.</li><li>스키마 디자인 고려항목:<ul><li>데이터의 올바른 균형</li><li>각 샤드의 독립성 보장</li><li>동시에 실행 중인 작업들 간의 경쟁 방지</li></ul></li></ul><h4 id=세-번째-계층-조기-발견>세 번째 계층: 조기 발견</h4><ul><li>클라우드 개발자가 당명한 과제들:<ul><li>데이터 저장소 간의 참조 무결성</li><li>스키마의 변경</li><li>오래된 코드</li><li>제로 다운타임 데이터 마이그레이션</li><li>다른 서비스들과의 통합 지점의 향상</li></ul></li></ul><h4 id=대역-외-데이터-검증>대역 외 데이터 검증</h4><ul><li>데이터 변조 버그를 알고 있는 엔지니어들은 운영 환경에서 더 신경을 많이 쓴다.</li><li>프로젝트 주기의 초기에 단위 테스트를 수행했을 때의 효과와 마찬가지로 데이터 검증 파이프라인의 투입 결과 역시 소프트웨어 개발 프로젝트의 전반적인 속도를 개선한다.</li><li>대역 외 데이터 검증은 올바르게 구현하기에 난해한 면이 있다.:<ul><li>너무 엄격하게 구현하면 간단하고 별 문제 없는 변경 사항으로 검증이 실패gkftn dlTek.</li><li>결과적으로 엔지니어는 데이터 검증 전체를 거부하게 된다.</li><li>올바른 균형을 찾기 위해서, 대부분 변경이 일어나지는 않지만 한번 변경이 일어나면 사용자의 데이터에 문제를 일으킬 수 있는 부분만을 검증하면 된다.</li></ul></li></ul><h4 id=데이터-복구의-동작-여부-확인하기>데이터 복구의 동작 여부 확인하기</h4><ul><li>일반 운영 엄무와 함께 복구 프로세스를 지속적으로 테스트한다.</li><li>복구 프로세스의 성공 여부를 지속적으로 파악하기 위해 복구 프로세스가 실패했을 때 전송될 알림을 설정한다.</li><li>복구 계획의 관점에서 확인해야할것:<ul><li>백업이 유효하고 완전한 상태인가 아니면 비어있는 상태인가?</li><li>복구를 위한 설정, 복원 및 사후 처리를 실행하기에 충분한 머신 자원을 확보하고 있가?</li><li>복구 프로세스가 적절한 시간 내에 완료되는가?</li><li>복구 프로세스가 진행되는 동안 상태를 모니터링할 수 있는가?</li><li>무정지 운영을 지원하지 않는 타지역의 미디어 저장소에 대한 접근 같이 직접 통제할 수 없는 외부 자원에 대한 의존도로부터 자유로운가?</li></ul></li></ul><h3 id=데이터-무결성과-관련된-sre의-일반-원리들>데이터 무결성과 관련된 SRE의 일반 원리들</h3><h4 id=초심자의-마음가짐>초심자의 마음가짐</h4><ul><li>신뢰하되 검증하고, 다중 방어 장치를 도입하라</li></ul><h4 id=신뢰하되-검증하라>신뢰하되 검증하라</h4><h4 id=희망은-전략이-아니다>희망은 전략이 아니다</h4><h4 id=다중-방어-조치>다중 방어 조치</h4><h3 id=결론>결론</h3><ul><li>데이터의 사용성은 모든 데이터 기반 시스템이 최우선적으로 고려해야할 사항이다.</li><li>어떤 종류의 장애도 발생할 수 있다는 생각보다는 모든 것이 잘못될 수 있다는 생각을 갖는 것은 실제로 발생할 긴급 사태를 대비하기로 위한 중요한 과정이다.</li><li>어떤 장애가 발생하더라도 적절한 시간 N 내에 복구할 수 있게 된다면 더욱 신속하고 세밀한 데이터 유실 탐지 매커니즘을 통해 이 시간을 더 줄일 수 있는 방법을 찾아 N=0을 만드는 목표를 달성하기 위해 노력하자.</li></ul><h2 id=27-대용량-환경에서의-신뢰할-수-있는-제품-출시>27. 대용량 환경에서의 신뢰할 수 있는 제품 출시</h2><h3 id=출시-조율-엔지니어링>출시 조율 엔지니어링</h3><ul><li>컨설팅팀이 제품 출시 절차를 도와준다:<ul><li>구글의 신뢰성 표준과 모범 사례를 준수하도록 제품과 서비스를 감사하고 신뢰성을 향상시키기 위해 도움을 준다.</li><li>출시에 함류한여러 팀 사이의 연락책 역할을 수행한다.</li><li>작업의 추진력을 유지함으로써 출시의 기술적 관점들을 주도한다.</li><li>출시가 안전하게 진행될 수 있도록 통제원 역할을 수행하며 출시의 완료를 선언한다.</li><li>개발자들에게 모범 사례 및 구글의 서비스들과 통합하는 방법을 교육하며 신속한 학습을 위해 내부 문건 및 교육 자료를 이용한다.</li></ul></li></ul><h3 id=제품-출시에-대한-lce팀의-역할>제품 출시에 대한 LCE팀의 역할</h3><ul><li>경험의 전파</li><li>교차 기능(cross-functional) rhkswja</li><li>객관성(objectivity)</li></ul><h3 id=출시-절차-마련하기>출시 절차 마련하기</h3><ul><li>성공적인 출시 절차의 특징<ul><li>경량(lightweight): 개발자들이 접근하기 쉬워야한다.</li><li>견고함(robust): 오류를 명확하게 잡아내야 한다.</li><li>주도면밀함(thorough): 중요한 부분은 일관적이고 재현 가능하게 다루어야 한다.</li><li>확장성(scalable): 더 많은 출시를 단순화하고 복잡한 출시를 줄여야한다.</li><li>순응동(adaptable): 일반적인 종류의 출시와 새로운 종류의 출시를 모두 잘 지원할 수 있어야한다.</li></ul></li><li>성공적인 전략:<ul><li>간결성(simplicity): 기본적인 것들은 완수한다. 모든 우발적 가능성에 대한 계획을 세우지는 않는다.</li><li>직접 부딪히기: 경험이 있는 엔지니어들이 각 출시별로 절차를 최적화하도록 한다.</li><li>빠른 공통 경로: 항상 공토엊ㄱ인 패턴을 따르는 출시를 정의하고 이 종류의 출시를 위한 간소화된 출시 절차를 제공한다.</li></ul></li><li>엔지니어는 너무 부담스럽거나, 그 가치가 미약하다고 생각하는 절차는 잘 지키지 않으려는 경향을 보인다.</li></ul><h3 id=출시-확인목록>출시 확인목록</h3><ul><li>가이드라인:<ul><li>모든 질문의 중요도를 입증해야한다. 이전의 출시에서 발생했던 문제에 의해 생겨난 질문이면 이상적이다.</li><li>모든 지시 사항은 견고하고 실용적이며 개발자들이 달성할 수 있는 합리적인것이어야 한다.</li></ul></li></ul><h3 id=집중과-간소화-진행하기>집중과 간소화 진행하기</h3><ul><li>규모가 큰 조직에서는 엔지니어가 공통적인 업무를 수행할 때 활용할만한 인프라스트럭쳐가 존재한다는 것을 모를 수도 있다.</li><li>LCE는 출시 작업을 수행하는 동안 발생하는 모든 문제점들의 최초 목격자가 된다.</li></ul><h3 id=예상치-못한-제품의-출시>예상치 못한 제품의 출시</h3><h3 id=출시-확인목록-개발하기>출시 확인목록 개발하기</h3><h4 id=아키텍처와-의존성>아키텍처와 의존성</h4><ul><li>확인목록 질문의 예:<ul><li>사용자의 요청은 프론트엔드를 거쳐 백엔드까지 어떻게 전달되는가?</li><li>요청의 종류별로 지연응답에 대한 요구사항이 서로 다른가?</li></ul></li><li>실행항목의 예:<ul><li>사용자와 관련된 요청을 관련이 없는 요청과 따로 분리한다.</li><li>요청의 규모에 대한 예측을 검증한다. 한 페이지에서 더 많은 수의 요청을 생성할 수 있다.</li></ul></li></ul><h4 id=통합-1>통합</h4><ul><li>실행항목의 예:<ul><li>서비스를 위한 새 DNS 이름 셋업</li><li>서비스와의 통신을 위한 로드밸런서 셋업</li><li>새 서비스에 대한 모니터링 셋업</li></ul></li></ul><h4 id=수용량-계획>수용량 계획</h4><ul><li>확인목록 질문의 예:<ul><li>제품의 출시가 언론이나 광고, 블로그 포스트 혹은 기타 다른 형태로 홍보되었는가?</li><li>출시 도중 및 출시 후 트래픽과 증가율은 어느 정도로 예상하는가?</li><li>전체 트래픽을 지원하기 위한 충분한 컴퓨팅 자원이 확보되었는가?</li></ul></li></ul><h4 id=장애-모드>장애 모드</h4><ul><li>확인목록 질문의 예:<ul><li>서비스의 디자인에 있어 단일 실패점이 존재하는가?</li><li>의존하는 서비스의 장애의 영향을 어떻게 최소화하고 있는가?</li></ul></li><li>실행항목의 예:<ul><li>요청이 너무 오래 실행되면서 자원을 소모하는 것을 방지하기 위해 요청 실행에 대한 마감기한을 설정한다.</li><li>과부화 발생시 새로운 요청을 미리 거부하도록 부하의 정량을 구현한다.</li></ul></li></ul><h4 id=클라이언트-동작>클라이언트 동작</h4><ul><li>확인목록 질문의 예:<ul><li>자동 저장/자동 완성/건강 상태 검사 기능 등을 구현하고 있는가?</li></ul></li><li>실행항목의 예:<ul><li>장애 발생 시 클라이언트가 즉각 동작을 중단하도록 한다.</li><li>자동으로 발생하는 요청을 충분히 고려한다.</li></ul></li></ul><h4 id=절차와-자동화>절차와 자동화</h4><ul><li>확인목록 질문의 예:<ul><li>서비스가 지속적으로 실행되기 위한 필요한 수동절차가 있는가?</li></ul></li><li>실행항목의 예:<ul><li>모든 수동절차는 문서화한다.:<ul><li>서비스를 새로운 데이터센터로 이전하기 위한 절차를 문서화한다.</li><li>새 버전의 빌드 및 배포 절차를 자동화한다.</li></ul></li></ul></li></ul><h4 id=배포-절차>배포 절차</h4><ul><li>실행항목의 예:<ul><li>모든 코드와 설정파일을 버전 관리 시스템에 제출한다.</li><li>각 릴리즈는 매번 새로운 릴리즈 브랜치에 관리한다.</li></ul></li></ul><h4 id=외부-의존성>외부 의존성</h4><ul><li>확인목록 질문의 예:<ul><li>제품의 출시에 어떤 서드파티 코드, 데이터, 서비스 혹은 이벤트에 대한 의존성 영향을 미치는가?</li><li>우리 서비스에 의존하는 파트너가 있는가? 그렇다면 제품의 출시를 그들에게 알려야하는가?</li><li>우리 또는 외부 벤더가 제품 출시 기일을 지킬 수 없을 때 어떤 일이 발생하는가?</li></ul></li></ul><h4 id=발표-계획>발표 계획</h4><ul><li>실행항목의 예:<ul><li>서비스를 출시하기 위해 필요한 실행 요소들을 정의한 출시 계획을 수립한다. 그리고 각 요소들을 누가 책임질 것인지도 결정한다.</li><li>개별 출시 단계마다 위험 요소들을 정의하고 우발적 상황에 대처할 수 있는 방안을 수립한다.</li></ul></li></ul><h3 id=안정적인-출시를-위한-기법들>안정적인 출시를 위한 기법들</h3><h4 id=점진적이고-단계적인-출시>점진적이고 단계적인 출시</h4><ul><li>시스템 관리 분야의 격언: 운영 중인 시스템은 절대 바꾸지 마라:<ul><li>모든 벼경은 위험을 의미하며, 위험은 시스템의 안정성을 확보하기 위해서는 최소화해야 할 요소다.</li></ul></li><li>어떤 변경 이후 일정 기간 동안의 검사를 통과하지 못하면 자동으로 롤백된다.</li><li>초청 시스템은 점진적 출시의 또다른 형태다.</li></ul><h4 id=기능-플래그-프레임워크>기능 플래그 프레임워크</h4></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/sidebar.js></script><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>