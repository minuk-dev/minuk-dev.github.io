<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Kafka</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>Kafka
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><a href=/wiki/><button class="btn btn-link"><i class="fa fa-arrow-left"></i>&nbsp;Front Page</button></a></div></div><div><h2>Kafka</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/kafka.md><h5>created : Mon, 13 Dec 2021 16:07:50 +0900</h5><h5>modified : Mon, 13 Dec 2021 16:36:06 +0900</h5></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#kafka>Kafka</a><ul><li><a href=#topic-partition-offset>Topic, Partition, Offset</a></li><li><a href=#broker>Broker</a></li><li><a href=#producer>Producer</a></li><li><a href=#consumer--consumer-group>Consumer & Consumer Group</a></li><li><a href=#zookeeper>Zookeeper</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=kafka>Kafka</h2><ul><li>Apache Kafka is an event streaming platform</li><li>publish-subscribe model(producer, consumer, broker)</li></ul><h3 id=topic-partition-offset>Topic, Partition, Offset</h3><ul><li>Topic : 특정 스트림 데이터이며, 카프카 클러스터에서 데이터를 관리할 때 기준이 된다.:<ul><li>Similar to a table in a database (without all the constraints)</li><li>원하는 수만큼 토픽을 만들 수 있다.</li><li>토픽의 구별자는 토픽의 이름이다.</li><li>토픽은 파티션으로 나누어 처리되며, 각 파티션은 순서가 있고, 각각의 파티션 내 메시지는 offset이라는 단위로 고유 id가 증가한다.:</li></ul></li><li>Parition : 각 토픽 당 데이터를 분산처리하는 단위. 카프카에서는 토픽 안에서 파티션을 나누어 그 수대로 데이터를 분산처리 한다. 카프카 옵션에서 지정한 replica의 수만큼 파티션이 각 서버들에게 복제된다.</li><li>offset은 특정 partition에서만 의미가 있으며 순서 또한 파티션 내에서만 보장된다.</li><li>데이터의 기본 보존 주기는 7일이고 log.retention.hours 설정을 통해서 변경 가능하다.</li><li>데이터가 특정 파티션에 쓰여지게 된다면 절대 변경되지 않는다.</li><li>특정 키로 파티션을 지정하지 않는다면, 데이터는 랜덤하게 파티션이 지정되어 쓰여진다.</li></ul><h3 id=broker>Broker</h3><ul><li>Kafka Cluster 는 여러대의 broker로 구성된다.</li><li>각 broker는 고유한 id로 구분되며, 특정한 topic partition을 포함한다.</li><li>bootstrap broker라 불리는 어떤 broker에나 연결이 된다면, 전체 클러스터에 연결된 것이다.</li><li>일반적으로 3개의 broker로 운영을 하는게 이상적이지만 규모에 따라서 여러개로 늘릴 수 있다.</li><li>Replication Factor:<ul><li>Kafka topic 파티션의 Replication Factor(RF)는 broker 설정 중 <code>offsets.topic.replication.factor</code>에 의해 결정 된다. 기본값은 3으로, 하나의 파티션이 총 3개로 분산되어 저장된다.</li><li>1개의 broker만이 특정 파티션의 leader가 될 수 있고, leader만이 해당 파티션의 데이터를 송수신 가능하다.</li></ul></li></ul><h3 id=producer>Producer</h3><ul><li>Producer는 topic에 데이터를 write한다.</li><li>Producer는 데이터를 쓸때 어떤 브로커와 파티션에 데이터를 write할지 알고 있다.</li><li>Producer는 데이터를 write 할 때의 receive acknowledgment를 선택할 수 있다.:<ul><li>acks=0 : Producer는 acknowledgement 를 기다리지 않음</li><li>acks=1 : producer는 leader acknowledgment를 기다렸다가 다음 액션을 한다.</li><li>acks=all : leader + ISR acknowledgment를 모두 기다린다.</li></ul></li><li>Message keys:<ul><li>Producer는 메시지 데이터와 함께 key를 선택하여 보낼 수 있다.</li><li>key=null 이라면, 데이터는 라운드로빈 동작으로 브로커에 순차적으로 데이터를 송신한다.</li><li>key를 지정하여 데이터를 송신하면, 해당 key로 보내지는 데이터는 항상 같은 파티션으로 보내진다.</li></ul></li></ul><h3 id=consumer--consumer-group>Consumer & Consumer Group</h3><ul><li><p>Consumer는 topic에 있는 데이터를 read한다.</p></li><li><p>Consumer는 데이터를 읽을 때에 자동적으로 어떤 브로커와 파티션에서 데이터를 read할 지 알고 있게 된다.</p></li><li><p>데이터는 각 파티션 내에 순서대로 읽어온다.</p></li><li><p>Consumer Groups:</p><ul><li>Consumer는 Consumer Group 안에 속하여 데이터를 read하게 된다.</li><li>그룹 내의 각 Consumer는 서로 다른 partition에 할당된다.</li><li>컨슈머의 수가 파티션의 수보다 많다면 컨수머는 놀게 된다.</li><li>컨수머는 자동적으로 GroupCoordinator와 ConsumerCoordinator를 사용하여 컨슈머와 파티션을 할당한다.</li></ul></li><li><p>Consumer Offsets:</p><ul><li>특정한 consumer가 어디까지 reading 했는지에 대한 offset정보를 저장하고 있다. <code>__consumer_offsets</code></li></ul></li><li><p>3 delivery semantic:</p><ul><li>at most once:<ul><li>offsets are committed as soon as the message is received. 메시지가 도착하는 즉시 offsets 은 커밋된다.</li><li>If the processing goes wrong, the message will be lost (it won&rsquo;t be read again). 처리가 잘못 되었을 때 메시지는 손실된다.</li></ul></li><li>at least once (usually perferred):<ul><li>offsets are committed after the message is processed. 메시지가 처리되면 offset이 commit 된다.</li><li>If the processing goes wrong, the message will be read agian. 처리가 잘못된다면, 동일한 메시지가 다시 읽힐 수 있다.</li><li>This can result it duplicate processing of messages. Make sure your processing is idempotent. 결과적으로 동일한 메시지의 중복된 처리를 읽으키기 때문에, 처리가 멱등성을 지녀야한다.(재처리 된다고 하더라도 상관 없어야한다.)</li></ul></li><li>Exactly once:<ul><li>Can be archieved for kafka</li><li>For kafka, External System workflows, use an idempotent consumer.</li></ul></li></ul></li></ul><h3 id=zookeeper>Zookeeper</h3><ul><li>zookeeper는 분산 코디네이션 시스템이다.</li><li>카프카 브로커는 하나의 클러스터로 코디네이팅하는 역할을 하며, 카프카 클러스터의 리더(Leader)fㅡㄹ 발탁하는 방식을 제공한다.</li><li>새로운 토픽 생성, 브로커 서버 다운 등 모든 카프카 클러스터 내 변화들에 대하여 알림을 준다.</li><li>카프카는 언제나 주키퍼가 존재해야한다.</li><li>일반적으로 주키퍼는 홀수개로 운영된다.</li><li>consumer offset은 zookeeper가 아닌 kafka topic에 저장되도록 되어 있다.</li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>