<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://unpkg.com/simpledotcss/simple.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>Kafka |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>Kafka</div></header><main><article class=main><div class=title><h1 class=title-header>Kafka</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/kafka.md><h5>created : Mon, 13 Dec 2021 16:07:50 +0900</h5><h5>modified : Mon, 13 Dec 2021 16:36:06 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
[[_index]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#kafka>Kafka</a><ul><li><a href=#topic-partition-offset>Topic, Partition, Offset</a></li><li><a href=#broker>Broker</a></li><li><a href=#producer>Producer</a></li><li><a href=#consumer--consumer-group>Consumer & Consumer Group</a></li><li><a href=#zookeeper>Zookeeper</a></li></ul></li></ul></nav></aside><div class=content><h2 id=kafka>Kafka</h2><ul><li>Apache Kafka is an event streaming platform</li><li>publish-subscribe model(producer, consumer, broker)</li></ul><h3 id=topic-partition-offset>Topic, Partition, Offset</h3><ul><li>Topic : 특정 스트림 데이터이며, 카프카 클러스터에서 데이터를 관리할 때 기준이 된다.:<ul><li>Similar to a table in a database (without all the constraints)</li><li>원하는 수만큼 토픽을 만들 수 있다.</li><li>토픽의 구별자는 토픽의 이름이다.</li><li>토픽은 파티션으로 나누어 처리되며, 각 파티션은 순서가 있고, 각각의 파티션 내 메시지는 offset이라는 단위로 고유 id가 증가한다.:</li></ul></li><li>Parition : 각 토픽 당 데이터를 분산처리하는 단위. 카프카에서는 토픽 안에서 파티션을 나누어 그 수대로 데이터를 분산처리 한다. 카프카 옵션에서 지정한 replica의 수만큼 파티션이 각 서버들에게 복제된다.</li><li>offset은 특정 partition에서만 의미가 있으며 순서 또한 파티션 내에서만 보장된다.</li><li>데이터의 기본 보존 주기는 7일이고 log.retention.hours 설정을 통해서 변경 가능하다.</li><li>데이터가 특정 파티션에 쓰여지게 된다면 절대 변경되지 않는다.</li><li>특정 키로 파티션을 지정하지 않는다면, 데이터는 랜덤하게 파티션이 지정되어 쓰여진다.</li></ul><h3 id=broker>Broker</h3><ul><li>Kafka Cluster 는 여러대의 broker로 구성된다.</li><li>각 broker는 고유한 id로 구분되며, 특정한 topic partition을 포함한다.</li><li>bootstrap broker라 불리는 어떤 broker에나 연결이 된다면, 전체 클러스터에 연결된 것이다.</li><li>일반적으로 3개의 broker로 운영을 하는게 이상적이지만 규모에 따라서 여러개로 늘릴 수 있다.</li><li>Replication Factor:<ul><li>Kafka topic 파티션의 Replication Factor(RF)는 broker 설정 중 <code>offsets.topic.replication.factor</code>에 의해 결정 된다. 기본값은 3으로, 하나의 파티션이 총 3개로 분산되어 저장된다.</li><li>1개의 broker만이 특정 파티션의 leader가 될 수 있고, leader만이 해당 파티션의 데이터를 송수신 가능하다.</li></ul></li></ul><h3 id=producer>Producer</h3><ul><li>Producer는 topic에 데이터를 write한다.</li><li>Producer는 데이터를 쓸때 어떤 브로커와 파티션에 데이터를 write할지 알고 있다.</li><li>Producer는 데이터를 write 할 때의 receive acknowledgment를 선택할 수 있다.:<ul><li>acks=0 : Producer는 acknowledgement 를 기다리지 않음</li><li>acks=1 : producer는 leader acknowledgment를 기다렸다가 다음 액션을 한다.</li><li>acks=all : leader + ISR acknowledgment를 모두 기다린다.</li></ul></li><li>Message keys:<ul><li>Producer는 메시지 데이터와 함께 key를 선택하여 보낼 수 있다.</li><li>key=null 이라면, 데이터는 라운드로빈 동작으로 브로커에 순차적으로 데이터를 송신한다.</li><li>key를 지정하여 데이터를 송신하면, 해당 key로 보내지는 데이터는 항상 같은 파티션으로 보내진다.</li></ul></li></ul><h3 id=consumer--consumer-group>Consumer & Consumer Group</h3><ul><li><p>Consumer는 topic에 있는 데이터를 read한다.</p></li><li><p>Consumer는 데이터를 읽을 때에 자동적으로 어떤 브로커와 파티션에서 데이터를 read할 지 알고 있게 된다.</p></li><li><p>데이터는 각 파티션 내에 순서대로 읽어온다.</p></li><li><p>Consumer Groups:</p><ul><li>Consumer는 Consumer Group 안에 속하여 데이터를 read하게 된다.</li><li>그룹 내의 각 Consumer는 서로 다른 partition에 할당된다.</li><li>컨슈머의 수가 파티션의 수보다 많다면 컨수머는 놀게 된다.</li><li>컨수머는 자동적으로 GroupCoordinator와 ConsumerCoordinator를 사용하여 컨슈머와 파티션을 할당한다.</li></ul></li><li><p>Consumer Offsets:</p><ul><li>특정한 consumer가 어디까지 reading 했는지에 대한 offset정보를 저장하고 있다. <code>__consumer_offsets</code></li></ul></li><li><p>3 delivery semantic:</p><ul><li>at most once:<ul><li>offsets are committed as soon as the message is received. 메시지가 도착하는 즉시 offsets 은 커밋된다.</li><li>If the processing goes wrong, the message will be lost (it won&rsquo;t be read again). 처리가 잘못 되었을 때 메시지는 손실된다.</li></ul></li><li>at least once (usually perferred):<ul><li>offsets are committed after the message is processed. 메시지가 처리되면 offset이 commit 된다.</li><li>If the processing goes wrong, the message will be read agian. 처리가 잘못된다면, 동일한 메시지가 다시 읽힐 수 있다.</li><li>This can result it duplicate processing of messages. Make sure your processing is idempotent. 결과적으로 동일한 메시지의 중복된 처리를 읽으키기 때문에, 처리가 멱등성을 지녀야한다.(재처리 된다고 하더라도 상관 없어야한다.)</li></ul></li><li>Exactly once:<ul><li>Can be archieved for kafka</li><li>For kafka, External System workflows, use an idempotent consumer.</li></ul></li></ul></li></ul><h3 id=zookeeper>Zookeeper</h3><ul><li>zookeeper는 분산 코디네이션 시스템이다.</li><li>카프카 브로커는 하나의 클러스터로 코디네이팅하는 역할을 하며, 카프카 클러스터의 리더(Leader)fㅡㄹ 발탁하는 방식을 제공한다.</li><li>새로운 토픽 생성, 브로커 서버 다운 등 모든 카프카 클러스터 내 변화들에 대하여 알림을 준다.</li><li>카프카는 언제나 주키퍼가 존재해야한다.</li><li>일반적으로 주키퍼는 홀수개로 운영된다.</li><li>consumer offset은 zookeeper가 아닌 kafka topic에 저장되도록 되어 있다.</li></ul></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>