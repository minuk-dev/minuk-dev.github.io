<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>디버깅을 통해 배우는 리눅스 커널의 구조와 원리</title><link rel=icon href=https://makerdark98.dev/images/Rb.png><meta property="og:title" content="디버깅을 통해 배우는 리눅스 커널의 구조와 원리"><meta property="og:description" content="MD98 블로그 : 디버깅을 통해 배우는 리눅스 커널의 구조와 원리"><meta property="og:image" content="https://makerdark98.dev/images/Rb.png"><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent: #00a3d2;--border-width:  5px }</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-98056974-1');</script><script>window.MathJax={jax:["input/TeX","output/CommonHTML"],extensions:["tex2jax.js","asciimath2jax.js","mml2jax.js","MathMenu.js","MathZoom.js"],TeX:{extensions:["AMSmath.js","AMSsymbols.js","autoload-all.js"]},tex2jax:{inlineMath:[['$','$'],["\\(","\\)"]],processEscapes:true},showProcessingMessages:false,messageStyle:"none",menuSettings:{zoom:"Click"},AuthorInit:function(){MathJax.Hub.Register.StartupHook("End",function(){var timeout=false,delay=250;var shrinkMath=function(){var dispFormulas=document.getElementsByClassName("formula");if(dispFormulas){var contentTest=document.getElementsByTagName("body")[0];var nodesWidth=contentTest.offsetWidth;var mathIndent=MathJax.Hub.config.displayIndent;var mathIndentValue=mathIndent.substring(0,mathIndent.length-2);for(var i=0;i<dispFormulas.length;i++){var dispFormula=dispFormulas[i];var wrapper=dispFormula.getElementsByClassName("MathJax_Preview")[0].nextSibling;var child=wrapper.firstChild;wrapper.style.transformOrigin="center";var oldScale=child.style.transform;var newValue=Math.min(0.80*dispFormula.offsetWidth/child.offsetWidth,1.0).toFixed(2);var newScale="scale("+newValue+")";if(!(newScale===oldScale)){wrapper.style.transform=newScale;wrapper.style["margin-left"]=Math.pow(newValue,4)*mathIndentValue+"px";var wrapperStyle=window.getComputedStyle(wrapper);var wrapperHeight=parseFloat(wrapperStyle.height);wrapper.style.height=""+(wrapperHeight*newValue)+"px";if(newValue==="1.00"){wrapper.style.cursor="";wrapper.style.height="";}
else{wrapper.style.cursor="zoom-in";}}}}};shrinkMath();window.addEventListener('resize',function(){clearTimeout(timeout);timeout=setTimeout(shrinkMath,delay);});});}};(function(d,script){script=d.createElement('script');script.type='text/javascript';script.async=true;script.onload=function(){};script.src='https://cdn.mathjax.org/mathjax/latest/MathJax.js';d.getElementsByTagName('head')[0].appendChild(script);}(document));</script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>디버깅을 통해 배우는 리눅스 커널의 구조와 원리</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:makerdark98@gmail.com><i class="fa fa-envelope-o"></i></a></li><li class=navbar-icon><a href=https://github.com/makerdark98/><i class="fa fa-github"></i></a></li><li><div style=max-width:250px;display:inline-block;max-height:40px><script async src="https://cse.google.com/cse.js?cx=003491619885022567520:wnnypdnx4aj"></script><div class=gcse-search></div></div></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick="(function(elem){elem.querySelector('a').click();})(this);">
<i class="fa fa-arrow-left"></i>[[Book reviews]]</button></div></div><div style=margin-left:auto><div style=display:flex><div style=margin-left:auto><div class=wiki-history></div></div></div><script src=/js/localhistory.js></script><script>var now="debug-linux"
pushHistory(now);</script></div></div><div><h2>디버깅을 통해 배우는 리눅스 커널의 구조와 원리</h2><a href=https://github.com/makerdark98/makerdark98.github.io/blame/master/src/content/wiki/debug-linux.md><h5>created : Tue, 08 Sep 2020 22:14:21 +0900</h5><h5>modified : Mon, 05 Oct 2020 20:43:26 +0900</h5></a><a href=https://makerdark98.dev/tags/linux><kbd class=item-tag>linux</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#간략-소개>간략 소개</a></li><li><a href=#설치>설치</a><ul><li><a href=#참고한-곳>참고한 곳</a></li><li><a href=#이미지-다운로드-및-소스코드-다운로드>이미지 다운로드 및 소스코드 다운로드</a></li><li><a href=#vim-설정>vim 설정</a></li></ul></li><li><a href=#책-따라하기>책 따라하기</a><ul><li><a href=#커널-디버깅과-코드-학습>커널 디버깅과 코드 학습</a></li><li><a href=#프로세스>프로세스</a></li><li><a href=#워크큐>워크큐</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=간략-소개>간략 소개</h2><ul><li>디버깅을 통해 배우는 리눅스 커널의 구조와 원리를 읽으면서 공부하는 내용 정리</li></ul><h2 id=설치>설치</h2><ul><li>작업하고 있는 곳의 환경상, 라즈베리파이를 직접적으로 사용하기 어려워 qemu로 가상화하기로 했다.</li><li>오로지 ssh로 붙어서 서버에서만 작업가능해야 한다.</li></ul><h3 id=참고한-곳>참고한 곳</h3><ul><li><a href=https://woodz.tistory.com/72>https://woodz.tistory.com/72</a></li><li><a href=https://mystrlight.tistory.com/90>https://mystrlight.tistory.com/90</a></li><li><a href=https://procdiaru.tistory.com/78>https://procdiaru.tistory.com/78</a></li><li><a href=https://nautiluslee.blogspot.com/2019/01/debootstrap.html>https://nautiluslee.blogspot.com/2019/01/debootstrap.html</a></li><li><a href=https://tistory.0wn.kr/368>https://tistory.0wn.kr/368</a></li></ul><h3 id=이미지-다운로드-및-소스코드-다운로드>이미지 다운로드 및 소스코드 다운로드</h3><h4 id=qemu-설치뇌피셜>qemu 설치(뇌피셜)</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt install qemu qemu-system-x86
</code></pre></div><ul><li>아마도 이렇게 하면 될것이다, 사실 qemu는 pintos 공부하면서 이미 설치를 다 해놔서&mldr;</li></ul><h4 id=리눅스-커널-소스코드-다운로드>리눅스 커널 소스코드 다운로드</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.143.tar.xz
</code></pre></div><h4 id=kernel-build>kernel build</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make defconfig
make menuconfig
</code></pre></div><ul><li>맨 마지막에 menuconfig 할때는 최하단 kernel hacking 에서 KGDB 체크한다. 나머진 참고한곳에 있는 3번째 칭크를 보고 했는데 정확히는 모르겠다.</li><li>이렇게 하고 나서, deboostrap 을 설치해야한다는데, 4번을 참고했다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt install debootstrap
</code></pre></div><hr><h4 id=이미지-굽기>이미지 굽기</h4><ul><li>5번 참고해서 create image 실행해주자.
해서 create-image.sh 실행해주자</li></ul><h4 id=고생한-부분>고생한 부분</h4><ul><li>KASLR 을 해제했다고 생각해서 한참동안을 왜 에러가 나오지? 하고 있었다. 주의하자 무조건 해제해줘야한다. 안그러면 디버그 포인트를 지나간다.</li><li>아 근데 왜 안되냐 ㅠ 안되서 다시 처음부터 해보고 있다.</li><li>아 드디어 찾았다. kvm 옵션 끄니까 되네</li><li>감격스러워서 스크린샷도 찍었다.</li><li><img src=/wiki/images/debug_kernel-1.png alt=debug-linux></li></ul><h4 id=qemu-실행-스크립트>qemu 실행 스크립트</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>qemu-system-x86_64 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -kernel ./linux-4.19.143/arch/x86_64/boot/bzImage <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -append <span style=color:#e6db74>&#34;console=ttyS0 root=/dev/sda rw debug nokaslr&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -hda buster.img <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -net user,hostfwd<span style=color:#f92672>=</span>tcp::10021-:22 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -net nic <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -nographic <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -m 2G <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -smp <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -s
</code></pre></div><ul><li>rw 옵션을 줘야지 안에서 실행 가능하다.</li></ul><h3 id=vim-설정>vim 설정</h3><ul><li></li></ul><h2 id=책-따라하기>책 따라하기</h2><h3 id=커널-디버깅과-코드-학습>커널 디버깅과 코드 학습</h3><ul><li>처음에 ftrace를 소개하는데, 잘 작동이 안된다. 이것도 config를 잘못한거였다. menuconfig -> kernel hacking -> tracer 에서 설정해주고 다시 빌드하자.</li></ul><h3 id=프로세스>프로세스</h3><ul><li>x64 용으로 컴파일 해서 작업하고 있어서, 다른부분이 있다.</li><li>책 151쪽에서 여러 함수들에 filter를 거는데, 당연히도 안걸린다. 그런데 function 을 걸면 당연히 문제가 된다. 스크립트채로 따라쳐서 실행하지 말고, 한줄한줄 실행하고 동작하는지 확인하면서 작업했다.</li></ul><h4 id=유저-레벨-프로세스-실행-실습>유저 레벨 프로세스 실행 실습</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat /sys/kernel/debug/tracing/available_filter_functions | grep sys_clone
</code></pre></div><ul><li>이렇게 하면 <code>__x64_sys_clone</code> 이 나오는데 이걸 <code>sys_clone</code> 대신 넣어주자.</li><li>그렇게 해서 나온 스크립트는 아래와 같다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>
echo <span style=color:#ae81ff>0</span> &gt; /sys/kernel/debug/tracing/tracing_on
sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;tracing_off&#34;</span>

echo <span style=color:#ae81ff>0</span> &gt; /sys/kernel/debug/tracing/events/enable
sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;events disabled&#34;</span>

echo __x64_sys_clone do_exit &gt; /sys/kernel/debug/tracing/set_ftrace_filter
sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;set_ftrace_filter init&#34;</span>

echo <span style=color:#66d9ef>function</span> &gt; /sys/kernel/debug/tracing/current_tracer
sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;function tracer enabled&#34;</span>

echo __x64_sys_clone do_exit &gt; /sys/kernel/debug/tracing/set_ftrace_filter
echo _do_fork copy_process* &gt;&gt; /sys/kernel/debug/tracing/set_ftrace_filter
sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;set_ftrace_filter enabled&#34;</span>

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/sched/sched_switch/enable
echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable
echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/sched/sched_process_fork/enable
echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/sched/sched_process_exit/enable

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/signal/enable

sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;event enabled&#34;</span>

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/options/func_stack_trace
echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/options/sym-offset
echo <span style=color:#e6db74>&#34;function stack trace enabled&#34;</span>

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/tracing_on
echo <span style=color:#e6db74>&#34;tracing_on&#34;</span>
</code></pre></div><ul><li>프로세스 생성 단계의 함수 흐름 : 책이랑 살짝 다른데 이건 cpu마다 다를듯?</li></ul><pre><code>copy_process.part.53+0x5/0x1d40
_do_fork+0xcf/0x3a0
__x64_sys_clone+0x27/0x30
do_syscall_64+0x55/0x110
</code></pre><ul><li>프로세스 종료 단계의 함수 흐름</li></ul><pre><code>do_exit+0x5/0xbd0
do_group_exit+0x47/0xb0
get_signal+0xfe/0x7e0
do_signal+0x37/0x650
exit_to_usermode_loop+0x9b/0xb0
do_syscall_64+0x101/0x110
</code></pre><h5 id=프로세스-실행-흐름>프로세스 실행 흐름</h5><ol><li>프로세스 생성</li><li>raspbian_proc 프로세스 실행</li><li>프로세스 종료</li><li>부모 프로세스에게 시그널 전달</li></ol><h5 id=배운-내용>배운 내용</h5><ul><li>프로세스가 스스로 exit POSIX 시스템 콜을 호출하면 스스로 소멸할 수 있다.</li><li>exit POSIX 시스템 콜에 대한 시스템 콜 핸들러는 sys_exit_group() 함수이다.</li><li>프로세스는 소멸되는 과정에서 부모 프로세스에게 SIGCHLD 시그널을 전달해 자신이 종료될 것이라고 통지한다.</li></ul><h4 id=커널-스레드>커널 스레드</h4><ul><li>커널 스레드는 커널 공간에서만 실행되며, 유저 공간과 상호작용하지 않습니다.</li><li>커널 스레드는 실행, 휴면 등 모든 동작을 커널에서 직접 제어 관리합니다.</li><li>대부분의 커널 스레드는 시스템이 부팅할 때 생성되고 시스템이 종료할 때까지 백그라운드로 실행됩니다.</li></ul><h5 id=커널-스레드-생성-과정>커널 스레드 생성 과정</h5><ol><li>kthreadd 프로세스에서 커널 스레드 생성을 요청</li></ol><ul><li>kthread_create()</li><li>kthread_create_on_node()</li></ul><ol><li>kthreadd 프로세스가 커널 스레드를 생성</li></ol><ul><li>kthreadd()</li><li>create_kthread()</li></ul><h5 id=커널-내부-프로세스의-생성-과정-_do_fork-함수>커널 내부 프로세스의 생성 과정 (_do_fork() 함수)</h5><ul><li><p>위에서 말한 대로 실제로 생성하는 곳은 kthreadd가 호출하는 create_kthread 인데, 이건 결국 _do_fork 를 호출한다.</p></li><li><p>_do_fork 의 호출 과정</p><ol><li>프로세스 생성 : copy_process() 함수를 호출해서 프로세스를 생성</li><li>생성한 프로세스의 실행 요청 : copy_process 함수를 호출해 프로세스를 만든 후, wake_up_new_task 함수를 호출</li></ol></li><li><p>copy_process() 함수를 호출해 프로세스를 생성</p></li><li><p>wake_up_new_task() 함수를 호출해 생성한 프로세스를 깨움</p></li><li><p>생성한 프로세스 PID를 반환</p></li></ul><h5 id=copy_process-함수-분석>copy_process 함수 분석</h5><ul><li>dup_task_struct : task_struct 구조체와 프로세스가 실행될 스택 공간을 할당, 이후 새로운 구조체 주소를 반환<ul><li>책에서는 여기만 나와 있는데, memory 동적할당이 어떻게 되는지 궁금해서 확인해봤다.</li><li>쭉쭉 따라가보면, alloc_task_struct_node -> kmem_cache_alloc_node -> kmem_cache_alloc ->slab_alloc 가 호출되는데, slab이 뭔지 몰라서 찾아봤다.<ul><li>참고 : <a href=https://lascrea.tistory.com/66>https://lascrea.tistory.com/66</a></li><li>slab allocator라고 하며, 일종의 자원 할당자 중 하나로 4KB의 크기를 가진 Page로 데이터를 저장하고 관리할 경우 발생하는 단편화를 최소화 하기 위해 만들어졌다.</li><li>리눅스 커널은 slab을 사용하고 있으며 /proc/meminfo에서 리눅스 커널이 사용하는 cache 크기를 의미한다.</li><li>리눅스 커널에서 커널과 디바이스 드라이버, 파일시스템 등은 영구적이지 않은 데이터(inode, task 구조체, 장치 구조체 등)들을 저장하기 위한 공간이 필요한데 이것이 slab에 관리된다.</li></ul></li></ul></li><li>그리고 기본적인 자원들(메모리, 파일 등)을 복사한다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> <span style=color:#75715e>/* copy all the process information */</span>
 shm_init_task(p);
 retval <span style=color:#f92672>=</span> security_task_alloc(p, clone_flags);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_audit;
 retval <span style=color:#f92672>=</span> copy_semundo(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_security;
 retval <span style=color:#f92672>=</span> copy_files(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_semundo;
 retval <span style=color:#f92672>=</span> copy_fs(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_files;
 retval <span style=color:#f92672>=</span> copy_sighand(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_fs;
 retval <span style=color:#f92672>=</span> copy_signal(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_sighand;
 retval <span style=color:#f92672>=</span> copy_mm(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_signal;
 retval <span style=color:#f92672>=</span> copy_namespaces(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_mm;
 retval <span style=color:#f92672>=</span> copy_io(clone_flags, p);
 <span style=color:#66d9ef>if</span> (retval)
   <span style=color:#66d9ef>goto</span> bad_fork_cleanup_namespaces;
 retval <span style=color:#f92672>=</span> copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);
</code></pre></div><h5 id=wake_up_new_task>wake_up_new_task()</h5><ul><li>프로세스 상태를 TASK_RUNNING으로 변경</li><li>현재 실행 중인 CPU 번호를 thread_info 구조체의 cpu 필드에 저장 (CONFIG_SMP 값이 켜져 있을때)</li><li>런큐에 프로세스를 큐잉</li></ul><h4 id=프로세스의-종료-과정-분석>프로세스의 종료 과정 분석</h4><ul><li><p>프로세스가 죽는 두가지 흐름</p><ul><li>유저 애플리케이션에서 exit() 함수를 호출할 때</li><li>종료 시그널을 전달받을 때</li></ul></li><li><p>이번에는 책 보기 전에 ftrace 결과에 나오는 함수들 다 찾아보자.</p><ul><li><code>kernel/exit.c</code><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>SYSCALL_DEFINE1(exit_group, <span style=color:#66d9ef>int</span>, error_code)
{
  do_group_exit((error_code <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>);
  <span style=color:#75715e>/* NOTREACHED */</span>
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div></li><li><code>kernel/signal.c</code><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>get_signal</span>(<span style=color:#66d9ef>struct</span> ksignal <span style=color:#f92672>*</span>ksig)
{
<span style=color:#75715e>/* skip */</span>
    <span style=color:#75715e>/*
</span><span style=color:#75715e>     * Death signals, no core dump.
</span><span style=color:#75715e>     */</span>
    do_group_exit(ksig<span style=color:#f92672>-&gt;</span>info.si_signo);
    <span style=color:#75715e>/* NOTREACHED */</span>
  }
  spin_unlock_irq(<span style=color:#f92672>&amp;</span>sighand<span style=color:#f92672>-&gt;</span>siglock);

  ksig<span style=color:#f92672>-&gt;</span>sig <span style=color:#f92672>=</span> signr;
  <span style=color:#66d9ef>return</span> ksig<span style=color:#f92672>-&gt;</span>sig <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div></li></ul><pre><code>* 이거 이외에도 `fpu.c`, `seccomp.c` 에 있는데, 이건 찾아보니까 fpu 에서 에러가 나서 죽일때랑, [[seccomp]]에서 강제로 죽일때 호출. 일반적으로 죽는 경우는 아니니, 위에 2가지만이 do_group_exit를 호출한다라고 알수 있다.

</code></pre></li><li><p>do_exit() 함수의 동작 방식 확인</p><ol><li>init 프로세스가 종료하면 강제 커널 패닉 유발 : 보통 부팅 과정에서 발생함</li><li>이미 프로세스가 do_exit() 함수의 실행으로 프로세스가 종료되는 도중 다시 do_exit() 함수가 호출됐는지 점검</li><li>프로세스 리소스(파일 디스크립터, 가상 메모리, 시그널) 등을 해제</li><li>부모 프로세스에게 자신이 종료되고 있다고 알림</li><li>프로세스의 실행 상태를 task_struct 구조체의 state 필드에 TASK_DEAD로 설정</li><li>do_task_dead() 함수에 호출해 스케줄링을 실행, do_task_dead() 함수에서 __schedule() 함수가 호출되어 프로세스 자료구조인 태스크 디스크립터와 스택 메모리를 해제</li></ol></li><li><p>do_task_daed() 함수를 호출하고 난 후의 동작</p><ul><li>__schedule() 함수</li><li>context_switch() 함수</li><li>finish_task_switch() 함수</li></ul></li></ul><h5 id=태스크-디스크립터task_struct-구조체>태스크 디스크립터(task_struct 구조체)</h5><ul><li>프로세스를 식별하는 필드<ul><li>comm : 프로세스 이름</li><li>pid : 프로세스 id</li><li>tgid : task_group id, 만약 thread가 leader 인 경우, tgid == pid</li></ul></li><li>프로세스 상태 저장<ul><li>state: 프로세스 실행 상태<ul><li>TASK_RUNNING : CPU에서 실행 중이거나 런큐에서 대기 상태에 있음</li><li>TASK_INTERRUPTIBLE : 휴면 상태</li><li>TASK_UNINTERRUPTIBLE : 특정 조건에서 깨어나기 위해 휴면 상태로 진입한 상태</li></ul></li><li>flags: 프로세스 세부 동작 상태와 속성 정보<ul><li>PF_IDLE : 자신이 IDLE thread 임을 나타내는 flag</li><li>PF_EXITING : 종료되는 중</li><li>PF_EXITPIDONE : 종료 됨</li><li>PF_WQ_WORKER : 워커 쓰레드</li><li>PF_KTHREAD : 커널 스레드</li></ul></li></ul></li><li>프로세스 간의 관계</li><li>real_parent : 자신을 생성한 부모 프로세스의 태스크 디스크립터 주소를 저장</li><li>parent : 부모 프로세스의 태스크 디스크립터 주소를 담고 있음.</li><li>children : 자식 프로세스 리스트</li><li>sibiling : 형제 프로세스 리스트</li><li>프로세스 실행 시각 정보</li><li>utime : 유저 모드에서 프로세스가 실행한 시각 (account_user_time)</li><li>stime : 커널 모드에서 프로세스가 실행한 시각 (account_system_index_time)</li><li>sched_info.last_arrival : 프로세스가 CPU에서 실행된 시각 (context_switch -> prepare_task_switch -> sched_info_switch -> __sched_info_switch -> sched_info_arrive)</li></ul><h5 id=스레드-정보--thread_info-구조체>스레드 정보 : thread_info 구조체</h5><ul><li>선점 스케줄링 실행 여부</li><li>시그널 전달 여부</li><li>인터럽트 컨텍스트와 Soft IRQ 컨텍스트 상태</li><li>휴면 상태로 진입하기 직전 레지스터 세트를 로딩 및 백업</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> thread_info {
  <span style=color:#66d9ef>struct</span> task_struct	<span style=color:#f92672>*</span>task;		<span style=color:#75715e>/* main task structure */</span>
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>		flags;		<span style=color:#75715e>/* low level flags */</span>
  __u32			cpu;		<span style=color:#75715e>/* current CPU */</span>
  __s32			preempt_count; <span style=color:#75715e>/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span>

  mm_segment_t		addr_limit; <span style=color:#75715e>/* thread address space:
</span><span style=color:#75715e>                                 0-0x7FFFFFFF for user-thead
</span><span style=color:#75715e>                                 0-0xFFFFFFFF for kernel-thread
</span><span style=color:#75715e>                               */</span>
  __u8			supervisor_stack[<span style=color:#ae81ff>0</span>];

<span style=color:#75715e>/* saved context data */</span>
<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           ksp;
};
<span style=color:#75715e>#endif
</span></code></pre></div><ul><li>preempt_count 가 바뀌는 조건<ul><li>인터럽트 컨텍스트 실행 시작 및 종료 설정</li><li>Soft IRQ 컨텍스트 실행 시작 및 종료 설정</li><li>프로세스 선점 스케줄링 가능 여부</li></ul></li></ul><h5 id=cpu-필드에-대한-상세-분석>cpu 필드에 대한 상세 분석</h5><ul><li>sm_processor_id()</li><li>set_task_cpu()</li></ul><h5 id=thread_info-구조체-초기화-코드-분석>thread_info 구조체 초기화 코드 분석</h5><ul><li>dup_task_struct()</li><li>setup_thread_stack(tsk, orig);</li><li>alloc_task_struct_node()</li><li>alloc_thread_stack_node()</li></ul><h5 id=프로세스의-태스크-디스크립터에-접근하는-매크로-함수>프로세스의 태스크 디스크립터에 접근하는 매크로 함수</h5><ul><li>current : 현재 구동 중인 프로세스의 태스크 디스크립터 주소</li><li>arch/x86/include/asm/current.h</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> DECLARE_PER_CPU(<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>, current_task);
 <span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span><span style=color:#a6e22e>get_current</span>(<span style=color:#66d9ef>void</span>)
 {
   <span style=color:#66d9ef>return</span> this_cpu_read_stable(current_task);
 }

 <span style=color:#75715e>#define current get_current()
</span></code></pre></div><ul><li>보면은, cpu 마다 task_struct를 선언하는데, 이 변수 명은 current_task 인데, arch/x86/kernel/process_64.c 에 있는 <code>__switch_to()</code>에서</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> this_cpu_write(current_task, next_p);
 this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p));

 <span style=color:#75715e>/* Reload sp0. */</span>
 update_task_stack(next_p);

 switch_to_extra(prev_p, next_p);
</code></pre></div><ul><li>이렇게 매번 task가 전환 될때 cpu 별로 따로 넣어준다. 이때마다, update_task_stack를 호출해주면서 stack을 설정한다.</li></ul><h5 id=프로세스-디버깅>프로세스 디버깅</h5><ul><li>사용하는 명령어 : layout asm</li><li>내용 정리<ul><li>리눅스 유틸리티 프로그램을 실행할 때 프로세스는 fork()와 execve() 시스템 콜 함수를 호출한다.</li><li>ftrce의 sched_process_exec 이벤트로 리눅스 유틸리티 프로그램의 파일 위치를 알 수 있다.</li><li>리눅스 유틸리티 프로그램을 종료할 때의 프로세스는 exit() 시스템 콜 함수를 호출한다.</li></ul></li></ul><h4 id=인터럽트>인터럽트</h4><ul><li>인터럽트 벡터와 인터럽트 핸들러</li><li>IRQ(Interrupt ReQuest)</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>request_irq)(<span style=color:#66d9ef>struct</span> dispc_device <span style=color:#f92672>*</span>dispc, irq_handler_t handler, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id);
</code></pre></div><h5 id=인터럽트-컨텍스트-활성화-시기>인터럽트 컨텍스트 활성화 시기</h5><ul><li>프로세스 실행 중</li><li>인터럽트 벡터 실행</li><li>커널 인터럽트 내부 함수 호출</li><li>인터럽트 종류별로 인터럽트 핸들러 호출<ul><li>인터럽트 컨텍스트 시작</li></ul></li><li>인터럽트 핸들러의 서브루틴 실행 시작</li><li>인터럽트 핸들러의 서브루틴 실행 마무리<ul><li>인터럽트 컨텍스트 마무리</li></ul></li></ul><h5 id=인터럽트-디스크립터>인터럽트 디스크립터</h5><ul><li>인터럽트 핸들러</li><li>인터럽트 핸들러 매개변수</li><li>논리적인 인터럽트 번호</li><li>인터럽트 실행 횟수</li></ul><h5 id=인터럽트-처리-흐름>인터럽트 처리 흐름</h5><ol><li>인터럽트 발생 : 인터럽트가 발생하면 프로세스는 실행 도중 인터럽트 벡터로 이동, 인터럽트 벡터에서 인터럽트 처리를 마리한 후 다시 프로세스를 실행하기 위해 실행 중인 프로세스의 레지스터 세트를 스택에 저장, IRQ 서 브시스템을 구성하는 함수들이 호출</li><li>인터럽트 핸들러 호출 : 발생한 인터럽트에 대앙하는 인터럽트 디스크립터를 읽어서 인터럽트 핸들러를 호출</li><li>인터럽트 핸들러 실행 : 인터럽트 핸들러에서 하드웨어를 직접 제어하고 유저 공간에 전달</li></ol><h5 id=인터럽트-서술자-테이블-interrupt-descriptor-table---idt>인터럽트 서술자 테이블 (Interrupt Descriptor Table - IDT)</h5><ul><li>인터럽트 벡터 테이블을 구현하기 위해 x86 아키텍처에서 사용되는 데이터 구조체이다.</li><li>IDT의 사용은 다음 3 종류의 이벹느들에 의해 발생된다.<ul><li>하드웨어 인터럽트</li><li>소프트웨어 인터럽트</li><li>프로세서 예외</li></ul></li></ul><h5 id=irq-chip>IRQ Chip</h5><ul><li>참고 : <a href=http://jake.dothome.co.kr/interrupts-2/>http://jake.dothome.co.kr/interrupts-2/</a></li><li>인터럽트 컨트롤러 드라이버를 위해 hw 제어를 담당하는 구현 부분을 가짐.</li></ul><h5 id=리눅스-커널>리눅스 커널</h5><ul><li><code>arch/x86/entry/entry_64.S</code> line number 655 common_interrupt: -> call <code>do_IRQ</code></li><li><code>arch/x86/kernel/irq.c</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * do_IRQ handles all normal device IRQ&#39;s (the special
</span><span style=color:#75715e> * SMP cross-CPU interrupts have their own specific
</span><span style=color:#75715e> * handlers).
</span><span style=color:#75715e> */</span>
__visible <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> __irq_entry <span style=color:#a6e22e>do_IRQ</span>(<span style=color:#66d9ef>struct</span> pt_regs <span style=color:#f92672>*</span>regs)
{
  <span style=color:#66d9ef>struct</span> pt_regs <span style=color:#f92672>*</span>old_regs <span style=color:#f92672>=</span> set_irq_regs(regs);
  <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span> desc;
  <span style=color:#75715e>/* high bit used in ret_from_ code  */</span>
  <span style=color:#66d9ef>unsigned</span> vector <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>regs<span style=color:#f92672>-&gt;</span>orig_ax;

  entering_irq();

  <span style=color:#75715e>/* entering_irq() tells RCU that we&#39;re not quiescent.  Check it. */</span>
  RCU_LOCKDEP_WARN(<span style=color:#f92672>!</span>rcu_is_watching(), <span style=color:#e6db74>&#34;IRQ failed to wake up RCU&#34;</span>);

  desc <span style=color:#f92672>=</span> __this_cpu_read(vector_irq[vector]);

  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>handle_irq(desc, regs)) {
    ack_APIC_irq();

    <span style=color:#66d9ef>if</span> (desc <span style=color:#f92672>!=</span> VECTOR_RETRIGGERED <span style=color:#f92672>&amp;&amp;</span> desc <span style=color:#f92672>!=</span> VECTOR_SHUTDOWN) {
      pr_emerg_ratelimited(<span style=color:#e6db74>&#34;%s: %d.%d No irq handler for vector</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
               __func__, smp_processor_id(),
               vector);
    } <span style=color:#66d9ef>else</span> {
      __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
    }
  }

  exiting_irq();

  set_irq_regs(old_regs);
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></div><ul><li>check handler at <code>if (!handle_irq(desc, regs))</code>. handler_irq is defined by an irq chip driver.</li><li>gic_handle_irq -> __handler_domain_irq -> generic_handle_irq -> handle_fasteoi_irq -> handle_irq_event -> handle_irq_event_percpu</li></ul><h5 id=interrupt-context>Interrupt Context</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>common_interrupt:
 <span style=color:#a6e22e>addq</span>	<span style=color:#66d9ef>$-0x80</span>, (%rsp)			<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>Adjust</span> <span style=color:#66d9ef>vector</span> <span style=color:#66d9ef>to</span> [-<span style=color:#ae81ff>256</span>, -<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>range</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>call</span>	<span style=color:#66d9ef>interrupt_entry</span>
 <span style=color:#a6e22e>UNWIND_HINT_REGS</span> <span style=color:#66d9ef>indirect</span><span style=color:#960050;background-color:#1e0010>=</span><span style=color:#ae81ff>1</span>
 <span style=color:#a6e22e>call</span>	<span style=color:#66d9ef>do_IRQ</span>	<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>rdi</span> <span style=color:#66d9ef>points</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>pt_regs</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#960050;background-color:#1e0010>/*</span> <span style=color:#960050;background-color:#1e0010>0(%</span><span style=color:#a6e22e>rsp</span>): <span style=color:#66d9ef>old</span> <span style=color:#66d9ef>RSP</span> *<span style=color:#960050;background-color:#1e0010>/</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=color:#a6e22e>ENTRY</span>(<span style=color:#66d9ef>interrupt_entry</span>)
 <span style=color:#a6e22e>UNWIND_HINT_IRET_REGS</span> <span style=color:#66d9ef>offset</span><span style=color:#960050;background-color:#1e0010>=</span><span style=color:#ae81ff>16</span>
 <span style=color:#a6e22e>ASM_CLAC</span>
 <span style=color:#a6e22e>cld</span>

 <span style=color:#a6e22e>testb</span>	<span style=color:#66d9ef>$3</span>, <span style=color:#66d9ef>CS-ORIG_RAX</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>8</span>(%rsp)
 <span style=color:#a6e22e>jz</span>	<span style=color:#ae81ff>1</span><span style=color:#66d9ef>f</span>
 <span style=color:#a6e22e>SWAPGS</span>
 <span style=color:#a6e22e>FENCE_SWAPGS_USER_ENTRY</span>
 <span style=color:#960050;background-color:#1e0010>/*</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>Switch</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>thread</span> <span style=color:#66d9ef>stack.</span> <span style=color:#66d9ef>The</span> <span style=color:#66d9ef>IRET</span> <span style=color:#66d9ef>frame</span> <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>orig_ax</span> <span style=color:#66d9ef>are</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>on</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span>, <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>well</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>address.</span> <span style=color:#66d9ef>RDI..R12</span> <span style=color:#66d9ef>are</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>not</span> (<span style=color:#66d9ef>yet</span>) <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span> <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>space</span> <span style=color:#66d9ef>has</span> <span style=color:#66d9ef>not</span> (<span style=color:#66d9ef>yet</span>) <span style=color:#66d9ef>been</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>allocated</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>them.</span>
  <span style=color:#960050;background-color:#1e0010>*/</span>
 <span style=color:#a6e22e>pushq</span>	%rdi

 <span style=color:#960050;background-color:#1e0010>/*</span> <span style=color:#a6e22e>Need</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>switch</span> <span style=color:#66d9ef>before</span> <span style=color:#66d9ef>accessing</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>thread</span> <span style=color:#66d9ef>stack.</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>SWITCH_TO_KERNEL_CR3</span> <span style=color:#66d9ef>scratch_reg</span><span style=color:#960050;background-color:#1e0010>=</span>%rdi
 <span style=color:#a6e22e>movq</span>	%rsp, %rdi
 <span style=color:#a6e22e>movq</span>	<span style=color:#66d9ef>PER_CPU_VAR</span>(<span style=color:#66d9ef>cpu_current_top_of_stack</span>), %rsp

  <span style=color:#960050;background-color:#1e0010>/*</span>
   <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>We</span> <span style=color:#66d9ef>have</span> <span style=color:#66d9ef>RDI</span>, <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>address</span>, <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>orig_ax</span> <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span> <span style=color:#66d9ef>on</span>
   <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>top</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>IRET</span> <span style=color:#66d9ef>frame.</span> <span style=color:#66d9ef>That</span> <span style=color:#66d9ef>means</span> <span style=color:#66d9ef>offset</span><span style=color:#960050;background-color:#1e0010>=</span><span style=color:#ae81ff>24</span>
   <span style=color:#960050;background-color:#1e0010>*/</span>
 <span style=color:#a6e22e>UNWIND_HINT_IRET_REGS</span> <span style=color:#66d9ef>base</span><span style=color:#960050;background-color:#1e0010>=</span>%rdi <span style=color:#66d9ef>offset</span><span style=color:#960050;background-color:#1e0010>=</span><span style=color:#ae81ff>24</span>

 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>7</span>*<span style=color:#ae81ff>8</span>(%rdi)		<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>regs-</span><span style=color:#960050;background-color:#1e0010>&gt;</span><span style=color:#66d9ef>ss</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>6</span>*<span style=color:#ae81ff>8</span>(%rdi)		<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>regs-</span><span style=color:#960050;background-color:#1e0010>&gt;</span><span style=color:#66d9ef>rsp</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>5</span>*<span style=color:#ae81ff>8</span>(%rdi)		<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>regs-</span><span style=color:#960050;background-color:#1e0010>&gt;</span><span style=color:#66d9ef>eflags</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>4</span>*<span style=color:#ae81ff>8</span>(%rdi)		<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>regs-</span><span style=color:#960050;background-color:#1e0010>&gt;</span><span style=color:#66d9ef>cs</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>3</span>*<span style=color:#ae81ff>8</span>(%rdi)		<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>regs-</span><span style=color:#960050;background-color:#1e0010>&gt;</span><span style=color:#66d9ef>ip</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>UNWIND_HINT_IRET_REGS</span>
 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>2</span>*<span style=color:#ae81ff>8</span>(%rdi)		<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>regs-</span><span style=color:#960050;background-color:#1e0010>&gt;</span><span style=color:#66d9ef>orig_ax</span> *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>pushq</span>	<span style=color:#ae81ff>8</span>(%rdi)			<span style=color:#960050;background-color:#1e0010>/</span>* <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>address</span> *<span style=color:#960050;background-color:#1e0010>/</span>

 <span style=color:#a6e22e>movq</span>	(%rdi), %rdi
 <span style=color:#a6e22e>jmp</span>	<span style=color:#ae81ff>2</span><span style=color:#66d9ef>f</span>
<span style=color:#960050;background-color:#1e0010>1:</span>
 <span style=color:#a6e22e>FENCE_SWAPGS_KERNEL_ENTRY</span>
<span style=color:#960050;background-color:#1e0010>2:</span>
 <span style=color:#a6e22e>PUSH_AND_CLEAR_REGS</span> <span style=color:#66d9ef>save_ret</span><span style=color:#960050;background-color:#1e0010>=</span><span style=color:#ae81ff>1</span>
 <span style=color:#a6e22e>ENCODE_FRAME_POINTER</span> <span style=color:#ae81ff>8</span>

 <span style=color:#a6e22e>testb</span>	<span style=color:#66d9ef>$3</span>, <span style=color:#66d9ef>CS</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>8</span>(%rsp)
 <span style=color:#a6e22e>jz</span>	<span style=color:#ae81ff>1</span><span style=color:#66d9ef>f</span>

 <span style=color:#960050;background-color:#1e0010>/*</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>IRQ</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>user</span> <span style=color:#66d9ef>mode.</span>
  <span style=color:#960050;background-color:#1e0010>*</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>We</span> <span style=color:#66d9ef>need</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>tell</span> <span style=color:#66d9ef>lockdep</span> <span style=color:#66d9ef>that</span> <span style=color:#66d9ef>IRQs</span> <span style=color:#66d9ef>are</span> <span style=color:#66d9ef>off.</span>  <span style=color:#66d9ef>We</span> <span style=color:#66d9ef>can</span><span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#66d9ef>t</span> <span style=color:#66d9ef>do</span> <span style=color:#66d9ef>this</span> <span style=color:#66d9ef>until</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>we</span> <span style=color:#66d9ef>fix</span> <span style=color:#66d9ef>gsbase</span>, <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>we</span> <span style=color:#66d9ef>should</span> <span style=color:#66d9ef>do</span> <span style=color:#66d9ef>it</span> <span style=color:#66d9ef>before</span> <span style=color:#66d9ef>enter_from_user_mode</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#960050;background-color:#1e0010>(</span><span style=color:#a6e22e>which</span> <span style=color:#66d9ef>can</span> <span style=color:#66d9ef>take</span> <span style=color:#66d9ef>locks</span>).  <span style=color:#66d9ef>Since</span> <span style=color:#66d9ef>TRACE_IRQS_OFF</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>idempotent</span>,
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>the</span> <span style=color:#66d9ef>simplest</span> <span style=color:#66d9ef>way</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>handle</span> <span style=color:#66d9ef>it</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>just</span> <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>it</span> <span style=color:#66d9ef>twice</span> <span style=color:#66d9ef>if</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>we</span> <span style=color:#66d9ef>enter</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>user</span> <span style=color:#66d9ef>mode.</span>  <span style=color:#66d9ef>There</span><span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>no</span> <span style=color:#66d9ef>reason</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>optimize</span> <span style=color:#66d9ef>this</span> <span style=color:#66d9ef>since</span>
  <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#a6e22e>TRACE_IRQS_OFF</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>a</span> <span style=color:#66d9ef>no-op</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>lockdep</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>off.</span>
  <span style=color:#960050;background-color:#1e0010>*/</span>
 <span style=color:#a6e22e>TRACE_IRQS_OFF</span>

 <span style=color:#a6e22e>CALL_enter_from_user_mode</span>

<span style=color:#960050;background-color:#1e0010>1:</span>
 <span style=color:#a6e22e>ENTER_IRQ_STACK</span> <span style=color:#66d9ef>old_rsp</span><span style=color:#960050;background-color:#1e0010>=</span>%rdi <span style=color:#66d9ef>save_ret</span><span style=color:#960050;background-color:#1e0010>=</span><span style=color:#ae81ff>1</span>
 <span style=color:#960050;background-color:#1e0010>/*</span> <span style=color:#a6e22e>We</span> <span style=color:#66d9ef>entered</span> <span style=color:#66d9ef>an</span> <span style=color:#66d9ef>interrupt</span> <span style=color:#66d9ef>context</span> - <span style=color:#66d9ef>irqs</span> <span style=color:#66d9ef>are</span> <span style=color:#66d9ef>off</span>: *<span style=color:#960050;background-color:#1e0010>/</span>
 <span style=color:#a6e22e>TRACE_IRQS_OFF</span>

 <span style=color:#a6e22e>ret</span>
<span style=color:#a6e22e>END</span>(<span style=color:#66d9ef>interrupt_entry</span>)
</code></pre></div><ul><li>여기서 이전에 있던 걸 저장하는 asm은 PUSH_AND_CLEAR_REGS 이다.</li></ul><h5 id=in_interrupt>in_interrupt</h5><ul><li><code>include/linux/preempt.h</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define in_interrupt()		(irq_count())
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define irq_count()	(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \
</span><span style=color:#75715e>   | NMI_MASK))
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>DECLARE_PER_CPU(<span style=color:#66d9ef>int</span>, __preempt_count);
<span style=color:#75715e>/*
</span><span style=color:#75715e> * We mask the PREEMPT_NEED_RESCHED bit so as not to confuse all current users
</span><span style=color:#75715e> * that think a non-zero value indicates we cannot preempt.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>preempt_count</span>(<span style=color:#66d9ef>void</span>)
{
  <span style=color:#66d9ef>return</span> raw_cpu_read_4(__preempt_count) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>PREEMPT_NEED_RESCHED;
}
</code></pre></div><ul><li>cpu 마다 <code>__preempt_count</code> 라는 변수를 만들고, 여기에 비트 연산해서 가져온다.</li><li>동작 순서<ol><li>irqchip driver에서 handle_domain_irq 를 호출해한다.</li><li>handle_domain_irq -> __handle_domain_irq -> irq_enter -> __irq_enter -> preempt_count_add 순으로 호출하면서 cpu가 인터럽트를 처리중이라는걸 명시해준다.</li><li>__handle_domain_irq -> generic_handle_irq -> handle_fasteoi_irq -> handle_irq_event -> handle_irq_event_percpu 순으로 호출되면서, interrupt handler 가 처리하도록 한다.</li></ol></li><li>인터럽트 컨텍스트에서 스케줄링하면 커널 패닉이 발생한다.<ul><li>인터럽트 컨텍스트에서 mutext 를 획득하면 mutex 내부에서 스캐줄링이 있기 때문에, 터진다.</li></ul></li></ul><h5 id=인터럽트-핸들러-등록>인터럽트 핸들러 등록</h5><ul><li>request_irq</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> __must_check
request_irq(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, irq_handler_t handler, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags,
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev)
</code></pre></div><ul><li><p>irq : 인터럽트 번호</p></li><li><p>handler : 인터럽트 발생 시 호출될 인터럽트 핸들러 주소</p></li><li><p>flags : 인터럽트의 속성 플래그</p></li><li><p>naem : 인터럽트 이름</p></li><li><p>dev : 인터럽트 핸들러에 전달하는 매개변수</p></li><li><p>request_threaded_irq</p><ul><li>request_irq 가 내부적으로 호출하는 함수</li><li>동작<ul><li>인터럽트 번호로 인터럽트 디스크립터 가져오기</li><li>irqaction 구조체로 독적 메모리 할당</li><li>irqaction 구조체 필드에 인터럽트 초기화 인자(인터럽트 핸들러, 인터럽트 속성, 인터럽트 핸들러 매개변수)를 설정</li></ul></li></ul></li><li><p>IRQ Storm : 인터럽트 신호가 엄청 자주 발생해서 시스템 오동작 유발</p><ul><li>IRQF_TRIGGER_HIGH</li><li>IRQF_TRIGGER_LOW</li><li>IRQF_TRIGGER_RISING</li><li>IRQF_TRIGGER_FALLING</li></ul></li></ul><h5 id=인터럽트-디스크립터-1>인터럽트 디스크립터</h5><ul><li>커널이 특정 드라이버나 메모리 같은 중요한 객체를 관리하려고 쓰는 자료구조<ul><li>주로 <code>task_struct</code>, <code>page</code>, <code>files_struct</code></li></ul></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> irq_desc {
  <span style=color:#66d9ef>struct</span> irq_common_data irq_common_data;
  <span style=color:#66d9ef>struct</span> irq_data        irq_data;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> __purcpu  <span style=color:#f92672>*</span>kstat_irqs;
  irq_flow_handler_t     handler_irq;
<span style=color:#75715e>#ifdef CONFIG_IRQ_PREFLOW_FASTEOI
</span><span style=color:#75715e></span>  irq_preflow_handler_t  preflow_handler;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span> <span style=color:#66d9ef>struct</span> irqaction        <span style=color:#f92672>*</span>action;
 <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            status_use_accessors;
}
</code></pre></div><ul><li>irq_common_data : 커널에서 처리하는 irq_chip 관련 함수에 대한 정보</li><li>irq_data : 인터럽트 번호와 해당 하드웨어 핀 번호</li><li>kstat_irq : 인터럽트가 발생한 횟수가 저장</li><li>action : 인터럽트 주요 정보</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> irqaction {
  irq_handler_t         handler;
  <span style=color:#66d9ef>void</span>                  <span style=color:#f92672>*</span>dev_id;
  <span style=color:#66d9ef>void</span> __percpu         <span style=color:#f92672>*</span>percpu_dev_id;
  <span style=color:#66d9ef>struct</span> irqaction      <span style=color:#f92672>*</span>next;
  irq_handler_t         thread_fn;
  <span style=color:#66d9ef>struct</span> task_struct    <span style=color:#f92672>*</span><span style=color:#66d9ef>thread</span>;
  <span style=color:#66d9ef>struct</span> irqaction      <span style=color:#f92672>*</span>second;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>          irq;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>          flags;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>         thread_flags;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>         thread_mask;
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>            <span style=color:#f92672>*</span>name;
  <span style=color:#66d9ef>struct</span> proc_dir_entry <span style=color:#f92672>*</span>dir;
} ____cacheline_internodealigned_in_smp;
</code></pre></div><ul><li>handler : 인터럽트 핸들러의 함수 주소</li><li>dev_id : 인터럽트 핸들러에 전달되는 매개변수</li><li>thread_fn : 인터럽트를 threaded IRQ 방식으로 처리할때 IRQ 스레드 처리 함수의 주소를 저장하는 필드, 지정하지 않으면 NULL</li><li>irq : 인터럽트 번후</li><li>flags : 인터럽트 플레그 설정 필드</li></ul><h5 id=인터럽트가-비활성화되어야-할-때>인터럽트가 비활성화되어야 할 때</h5><ul><li><p>SoC에서 정의한 하드웨어 블록에 정확한 시퀀스를 줘야할 경우</p></li><li><p>시스템이 유휴 상태에 진입하기 직전의 <em>시스템의 상태 정보</em> 값을 저장하는 동작</p></li><li><p>각 디바이스 드라이버가 서스펜드 모드로 진입할 때 디바이스 드라이버에 데이ㅌ 시트에서 명시한 대로 정확히 특정 시퀀스를 줘야 할 경우</p></li><li><p>예외가 발생해서 시스템 리셋을 시키기 전</p></li><li><p>local_irq_disable : 해당 cpu 라인에서 인터럽트의 발생을 비활성화 하는 함수</p></li><li><p>local_irq_enable : 해당 CPU 인터럽트 라인을 활성화</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define raw_local_irq_enable()		arch_local_irq_enable()
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> notrace <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>arch_local_irq_enable</span>(<span style=color:#66d9ef>void</span>)
{
 native_irq_enable();
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>native_irq_enable</span>(<span style=color:#66d9ef>void</span>)
{
 <span style=color:#66d9ef>asm</span> <span style=color:#66d9ef>volatile</span>(<span style=color:#e6db74>&#34;sti&#34;</span><span style=color:#f92672>:</span> <span style=color:#f92672>:</span> <span style=color:#f92672>:</span><span style=color:#e6db74>&#34;memory&#34;</span>);
}
</code></pre></div><h5 id=인터럽트-디버깅>인터럽트 디버깅</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>
echo <span style=color:#ae81ff>0</span> &gt; /sys/kernel/debug/tracing/tracing_on
sleep <span style=color:#ae81ff>1</span>
echo <span style=color:#e6db74>&#34;tracing_off&#34;</span>
echo nop &gt; /sys/kernel/debug/tracing/current_tracer
echo <span style=color:#ae81ff>0</span> &gt; /sys/kernel/debug/tracing/events/enable
sleep <span style=color:#ae81ff>1</span>

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/sched/sched_switch/enable
sleep <span style=color:#ae81ff>1</span>

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/irq/irq_handler_entry/enable
echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/events/irq/irq_handler_exit/enable

echo <span style=color:#ae81ff>1</span> &gt; /sys/kernel/debug/tracing/tracing_on
echo <span style=color:#e6db74>&#34;tracing_on&#34;</span>
</code></pre></div><h4 id=인터럽트-후반부-처리>인터럽트 후반부 처리</h4><ul><li>인터럽트 후반부의 필요성</li><li>인터럽트가 발생하면 커널은 실행 중인 프로세스를 멈추가 인터럽트 벡터를 실행해서 인터럽트 핸들러를 실행하게 된다. 이는 프로세스 입장에서는 실행 도중 멈추는 것이니 최대한 빨리 실행되지 않는다면, 프로세스가 동작하다가 멈춘 것처럼 보인다.</li><li>이는 다음 4가지 기법들을 이끌어 낸다.<ul><li>IRQ 스레드</li><li>Soft IRQ</li><li>테스크릿</li><li>워크큐</li></ul></li><li>인터럽트 컨텍스트에서 시간을 오래 소모하면 커널 패닉이 일어난다.</li></ul><h5 id=top-halfbottom-half>Top Half/Bottom Half</h5><ul><li>Top Half : 인터럽트가 발생한 후 빨리 처리해야 하는 일</li><li>Bottom Half : 조금 있다가 처리해도 되는일</li><li>인터럽트 핸들러는 Top Half를, 프로세스 레벨에선 Bottom Half 를 처리한다.</li></ul><h5 id=인터럽트-후반부-처리-기법-정리>인터럽트 후반부 처리 기법 정리</h5><ul><li>IRQ 쓰레드(threaded IRQ) : 인터럽트를 처리하는 전용 IRQ 스레드에서 인터럽트 후속 처리를 수행한다.</li><li>Soft IRQ : 인터럽트 핸들러 실행이 끝나면 바로 시작되며, Soft IRQ 컨텍스트에서 실행되며, 시간이 오래 걸릴 경우 ksoftirqd 프로세스를 깨우고 서비스를 종료한다. 이후 ksoftirqd 라는 프로세스에서 나머지 내용들을 처리한다.</li><li>테스크릿 : Soft IRQ 서비스를 동적으로 쓸 수 있는 인터페이스이자 자료구조</li><li>워크큐 : 인터럽트 핸들러가 실행될 때 워크를 워크큐에 큐잉하고 프로세스 레벨의 워커 스레드에서 인터럽트 후반부를 처리한다.</li></ul><h5 id=어떤-처리기법을-적용해야-하는가>어떤 처리기법을 적용해야 하는가</h5><ul><li>인터럽트가 자주 발생할 경우 : Soft IRQ나 테스크릿<ul><li>IRQ 스레드는 실시간 프로세스로 구동되며, 이는 선점 스케줄링을 유발하여 다른 프로세스들이 대기하게 된다. 이는 시스템 반응 속도가 느려지는 결과가 생긴다.</li><li>워크큐는 실행 시간 측면에서, 큐잉 뒤 워크를 깨우는 시간이 오래 걸리고, 워커 스레드는 일반 프로세스로 우선순위가 높지 않다.</li></ul></li><li>인터럽트 개수가 많을 경우 : IRQ 스레드를 생성할 때, 메모리 주의<ul><li>인터럽트 개수만큼 IRQ 스레드가 생성되기 때문에 메모리를 더 사용하게 된다.</li></ul></li></ul><h5 id=irq-스레드-threaded-irq>IRQ 스레드 (threaded IRQ)</h5><ul><li><p>IRQ : Interrupt Request으 약자로 하드웨어에서 발생한 인터럽트를 처리한다.</p></li><li><p>Threaed IRQ : 인터럽트 핸들러에서 바로 처리하지 않아도 되는 일을 수행하는 프로세스를 두고 처리하는 방식</p></li><li><p><code>irq/인터럽트 번호 - 인터럽트 이름</code> 의 순서로 IRQ 스레드의 이름이 지어진다. (예시 : irq/86-mmc1 는 mmc1이라는 이름의 86번 인터럽트를 처리하는 IRQ 스레드)</p></li></ul><h5 id=irq-생성-방법>IRQ 생성 방법</h5><ul><li><p>request_threaded_irq -> __setup_irq -> setup_irq_thread -> kthread_create 과정을 통해서 커널 스레드를 생성</p></li><li><p>request_threaded_irq</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>request_threaded_irq</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, irq_handler_t handler,
 irq_handler_t thread_fn, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> irqflags,
 <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>devname, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dev_id);
</code></pre></div><ul><li><p>irq : 인터럽트 번호</p></li><li><p>handler : 인터럽트 핸들러 주소</p></li><li><p>thread_fn : IRQ 스레드 처리 함수의 주소</p></li><li><p>irqflags : 인터럽트 핸들링 플래그</p></li><li><p>devname : 인터럽트 핸들러 이름</p></li><li><p>dev_id : 인터럽드 디바이스 정보</p></li><li><p>하는일</p><ol><li>인터럽트 디스크립터 설정 : 이나를 인터럽트 디스크립터 필드에 할당</li><li>IRQ 스레드 생성 : thread_fn 인자에 IRQ 스레드 처리 함수 주소를 지정하면 IRQ 스레드 생성</li></ol></li></ul></li><li><p>__setup_irq</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>
 __setup_irq(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>struct</span> irq_desc <span style=color:#f92672>*</span>desc, <span style=color:#66d9ef>struct</span> irqaction <span style=color:#f92672>*</span>new)
</code></pre></div><ul><li><p>irq : 인터럽트 번호</p></li><li><p>desc : 인터럽트 디스크립터</p></li><li><p>new : 인터럽트 디스크립터의 action 필드</p></li><li><p>하는일</p><ul><li>IRQ 스레드 처리 함수가 등록됐는지 점검</li><li>만약 IRQ 스레드가 등록됐으면 setup_irq_thread 함수를 호출해 IRQ 스레드를 생성</li></ul></li></ul></li><li><p>setup_irq_thread</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>
 setup_irq_thread(<span style=color:#66d9ef>struct</span> irqaction <span style=color:#f92672>*</span>new, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> irq, <span style=color:#66d9ef>bool</span> secondary)
</code></pre></div></li><li><p>IRQ 스레드 처리 함수 : 인터럽트별로 지정한 IRQ 스레드별로 후반부를 처리하는 함수</p></li><li><p>IRQ 스레드 핸들러 함수 : irq_thread() 함수를 뜻하며, 인터럽트별로 지정된 IRQ 스레드 처리함수를 호출하는 역할</p></li></ul><h5 id=irq-스레드의-실행과정>IRQ 스레드의 실행과정</h5><ol><li>인터럽트 핸들러에서 IRQ_WAKE_THREAD를 반환</li><li>IRQ 스레드를 꺠움</li><li>IRQ 스레드 핸들러인 irq_thread() 함수를 실행</li><li>irq_thread() 함수에서 IRQ 스레드 처리 함수 호출</li></ol><hr><ul><li>handle_irq_event -> handle_irq_event_percpu -> __handle_irq_event_percpu -> __irq_wake_thread -> wake_up_process</li><li>만약 IRQ 스레드를 깨우고 싶으면 IRQ_WAKE_THREAD를 반환하고,아니라면 IRQ_HANDLED를 반환하면 된다.</li></ul><h4 id=soft-irq>Soft IRQ</h4><ul><li>리눅스 커널에서 지원하는 10가지 Soft IRQ 서비스<ul><li>HI, TIMER, NET_TX, NET_RX, BLOCK, IRQ_POLL, TASKLET, SCHED, HRTIMER, RCU</li></ul></li></ul><h5 id=soft-irq-서비스의-라이프-사이클>Soft IRQ 서비스의 라이프 사이클</h5><ol><li>부팅 과정</li></ol><ul><li>Soft IRQ 서비스 등록</li><li>open_softirq()</li></ul><ol><li>인터럽트 처리</li></ol><ul><li>Soft IRQ 서비스 요청</li><li>raise_softirq()</li></ul><ol><li>Soft IRQ 컨텍스트</li></ol><ul><li>Soft IRQ 서비스 실행</li><li>__do_softirq()</li></ul><h5 id=발생-흐름>발생 흐름</h5><ol><li>인터럽트가 발생하면 해당 인터럽트 핸들러에서 Soft IRQ 서비스를 요청한다. 이를 위해 raise_softirq_irqoff() 함수를 호출해야 한다. 이는 인터럽트 핸들러에서 IRQ_WAKE_THREAD를 반환하는 동작과 유사하다.</li><li>인터럽트 서비스 루틴 동작이 끝나면 irq_exit() 함수를 호출한다. 여기서 Soft IRQ 서비스 요청 여부를 점검한다. 요청한 Soft IRQ 서비스가 있으면 __do_softirq() 함수를 호출해서 해당 Soft IRQ 서비스 핸들러를 실행한다. 만약 Soft IRQ 서비스 요청이 없으면 riq_exit() 함수는 바로 종료하게 된다.</li><li>__do_softirq() 함수에서 Soft IRQ 서비스 핸들러 호출을 끝내면 Soft IRQ 서비스 요청이 있었는지 다시 체크한다. 이미 Soft IRQ 서비 스핸들러 처리 시간이 2ms 이상이거나 10번 이상 Soft IRQ 서비스 핸들러를 처리했다면 다음 동작을 수행한다.</li></ol><ul><li>wakeup_softirqd() 함수를 호출해서 ksoftirqd 프로세스를 깨움</li><li>__do_softirq() 함수 종료</li></ul><ol><li>ksoftirqd 프로세스 가깨어나 3단계에서 마무리하지 못한 Soft IRQ 서비스 핸들러를 실행한다.</li></ol><h5 id=후반부-기법으로-soft-irq를-사용하는-상황>후반부 기법으로 Soft IRQ를 사용하는 상황</h5><ul><li>인터럽트 발생 빈도가 높거나 인터럽트 후반부를 빨리 처리해야 할 때 사용한다.</li><li>커널에서는 Soft IRQ를 디바이스 드라이버 레벨에서 쓸 수 있는 태스크릿이라는 인터페이스 환경을 제공한다.</li></ul><h5 id=soft-irq-서비스-설명>Soft IRQ 서비스 설명</h5><table><thead><tr><th>우선순위</th><th>Soft IRQ 서비스</th><th>설명</th><th>Soft IRQ 서비스 핸들러</th></tr></thead><tbody><tr><td>0</td><td>HI_SOFTIRQ</td><td>가장 우선순위가 높으며 TASKLET_HI로 적용</td><td>tasklet_hi_action()</td></tr><tr><td>1</td><td>TIMER_SOFTIRQ</td><td>동적 타이버로 사용</td><td>run_timer_softirq()</td></tr><tr><td>2</td><td>NET_TX_SOFTIRQ</td><td>네트워크 패킷 송신용으로 사용</td><td>net_tx_action()</td></tr><tr><td>3</td><td>NET_RX_SOFTIRQ</td><td>네트워크 패킷 수신용 사용</td><td>net_rx_action()</td></tr><tr><td>4</td><td>BLOCK_SOFTIRQ</td><td>블록 디바이스에서 사용</td><td>blk_done_softirq()</td></tr><tr><td>5</td><td>IRQ_POLL_SOFTIRQ</td><td>IRQ_POLL 연관 동작</td><td>blk_iopoll_softirq()</td></tr><tr><td>6</td><td>TASKLET_SOFTIRQ</td><td>일반 태스크릿으로 사용</td><td>tasklet_action()</td></tr><tr><td>7</td><td>SCHED_SOFTIRQ</td><td>스케쥴러에서 사용</td><td>run_reblanace_domains()</td></tr><tr><td>8</td><td>HRTIMER_SOFTIRQ</td><td>현재 사용하지 않지만 하위 호환성을 위해 남겨둠</td><td>run_timer_softirq()</td></tr><tr><td>9</td><td>RCU_SOFTIRQ</td><td>RCU 처리용으로 사용</td><td>rcu_process_callbacks()</td></tr></tbody></table><h5 id=raise_softirq-함수>raise_softirq() 함수</h5><ul><li>raise_softirq -> raise_softirq_irqoff -> or_softirq_pending</li><li>irq_exit -> invoke_softirq -> __do_softirq</li><li>run_ksoftirqd -> __do_softirq</li></ul><h5 id=__do_softirq-함수>__do_softirq 함수</h5><ul><li>실제로 Soft IRQ 서비스 핸들러를 실행시켜주는 곳</li><li>시간이 오래걸리거나, 특정 횟수 이상 서비스를 실행했으면ksoftirqd 스레드를 깨움.</li></ul><h5 id=ksoftirqd-스레드>ksoftirqd 스레드</h5><ul><li>wakeup_softirqd -> wake_up_process</li><li>run_ksoftirqd -> __do_softirq</li></ul><h5 id=정리>정리</h5><ul><li>Soft IRQ 서비스 요청 시기 : 인터럽트가 발생하면 인터럽트 핸들러에서 Soft IRQ 서비스를 요청</li><li>Soft IRQ 서비스 실행의 출발점 : 인터럽트 핸들러 수행이 끝나면 요청한 Soft IRQ 서비스가 있엇는지 체크, irq_exit() -> invoke_softirq() -> __do_softirq()</li><li>Soft IRQ 전용 스레드인 ksoftirqd 스레드의 기상 시점 : __do_softirqd() 함수 실행시간이 2ms 이상이거나, Soft IRQ 서비스 핸들러를 10번 이상 호출했다면 ksoftirqd 스레드가 일어난다.</li></ul><h4 id=ksoftirqd-스레드-1>ksoftirqd 스레드</h4><ul><li>Soft IRQ 서비스를 인터럽트를 처리 한 후의 시점이 아닌 프로세스 레벨에서 실행할 수 있게 생성된 프로세스</li><li>percpu 타입의 프로세스이며, cpu 코어의 개수 만큼 생성되어 정해진 cpu 내에서만 실행된다.</li></ul><h5 id=ksoftirqd-스레드-기상-시점>ksoftirqd 스레드 기상 시점</h5><ul><li><p>__do_softirq() 함수에서 Soft IRQ 서비스를 실행한 후</p></li><li><p>인터럽트 컨텍스트가 아닌 상황에서 Soft IRQ 서비스를 요청할 때</p></li><li><p>__do_softirq() 함수에서 Soft IRQ 서비스의 실행 시간이 MAX_SOFTIRQ_TIME 을 초과 했을 때</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>asmlinkage __visible <span style=color:#66d9ef>void</span> __softirq_entry <span style=color:#a6e22e>__do_softirq</span>(<span style=color:#66d9ef>void</span>)
{
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> jiffies <span style=color:#f92672>+</span> MAX_SOFTIRQ_TIME;
  <span style=color:#75715e>/* skip */</span>
  restart :
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>while</span> ((softirq_bit <span style=color:#f92672>=</span> ffs(pending))) {
  <span style=color:#75715e>/* skip */</span>
    trace_softirq_entry(vec_nr);
    h<span style=color:#f92672>-&gt;</span>action(h);
    trace_softirq_exit(vec_nr);
    <span style=color:#75715e>/* skip */</span>
    h <span style=color:#f92672>++</span>;
    pending <span style=color:#f92672>&gt;&gt;=</span> softirq_bit;
  }
  pending <span style=color:#f92672>=</span> local_softirq_pending();
  <span style=color:#66d9ef>if</span> (pending) {
    <span style=color:#66d9ef>if</span> (time_before(jiffies, end) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>need_resched() <span style=color:#f92672>&amp;&amp;</span>
      <span style=color:#f92672>--</span>max_restart)
      <span style=color:#66d9ef>goto</span> restart;

    wake_softirqd();
  }
}

<span style=color:#f92672>*</span> Soft IRQ <span style=color:#960050;background-color:#1e0010>서비스를</span> <span style=color:#960050;background-color:#1e0010>요청할</span> <span style=color:#960050;background-color:#1e0010>때</span> (raise_softirq_irqoff)
  <span style=color:#960050;background-color:#1e0010>```</span>c
  <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> raise_softirq_irqoff(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> nr)
  {
    __raise_softirq_irqoff(nr);

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>in_interrupt())
      wakeup_softirqd();
  }
</code></pre></div><h5 id=ksoftirqd-핸들러-run_ksoftirqd>ksoftirqd 핸들러 run_ksoftirqd</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_ksoftirqd</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> cpu)
{
  local_irq_disable();
  <span style=color:#66d9ef>if</span> (local_softirq_pending()) {
    __do_softirq();
    local_irq_enable();
    cond_resched_cru_qs();
    <span style=color:#66d9ef>return</span>;
  }
  local_irq_enable();
}
</code></pre></div><h5 id=soft-irq-컨텍스트>Soft IRQ 컨텍스트</h5><ul><li>Soft IRQ 컨텍스트의 시작점<ul><li>__do_softirq() 에서 __local_bh_disable_ip(<em>RET_IP</em>, SOFTIRQ_OFFSET) 을 호출하면서 시작</li></ul></li><li>Soft IRQ 컨텍스트 확인 : in_softirq()</li></ul><h4 id=태스크릿>태스크릿</h4><ul><li>동적으로 Soft IRQ 서비스를 쓸 수 있게 만든 인터페이스</li></ul><h5 id=태스크릿-실행-순서>태스크릿 실행 순서</h5><ol><li>Soft IRQ 서비스 요청</li><li>Soft IRQ 서비스 실행</li><li>ksoftirqd 스레드를 깨움</li><li>ksfotirqd 스레드 실행</li></ol><h5 id=태스크릿의-실행-주체>태스크릿의 실행 주체</h5><ul><li>tasklet_action()</li></ul><h5 id=태스크릿-자료-구조>태스크릿 자료 구조</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> tasklet_struct
{
  <span style=color:#66d9ef>struct</span> tasklet_struct <span style=color:#f92672>*</span>next;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> state;
  atomic_t count;
  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>);
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> data;
}
</code></pre></div><ul><li>next : 다음 태스크릿을 가리키는 용도의 포인터</li><li>state : 캐스크릿의 세부 상태 정보를 저장하는 필드, 아래 나오는 플레그 중 하나를 저장한다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>enum</span>
{
  TASKLET_STATE_SCHED,  <span style=color:#75715e>/* Tasklet is scheduled for execution. */</span>
  TASKLET_STATE_RUN     <span style=color:#75715e>/* Tasklet is running (SMP only) */</span>
}
</code></pre></div><ul><li>TASKLET_STATE_SCHED : 태스크릿 서비스를 요청한 후 아직 태스크릿 핸들러를 처리하지 않는 상태</li><li>TASKLET_STATE_RUN : 태스크릿 핸들러를 실행 중인 상태</li><li>count : 태스크릿의 레퍼런스 카운터, 초기화할때(tasklet_init)에서 0으로 설정. 반드시 0이여야지만 태스크릿을 실행</li><li>func : 테스크릿 핸들러 함수 주소, tasklet_init 함수를 호출할 때 2번째 인자로 등록</li><li>data : 태스크릿 핸들러 함수에 전달되는 매개변수</li></ul><h5 id=태스크릿-등록-방법>태스크릿 등록 방법</h5><ul><li>태스크릿 전역변수 선언 : DECLARE_TASKLET() 또는 DECLARE_TASKLET_DISABLED() 함수 호출<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define DECLARE_TASKLET(name, func, data) \
</span><span style=color:#75715e>struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define DECLARE_TASKLET_DISABLED(name, func, data) \
</span><span style=color:#75715e>struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* example */</span>
DECLARE_TASKLET_DISABLED(keyboard_tasklet, kbd_bh, <span style=color:#ae81ff>0</span>);

<span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>kdb_init</span>(<span style=color:#66d9ef>void</span>)
{
  <span style=color:#75715e>/* skip */</span>
  tasklet_enable(<span style=color:#f92672>&amp;</span>keyboard_tasklet);
  tasklet_schedule(<span style=color:#f92672>&amp;</span>keyboard_tasklet);
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><ul><li>기본적으로는 태스크릿을 비활성화해 초기화 한 후 tasklet_enable() 함수를 호출하면 태스크릿을 활성화 할수 있다.</li></ul></li><li>테스크릿 초기화 함수 호출 : tasklet_init() 함수<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tasklet_init</span>(<span style=color:#66d9ef>struct</span> tasklet_struct <span style=color:#f92672>*</span>t,
  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>), <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> data);
</code></pre></div><ul><li>t : 태스크릿을 식별하는 구조체</li><li>func : 태스크릿 핸들러 함수</li><li>data : 태스크릿 콜백 함수로 전달하는 매개변수</li></ul></li></ul><h5 id=태스크릿-실행-요청-방법>태스크릿 실행 요청 방법</h5><ul><li>tasklet_schedule()<ul><li>tasklet_schedule -> __tasklet_schedule -> __tasklet_schedule_common<ul><li>tasklet_schedule : state를 TASKLET_STATE_SCHED로 바꿈</li><li>__stasklet_schedule : __tasklet_schedule_commone 함수 호출</li><li>__tasklet_schedule_common : tasklet_vec 에 태스크릿 핸들러 등록</li></ul></li></ul></li></ul><h5 id=soft-irq-디버깅-해보기>Soft IRQ 디버깅 해보기</h5><ul><li>ftrace 코드<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash></code></pre></div></li></ul><p>#!/bin/bash</p><p>echo 0 > /sys/kernel/debug/tracing/tracing_on
sleep 1
echo &ldquo;tracing_off&rdquo;</p><p>echo 0 > /sys/kernel/debug/tracing/events/enable
sleep 1
echo &ldquo;events disabled&rdquo;</p><p>echo 1 > /sys/kernel/debug/tracing/events/irq/softirq_raise/enable
echo 1 > /sys/kernel/debug/tracing/events/irq/softirq_entry/enable
echo 1 > /sys/kernel/debug/tracing/events/irq/softirq_exit/enable</p><p>sleep 1
echo &ldquo;set_ftrace_filter enabled&rdquo;</p><p>echo 1 > /sys/kernel/debug/tracing/tracing_on
echo &ldquo;tracing_on&rdquo;</p><pre><code>* ftrace log 확인하기
```log
 soft_irq_ftrace-2255  [000] d.h. 19085.301866: softirq_raise: vec=7 [action=SCHED]
 soft_irq_ftrace-2255  [000] ..s. 19085.301920: softirq_entry: vec=1 [action=TIMER]
 soft_irq_ftrace-2255  [000] ..s. 19085.301940: softirq_exit: vec=1 [action=TIMER]
 soft_irq_ftrace-2255  [000] ..s. 19085.301944: softirq_entry: vec=7 [action=SCHED]
</code></pre><ul><li>softirq_entry : 시작, softirq_exit : 실행 마무리, softirq_raise : 서비스 요청</li><li>Soft IRQ 서비스 실행 횟수 확인<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat /proc/softirqs
</code></pre></div></li></ul><hr><h4 id=인터럽트-정리>인터럽트 정리</h4><ul><li>인터럽트가 발생했을 때 빨리 실행해야 하는 코드는 인터럽트 핸들러에서 처리, 나머지는 후반부 처리</li><li>IRQ 스레드는 후반부 처리를 위핸 전용 커널 스레드, request_threaded_irq 함수가 실행될 때 생성, 인터럽트 핸들러에서 IRQ_THREAD_WAKE를 반환하면 깨어남.</li><li>Soft IRQ : 빠른 시간 내에 인터럽트 후반부 처리를 하기 위한 기법, 네트워크 고속 패킷이나 스토리지 디바이스에 서사용</li><li>Soft IRQ 는 서비스 요청과 서비스 실행 단계로 나눌수 있으며, 실행할 때 softirq_vec 이라는 Soft IRQ 벡터에 등록된 함수를 호출</li><li>Soft IRQ 컨텍스트는 Soft IRQ 서비스를 실행 중인 상태이며, 프로세스를 관리하는 thread_info 구조체의 preempt_count 필드에 SOFTIRQ_OFFSET을 나타내는 0x100을 저장.</li><li>태스크릿은 동적으로 Soft IRQ 서비스를 사용하기 위한 인터페이스</li></ul><h3 id=워크큐>워크큐</h3><ul><li>주요 키워드 : 워크, 워커스레드, 워커 풀, 풀워크큐</li><li>워크 : 워크큐를 실행하는 단위<ul><li><p>실행 처리 흐름</p><ol><li>워크 큐잉(schedule_work), insert_work)</li><li>워크 스레드 깨움(wake_up_worker)</li><li>워크 스레드 실행(process_one_work)</li></ol></li><li><p>커널 후반부를 처리하는 단위, 워 크핸들러 실행 도중 휴면 상태에 진입할 숫 있다.</p></li><li><p>워크는 워커 스레드가 실행한다.</p></li></ul></li><li>워크 스레드<ul><li>워커 스레드의 이름은 &ldquo;kworker/&rdquo; 로 시작하며, 워크큐의 종류에 다라 &ldquo;kworker/&rdquo; 다음에 번호를 부여한다.</li><li>워커 스레드 핸들러 함수는 worker_thread() 함수다.</li></ul></li><li>워커 풀<ul><li>큐잉한 워크 리스트를 관리</li><li>워커 스레드를 생성하면서 관리</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> worker_pool {
  spinlock_t lock;
  <span style=color:#66d9ef>int</span> cpu;
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>struct</span> list_head worklist;
  <span style=color:#66d9ef>int</span> nr_workers;
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>struct</span> list_head workers;
}
</code></pre></div></li><li>풀워크큐<ul><li>워커 풀을 통해 워크와 워커 스레드를 관리한다.</li></ul></li></ul><h4 id=워크큐의-특징>워크큐의 특징</h4><ul><li>워커 스레드가 워커를 실행할 때는 언제든 휴면이 가능한다. 따라서 스케쥴링을 지원하는 모든 커널 함수를 쓸 수 있다.</li><li>실행 시각에 민감한 후반부를 처리하는 용도로 워크큐의 워크를 사용하는 것은 적합하지 않다. 시스템 부하에 따라 워크 핸들러의 실행 시각 시간이 달라질 수 있다.</li><li>드라이브 레벨에 서워크는 쓰기 쉽다. 워크는 work_struct 구조체 변수만 설정, 워크를 실행할 코드에 queue_work() 혹은 schedule_work() 함수만 추가하면 된다.</li><li>워크큐를 쓰면 드라이버를 조금 더 유연하게 설계 가능하다. 또한 딜레이 워크(struct delayed_work)를 제공하며, 이를 사용해 jiffies(1/HZ) 단위로 워크를 특정 시각 이후로 지연시킨 후 실행 가능</li></ul><h4 id=워크큐와-다른-인터럽트-후반부-기법과의-비교>워크큐와 다른 인터럽트 후반부 기법과의 비교</h4><ul><li>vs IRQ 스레드 방식<ul><li>스레드의 우선순위 : IRQ 스레드는 우선순위를 높여서 처리 가능</li></ul></li><li>vs Soft IRQ 방식과의 비교<ul><li>Soft IRQ는 인터럽트 발생 빈도가 높고 후반부를 빨리 처리해야하는 상황에서 사용</li><li>워크큐는 Soft IRQ에 비해 처리 속도가 느리다.</li></ul></li></ul><h4 id=워크큐-설계>워크큐 설계</h4><ul><li>인터럽트 핸들러로 빨리 처리해야 할 코드를 수행한 후 워크를 워크큐에 큐잉한다.</li><li>인터럽트 후반부로 처리해야 할 코드를 워크 핸들러에서 처리한다.</li></ul><h4 id=워크큐의-종류>워크큐의 종류</h4><h5 id=alloc_workqueue>alloc_workqueue()</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define alloc_workqueue(fmt, flags, max_active, args...) \
</span><span style=color:#75715e>  __alloc_workqueue_key((fmt), (flags), (max_active), \
</span><span style=color:#75715e>    NULL, NULL, ##args)
</span></code></pre></div><ul><li>fmt : 워크큐의 이름을 지정하며, workqueue_struct 구조체의 name 필드에 저장된다.</li><li>flags : 워크큐의 속성 정보 저장, workqueue_struct 구조체의 flags 필드에 저장.<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>enum</span> {
  WQ_UNBOUND <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>,
  WQ_FREEZABLE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>,
  WQ_MEM_RECLAIM <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>,
  WQ_HIGHPRI <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>,
  WQ_CPU_INTENSIVE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>,
  WQ_SYSFS <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>,
  WQ_POWER_EFFICIENT <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>,
  <span style=color:#75715e>/* skip */</span>
}
</code></pre></div></li><li>max_active : workqueue_struct 구조체의 saved_max_active에 저장</li><li>workqueue_init_early 함수에서 호출됨.</li></ul><h5 id=7가지-워크큐>7가지 워크큐</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>workqueue_init_early</span>(<span style=color:#66d9ef>void</span>)
{
  <span style=color:#66d9ef>int</span> std_nice[NR_STD_WORKER_POOLS] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, HIGHPRI_NICE_LEVEL };
  <span style=color:#66d9ef>int</span> i, cpu;
  <span style=color:#75715e>/* skip */</span>
  system_wq <span style=color:#f92672>=</span> alloc_workqueue(<span style=color:#e6db74>&#34;events&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
  system_highpri_wq <span style=color:#f92672>=</span> alloc_workqueue(<span style=color:#e6db74>&#34;events_highpri&#34;</span>, WQ_HIGHPRI, <span style=color:#ae81ff>0</span>);
  system_long_wq <span style=color:#f92672>=</span> alloc_workqueue(<span style=color:#e6db74>&#34;events_long&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
  system_unbound_wq <span style=color:#f92672>=</span> alloc_workqueue(<span style=color:#e6db74>&#34;evnets_unbound&#34;</span>, WQ_UNBOUND,
                        WQ_UNBOUND_MAX_ACTIVE);
  system_freezable_wq <span style=color:#f92672>=</span> alloc_workqueue(<span style=color:#e6db74>&#34;events_power_efficient&#34;</span>,
                        WQ_FREEZABLE, <span style=color:#ae81ff>0</span>);
  system_power_efficient_wq <span style=color:#f92672>=</span> alloc_workqueue(<span style=color:#e6db74>&#34;events_power_efficient&#34;</span>,
                        WQ_POWER_EFFICIENT, <span style=color:#ae81ff>0</span>);
  system_freezable_power_efficient_wq <span style=color:#f92672>=</span>
    alloc_workqueue(<span style=color:#e6db74>&#34;events_freezable_power_efficient&#34;</span>,
                        WQ_FREEZABLE <span style=color:#f92672>|</span> WQ_POWER_EFFICIENT,
                        <span style=color:#ae81ff>0</span>);

  BUG_ON(<span style=color:#f92672>!</span>system_wq <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>system_highpri_wq <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>system_long_wq <span style=color:#f92672>||</span>
        <span style=color:#f92672>!</span>system_unbound_wq <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>system_freezable_sq <span style=color:#f92672>||</span>
        <span style=color:#f92672>!</span>system_power_efficient_wq <span style=color:#f92672>||</span>
        <span style=color:#f92672>!</span>system_freezable_power_efficient_wq);
}
</code></pre></div><ul><li>7가지 워크큐 생성</li><li>워크큐가 제대로 생성됐는지 점검</li><li>system_wq : 시스템 워크큐</li><li>system_highpri_wq : 시스템 워크큐에서 쓰는 워커 스레드 보다 우선순위가 높은 워커 스레드를 처리하는 큐</li><li>system_long_wq : 오래걸리는 작업 때 사용</li><li>system_unbound_wq : percpu 타입의 워커를 쓰지 않고 wq->numa_pwq_tbl[node]에 지정된 워커 풀을 쓴다. 시스템 워크큐보다 빨리 실행된다.</li><li>system_freezable_wq : freezable 유저 프로세스나 커널 쓰레드를 처리할때 사용. (freeze_wokques_begin() 함수에서 실행)<ul><li>프로세스를 얼릴때는 __frefrigerator 함수를 호출</li></ul></li><li>system_power_efficient_wq, system_freezable_power_efficient_wq : 절전 목적으로 사용하는 워크큐</li></ul><h5 id=워크>워크</h5><ul><li>워크큐를 실행하는 기본 단위</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> work_struct {
  atomic_long_t data;
  <span style=color:#66d9ef>struct</span> list_head entry;
  work_func_t func;
  <span style=color:#75715e>#ifdef CONFIG_LOCKDEP
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> lockdep_map lockdep_map;
  <span style=color:#75715e>#endif
</span><span style=color:#75715e></span>};
</code></pre></div><ul><li><p>data : 워크 실행상태를 나타낸다.</p><ul><li>워크 초기화 : 0xFFFFFFE0</li><li>워크를 워크큐에 큐잉 : WORK_STRUCT_PENDING_BIT(0x1)</li></ul></li><li><p>entry : 연결 리스트, worker_pool 구조체 중 연결 리스트 worklist에 등록된다.</p></li><li><p>func : 워크 핸들러 함수의 주소를 저장</p></li><li><p>초기화 방법 : INIT_WORK, DECLARE_WORK</p><ul><li><p>INIT_WORK : 커널이 INIT_WORK 함수를 실행할 때 워크를 초기화</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>INIT_WORK(<span style=color:#f92672>&amp;</span>work, callback);
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define INIT_WORK(_work, _func)                              \
</span><span style=color:#75715e>      __INIT_WORK((_work), (_func), 0)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define __INIT_WORK(_work, _func, _onstack)                  \
</span><span style=color:#75715e>  do {                                                    \
</span><span style=color:#75715e>        __init_work((_work), _onstack);                   \
</span><span style=color:#75715e>        (_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT(); \
</span><span style=color:#75715e>        INIT_LIST_HEAD(&amp;(_work)-&gt;entry);                  \
</span><span style=color:#75715e>        (_work)-&gt;func = (_func);                          \
</span><span style=color:#75715e>  } while(0)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define WORK_DATA_INIT() ATOMIC_LONG_INIT(WORKSTRUCT_NO_POOL)
</span></code></pre></div><ul><li>6번째 줄의 __init_work 함수는 CONFIG_DEBUG_OBJECTS 커널 컨피그가 활성화돼 있어야 실행, 대부분 비활성</li></ul></li><li><p>DECLARE_WORK : 커널이 컴파일될 때 워크 세부 정보가 포함된 전역 변수 생성</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#a6e22e>DECLARE_WORK</span>(work, callback);
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define DECLARE_WORK(n, f)                                    \
</span><span style=color:#75715e>      struct work_struct n = __WORK_INITIALIZER(n, f)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define __WORK_INITIALIZER(n, f) {                            \
</span><span style=color:#75715e>  .data = WORK_DATA_STATIC_INIT(),                            \
</span><span style=color:#75715e>  .entry = { &amp;(n).entry, &amp;(n).entry },                        \
</span><span style=color:#75715e>  .func = (f),                                                \
</span><span style=color:#75715e>  __WORK_INIT_LOCKDEP_MAP(#n, &amp;(n))                           \
</span><span style=color:#75715e>}
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define WORK_DATA_STATIC_INIT()                               \
</span><span style=color:#75715e>      ATOMIC_LONG_INIT((unsigned long)(WORK_STRUCT_NO_POOL | WORK_STRUCT_STATIC))
</span></code></pre></div></li></ul></li></ul><h5 id=워크-큐잉>워크 큐잉</h5><ul><li>schedule_work(), queue_work_on(), __queue_work(), insert_work(), wake_up_worker()</li><li>interface<ul><li><p>schedule_work()</p><ul><li>시스템 워크큐에 큐잉</li><li>호출 구조 : schedule_work() -> queue_work() -> queue_work_on() -> __queue_work()</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>schedule_work(<span style=color:#f92672>&amp;</span>work);
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>schedule_work</span>(<span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
{
   <span style=color:#66d9ef>return</span> queue_work(system_wq, work);
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>system_wq __read_mostly;
EXPORT_SYMBOL(system_wq);
</code></pre></div><ul><li>queue_work()</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queue_work</span>(<span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
             <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
{
  <span style=color:#66d9ef>return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
</code></pre></div><ul><li>queue_work_on()</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queue_work_on</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
   <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
{
  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> false;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;

  local_irq_save(flags);

  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
    __queue_work(cpu, wq, work);
    ret <span style=color:#f92672>=</span> true;
  }

  local_irq_restore(flags);
  <span style=color:#66d9ef>return</span> ret;
}
</code></pre></div><ul><li>__queue_work()</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__queue_work</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
           <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work);
</code></pre></div><ul><li>queue_work_on 이 호출할 때, 인자<ul><li>cpu : WORK_CPU_UNBOUND</li><li>wq : system_wq</li><li>work : work_struct 구조체의 주소</li></ul></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__queue_work</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
           <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
{
  <span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>pwq;
  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>last_pool;
  <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>worklist;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> work_flags;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> req_cpu <span style=color:#f92672>=</span> cpu;
  <span style=color:#75715e>/* skip */</span>
retry:
  <span style=color:#66d9ef>if</span> (req_cpu <span style=color:#f92672>==</span> WORK_CPU_UNBOUND)
    cpu <span style=color:#f92672>=</span> wq_select_unbound_cpu(raw_smp_processor_id());
  <span style=color:#75715e>/* pwq which will be used unless @work is executing elsewhere */</span>
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(wq<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WQ_UNBOUND))
    pwd <span style=color:#f92672>=</span> per_cpu_ptr(wq<span style=color:#f92672>-&gt;</span>cpu_pwqs, cpu);
  <span style=color:#66d9ef>else</span>
    pwd <span style=color:#f92672>=</span> unbound_pwq_by_node(wq, cpu_to_node(cpu));

  last_pool <span style=color:#f92672>=</span> get_work_pool(work);
  <span style=color:#66d9ef>if</span> (last_pool <span style=color:#f92672>&amp;&amp;</span> last_pool <span style=color:#f92672>!=</span> pwq<span style=color:#f92672>-&gt;</span>pool) {
    <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker;

    spin_lock(<span style=color:#f92672>&amp;</span>last_pool<span style=color:#f92672>-&gt;</span>lock);

    worker <span style=color:#f92672>=</span> find_worker_executing_work(last_pool, work);

    <span style=color:#66d9ef>if</span> (worker <span style=color:#f92672>&amp;&amp;</span> worker<span style=color:#f92672>-&gt;</span>current_pwq<span style=color:#f92672>-&gt;</span>wq <span style=color:#f92672>==</span> wq) {
      pwd <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>current_pwq;
    } <span style=color:#66d9ef>else</span> {
      <span style=color:#75715e>/* meh... not running there, queue her */</span>
      spin_unlock(<span style=color:#f92672>&amp;</span>last_pool<span style=color:#f92672>-&gt;</span>lock);
      spin_lock(<span style=color:#f92672>&amp;</span>pwd<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>lock);
    }
  } <span style=color:#66d9ef>else</span> {
    spin_lock(<span style=color:#f92672>&amp;</span>pwq<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>lock);
  }
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#75715e>/* pwq determined, queue */</span>
  trace_workqueue_queue_work(req_cpu, pwq, work);
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>if</span> (likely(pwq<span style=color:#f92672>-&gt;</span>nr_active <span style=color:#f92672>&lt;</span> pwq<span style=color:#f92672>-&gt;</span>max_active)) {
    trace_workqueue_activate_work(work);
    pwq<span style=color:#f92672>-&gt;</span>nr_active<span style=color:#f92672>++</span>;
    worklist <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pwq<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>worklist;
    <span style=color:#66d9ef>if</span> (list_empty(worklist))
      pwq<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>watchdog_ts <span style=color:#f92672>=</span> jiffies;
  } <span style=color:#66d9ef>else</span> {
    work_flags <span style=color:#f92672>|=</span> WORK_STRUCT_DELAYED;
    worklist <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pwq<span style=color:#f92672>-&gt;</span>delayed_works;
  }

  insert_work(pwq, work, worklist, work_flags);
  <span style=color:#75715e>/* skip */</span>
}
</code></pre></div><ul><li>풀워크큐 가져오기</li><li>워커 구조체 가져오기</li><li>ftrace 로그 출력</li><li>워커 풀에 워크의 연결리스트를 등록하고 워커 스레드 깨우기</li></ul></li><li><p>get_work_pool()</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span><span style=color:#a6e22e>get_work_pool</span>(<span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
{
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> data <span style=color:#f92672>=</span> atomic_long_read(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>data);
  <span style=color:#66d9ef>int</span> pool_id;

  assert_rcu_or_pool_mutex();

  <span style=color:#66d9ef>if</span> (data <span style=color:#f92672>&amp;</span> WORK_STRUCT_PWQ)
    <span style=color:#66d9ef>return</span> ((<span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>)
      (data <span style=color:#f92672>&amp;</span> WORK_STRUCT_WQ_DATA_MASK))<span style=color:#f92672>-&gt;</span>pool;

  pool_id <span style=color:#f92672>=</span> data <span style=color:#f92672>&gt;&gt;</span> WORK_OFFQ_POOL_SHIFT;
  <span style=color:#66d9ef>if</span> (pool_id <span style=color:#f92672>==</span> WORK_OFFQ_POOL_NONE)
    <span style=color:#66d9ef>return</span> NULL;

  <span style=color:#66d9ef>return</span> idr_find(<span style=color:#f92672>&amp;</span>worker_pool_idr, pool_id);
}
</code></pre></div></li><li><p>insert_work()</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert_work</span>(<span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>pwq, <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work,
                     <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> extra_flags)
{
  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> pwq<span style=color:#f92672>-&gt;</span>pool;

  set_work_pwq(work, pwq, extra_flags);
  list_add_tail(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>entry, head);
  get_pwq(pwq);

  smp_mb();

  <span style=color:#66d9ef>if</span> (__need_more_worker(pool))
    wake_up_worker(pool);
}
</code></pre></div></li><li><p>wake_up_worker()</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wake_up_worker</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
{
  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> first_idle_worker(pool);

  <span style=color:#66d9ef>if</span> (likely(worker))
    wake_up_process(worker<span style=color:#f92672>-&gt;</span>task);
}
</code></pre></div></li><li><p>find_worker_executing_work()</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span><span style=color:#a6e22e>find_worker_executing_work</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool,
                                                <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
{
  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker;

  hash_for_each_possible(pool<span style=color:#f92672>-&gt;</span>busy_hash, worker, hentry,
                      (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)work)
    <span style=color:#66d9ef>if</span> (worker<span style=color:#f92672>-&gt;</span>current_work <span style=color:#f92672>==</span> work <span style=color:#f92672>&amp;&amp;</span>
          worker<span style=color:#f92672>-&gt;</span>current_func <span style=color:#f92672>==</span> work<span style=color:#f92672>-&gt;</span>func)
      <span style=color:#66d9ef>return</span> worker;

  <span style=color:#66d9ef>return</span> NULL;
}
</code></pre></div></li></ul><h5 id=워크의-실행-주체>워크의 실행 주체</h5><ul><li>워커 스레드, 워크를 워크큐에 큐잉하면 워커 스레드를 깨운다.</li><li>worker_thread()<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>worker_thread</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>__worker)
{
  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> __worker;
  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>pool;

  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>do</span> {
    <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span>
      list_first_entry(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worklist,
        <span style=color:#66d9ef>struct</span> work_struct, entry);

    pool<span style=color:#f92672>-&gt;</span>watchdog_ts <span style=color:#f92672>=</span> jiffies;

    <span style=color:#66d9ef>if</span> (likely(<span style=color:#f92672>!</span>(<span style=color:#f92672>*</span>work_data_bits(work) <span style=color:#f92672>&amp;</span> WORK_STRUCT_LINKED))) {
      <span style=color:#75715e>/* optimization path, not strictly necessary */</span>
      process_one_work(worker, work);
      <span style=color:#66d9ef>if</span> (unlikely(<span style=color:#f92672>!</span>list_empty(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled)))
        process_scheduled_works(worker);
    } <span style=color:#66d9ef>else</span> {
      move_linked_works(work, <span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled, NULL);
      process_scheduled_works(worker);
    }
  } <span style=color:#66d9ef>while</span> (keep_working(pool));
}
</code></pre></div><ul><li>keep_working() : 이미 큐잉된 워크가 있으면 true를 반환하는 역할<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>keep_working</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
{
  <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>list_empty(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worklist) <span style=color:#f92672>&amp;&amp;</span>
    atomic_read(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>nr_running) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></div></li><li>워커 풀에 워크가 큐잉됐는지 체크한다.</li><li>워커 풀에 큐잉된 워크의 연결 리스트를 가져와 워크 구조체를 알아낸다.</li><li>process_one_work() 함수를 호출해 워크를 실행한다.</li></ul></li><li>process_one_work()<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process_one_work</span>(<span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker. <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
__releases(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock)
__acquires(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock)
{
  <span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>pwq <span style=color:#f92672>=</span> get_work_pwq(work);
  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>pool;
  <span style=color:#66d9ef>bool</span> cpu_intensive <span style=color:#f92672>=</span> pwq<span style=color:#f92672>-&gt;</span>wq<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WQ_CPU_INTENSIVE;
  <span style=color:#66d9ef>int</span> work_color;
  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>collision;
  <span style=color:#75715e>/* skip */</span>
  collision <span style=color:#f92672>=</span> find_worker_executing_work(pool, work);
  <span style=color:#66d9ef>if</span> (unlikely(collision)) {
    move_linked_works(work, <span style=color:#f92672>&amp;</span>collision<span style=color:#f92672>-&gt;</span>scheduled, NULL);
    <span style=color:#66d9ef>return</span>;
  }

  <span style=color:#75715e>/* claim and dequeue */</span>
  debug_work_deactivate(work);
  hash_add(pool<span style=color:#f92672>-&gt;</span>busy_hash, <span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>hentry, (unsgined <span style=color:#66d9ef>long</span>)work);
  worker<span style=color:#f92672>-&gt;</span>current_work <span style=color:#f92672>=</span> work;
  worker<span style=color:#f92672>-&gt;</span>current_func <span style=color:#f92672>=</span> work<span style=color:#f92672>-&gt;</span>func;
  worker<span style=color:#f92672>-&gt;</span>current_pwq <span style=color:#f92672>=</span> pwq;
  work_color <span style=color:#f92672>=</span> get_work_color(work);
  <span style=color:#75715e>/* skip */</span>

  list_del_init(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>entry);
  <span style=color:#75715e>/* skip */</span>

  set_work_pool_and_clear_pending(work, pool<span style=color:#f92672>-&gt;</span>id);
  <span style=color:#75715e>/* skip */</span>

  trace_workqueue_execute_start(work);
  worker<span style=color:#f92672>-&gt;</span>current_func(work);
  trace_workqueue_execute_end(work);
  <span style=color:#75715e>/* skip */</span>
  <span style=color:#66d9ef>if</span> (unlikely(in_atomic() <span style=color:#f92672>||</span> lockdep_depth(current) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
    pr_err(<span style=color:#e6db74>&#34;BUG: workqueue leaked lock or atomic: %s/0x%08x/%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
      <span style=color:#e6db74>&#34;last function: %pf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
      current<span style=color:#f92672>-&gt;</span>comm, prempt_count(), task_pid_nr(current),
      worker<span style=color:#f92672>-&gt;</span>current_func);
      debug_show_held_locks(current);
      dump_stack();
  }
}
</code></pre></div><ul><li>워크 전처리 : 하나의 워크를 여러 워커에서 실행하지 않도록 관리</li><li>워크 핸들러 실행</li></ul></li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=makerdark98/makerdark98.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><footer><p class="copyright text-muted">© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/calintat/minimal>Minimal</a>.</p></footer></body></html>