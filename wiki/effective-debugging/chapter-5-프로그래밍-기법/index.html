<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Effective Debugging/Chapter 5. 프로그래밍 기법</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent: #00a3d2;--border-width:  5px }</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on('click',function(){$('.collapse').collapse('hide');})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-98056974-1');</script><script>window.MathJax={jax:["input/TeX","output/CommonHTML"],extensions:["tex2jax.js","asciimath2jax.js","mml2jax.js","MathMenu.js","MathZoom.js"],TeX:{extensions:["AMSmath.js","AMSsymbols.js","autoload-all.js"]},tex2jax:{inlineMath:[['$','$'],["\\(","\\)"]],processEscapes:true},showProcessingMessages:false,messageStyle:"none",menuSettings:{zoom:"Click"},AuthorInit:function(){MathJax.Hub.Register.StartupHook("End",function(){var timeout=false,delay=250;var shrinkMath=function(){var dispFormulas=document.getElementsByClassName("formula");if(dispFormulas){var contentTest=document.getElementsByTagName("body")[0];var nodesWidth=contentTest.offsetWidth;var mathIndent=MathJax.Hub.config.displayIndent;var mathIndentValue=mathIndent.substring(0,mathIndent.length-2);for(var i=0;i<dispFormulas.length;i++){var dispFormula=dispFormulas[i];var wrapper=dispFormula.getElementsByClassName("MathJax_Preview")[0].nextSibling;var child=wrapper.firstChild;wrapper.style.transformOrigin="center";var oldScale=child.style.transform;var newValue=Math.min(0.80*dispFormula.offsetWidth/child.offsetWidth,1.0).toFixed(2);var newScale="scale("+newValue+")";if(!(newScale===oldScale)){wrapper.style.transform=newScale;wrapper.style["margin-left"]=Math.pow(newValue,4)*mathIndentValue+"px";var wrapperStyle=window.getComputedStyle(wrapper);var wrapperHeight=parseFloat(wrapperStyle.height);wrapper.style.height=""+(wrapperHeight*newValue)+"px";if(newValue==="1.00"){wrapper.style.cursor="";wrapper.style.height="";}
else{wrapper.style.cursor="zoom-in";}}}}};shrinkMath();window.addEventListener('resize',function(){clearTimeout(timeout);timeout=setTimeout(shrinkMath,delay);});});}};(function(d,script){script=d.createElement('script');script.type='text/javascript';script.async=true;script.onload=function(){};script.src='https://cdn.mathjax.org/mathjax/latest/MathJax.js';d.getElementsByTagName('head')[0].appendChild(script);}(document));</script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>Effective Debugging/Chapter 5. 프로그래밍 기법</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:makerdark98@gmail.com><i class="fa fa-envelope-o"></i></a></li><li class=navbar-icon><a href=https://github.com/makerdark98/><i class="fa fa-github"></i></a></li><li><div style=max-width:250px;display:inline-block;max-height:40px><script async src="https://cse.google.com/cse.js?cx=003491619885022567520:wnnypdnx4aj"></script><div class=gcse-search></div></div></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><a href=/wiki/><button class="btn btn-link"><i class="fa fa-arrow-left"></i>&nbsp;Front Page</button></a></div><div style=margin-left:auto><div style=display:flex><div style=margin-left:auto><div class=wiki-history></div></div></div><script src=/js/localhistory.js></script><script>var now="Chapter 5- 프로그래밍 기법"
pushHistory(now);</script></div></div><div><h2>Effective Debugging/Chapter 5. 프로그래밍 기법</h2><a href=https://github.com/makerdark98/makerdark98.github.io/blame/master/src/content/wiki/Effective%20Debugging/Chapter%205-%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d%20%ea%b8%b0%eb%b2%95.md><h5>created : Tue, 07 Apr 2020 20:44:40 +0900</h5><h5>modified : Thu, 09 Apr 2020 21:48:01 +0900</h5></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#item-38-의심스런-코드를-검토하고-손으로-실행해보기>Item 38. 의심스런 코드를 검토하고 손으로 실행해보기</a></li><li><a href=#item-39-동료-검토하기>Item 39. 동료 검토하기</a></li><li><a href=#item-40-디버깅-기능-추가하기>Item 40. 디버깅 기능 추가하기</a></li><li><a href=#item-41--로그-남기기>Item 41. 로그 남기기</a></li><li><a href=#item-42-단위-테스트-사용하기>Item 42. 단위 테스트 사용하기</a></li><li><a href=#item-42-assertion-사용하기>Item 42. Assertion 사용하기</a><ul><li><a href=#기억할-사항>기억할 사항</a></li></ul></li><li><a href=#item-44-코드를-바꿔보면서-검증하기>Item 44. 코드를 바꿔보면서 검증하기</a><ul><li><a href=#기억할-사항-1>기억할 사항</a></li></ul></li><li><a href=#item-45-정상적인-코드와-문제가-발생한-코드의-차이점-줄이기>Item 45. 정상적인 코드와 문제가 발생한 코드의 차이점 줄이기</a></li><li><a href=#item-46-의심스런-코드-간소화하기>Item 46. 의심스런 코드 간소화하기</a></li><li><a href=#item-47-의심스런-코드를-다른-언어로-작성해보기>Item 47. 의심스런 코드를 다른 언어로 작성해보기</a></li><li><a href=#item-48-의심스런-코드의-가독성과-구조-향상시키기>Item 48. 의심스런 코드의 가독성과 구조 향상시키기</a><ul><li><a href=#기억할-사항-2>기억할 사항</a></li></ul></li><li><a href=#item-49-버그의-증상이-아닌-원인-고치기>Item 49. 버그의 증상이 아닌 원인 고치기</a><ul><li><a href=#버그의-증상만을-고치는-예시>버그의 증상만을 고치는 예시</a></li><li><a href=#위와-같이-증상만을-없앨-경우-문제>위와 같이 증상만을 없앨 경우 문제</a></li><li><a href=#기억할-사항-3>기억할 사항</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=item-38-의심스런-코드를-검토하고-손으로-실행해보기>Item 38. 의심스런 코드를 검토하고 손으로 실행해보기</h2><ul><li>코드를 작성할 때 흔히 저지르는 실수를 하지 않았는지 살펴본다.</li><li>코드가 정확하게 동작하는지 직접 손으로 실행해서 확인한다.</li><li>복잡한 자료구조는 그림으로 쉽게 표현한다.</li><li>복잡한 코드를 쉽게 표현할 때는 종이나 화이트보드의 공간을 넉넉히 확보하고 색깔도 적절히 활용한다.</li><li>실제 물체를 활용하면 문제에 좀 더 집중할 수 있다.</li></ul><h2 id=item-39-동료-검토하기>Item 39. 동료 검토하기</h2><ul><li>자신이 작성한 코드를 고무 오리에게 설명한다.</li><li>동료 검토를 비롯한 코드 리뷰 과정을 거친다.</li><li>다양한 개체가 엮인 코드에서 발생한 오류를 디버익할 떄는 역할 놀이 방식을 적용한다.</li></ul><h2 id=item-40-디버깅-기능-추가하기>Item 40. 디버깅 기능 추가하기</h2><ul><li>작성하는 프로그램에 디버그 모드로 진입하는 옵션을 추가한다.</li><li>프로그램의 상태를 조작하고, 연산의 수행 과정을 로그로 남기고, 런타임 복잡도를 줄이고, 사용자 인터페이스 ㅐ비게이션 과정을 건너뛰고, 복잡한 자료구조를 화면에 표시하는 명령을 추가한다.</li><li>임베디드 장치나 서버를 디버깅할 수 있도록 명령줄 인터페이스, 웹 인터페이스, 시리얼 인터페이스 등을 제공한다.</li><li>외부 오류 상황을 재현할 수 있는 디버그 모드 명령을 추가한다.</li></ul><h2 id=item-41--로그-남기기>Item 41. 로그 남기기</h2><ul><li>로그를 남기는 문장을 추가하여 지속적으로 관리할 수 있는 형태의 디버깅 infrastructure를 구축한다.</li><li>로깅 프레임워크를 처음부터 새로 만들지 말고 가급적 기존에 나와 있는 것을 활용한다.</li><li>로그로 남기고 싶은 주제와 세부 사항을 로깅 프레임워크에서 적절히 설정한다.</li></ul><h2 id=item-42-단위-테스트-사용하기>Item 42. 단위 테스트 사용하기</h2><ul><li>단위 테스트를 통해 의심 가는 루틴을 검색하여 오류가 발생한 지점을 정확히 찾아낸다.</li><li>단위 테스트 작업의 효율을 높이도록, 적절한 단위 테스팅 프레임워크를 골라서 프로그램에 단위 테스트를 수행하는 코드를 추가하고, 자동으로 단위 테스트를 수행하도록 설정한다.</li></ul><h2 id=item-42-assertion-사용하기>Item 42. Assertion 사용하기</h2><ul><li>프로그램이 시작하는 지점에서 CPU의 아키텍쳐 종류에 관련된 속성을 검사하는 경우</li><li>루틴의 시작 시점에서 전달된 매개변수의 타입이 정확한지 그리고 유효한 값인지, 적절한 값으로 들어왔는지 등을 검사하는 경우</li><li>루틴이 끝나는 지점에서 겨로가가 정확한지 검사하는 경우</li><li>자주 호출되는 복잡한 메서드의 시작과 끝 부분에서 클래스의 상태가 일관성 있게 유지되는지 검사하는 경우</li><li>정상적으로 동작해야할 API 루틴을 호출한 뒤에 진짜 오류가 없는지 확인하는 경우</li><li>소프트웨어에서 사용할 자원을 불러온 뒤에 제대로 처리됐는지 확인하는 경우</li><li><code>switch</code>문의 default 케이스에서 assertion으로 처리하지 않는 나머지 모든 경우를 다루고 있는지 확인할 때</li><li>자료구조를 초기화한 후에 예상했던 값을 유지하고 있는지 확인할 때</li></ul><h3 id=기억할-사항>기억할 사항</h3><ul><li>단위 테스트에 assertion을 가미하면 오류가 발생한 지점을 더욱 정확히 찾아낼 수 있다.</li><li>복잡한 알고리즘을 디버깅할 때 assertion을 활용하여 선행 조건과 불변 속성과 후행 조건을 검사한다.</li><li>문서화를 위해 assertion을 사용하면 코드를 이해하기 쉬워지기 때문에 나중에 문제가 발생하여 디버깅하거나 테스트할 떄 도움된다.</li></ul><h2 id=item-44-코드를-바꿔보면서-검증하기>Item 44. 코드를 바꿔보면서 검증하기</h2><p>다음과 같은 질문을 해보기</p><ul><li>이 루틴의 매개변수로 null이 전달될 수 있는가?</li><li>변수의 값이 999ms 이상일 경우에도 코드가 정확하게 작동하는가?</li><li>이 루틴에 진입하면서 lock이 걸리면 경고 메시지가 로그에 기록되는가?</li><li>현재 나타난 문제가 메서드들을 호출하는 순서와 관련이 있는가?</li><li>현재 사용하는 API보다 더 잘 작동하는 API는 없는가?</li></ul><h3 id=기억할-사항-1>기억할 사항</h3><ul><li>코드에 나온 값이 정확한지 확인하기 위해 다른 값으로 직접 변경해본다.</li><li>어떤 방식으로 코드를 작성해야 할지에 대한 가이드를 찾을 수 없다면 직접 여러 방법으로 구현해서 비교한다.</li></ul><h2 id=item-45-정상적인-코드와-문제가-발생한-코드의-차이점-줄이기>Item 45. 정상적인 코드와 문제가 발생한 코드의 차이점 줄이기</h2><ul><li>오류를 발생시킨 요소를 찾으려면 정상 작동하는 예제와 일치할 때까지 코드를 점진적으로 가지치기하거나, 반대로 정상 작동하는 예제가 오류가 발생한 코드와 비슷해질 때까지 수정하는 방식으로 진행한다.</li></ul><h2 id=item-46-의심스런-코드-간소화하기>Item 46. 의심스런 코드 간소화하기</h2><ul><li>코드에 존재하는 오류가 더욱 잘 드러나도록, 커다란 코드 블록 덩어리를 잘 선별하여 가지치기한다.</li><li>코드의 실행 상태를 살펴보거나 테스트하기 쉽도록 복잡한 문장이나 함수를 잘게 쪼갠다.</li><li>복잡하고 버그가 많은 알고리즘을 좀 더 간결한 알고리즘으로 대체하는 방법을 찾아본다.</li></ul><h2 id=item-47-의심스런-코드를-다른-언어로-작성해보기>Item 47. 의심스런 코드를 다른 언어로 작성해보기</h2><ul><li>더 이상 오류를 해결하기 힘들 떄는 코드에서 발생할 수 있는 오류를 최대한 줄일 수 있도록 좀 더 표현력이 뛰어난 언어로 다시 작성해본다.</li><li>풍부한 디버깅 기능을 활용할 수 있도록 프로그래밍 환경을 개선한 뒤 오류가 있는 코드를 여기서 실행해본다.</li><li>제대로 작동하는 대체 구현을 확보했다면 이를 직접 활용하거나 기존 코드의 오류를 찾아내기 위한 참고용으로 활용한다.</li></ul><h2 id=item-48-의심스런-코드의-가독성과-구조-향상시키기>Item 48. 의심스런 코드의 가독성과 구조 향상시키기</h2><ul><li>산탄총으로 수술하기(shortgun surgery) 패턴<ul><li>변경해야 할 필드와 메서드를 모두 동일한 클래스에 옮긴 다음 이들이 서로 일관성 있게 구성되어 있는지 확인해본다.</li></ul></li><li>데이터 덩어리(data clumps) 패턴<ul><li>매개변수나 반환값을 표현할 떄 하나의 클래스에 담아서 전달한다.</li></ul></li><li>기본적으로 제공하는 자료형만으로 값을 표기하지 말고 새롭게 정의한다.</li><li>인터페이스를 여러가지 방식으로 표현할때 일관성있게 비슷한 스타일로 표현한다.</li><li>루틴에 코드를 너무 많이 담지 않는다.</li><li>쓸데없이 친한코드를 제거한다.<ul><li><code>account.getWoner().getName()</code>을 <code>account.getOwnerName()</code>이라는 위임 메서드로 표현한다.</li></ul></li><li>데드 코드와 추측으로 일반화한 코드를 제거한다.</li></ul><h3 id=기억할-사항-2>기억할 사항</h3><ul><li>에러 패턴이 눈에 띄기 쉽도록 코드의 포맷을 일관성 있게 맞춘다.</li><li>잘못 작성되거나 쓸데없이 복잡한 코드 속에 숨어 있는 버그가 드러나도록 코드를 리팩토링한다.</li></ul><h2 id=item-49-버그의-증상이-아닌-원인-고치기>Item 49. 버그의 증상이 아닌 원인 고치기</h2><h3 id=버그의-증상만을-고치는-예시>버그의 증상만을 고치는 예시</h3><ul><li><p>널 포인터 참조 값 사용 피하기</p><p>if (p != null)
p.aMethod();</p></li><li><p>0으로 나누기 피하기</p><p>if (nVehicleWheels == 0)
return weight;
else
return weight / nVehicleWheels;</p></li><li><p>잘못된 숫자를 논리적인 버위에 억지로 집어넣기</p><p>a = surfaceArea()
if (a &lt; 0)
a = 0;</p></li><li><p>잘려진 성(surname) 고치기</p><p>if (surname.equals(&ldquo;Wolfeschlegelsteinha&rdquo;))
surname = &ldquo;Wolfeshlegelsteinhausenbergerdorff&rdquo;;</p></li></ul><h3 id=위와-같이-증상만을-없앨-경우-문제>위와 같이 증상만을 없앨 경우 문제</h3><ul><li>몇 가지 기능을 끊어 버리는 방식으로 버그를 해결하면 더욱 찾기 힘든 버그가 나타날 가능성이 높아진다.</li><li>근본 원인을 수정하지 않으면 버그로 인해 발생하는 현상 중에서 잘 드러나지 않는 것들은 그대로 남아 있기 때문에 나중에 다시 나타날 때는 더욱 교묘하게 숨은 형태로 나타날 수 있다.</li><li>프로그램의 코드가 쓸데없이 복잡해져서 이해하거나 수정하기 힘들어진다.</li><li>임시방편으로 수정하면 버그로 인해 나타나는 현상이 사라져서 근본 원인을 찾기가 더 어려워진다. 이를테면, 근본 원인의 실마리가 되는 충돌 현상을 숨겨버리면 디버깅이 힘들어진다.</li></ul><h3 id=기억할-사항-3>기억할 사항</h3><ul><li>절대로 코드의 증상만 피해가는 방식으로 수정하지 말고 근본 원인을 찾아서 고친다.</li><li>특수한 경우에 대한 문제만 해결하지 말고 가능하면 복잡한 경우의 수를 일반화한다.</li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=makerdark98/makerdark98.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><footer><p class="copyright text-muted">© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/calintat/minimal>Minimal</a>.</p></footer></body></html>