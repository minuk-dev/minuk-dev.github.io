<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Mastering-OpenTelemetry-And-Observability</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>Mastering-OpenTelemetry-And-Observability
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><a href=/wiki/><button class="btn btn-link"><i class="fa fa-arrow-left"></i>&nbsp;Front Page</button></a></div></div><div><h2>Mastering-OpenTelemetry-And-Observability</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/Mastering-OpenTelemetry-And-Observability.md><h5>created : Sat, 12 Apr 2025 22:55:34 +0900</h5><h5>modified : Tue, 15 Apr 2025 01:19:00 +0900</h5></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#chapter-1-what-is-observability>Chapter 1. What Is Observability?</a><ul><li><a href=#definition>Definition</a></li><li><a href=#cloud-native-era>Cloud Native Era</a></li><li><a href=#monitoring-compared-to-observability>Monitoring Compared to Observability</a></li><li><a href=#metadata>Metadata</a></li><li><a href=#collecting-signals>Collecting Signals</a></li><li><a href=#push-versus-pull-collection>Push Versus Pull Collection</a></li><li><a href=#data-collection>Data Collection</a></li><li><a href=#sampling-signals>Sampling Signals</a></li><li><a href=#observability>Observability</a></li><li><a href=#application-performance-monitoring>Application Performance Monitoring</a></li></ul></li><li><a href=#chapter-2-introducing-opentelemetry>Chapter 2. Introducing OpenTelemetry</a><ul><li><a href=#background>Background</a></li><li><a href=#instrumentation-1>Instrumentation</a></li><li><a href=#opentelemetry-concepts>OpenTelemetry Concepts</a></li><li><a href=#the-bottom-line-1>The Bottom Line</a></li></ul></li><li><a href=#chapter-3-getting-started-with-the-astronomy-shop>Chapter 3. Getting Started with the Astronomy Shop</a></li><li><a href=#chapter-4-understanding-the-opentelemetry-specification>Chapter 4. Understanding the OpenTelemetry Specification</a><ul><li><a href=#api-specification>API Specification</a></li><li><a href=#api-definition>API Definition</a></li><li><a href=#sdk-implementation>SDK Implementation</a></li><li><a href=#data-specification>Data Specification</a></li><li><a href=#general-specification>General Specification</a></li><li><a href=#the-bottom-line-2>The Bottom Line</a></li></ul></li><li><a href=#chapter-5-managing-the-opentelemetry-collector>Chapter 5. Managing the OpenTelemetry Collector</a><ul><li><a href=#deployment-modes>Deployment Modes</a></li><li><a href=#configuration>Configuration</a></li><li><a href=#extensions>Extensions</a></li><li><a href=#connectors>Connectors</a></li><li><a href=#observing>Observing</a></li><li><a href=#troubleshooting>Troubleshooting</a></li></ul></li><li><a href=#beyond-the-basics>Beyond the Basics</a><ul><li><a href=#distributions-1>Distributions</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h1 id=mastring-opentelemetry-and-obserability>Mastring OpenTelemetry And Obserability</h1><ul><li>Enhancing Application and Infrastructure Performance and Avoiding Outages</li><li>Terms:<ul><li>Backend: The data access layer of an application, which often includes processing and persistence of data.</li><li>Framework: A structure on which other things are built.<ul><li>OTel is a telemetry framework that can be extended to support various use cases.</li></ul></li><li>Frontend: The presentation layer of an application, which is often a user interface of user-facing way to interact with an application.</li><li>Instrumentation: Software added to an application to generate telemetry data. Various forms of instrumentation are available, including automatic, which is injected at runtime, manual, which is added with the existing code, and programmatic, which is a particular form of manual instrumenation where specific libraries or frameworks have already been instrumented.</li><li>Platform: An environment in which software is executed. An observability or monitoring platform typically consists of one or more backend and frontend components.</li><li>Telemetry: Data used to determine the health, performance, and usage of applications.</li></ul></li></ul><h2 id=chapter-1-what-is-observability>Chapter 1. What Is Observability?</h2><h3 id=definition>Definition</h3><ul><li>Observability is a system property that defines the degree to which the system can generate actionable insights. It allows users to understand a system&rsquo;s state from these external outputs and take (corrective) action.<ul><li>ref. <a href=https://glossary.cncf.io/observability/>https://glossary.cncf.io/observability/</a></li></ul></li><li>The goal of observability should be where a system&rsquo;s state can be fully understood from its external output without the need to ship code.</li><li>Observability is not just about collecting data but about collecting meaningful data.</li><li>A system is truly observable when you can troubleshoot without prior knowledge of the system.</li></ul><h3 id=cloud-native-era>Cloud Native Era</h3><h3 id=monitoring-compared-to-observability>Monitoring Compared to Observability</h3><ul><li>The data collection needs to be added before issues happen; otherwise, you cannot proactively determine nor quickly resolve the problems as the arise.</li></ul><h4 id=types-of-monitoring>Types of Monitoring</h4><ul><li>White box monitoring</li><li>Blackbox-monitoring</li></ul><hr><ul><li>Due to the difficulty in troubleshooting mircroservice-based architectures, a popular meme was shared throughout the community:<ul><li>We replaced our monolith with micro services so that every outage could be more like a murder mystery.</li></ul></li></ul><h3 id=metadata>Metadata</h3><h4 id=dimensionality>Dimensionality</h4><ul><li>Dimensionality refres to the number of unique keys</li></ul><h4 id=cardinality>Cardinality</h4><ul><li>Cardinality refres to the number of unique values for a given key within a set.</li></ul><h4 id=semantice-conventions>Semantice Conventions</h4><ul><li>semconvs are standardized dimensions, or keys, for metadata and ensure consistency in how data is recorded, labeled, and interpreted across different systems and services.</li></ul><h4 id=data-sensitivity>Data Sensitivity</h4><ul><li>Metadata can contain sensitive information.</li></ul><h4 id=signals>Signals</h4><ul><li>MELT: metrics, events, logs, and traces</li></ul><h4 id=metrics>Metrics</h4><ul><li>RED: requests, error, and duration</li><li>USE: Utilization, saturation, and erros</li><li>Four golden signals: latency, traffic, errors, saturation</li></ul><h4 id=logs>Logs</h4><ul><li>Structured</li><li>Unstructured</li></ul><h4 id=traces>Traces</h4><ul><li>A trace is a recording of a time-based transaction or end-to-end request with metadata</li><li>Head-based</li><li>Tail based</li></ul><h4 id=other-signals>Other Signals</h4><ul><li>Baggage: metadata passed between spans that must be explicitly added to signals.</li><li>Sessions: used in Real User Monitoring (RUM) to analyze user experience (UX)</li><li>Profiles</li></ul><h3 id=collecting-signals>Collecting Signals</h3><ul><li>Metrics emit small payloads at very frequent intervals. As a result, performance is critical. Metrics are usually not collected nor sent anywhere by default. While it is easy to add metrics and many frameworks exist, most metrics do not contain context or correlation information.</li><li>Logs can contain richer information than metrics but, as a result, have larger payloads, and parsing requires proper formatting. Logs are usually written to a destination like a disk or a remote solution. While frameworks exist to add logs to applications, developers add most logging manually. Likce metrics, most logs do not contain context or correlation.</li><li>Traces are similar to logs. While they are easier to parse, it requires assembling an entire trace to realize the full potential. Traces require passing a context (typically a header) between request. In addition, adding trace instrumentation is often significantly more challenging than metrics or logs. Trace payloads are as big, if not bigger, than logs and are frequently sampled.</li></ul><h4 id=instrumentation>Instrumentation</h4><ul><li>Manual, Automatic, Via an instrumentation library</li></ul><h3 id=push-versus-pull-collection>Push Versus Pull Collection</h3><ul><li>Cloud native workloads, pull is most common for metrics</li></ul><h3 id=data-collection>Data Collection</h3><ul><li>Simplicity, Efficiency, Middle ground, Consistency</li></ul><h3 id=sampling-signals>Sampling Signals</h3><ul><li>Filtering</li><li>Sampling</li></ul><h3 id=observability>Observability</h3><ul><li>Scalability</li><li>Reliability</li><li>User experience</li><li>Ease of use</li><li>Performance</li><li>Security</li><li>Cost</li><li>Lock-in</li></ul><h3 id=application-performance-monitoring>Application Performance Monitoring</h3><h4 id=the-bottom-line>The Bottom Line</h4><ul><li>Differentiate between monitoring and observability<ul><li>What is the difference between a &ldquo;Known known&rdquo; and &ldquo;unknown unknown&rdquo;</li></ul></li><li>Explain the importance of metadata<ul><li>What are the differences between dimensionality, cardinality, and semantic conventions?</li></ul></li><li>Identify the differences between telemetry signals.<ul><li>Why are there at least three separate ways to collect telemetry data from applications?</li></ul></li><li>Distinguish between instrumentation and data collection.<ul><li>Given instrumentation, why is data collection necessary?</li></ul></li><li>Analyze the requirements for choosing an observability platform<ul><li>How are observability platforms different from APM?</li></ul></li></ul><h2 id=chapter-2-introducing-opentelemetry>Chapter 2. Introducing OpenTelemetry</h2><h3 id=background>Background</h3><h4 id=observability-pain-points>Observability Pain Points</h4><ul><li>Inconsistent features</li><li>vendor lock-in</li><li>Supportability and security concerns</li><li>Duplication among vendors</li><li>Lack of standardization, including context and correlation across signals and semantic conventions (semconvs)</li></ul><h4 id=the-rise-of-open-source-software>The Rise of Open Source Software</h4><h4 id=specification>Specification</h4><ul><li>Data specification: Used to define implementation guidance, data models, semconvs, and protocols</li><li>API Specification: Used to define the instrumentation interface standard for applications</li><li>SDK Specification: Used to define the standard for processing and exporting signals provided by the API specification</li><li>Versioning and Stabability: SUed to define versioning scheme and support gurantees</li></ul><h4 id=data-collection-1>Data Collection</h4><ul><li>The OTel Collector is a significant component and primary data collection mechanism in the Otel Project.</li><li>Otel collector supports:<ul><li>A robust and extensible architecture to receive, process, and export traces, metrics, and logs</li><li>A variety of form factors, including agent and edge processing as well as push and pull collection mechanism</li><li>A variety of integrations, including Prometheus, Fluent Bit, Apache Arrow, and eBPF, to name a few</li></ul></li></ul><h3 id=instrumentation-1>Instrumentation</h3><ul><li>Supports:<ul><li>A robust and extensive architecture to generate, process, and export signals</li><li>A single instrumentation solution for more than ten languages that supports traces, metrics, and logs.</li><li>Manual and automatic instrumentation</li></ul></li></ul><h3 id=opentelemetry-concepts>OpenTelemetry Concepts</h3><h4 id=distributions>Distributions</h4><h4 id=pipelines>Pipelines</h4><ul><li>Instrumentation: Providers, Generators, Processors, Exporters</li><li>Collector: Receivers or Connectors, Processors, Exporters or Connectors</li></ul><h4 id=resources>Resources</h4><ul><li>Cloud Provider: In develpment</li><li>Compute Unit: In development</li><li>Compute Instance: In develpment</li><li>Environment: In develpment</li><li>Service: Mixed (service.name and service.version stable)</li><li>Telemetry: Mixed (telemetry.sdk.* stable)</li></ul><h4 id=registry>Registry</h4><ul><li>Automatic instrumentation for specific frameworks and languages</li><li>Instrumentation and Collector components, including generators, receivers, processors, exporters, and extensions. Vendoer components are listed here as well as components for other open source projects.</li><li>OTel components for instrumentation languages not hostsed by OTel, including Crystal, Dart, Haskell, Kotlin, Ocamel, Perl, and Scalar.</li></ul><h4 id=roadmap>Roadmap</h4><ul><li>1 traces, 2 metrics, 3 logs</li><li>No plans for creating a major version of OpenTelemetry (API) past v1.0</li></ul><h3 id=the-bottom-line-1>The Bottom Line</h3><ul><li>Recognize observability problems and the need for open standards.:<ul><li>What is an open stardard and why does it matter?</li></ul></li><li>Explain the history and goals of the OpenTelemetry project:<ul><li>What does the OTel project provides, and what does it intentionally not provide?</li></ul></li><li>Identify the OpenTelemetry components and project status:<ul><li>Is OTel generally available (GA) and production-ready?<ul><li><a href=https://github.com/open-telemetry/opentelemetry-collector/blob/main/docs/ga-roadmap.md>https://github.com/open-telemetry/opentelemetry-collector/blob/main/docs/ga-roadmap.md</a></li><li><a href=https://opentelemetry.io/community/roadmap/>https://opentelemetry.io/community/roadmap/</a></li></ul></li></ul></li></ul><h2 id=chapter-3-getting-started-with-the-astronomy-shop>Chapter 3. Getting Started with the Astronomy Shop</h2><h2 id=chapter-4-understanding-the-opentelemetry-specification>Chapter 4. Understanding the OpenTelemetry Specification</h2><h3 id=api-specification>API Specification</h3><h3 id=api-definition>API Definition</h3><h4 id=api-context>API Context</h4><h4 id=api-signals>API Signals</h4><ul><li><p>Traces support TracerProvider, Tracer, and Span</p></li><li><p>Metrics support MeterProvider, Meter, and Instrument.</p></li><li><p>Logs support LoggerProvider and Logger.</p></li><li><p>A Signal Provider is a stateful object that holds all the Signal Recorders.</p></li><li><p>An application should user a signal Signal Provider and may have one or more Signal Recorders.</p></li><li><p>A Signal Provider must provide a way to get its respective Signal Recorder</p></li><li><p>A Signal Provider must be the only way to create a Signal Recorder.</p></li><li><p>The interfaces supports by signals are vast and signal specific.</p></li></ul><h4 id=api-implementation>API Implementation</h4><h4 id=sdk-specification>SDK Specification</h4><ul><li>Signal-specific processors, exporters, and samplers</li><li>Configuration</li><li>Resources</li></ul><h4 id=sdk-definition>SDK Definition</h4><ul><li>Categories:<ul><li>Constructors are used by application owners and include configuration objects, environment variables, and SDK builders.</li><li>Plug-in interfaces are used by plug-in authors and include processors, exporters, and samplers.</li></ul></li><li>OTel SDK spec covers<ul><li>Configuration: OTel requires the SDK configuration be possible programmatically and via a file, while envrionment variables (envvars) are optional.</li><li>Resources: OTel requires taht the SDK provide access to a resource with at least semantic attributes with a default value. A resource is an &ldquo;immutable representation of the entity producing telemetry.&rdquo; Beyond the options to create and merge resources, resource detectors may be implemented to add metadata automatically.</li></ul></li></ul><h4 id=sdk-signals>SDK Signals</h4><ul><li>Signal Provider: Shutdown, Force Flush</li><li>Traces: OTLP, standard out, Jaeger, Zipkin</li><li>Metrics: OTLP, standard out, in-memory, and Prometheus</li><li>Logs: OTLP and standard out</li></ul><h3 id=sdk-implementation>SDK Implementation</h3><h3 id=data-specification>Data Specification</h3><ul><li>Data models: <a href=https://opentelemetry.io/docs/specs/otel/metrics/data-model>https://opentelemetry.io/docs/specs/otel/metrics/data-model</a></li><li>Protocols: <a href=https://opentelemetry.io/docs/specs/otel/protocol/>https://opentelemetry.io/docs/specs/otel/protocol/</a><ul><li><a href=https://opentelemetry.io/docs/specs/opamp/>https://opentelemetry.io/docs/specs/opamp/</a></li></ul></li><li>Semantic conventions: <a href=https://opentelemetry.io/docs/specs/otel/semantic-conventions>https://opentelemetry.io/docs/specs/otel/semantic-conventions</a></li></ul><h4 id=data-models>Data Models</h4><ul><li>OTel instruments have multiple proprties<ul><li>Additive, nonadditive, monotonic, or grouped</li><li>Synchronous or asynchronous</li></ul></li><li>Temporality is not applicable to the Last Value aggregation. Temporality is confugred when creating instrumentation. Beyond temporality, metrics can also be reaggregated in the following ways:<ul><li>Spatial: Used to reduce the number of attributes on a metric</li><li>Transformative: Used to change the temporality of metrics that are sum aggregated (cumulative to delta or vice versa)</li></ul></li><li>The metric instruments available in OTel, along with their associated properties, type, and default aggregation</li></ul><table><thead><tr><th>Instrument</th><th>Properties</th><th>Type</th><th>Default Aggregation</th></tr></thead><tbody><tr><td>Counter</td><td>Monotonic</td><td>Synchronous</td><td>Sum</td></tr><tr><td>UpDownCounter</td><td>Additive</td><td>Synchronous</td><td>Sum</td></tr><tr><td>ObserableCounter</td><td>Monotonic</td><td>Asynchronous</td><td>Sum</td></tr><tr><td>ObservableUpDownCounter</td><td>Addtive</td><td>Asynchrous</td><td>Sum</td></tr><tr><td>Gauge</td><td>Nonadditive</td><td>Synchronous</td><td>Last Value</td></tr><tr><td>Observable Gauge</td><td>Nondditive</td><td>Asynchronous</td><td>Last Value</td></tr><tr><td>Histogram</td><td>Grouped</td><td>Synchronous</td><td>Histogram</td></tr></tbody></table><ul><li>Field names available to log records and what they mean</li></ul><table><thead><tr><th>Field Name</th><th>Description</th><th>Notes</th></tr></thead><tbody><tr><td>Timestamp</td><td>When the event occurred</td><td>Common syslog concepts</td></tr><tr><td>ObservedTimestamp</td><td>When the event was observed</td><td></td></tr><tr><td>SeverityText</td><td>Log level</td><td></td></tr><tr><td>SeverityNumber</td><td>Numeric value of log level</td><td></td></tr><tr><td>Body</td><td>The message of the log record</td><td></td></tr><tr><td>Resource</td><td>Source information</td><td>OTel concept; metadata</td></tr><tr><td>Attributes</td><td>Additional information</td><td></td></tr><tr><td>InstrumentationScope</td><td>Scope that emitted the log record</td><td></td></tr><tr><td>TraceID</td><td>Request trace ID</td><td>Used to enable trace correlation</td></tr><tr><td>SpanId</td><td>Request span ID</td><td></td></tr><tr><td>TraceFlags</td><td>W3C trace flags</td><td></td></tr></tbody></table><h4 id=data-protocols>Data Protocols</h4><ul><li>OTLP</li></ul><h4 id=data-semantic-conventions>Data Semantic Conventions</h4><h4 id=data-compatibility>Data Compatibility</h4><ul><li>Trace: W3C, B3, and Jaeger context propagation</li><li>Metrics: Prometheus and OpenMetrics</li><li>Logs: Trace context in non-OTLP formats</li></ul><h3 id=general-specification>General Specification</h3><h3 id=the-bottom-line-2>The Bottom Line</h3><ul><li>Distinguish between OpenTelemetry versioning and stability, including support guarantees.<ul><li>What are the long-term support guarantees for OTel?</li></ul></li><li>Understand the OpenTelemetry data model, including protocol support and OTLP<ul><li>How is OTLP leveraged in OTel, and what value does it provide?</li></ul></li><li>Differentiate betwen the OpenTelemetry API and SDK<ul><li>Who or what typically implements the OTel API and SDK?</li></ul></li></ul><h2 id=chapter-5-managing-the-opentelemetry-collector>Chapter 5. Managing the OpenTelemetry Collector</h2><ul><li>All data received by a reciever is converted to OpenTelemetry Protocol (OTLP) protobuf structs.</li><li>By default, the Collector is stateless and keeps all data in memory.</li><li>OTel Pros:<ul><li>Open source and vendor-agnostic: The collector can transform data from any available receiver format to any available exporter format.</li><li>Extensible: The Collector supports observability data formats, including Jaeger, Prometheus, and OpenSearch, and can be extended to support future formats.</li><li>One agent for all signals: The collector is among the first to support trace, metrics, and logs in both agent and gateway modes.</li><li>Processing capabilities: The Collector offers a rich set of processing capabilities, which can be leveraged by any data that the Collector can receive.</li><li>Multiple destinations: One use case that most agents do not handle well is the ability to export the same data to two different platforms in parallel. The Collector fully supports this capability.</li><li>Fully OTel compliant: Given the Collector exists in the OTel project, it fully supports all OTel concepts, including signals, resources, and schemas.</li></ul></li></ul><h3 id=deployment-modes>Deployment Modes</h3><h4 id=agent-mode>Agent Mode</h4><ul><li>Stand-alone instance<ul><li>Unavailable:<ul><li>During an upgrade</li><li>During a restart</li><li>Improperly sized</li><li>Improperly configured</li></ul></li></ul></li></ul><h4 id=gateway-mode>Gateway Mode</h4><ul><li>Scenarios:<ul><li>You want to collect data from specific APIs, like the k8s API, or scrape a Prometheus server configured for federation</li><li>You want to leverage tail-based sampling.</li><li>You want to receive data from applications that do not support sending to an agent.</li><li>Your network configuration prevents agents from accessing the Internet and you leverage a cloud-based observability platform.</li><li>Your security team requires that API tokens be managed central and/or separated from agents.</li></ul></li></ul><table><thead><tr><th>Flow</th><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td>Instrumentation to observability platform</td><td>- Quickest time to value; simplicity.- Lowest latency.</td><td>- Less data processing flexibility and requires language-specific components, such as resource detection and configuration.- Operational complexity as each language and possibly each application needs to be independently configured.- Added resource requirements to handle processing, and buffer and retry logic.- Decentralized security controls.</td></tr><tr><td>Instrumentation to agent to observability platform</td><td>- Quick time to value, especially given that instrumentation sends data to a local OTLP destination by default.- Separates telemetry generation from transmission, reducing application load.Enhanced data processing capabilities and dynamic configuration without redploying applications.</td><td>- Agent is a single point of failure and must be sized and monitored properly.</td></tr><tr><td>Instrumentation to gateway to observability platform</td><td>- If a gateway cluster separates telemetry generation from transmission without a single point of failure.- Supports advanced data processing capabilities, including metric aggregation and tail-based sampling.- Useful in certain environments, such as serverless, where an agent deployment may not be possible.</td><td>- Cannot offload all application processing capabilities, including resource detection.- Requires thought when configuring pull-based receivers to ensure proper load balancing and no data duplication.- May introduce unacceptable latency, impacting applications.</td></tr><tr><td>Instrumentation to agent to gateway to observability platform</td><td>- The pros of agent and gateway mode. Supports the most use cases and requirements while providing the most data flexibility and portability.</td><td>- Complex configuration and highest management costs.</td></tr></tbody></table><h4 id=sizing>Sizing</h4><ul><li>Running complex regular expressions via configured processors against a large volume of data may result in an excessive amount of CPU being consumed. Optimizing the configuration to be more efficient or load balancing the data across a larger pool of smaller Collectors could help offset this issue.</li><li>Significant spikes in traffic, custom buffer and retry configurations, and the tail-based sampling processor may result in excessive amounts of memory being consumed, leading to the Collector restarting. Testing failure scenarios to understand Collector behavior and validating Collector configuration is vital.</li><li>Excessive logging or configuring the storage extension may consume all disk space. Monitoring and alerting against disk space can help mitigate this issue.</li></ul><h4 id=components>Components</h4><ul><li>Receivers</li><li>Processors</li><li>Exporters</li><li>Connectors</li><li>Extensions</li></ul><h3 id=configuration>Configuration</h3><ul><li><p>GOGC: default 100</p></li><li><p>GOMEMLIMIT: no default</p></li><li><p>Ballast extensions: deprecated. removed recommended</p></li><li><p>Important:</p><ul><li>The components available depend on the Collector distribution being rune.</li><li>Every component has a GItHub README that details status, supported signals, defaults, and configuration options.</li><li>Within service::pipeline, one ore more receivers and exporters and zero or more processors or connectors msut be defined per signal.</li><li>Not everything defined outside of the service section needs to be used in the service::pipelines section.</li><li>The components specified in a <code>service::pipelines::&lt;signal></code> must support the signal type.</li><li>More than one configuration can be passed to the Collector in which case configurations are merged.</li><li>You can use something defined outside of the service section in multiple service::pipelines.</li><li>The order in which <code>service::pipelines::&lt;signal>::processors</code> are defined determines the order in which processors are executed.</li><li>The same component and the same <code>service::pipelines::&lt;signal></code> can be defined multiple times by adding a forward slash followed by one more characters like <code>&lt;component>[/&lt;name>]</code>.</li></ul></li><li><p>otelbin</p><ul><li><a href=https://www.otelbin.io/>https://www.otelbin.io/</a></li></ul></li><li><p>Processors:</p><ul><li>Memory limiter: highly recommended</li></ul></li><li></li></ul><table><thead><tr><th>Category</th><th>Examples</th></tr></thead><tbody><tr><td>Metadata processing</td><td>- k8sattributesprocessor- resourceprocessor</td></tr><tr><td>Filtering, routing, and sampling</td><td>- filterprocessor- routingprocessor (fyi. deprecated router connector)- tailsamplingprocessor</td></tr><tr><td>Enriching</td><td>- k8sattributeprocessor- resourcedetection</td></tr><tr><td>Generating (primarily metrics)</td><td>- metricsgenerationprocessor- spanmetricsprocessor</td></tr><tr><td>Grouping (helpful in batching and processing)</td><td>- groupbyattrprocessor- groupbytraceprocessor (valid for tail-based sampling)</td></tr><tr><td>Transforming (primarily metrics)</td><td>- cumulativetodeltaprocessor- deltatorateprocessor- schemaprocessor</td></tr></tbody></table><ul><li>Order<ol><li>Memory limiter</li><li>Any filtering or sampling</li><li>Any processor relying on sending source from context (e.g. k8s attritubes)</li><li>batch</li><li>Any other processor, including CRUD metadata</li></ol></li></ul><h3 id=extensions>Extensions</h3><table><thead><tr><th>Category</th><th>Examples</th></tr></thead><tbody><tr><td>Authentication - Used by receivers and exporters</td><td>- basicauthextension- bearertokenauthextension- oidcauthextension</td></tr><tr><td>Health and Troubleshooting</td><td>- healthcheckextension- pprofextension- remotetapextension- zpagesextension</td></tr><tr><td>Observers - Used by receivers to discover and collect data dynamically</td><td>- dockerobserver- hostobserver- k8sobserver</td></tr><tr><td>Persistence - Via a database or filesystem</td><td>- storage/dbstorage- storage/filestorage</td></tr></tbody></table><h3 id=connectors>Connectors</h3><ul><li>Exceptions: Generating metrics or logs from span exceptions</li><li>Failover: Allows for health-based routing between trace, metric, and log pipelines, depending on the health of target downstream exporters</li><li>Service graph: Building a map representing the interrelationships between various services in a system</li></ul><h3 id=observing>Observing</h3><ul><li>Metrics</li><li>Health check extension</li><li>zPages extension</li></ul><h4 id=relevant-metrics>Relevant Metrics</h4><ul><li>Dropped data:<ul><li>otelcol_processor_dropped_spans</li><li>otelcol_processor_dropped_metric_points</li><li>otelcol_processor_dropped_log_records</li></ul></li><li>Queue length:<ul><li>otelcol_exporter_queue_capacity</li><li>otelcol_exporter_queue_size</li></ul></li><li>Enqueue failed:<ul><li>otelcol_exporter_enqueue_failed_spans</li><li>otelcol_exporter_enqueue_failed_metric_points</li><li>otelcol_exporter_enqueue_failed_log_records</li><li>Recevier refused:<ul><li>otelcol_receiver_refused_spans</li><li>otelcol_receiver_refused_metric_points</li><li>otelcol_receiver_refused_log_records</li></ul></li></ul></li><li>Exporter send faield:<ul><li>otelcol_exporter_send_failed_spans</li><li>otelcol_exporter_send_failed_metric_points</li><li>otelcol_exporter_send_failed_log_records</li></ul></li><li>CPU cors against a known rate:<ul><li>otelcol_receiver_accepted_spans</li><li>otelcol_receiver_accpeted_metric_points</li><li>otelcol_receiver_accpted_log_records</li></ul></li></ul><h3 id=troubleshooting>Troubleshooting</h3><h4 id=out-of-memory-crashes>Out of Memory crashes</h4><ul><li>Reasons:<ul><li>A misconfiguration<ul><li>GOGC, GOMEMLIMIT</li></ul></li><li>An improperly sized Collector</li><li>Using an alpha component</li></ul></li></ul><h4 id=data-not-being-received-or-exported>Data Not Being Received or Exported</h4><ul><li>Debug exporter</li><li>zPages extension</li></ul><h4 id=performance-issues>Performance Issues</h4><ul><li>Memory -> Go envrionment variables, memory limiter</li><li>CPU:<ul><li>alpha component which is not optizmied yet.</li><li>memory related: zPages</li></ul></li><li>pprof extension</li></ul><h2 id=beyond-the-basics>Beyond the Basics</h2><h3 id=distributions-1>Distributions</h3><ul><li>Core, Contrib, K8s</li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>