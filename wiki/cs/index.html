<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>cs 기본</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>cs 기본
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[study-note]]</button></div></div></div><div><h2>cs 기본</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/cs.md><h5>created : Wed, 28 Sep 2022 17:27:10 +0900</h5><h5>modified : Fri, 30 Sep 2022 19:46:40 +0900</h5></a><a href=https://minuk.dev/tags/cs><kbd class=item-tag>cs</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#정리-동기>정리 동기</a></li><li><a href=#algorithm>Algorithm</a><ul><li><a href=#selection-sort>Selection Sort</a></li><li><a href=#bubble-sort>Bubble Sort</a></li><li><a href=#merge-sort>Merge Sort</a></li><li><a href=#insertion-sort>Insertion Sort</a></li><li><a href=#quick-sort>Quick Sort</a></li><li><a href=#heap-sort>Heap Sort</a></li><li><a href=#lru-cache-least-recently-used>LRU Cache (Least Recently Used)</a></li></ul></li><li><a href=#operating-system>Operating System</a><ul><li><a href=#프로세스-쓰레드>프로세스, 쓰레드</a></li><li><a href=#multi-process-vs-multi-thread>Multi Process vs Multi Thread</a></li><li><a href=#동기화-문제>동기화 문제</a></li><li><a href=#context-switching>Context Switching</a></li><li><a href=#interrupt>Interrupt</a></li><li><a href=#deadlock>Deadlock</a></li><li><a href=#cpu-scheduling>CPU Scheduling</a></li><li><a href=#scheduler>Scheduler</a></li><li><a href=#paging-vs-segmentation>Paging vs Segmentation</a></li><li><a href=#페이지-교체-알고리즘>페이지 교체 알고리즘</a></li></ul></li><li><a href=#compiler>Compiler</a><ul><li><a href=#lexical-analyzer>Lexical Analyzer</a></li><li><a href=#syntax-analyzer>Syntax Analyzer</a></li><li><a href=#semantic-analyzer>Semantic Analyzer</a></li><li><a href=#immediate-code-generator>Immediate Code Generator</a></li><li><a href=#code-optimizer>Code Optimizer</a></li><li><a href=#code-generator>Code Generator</a></li></ul></li><li><a href=#design-pattern>Design Pattern</a><ul><li><a href=#디자인-패턴-구조>디자인 패턴 구조</a></li><li><a href=#디자인-패턴-종류>디자인 패턴 종류</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=정리-동기>정리 동기</h2><ul><li>적으면서 공부하려고</li><li><a href=https://github.com/WooVictory/Ready-For-Tech-Interview>출처</a></li></ul><h2 id=algorithm>Algorithm</h2><h3 id=selection-sort>Selection Sort</h3><ul><li>Unstable sort</li><li>O(N^2)</li><li>단순한 알고리즘</li><li>적은 교환 횟수</li><li>추가 메모리 공간 필요 없음</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span>; i <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> standard <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> 1; j <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span>; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>standard<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>        standard <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>standard<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    arr<span style=color:#f92672>[</span>standard<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bubble-sort>Bubble Sort</h3><ul><li>구현이 단순</li><li>이미 정렬된 데이터를 정렬할때, 가장 빠르다.</li><li>배열 안에서 정렬하는 방식으로 다른 메모리 공간 필요 없음.</li><li>stable sort</li><li>O(n^2)</li><li>교환 횟수가 많다.</li><li>역순 정렬시 가장 느림.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span>; i <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> 1; j <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> arr<span style=color:#f92672>[</span>j <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        arr<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>j <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        arr<span style=color:#f92672>[</span>j <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=merge-sort>Merge Sort</h3><ul><li>Stable stort</li><li>추가 메모리가 필요하다.</li><li>데이터 분포에 영향을 덜 받는다.</li><li>LinkedList 에서 효율적이다.</li><li>O(nlgn)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mergeSort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>&lt;</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>    mergeSort(a, left, mid);
</span></span><span style=display:flex><span>    mergeSort(a, mid <span style=color:#f92672>+</span> 1, right);
</span></span><span style=display:flex><span>    merge(a, left, mid, right);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> mid, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i, j, k;
</span></span><span style=display:flex><span>  i <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>  j <span style=color:#f92672>=</span> (mid <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>  k <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> sorted <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>, right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> mid <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) sorted<span style=color:#f92672>[</span>k<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> sorted<span style=color:#f92672>[</span>k<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> mid) {
</span></span><span style=display:flex><span>    sorted<span style=color:#f92672>[</span>k<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>    sorted<span style=color:#f92672>[</span>k<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (k <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> 1; i <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    a<span style=color:#f92672>[</span>left <span style=color:#f92672>+</span> k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> sorted<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=insertion-sort>Insertion Sort</h3><ul><li>O(n^2) (평균, 최악), O(n) (최선)</li><li>추가 공간 필요 없음.</li><li>단순한 알고리즘</li><li>이미 정렬되어있는 경우 효율적</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span>; i <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> standard <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (0 <span style=color:#f92672>&lt;=</span> idx <span style=color:#f92672>&amp;&amp;</span> standard <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>idx<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>      arr<span style=color:#f92672>[</span>idx <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>idx<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>      idx <span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    arr<span style=color:#f92672>[</span>idx <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> standard;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=quick-sort>Quick Sort</h3><ul><li>Unstable sort</li><li>평균적으로 가장 빠른 구현</li><li>피벗 선정하는게 중요</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>quickSort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> L <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> right;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> arr<span style=color:#f92672>[</span>(left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> 2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (L <span style=color:#f92672>&lt;=</span> R) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (arr<span style=color:#f92672>[</span>L<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> pivot) L <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (pivot <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>R<span style=color:#f92672>]</span>) R <span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (L <span style=color:#f92672>&lt;=</span> R) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (L <span style=color:#f92672>!=</span> R) {
</span></span><span style=display:flex><span>        swap(arr, L, R);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      L <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      R <span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>&lt;</span> R) quickSort(arr, left, R);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (L <span style=color:#f92672>&lt;</span> right) quickSort(arr, L, right);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=heap-sort>Heap Sort</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>heapSort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> (n <span style=color:#f92672>/</span> 2) <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&gt;=</span> 0; i <span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>    heapify(arr, n, i);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&gt;</span> 0; i <span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>    swap(arr, 0, i);
</span></span><span style=display:flex><span>    heapify(arr, i, 0);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>heapify</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 2;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> arr<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>l<span style=color:#f92672>]</span>) p <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> arr<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> arr<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>) p <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> p) {
</span></span><span style=display:flex><span>    swap(arr, p, i);
</span></span><span style=display:flex><span>    heapify(arr, n, p);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=lru-cache-least-recently-used>LRU Cache (Least Recently Used)</h3><ul><li>가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘</li><li>자세한건 Demand Paging (페이지 요청 기법) 참고</li></ul><h2 id=operating-system>Operating System</h2><h3 id=프로세스-쓰레드>프로세스, 쓰레드</h3><ul><li><p>Process:</p><ul><li>실행 중인 프로그램, CPU 할당을 받는 작업의 단위</li><li>운영체제로부터 시스템 자원을 할당받는다.</li><li>할당받는 시스템 자원:<ul><li>CPU Time, Memory Address Space, (Code, Data, Stack, Heap)</li></ul></li><li>기본적으로 프로세스당 최소 1개의 쓰레드 존재</li><li>프로세스 간 통신을 위해서는 IPC 통신이 필요하다.:<ul><li>Pipe, Socket, File, Shared Memory</li></ul></li></ul></li><li><p>PCB (Process Control Block):</p><ul><li>특정 프로세스에 대한 중요한 정보를 저장하고 있는 커널 내의 자료구조</li><li>프로세스의 생성과 동시에 고유한 PCB 생성</li><li>프로세스는 CPU를 할당 받아 작업을 처리하다가 Context Switch 시에 PCB에 진행 사항을 저장하고, 다시 실행될때 불러온다.</li><li>PCB 내부에 저장되는 정보:<ul><li>PID, Status (New, Ready, Running, Waiting, Terminated), PC (Program Counter), Registers, Scheduling Info, IO info, Accounting info (recent cpu time etc)</li></ul></li></ul></li><li><p>Thread:</p><ul><li>프로세스의 실행 단위</li><li>프로세스 내부의 쓰레드끼리는 서로 주소 공간과 자원을 공유할 수 있다.</li><li>Thread 는 Stack 영역을 별도로 가진다.</li><li>쓰레드는 별도의 레지스터와 스택을 가지고 있다.</li></ul></li></ul><h3 id=multi-process-vs-multi-thread>Multi Process vs Multi Thread</h3><ul><li><p>Multi Process:</p><ul><li>안정성 (하나가 죽어도 다 죽지는 않음)</li><li>Context Switching Overhead:<ul><li>이건 참고 사이트랑 살짝 의견이 다르긴 한데, 사실상 표준인 Linux Kernel 같은 경우 Process 와 Thread가 크게 차이가 없는 걸로 안다. 물론 당연히 Heap 영역이 Cache Hit rate 에 영향이 있을테니 Process 가 약간 느리긴 하다.</li></ul></li><li>IPC: 코딩이 난해함. (<code>/dev/shm</code>, <code>/dev/mqueue</code>, ipc 에 대한 이해가 필요하다.):<ul><li>IPC 종류:<ul><li>Pipe, Named Pipe, Message Queue, Shared Memory, Memory Map, Socket</li></ul></li><li>좀 공부해봤는데 IPC namespace 를 공유하면 <code>/proc/sys/fs/mqueue</code> (POSIX message queue), <code>/proc/sys/kernel</code> 내의 System V IPC interface, <code>/proc/sysvipc</code> 를 공유해준다. (이건 지금 코딩하고 있는 거 때문에 좀 더 상세히 봄)</li></ul></li></ul></li><li><p>Multi Thread:</p><ul><li>메모리 공간 및 자원 소모가 상대적으로 적다.</li><li>Context switching 시 cache memory 에서 이득을 보게 된다.</li><li>Concurrency Issue에 관련되어 주의가 필요하며 동기화 이슈가 있다.</li></ul></li><li><p><del>쓰레드 생성은 프로세스 생성에 비해 시스템 콜이 줄어들어 자원을 효율적으로 관리할수 있다.</del> 라고 나와있긴 한데, 이건 항상 맞는 소리는 아니다.:</p><ul><li><a href=https://stackoverflow.com/questions/9477753/linux-system-call-for-creating-process-and-thread>참고자료</a></li><li>일단 시스템 콜 자체는 생성 시점에서는 똑같다. 심지어 생성 속도도 비슷한다. lazy 하게 memory 공간이 copy 되기 때문인데 자세한건 mmu 레벨까지 가야해서 여기에다가 적기는 좀 그렇고 대충 쓰기 protect 걸고, 쓰기 요청때 copy 하는 copy-on-write 를 사용한다고만 이해하면 된다.</li><li>물론 실제로 copy-on-write 하면 첫 쓰기 요청때 느리긴 하다.</li><li>자원은 Thread 가 더 효율적으로 관리할 가능성이 큰데, Process 가 할당 받은 Page 내부에 사용 안하는 공간이 있을 가능성이 있기 때문이다.</li><li>뭐 이것도, Thread가 메모리 사용을 할때 Process Memory Pool 에서 가져다가 한다는 게 있어야 하긴 하는데, 조금만 신경써서 코딩하면 (혹은 라이브러리를 사용하면) 그리 어려운 일은 아니다. 반면 프로세스에서 이건 지옥이다. 공유 메모리에서 이짓거리를 해야하니</li></ul></li><li><p>참고자료에서 이것저것 옛날 내용이 많고, 조금 과거 이론이 많아서 대충 좀 버린다.</p></li><li><p>Reentrant:</p><ul><li>재진입성 : 여러 쓰레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다</li><li>일반적으로 재진입성을 만족시키기 위해서는 호출된 매개변수만으로 동작해야한다.:<ul><li>뭐 조금만 생각해보면, 공유자원이 있더라도 공유자원을 초기 상태로 만들고 함수를 종료한다. 라는게 보장되도 가능하다.</li></ul></li></ul></li></ul><h3 id=동기화-문제>동기화 문제</h3><ul><li><p>실행 순서의 동기화:</p><ul><li>여러개의 쓰레드들이 순서가 있는 경우</li><li>예시 : IO intensive 한 작업과 CPU intensive 한 작업이 있고, CPU intensive 한게 먼저 반환 되어야할때, Thread 로 분리하여 동시 작업하고 동기화 해준다.:<ul><li>생각보다 유사한 상황이 많이 나올수 있다.</li><li>오래걸리는 암호화와 파일 읽기가 예시로 있을 수 있다.</li><li>timing attack 과 같은 보안적 요소를 고려하는 것, 어짜피 동일한 request 가 많다면, 각 요청이 서로 다른 step 단계에 있어서 단일 쓰레드로 하는게 이득일수 있긴하지만 고려해볼만 요소이다.</li></ul></li></ul></li><li><p>유저 모드 동기화:</p><ul><li>커널의 도움 없이 하는 방법</li><li>?? 이게 있어?</li><li>violate 로 busy wait 하는 방법 ?? 이게 효율적일까? IoT 할때나 좀 써보고 그 이외에서는 안써봤는데 걍 커널 도움 받는게 맞지 않나? 그냥 busy wait 안하고 sleep 호출하는 구조로 해도 system call 이득도 없어져서 손해인데</li></ul></li><li><p>커널모드 동기화:</p><ul><li>Semaphore, Mutex, Lock</li></ul></li></ul><h3 id=context-switching>Context Switching</h3><ul><li>Context Switching 의 비용:<ul><li>Cache 초기화</li><li>Memory mapping 초기화</li><li>user mode 와 kernel 모드 전환</li></ul></li></ul><h3 id=interrupt>Interrupt</h3><ul><li>Hardware Interrupt</li><li>Software Intterupt:<ul><li>Exception</li><li>System call</li></ul></li><li>Interrupt Handling Process:<ul><li>Interrupt Vector : 여러가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블</li></ul></li></ul><h3 id=deadlock>Deadlock</h3><ul><li>Deadlock 발생 조건:<ul><li>Mutual Exclusion</li><li>Hold and Wait</li><li>No Preemption</li><li>Circular Wait</li></ul></li><li>Deadlock 처리 방법:<ul><li>Prevention</li><li>Avoidance</li><li>Recovery</li><li>Detection</li></ul></li></ul><h3 id=cpu-scheduling>CPU Scheduling</h3><ul><li><p>Preemptive vs Non-Preemptive:</p><ul><li>Preemptive (선점) : 중간에 뻇기 가능</li><li>Non-Preemptive (비선점) : 아무도 못뺏음</li></ul></li><li><p>Preemptive Scheduling Algorithm:</p><ul><li>SRT(Shortest Remaining Time) Scheduling:<ul><li>이론적인 방법, 어떠한 작업이 얼마나 뒤에 끝날지 계산이 어려움</li></ul></li><li>Roud Robin Scheduling:<ul><li>공평한 것 같지만, 실효성이 없음. 늦어도 되는 작업을 뒤로 미루지 못함.</li></ul></li><li>Multi-level Queue:<ul><li>합리적인 것 같지만 동적으로 할당이 어려움. 특정 큐에 Starvation이 날수 있음</li></ul></li><li>Multi-level feedback Queue:<ul><li>현재 가장 널리 채택되는 방법</li></ul></li></ul></li><li><p>Non-Preemptive Scheduling Algorithm:</p><ul><li>FCFS(First Come First Server)</li><li>SJF(Shortest-Job-First)</li></ul></li></ul><h3 id=scheduler>Scheduler</h3><ul><li><p>Long-term Scheduler</p></li><li><p>Short-term Scheduler : Dispatcher</p></li><li><p>Medium-term Scheduler</p></li><li><p>찾아보면 각자 다 달라서 굳이 설명은 안 적어둔다.</p></li></ul><h3 id=paging-vs-segmentation>Paging vs Segmentation</h3><ul><li>가상 메모리를 관리하는 기법</li><li>페이징(Paging):<ul><li>프로세스의 주소 공간을 동일한(공정된) 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 저장하는 방식</li><li>외부 단편화와 압축 작업을 해소하기 위함이다.</li><li>메모리는 Frame 이라는 고정 크기로 분할되고, 프로세스는 Page라 불리는 고정 크기로 분할된다.</li><li>MMU 를 통해서 Logical Address 를 Physical Address 로 바꾼다.</li></ul></li><li>세그멘테이션(Segmentation):<ul><li>프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할하고 메모리에 배치하는 것을 말하며, 각 세그먼트의 크기는 일정하지 않다.</li></ul></li></ul><h3 id=페이지-교체-알고리즘>페이지 교체 알고리즘</h3><ul><li>가상 메모리는 요구 페이징 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다.</li><li>메모리가 가득차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 outgㅏ고 해당 공간에 현재 필요한 페이지를 in 시켜야한다.</li></ul><h2 id=compiler>Compiler</h2><h3 id=lexical-analyzer>Lexical Analyzer</h3><ul><li>Token</li><li>Lexeme : Token 의 Pattern을 만족하는 문자열</li><li>Pattern : Token 을 정의하는 rule</li></ul><h3 id=syntax-analyzer>Syntax Analyzer</h3><ul><li>Chomsky hierarchy:<ul><li>recursively enumerable > context-sensitive > context-free > regular</li></ul></li></ul><h3 id=semantic-analyzer>Semantic Analyzer</h3><h3 id=immediate-code-generator>Immediate Code Generator</h3><h3 id=code-optimizer>Code Optimizer</h3><h3 id=code-generator>Code Generator</h3><h2 id=design-pattern>Design Pattern</h2><h3 id=디자인-패턴-구조>디자인 패턴 구조</h3><ul><li>Context: 문제가 발생하는 상황을 기술한다.</li><li>Problem: 패턴이 적용해어 해결될 필요가 있는 여러 디자인 이슈 기술</li><li>Solution : 관계, 책임, 협력 관계를 기술한다.</li></ul><h3 id=디자인-패턴-종류>디자인 패턴 종류</h3><ul><li>Creational Pattern:<ul><li>Abstract Factory : 구체적인 클래스에 의존하지 않고 서로 여관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공</li><li>Builder</li><li>Factory Method</li><li>Prototype</li><li>Singleton</li></ul></li><li>Structural Pattern:<ul><li>Adapter</li><li>Bridge</li><li>Composite</li><li>Decorator</li><li>Facade</li><li>Flyweight</li><li>Proxy</li></ul></li><li>Behavioral Pattern:<ul><li>Chain of Reponsibility</li><li>Command</li><li>Interpreter</li><li>Iterator</li><li>Mediator</li><li>Memonto</li><li>Observer</li><li>State</li><li>Strategy</li><li>Template Method</li><li>Visitor</li></ul></li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>