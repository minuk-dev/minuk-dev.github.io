<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lectures/design-pattern</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>lectures/design-pattern
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[lectures]]</button></div></div></div><div><h2>lectures/design-pattern</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/lectures/design-pattern.md><h5>created : Sun, 23 Oct 2022 00:15:47 +0900</h5><h5>modified : Sun, 23 Oct 2022 20:24:38 +0900</h5></a><a href=https://minuk.dev/tags/design-pattern><kbd class=item-tag>design-pattern</kbd></a>
<a href=https://minuk.dev/tags/lecture><kbd class=item-tag>lecture</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#5-factory>5. Factory</a><ul><li><a href=#factory-patterns>Factory Patterns</a></li><li><a href=#factory-method-pattern>Factory Method Pattern</a></li><li><a href=#design-principle-dependency-inversion-principle>Design Principle: Dependency Inversion Principle</a></li><li><a href=#factory-method-pattern-1>Factory Method Pattern</a></li><li><a href=#abstract-factory-patttern>Abstract Factory Patttern</a></li><li><a href=#factory-paterns>Factory Paterns</a></li><li><a href=#participants>Participants</a></li><li><a href=#abstract-factory-pattern>Abstract Factory Pattern</a></li><li><a href=#related-patterns>Related Patterns</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#6-adapter-pattern>6. Adapter Pattern</a><ul><li><a href=#typical-working-process-and-motivation>Typical working process and Motivation</a></li><li><a href=#implementation-issues>Implementation Issues</a></li><li><a href=#summary-1>Summary</a></li></ul></li><li><a href=#7-facade-pattern>7. Facade Pattern</a><ul><li><a href=#motivation>Motivation</a></li><li><a href=#benefits>Benefits</a></li><li><a href=#the-principle-of-least-knowledge-law-of-demeter>The Principle of Least Knowledge (Law of Demeter)</a></li><li><a href=#facade-review>Facade Review</a></li><li><a href=#related-patterns-1>Related Patterns</a></li></ul></li><li><a href=#8-singleton-pattern>8. Singleton Pattern</a><ul><li><a href=#design-points>Design Points</a></li><li><a href=#reviewing-the-options>Reviewing the Options</a></li><li><a href=#related-patterns-and-summary>Related Patterns and Summary</a></li></ul></li><li><a href=#9-mediator-pattern>9. Mediator Pattern</a><ul><li><a href=#battling-class-complexity>Battling Class Complexity</a></li><li><a href=#mediator-pattern>Mediator Pattern</a></li><li><a href=#decoupling-senders-and-receivers>Decoupling Senders and Receivers</a></li><li><a href=#communication-encaplusate-vs-distribute>Communication: Encaplusate vs. Distribute</a></li></ul></li><li><a href=#10-solid>10. SOLID</a><ul><li><a href=#the-single-responsibility-principle>The Single Responsibility Principle</a></li><li><a href=#open-closed-principle>Open Closed principle</a></li><li><a href=#liskov-substitution-principle>Liskov Substitution Principle</a></li><li><a href=#dependency-inversion-principle>Dependency Inversion Principle</a></li><li><a href=#interface-segregation-principle-isp>Interface Segregation Principle (ISP)</a></li><li><a href=#summary-2>Summary</a></li></ul></li><li><a href=#11-iterator-pattern>11. Iterator Pattern</a><ul><li><a href=#the-iterator-pattern>The Iterator Pattern</a></li><li><a href=#iterator-pattern>Iterator Pattern</a></li><li><a href=#related-patterns-2>Related Patterns</a></li><li><a href=#summary-3>Summary</a></li></ul></li><li><a href=#12-composite-pattern>12. Composite Pattern</a><ul><li><a href=#things-to-consider>Things to Consider</a></li><li><a href=#related-patterns-3>Related Patterns</a></li><li><a href=#summary-4>Summary</a></li></ul></li><li><a href=#decorator-pattern>Decorator Pattern</a><ul><li><a href=#design-princple-ocp>Design Princple: OCP</a></li><li><a href=#review-of-decorator-idea>Review of Decorator Idea</a></li><li><a href=#the-definition-of-the-decorator>The Definition of the Decorator</a></li><li><a href=#related-patterns-4>Related Patterns</a></li><li><a href=#summary-5>Summary</a></li></ul></li><li><a href=#state-pattern>State Pattern</a><ul><li><a href=#applicaility-of-the-state-pattern>Applicaility of the State Pattern</a></li><li><a href=#consequences-of-the-state-pattern>Consequences of the State Pattern</a></li><li><a href=#state-vs-strategy>State vs. Strategy</a></li><li><a href=#summary-6>Summary</a></li></ul></li><li><a href=#builder-pattern>Builder Pattern</a><ul><li><a href=#builder---participants>Builder - Participants</a></li><li><a href=#when-a-builder-shouldnt-be-used>When a Builder Shouldn&rsquo;t Be Used</a></li><li><a href=#related-patterns-and-summary-1>Related Patterns and Summary</a></li></ul></li><li><a href=#template-method-pattern>Template Method Pattern</a><ul><li><a href=#design-princi8ple-hollywood-principle>Design Princi8ple: Hollywood Principle</a></li><li><a href=#related-patterns-5>Related Patterns</a></li><li><a href=#summary-7>Summary</a></li></ul></li><li><a href=#proxy-pattern>Proxy Pattern</a><ul><li><a href=#proxy-pattern-collaborations>Proxy Pattern Collaborations</a></li><li><a href=#applicability>Applicability</a></li><li><a href=#distributed-computing>Distributed Computing</a></li><li><a href=#client-server-model-and-programming>Client-Server Model and Programming</a></li><li><a href=#remote-procedure-call-rpc>Remote Procedure Call (RPC)</a></li><li><a href=#serialization-basics>Serialization basics</a></li><li><a href=#object-graphs-and-transient-fields>Object graphs and transient fields</a></li><li><a href=#related-patterns-6>Related Patterns</a></li></ul></li><li><a href=#chain-of-responsibility-pattern>Chain of Responsibility Pattern</a><ul><li><a href=#helphandler-class-diagram>HelpHandler class diagram</a></li><li><a href=#participants-1>Participants</a></li><li><a href=#consequences>Consequences</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#related-pattern>Related pattern</a></li></ul></li><li><a href=#bridge-pattern>Bridge Pattern</a><ul><li><a href=#problem-analysis>Problem Analysis</a></li><li><a href=#introducing-bridge-pattern>Introducing Bridge Pattern</a></li><li><a href=#structure-of-bridge-pattern>Structure of Bridge Pattern</a></li><li><a href=#participants--collaborations>Participants & Collaborations</a></li><li><a href=#comparision-with-adapter>Comparision with Adapter</a></li><li><a href=#summary-8>Summary</a></li></ul></li><li><a href=#prototype-pattern>Prototype Pattern</a><ul><li><a href=#prototype---participants>Prototype - participants</a></li><li><a href=#whats-so-special-about-the-pattern>What&rsquo;s so special about the pattern?</a></li><li><a href=#cloning-in-java>Cloning in JAVA</a></li><li><a href=#review>Review</a></li></ul></li><li><a href=#visitor-pattern>Visitor Pattern</a><ul><li><a href=#motivations-and-benefits>Motivations and Benefits</a></li><li><a href=#participants-2>Participants</a></li><li><a href=#collaborations>Collaborations</a></li><li><a href=#method-overloading>Method Overloading</a></li><li><a href=#technical-details>Technical Details</a></li><li><a href=#how-double-dispatch-is-implemented-in-visitor-pattern>How Double-dispatch is implemented in Visitor Pattern</a></li><li><a href=#benefits-1>Benefits</a></li><li><a href=#liabilities>Liabilities</a></li><li><a href=#implementation-of-traversal>Implementation of Traversal</a></li><li><a href=#summary-9>Summary</a></li></ul></li><li><a href=#design-patterns-review>Design Patterns Review</a><ul><li><a href=#abstraction>Abstraction</a></li><li><a href=#information-hiding-and-encapsulation>Information hiding and Encapsulation</a></li><li><a href=#separation-of-concerns-soc>Separation of COncerns (SoC)</a></li><li><a href=#interfaces>Interfaces</a></li><li><a href=#modularity>Modularity</a></li><li><a href=#measuring-mdoularity>Measuring Mdoularity</a></li><li><a href=#copuling>Copuling</a></li><li><a href=#cohesion>Cohesion</a></li><li><a href=#review-of-behavioral-patterns>Review of Behavioral Patterns</a></li><li><a href=#review-of-structural-patterns>Review of Structural Patterns</a></li><li><a href=#review-of-creational-patterns>Review of Creational Patterns</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=5-factory>5. Factory</h2><h3 id=factory-patterns>Factory Patterns</h3><ul><li>Creational patterns:<ul><li>Allow to creating new objects without explicitly using the new operator</li><li>We can instantiate different objects without modifying client code!</li></ul></li><li>Factory Method:<ul><li>Uses inheritance to decide the object to be instantiated</li></ul></li><li>Abstract Factory:<ul><li>Delegates object creation to a factory object</li></ul></li></ul><h3 id=factory-method-pattern>Factory Method Pattern</h3><ul><li><p>Purpose:</p><ul><li>Exposes a method for creating objects, allowing subclasses to constrol the actual creation process.</li></ul></li><li><p>Use When:</p><ul><li>A class will not know what classes it will be required to create.</li><li>Subclasses may specify what objects should be created.</li><li>Parent classes wish to defer creation to their subclasses.</li></ul></li><li><p>Defines an instance for creating an object, but lets subclasses decide which class to instantiate.</p></li><li><p>Factory Method lets a class defer instantiation to subclasses</p></li></ul><h3 id=design-principle-dependency-inversion-principle>Design Principle: Dependency Inversion Principle</h3><ul><li>Dependency Inversion Principle:<ul><li>Depend upon abstractions. Do not depend upon concreate classes.</li><li>High-level components should not depend on low-level components; rather, they should both depend on abstractions</li></ul></li><li>Factory Method is one way of following the dependency inversion principle</li></ul><h3 id=factory-method-pattern-1>Factory Method Pattern</h3><ul><li>What exactly does it mean by saying that &ldquo;the Facotry Method Pattern lets subclasses decide which class to instantiate?&rdquo;:<ul><li>Creator class is written in such a fashion that it does not know what actual Concrete Product class will be instantiated. The Concreate Product class to be instantiated is determined solely by which Concrete Creator subclass is instantiated and sused by the application.</li><li>It does not mean that the subclass decides at runtime which ConcreteProduct class to create</li></ul></li></ul><h3 id=abstract-factory-patttern>Abstract Factory Patttern</h3><ul><li>Purpose:<ul><li>Provide an interface that delegates creation calls to one or more concrete classes in order to deliver specific objects.</li></ul></li><li>Use When:<ul><li>The creation of objects should be independent of the system utilizing them.</li><li>Systems should be capable of using multiple families of objects.</li><li>Families of objects must be used together.</li><li>Libraries must be publisehd without expsing implementation details.</li><li>Concreate classes should be decoupled from clients.</li></ul></li></ul><h3 id=factory-paterns>Factory Paterns</h3><ul><li>Abstract factory pattern is one level of abstraction higher than the factory method pattern</li><li>Mechanisms:<ul><li>Abstract Factory pattern uses composition & delegation</li><li>Factory Method pattern uses inheritance</li></ul></li></ul><h3 id=participants>Participants</h3><ul><li>AbstractFactory:<ul><li>Declares an interface for operations that create abstract product objects</li></ul></li><li>Concreate Factory:<ul><li>Implements the operations to create concreate product objects</li></ul></li><li>Abstract Product:<ul><li>Declares an interface for a type of product object</li></ul></li><li>ConcreateProduct:<ul><li>Defines a product object to be created by the corresponding concreate factory</li><li>Implements the AbstractProduct interface</li></ul></li><li>Client:<ul><li>Uses only interfaces declared by AbstractFactory and AbstractProduct classes</li></ul></li></ul><h3 id=abstract-factory-pattern>Abstract Factory Pattern</h3><ul><li>Consequences:<ul><li>(+) Isolates concrete classes:<ul><li>Factory encapsulates responsibility and process of creating parts</li><li>Isolates clients from implementation classes</li></ul></li><li>(+) Exchanging product families easy:<ul><li>Concret factory appears once where it is instantiated</li></ul></li><li>(+) Promotes consistency among products</li><li>(-) Supporting new kinds of proudcts is difficult:<ul><li>Fixes set of parts to be created</li></ul></li></ul></li></ul><h3 id=related-patterns>Related Patterns</h3><ul><li>Abstract Factory:<ul><li>classes are often implemented with Factory Methods</li><li>but they can also be implemented using Prototype</li></ul></li><li>Easy start -> Factory Method:<ul><li>less complicated, more customizable, subclasses proliferate</li><li>Later evolve toward Abstract Factory, Prototype, or Builder when more flexibility is needed.</li></ul></li></ul><h3 id=summary>Summary</h3><ul><li>Dependency Inversion Principle (DIP):<ul><li>Depend on abstractions. Do not depend on concreate classes</li></ul></li><li>Factory Method:<ul><li>Define an interface for creating an object, but let subclasses decide which class to instantiate.</li><li>Class-scope pattern (uses only inheritance)</li></ul></li><li>Abstract Factory:<ul><li>Provide an interface for creating families of related or dependent objects without specifying their concreate classes</li><li>Object-scope pattern (uses object composition & delegation)</li></ul></li></ul><h2 id=6-adapter-pattern>6. Adapter Pattern</h2><ul><li>Also known as:<ul><li>Wrapper</li></ul></li><li>Purpose:<ul><li>Permits classes with different interfaces to work together by creating a common object by which they may communicate and interact.</li></ul></li><li>Use When:<ul><li>A class to be used doesn&rsquo;t meet interface requirements.</li></ul></li></ul><h3 id=typical-working-process-and-motivation>Typical working process and Motivation</h3><ul><li>Mechanism:<ul><li>A client makes a request to the adapter by calling a method on it using the target interface</li><li>The adapter translates the rquest into one or more calls on the adaptee using the adpatee interface</li><li>The client receives the resutls of the call and never knows there is an dapter doing the translation</li></ul></li><li>Motivation:<ul><li>A toolkit or class library may have an interface which is incompatible wich an application&rsquo;s interface we want to integrate.</li><li>It is possible that we do not have access to the source code of the toolkit or library.</li><li>Even if the source code is available, we may want to minimize the change</li></ul></li></ul><h3 id=implementation-issues>Implementation Issues</h3><ul><li>How much adaptation?:<ul><li>Simple and straightforward interface conversion such as:<ul><li>Chaning method names</li><li>Changing the order of arguments</li></ul></li><li>Totally different set of operations</li></ul></li><li>Two-way transparency?:<ul><li>A two-way adapter supports both the Target and the Adaptee interface. It allows an adapted object (Adapter) to appear as an Adaptee object or a Target object</li></ul></li></ul><h3 id=summary-1>Summary</h3><ul><li>Adapter pattern:<ul><li>Converts the interface of a class into another interface clients expect.</li><li>Lets classes work together that couldn&rsquo;t otherwise because of incompatible interfaces</li><li>Class adapter and object adapter</li></ul></li></ul><h2 id=7-facade-pattern>7. Facade Pattern</h2><ul><li><p>Purpose:</p><ul><li>Supplies a single interface to a set of interfaces within a system.</li></ul></li><li><p>Use When:</p><ul><li>A simple interface is needed to provide access to a complex system.</li><li>There are many dependencies between system implementations and clients.</li><li>Systems and subsystems should be layerd.</li></ul></li><li><p>Provides a unified interface to a set of interfaces in a subsystem. It defines a higher-level interface that makes a subsystem easier to use</p></li></ul><h3 id=motivation>Motivation</h3><ul><li>In typical OO Design,:<ul><li>Structuring a system into subsystems helps reduce complexity</li><li>Subsystems are groups of classes, or groups of classes and other subsystems</li><li>May produces many minimal classes</li></ul></li><li>Problems:<ul><li>Class/Subsystem interface can become quite complex:<ul><li>Too many options to use!</li></ul></li><li>A new-comer cannot figure out where to begin</li></ul></li><li>Solution:<ul><li>Facade object provides a single, simplified interface to the more general facilities of a subsystem</li></ul></li></ul><h3 id=benefits>Benefits</h3><ul><li>Hides the implementation of the subsystem from clients:<ul><li>makes the subsystem easier to use</li></ul></li><li>Promotes weak coupling between the subsystem and its clients:<ul><li>allows changing the classes comprising the subsystem without affecting the clients</li></ul></li><li>Does not prevent sophisticated clients from accessing the underlying classes</li><li>Notice: Facde does not add any functionality, it just simplifies interface</li></ul><h3 id=the-principle-of-least-knowledge-law-of-demeter>The Principle of Least Knowledge (Law of Demeter)</h3><ul><li>Talk only to your immediate friends:<ul><li>When you design a system, you should be careful of the number of classes it interacts with and also how it comes to interact with those classes</li><li>A method m of an object o may only invoke the methods of the following kinds of objects</li></ul></li></ul><h3 id=facade-review>Facade Review</h3><ul><li>Provides a unified interface to a set of interfaces in a subsystem.</li><li>Facade defines a higher-level interface that makes the subsystem easier to use</li></ul><h3 id=related-patterns-1>Related Patterns</h3><ul><li>Mediator:<ul><li>Mediator&rsquo;s colleagues are aware of Mediator</li></ul></li><li>Facade:<ul><li>Unidirecitonal rather than cooperative interactions between object and subsystem</li><li>The subsystem doesn&rsquo;t know about the Facade</li><li>Facade doesn&rsquo;t add funcitonality, Mediator does</li></ul></li></ul><h2 id=8-singleton-pattern>8. Singleton Pattern</h2><ul><li>Purpose:<ul><li>Ensures that only one instance of a class is allowed within a system.</li></ul></li><li>Use When:<ul><li>Exactly one instance of a class is required.</li><li>Controlled access to a single object is necessary.</li></ul></li></ul><h3 id=design-points>Design Points</h3><ul><li>Make the constructor be private:<ul><li><code>private Singleton() {}</code></li></ul></li><li>Provide a getInstance() method:<ul><li><code>public static Singleton getInstance()</code></li></ul></li><li>Remember the instance once you have created it.</li></ul><h3 id=reviewing-the-options>Reviewing the Options</h3><ul><li>Synchronize the getInstance() method (Option 1):<ul><li>A straightforward technique that is guaranteed to work. It causes small impact on run-time performance due to frequent locking.</li></ul></li><li>Use eager instantiation (Option 2):<ul><li>In case we are alwasy going to instantitate the calss, then statically initializing the intsance would cause no concerns.</li></ul></li><li>Double checked locking (Option 3):<ul><li>A perfect solution w.r.t performance. However, double-checked locking may be overkill in case we have no performance concerns. In addition, we&rsquo;d have to ensure that we are running at least Java 5.</li></ul></li></ul><h3 id=related-patterns-and-summary>Related Patterns and Summary</h3><ul><li>Abstract Factory, Builder, and Prototype can use Single in their implementation</li><li>Facade objects are often Singletons because only one Facade object is required.</li><li>State objects are often Singletons.</li><li>Singleton pattern:<ul><li>creates at most one instance</li><li>Implemenation: beware of multi-threaded issue</li></ul></li></ul><h2 id=9-mediator-pattern>9. Mediator Pattern</h2><ul><li>Purpose:<ul><li>Allows loose coupling by encapsulating the way disparate sets of objects interact and communicate with each other.</li></ul></li><li>Use When:<ul><li>Communication between sets objects is well defined and complex.</li><li>Too many relationships exist and common point of control or communication is needed.</li></ul></li></ul><h3 id=battling-class-complexity>Battling Class Complexity</h3><ul><li>Let&rsquo;s abstract this to classes and their objects in a program:<ul><li>When objects are allowed to communicate directly with each other, then they become too tightly coupled.</li><li>When one object wishes to send a message to another then we need the equivalent of an air traffic controller to forward the message to the recipient</li><li>Keep the dispatching information inside the new controller</li><li>Call this coordinating object a mediator</li></ul></li></ul><h3 id=mediator-pattern>Mediator Pattern</h3><ul><li>Encapsulates interconnects between objects into Mediator:<ul><li>communications hub</li><li>Reponsible for coordinating and controlling colleague interaction</li></ul></li><li>Promotes loose couping betwee nclasses:<ul><li>By preventing from referring to each other explicitly</li><li>Mediator is commonly used to coordinate related GUI components</li></ul></li><li>(-) mediators are hardly ever reusable</li><li>(+) easy to understatnd the flow of communication</li></ul><h3 id=decoupling-senders-and-receivers>Decoupling Senders and Receivers</h3><ul><li><p>Observer Pattern:</p><ul><li>decouples subjects and observers by an interface for signaling changes</li><li>a subject may have multiple observers</li><li>the number of observers can vary at run-time</li><li>best for decoupling objects with data dependencies</li></ul></li><li><p>Mediator Pattern:</p><ul><li>decouples objects (Colleagues) through a Mediator object</li><li>routes requests between Colleague objects</li><li>centralizes communication between Colleague objects</li></ul></li></ul><h3 id=communication-encaplusate-vs-distribute>Communication: Encaplusate vs. Distribute</h3><ul><li>Mediator:<ul><li>encapsulates communication between objects</li><li>centralizes communications</li><li>maintains a communication constratin in the mediator</li><li>(-) mediators are hardly ever reusable</li><li>(+) easier to understand the flow of communication</li></ul></li><li>Observer:<ul><li>distributes communication by introducing Observer and Subject objects</li><li>observer and subject cooperate to maintain a constraint</li><li>(+) easire to make reusable observers and subects</li><li>(-) difficulat to understand the flow of communication</li></ul></li></ul><h2 id=10-solid>10. SOLID</h2><ul><li>The Single-Responsibility Principle (SRP)</li><li>The Open-Closed Principle (OCP)</li><li>The Liskov Substitution Principle (LSP)</li><li>The Interface Segregation Principle (ISP)</li><li>The Dependency Inversion Principle (DIP)</li></ul><h3 id=the-single-responsibility-principle>The Single Responsibility Principle</h3><ul><li>Responsibility:<ul><li>&ldquo;a contract or obligation of a class&rdquo;</li><li>reason to change:<ul><li>More responsibilities == More likelihood of change</li><li>The more a class changes, the more likely we will introduce bugs</li><li>Changes can impact the others</li></ul></li></ul></li><li>SRP: Separate coupled responsibilities into separate classes:<ul><li>Related measure - Cohesion: how strongly-related and focused are the various responsibilities of a module</li></ul></li></ul><h3 id=open-closed-principle>Open Closed principle</h3><ul><li>Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.</li><li>You should be able to extend a class&rsquo;s behavior, without modifying it.</li></ul><h4 id=conforming-to-ocp>Conforming to OCP</h4><ul><li>Open for extension:<ul><li>Behavior of the module can be extended</li><li>We are able to chnage what the module does</li></ul></li><li>Closed for modification:<ul><li>Extending behavior does not result in excessive modification such as architectural changes of the module</li></ul></li><li>Violation Indicator: Design Smell of Rigidity:<ul><li>A single change to a program results in a cascade of changes to dependent modules</li></ul></li></ul><h4 id=abstraction-is-the-key>Abstraction is the Key!</h4><ul><li>Abstractions:<ul><li>Fixed and yet represent an unbounded group of possible behaviors</li><li>Abstract base class: fixed</li><li>All the possible derived classes : unbounded group of possible behaviors</li></ul></li><li>Program the class:<ul><li>to interfaces (or abstract classes)</li><li>not to implementation (concrete classes)</li></ul></li></ul><h4 id=anticipating-future-changes>Anticipating Future Changes</h4><ul><li><p>Strategy is needed:</p><ul><li>Choose the kinds of changes against which to close design</li><li>Guess the most likely kinds of changes, and then construct abstractions to protect him from those changes.</li></ul></li><li><p>Beware: Consider the cost!:</p><ul><li>Conforming to OCP is expensive</li><li>Time and effort to create appropriate abstractions</li><li>Abstractions also increase complexity</li></ul></li><li><p>Do not put hooks in for changes that might happen:</p><ul><li>&ldquo;Fool me once, shame on you. Fool me twice, shame on me&rdquo;</li><li>Initially write the code expecting it to not change.</li><li>When a change occurs, implement the abstractions that protect from future changes of that kind.</li><li>It&rsquo;s better to take the first hist as early as possible:<ul><li>We want to know what kind of changes are likely before going too far in the development.</li></ul></li><li>Use TDD and listen to the tests.</li></ul></li></ul><h3 id=liskov-substitution-principle>Liskov Substitution Principle</h3><ul><li><p>Subtypes must be substitutable for their base types</p></li><li><p>Drvied classes msut be substitutable for their base classes</p></li><li><p>A rule that you want to check when you decide to use inheritance or not</p></li><li><p>If C is a subtype of P, then objects of type P may be replased with objects of type C without altering any of the desirable properties of the program</p></li></ul><h4 id=subtytping-vs-implementation-inheritance>Subtytping VS Implementation Inheritance</h4><ul><li><p>Subtyping:</p><ul><li>establishes ans IS_A relationsihp</li><li>also known as interface inheritance</li></ul></li><li><p>Implementation Inheritance:</p><ul><li>only reuses implementation and establishes a syntactic relationship not necessarily a semantic relationship</li><li>Also known as code inheritance</li></ul></li><li><p>Most OOP languages like Java, C++, and C#, inheritance keyword such as &ldquo;extends&rdquo; does the both Subtypign and Implementation Inheritance:</p><ul><li>But some languages disthingushi them</li></ul></li><li><p>Think twice when you dicide to use Inheritance!:</p><ul><li>If you want to reuse implementation of List, you had better exploit object composition, not inheritance.</li><li>If you inherit Queue from List, then you violate LSP since Queue object cannot be substituable for List.</li></ul></li></ul><h3 id=dependency-inversion-principle>Dependency Inversion Principle</h3><ul><li>High-level modules should not depend on low-level modules. Both should depend on abstractions</li><li>Abstractions should not depend on details. Details should depend on abstractions.</li><li>Why Inversion?:<ul><li>DIP attempts to &ldquo;invert&rdquo; the dependencies that result from a structured analysis and design approach</li></ul></li></ul><h4 id=inversion-of-ownership>Inversion of Ownership</h4><ul><li>Its not just an inversion of dependency, DIP also inverts ownership:<ul><li>Typically a service interface is &ldquo;owned&rdquo; or declared by the server, here the client is specifying what they want from the server</li><li>DIP -> Clients should own the interface!</li></ul></li></ul><h3 id=interface-segregation-principle-isp>Interface Segregation Principle (ISP)</h3><ul><li>Clients should not be forced to depend on methods they do not use</li><li>Make fine grained interfaces that are client specific</li></ul><h4 id=fat-interface>Fat interface</h4><ul><li>Bundling functions for different clients into one interface create unnecessary coupling among the clients.:<ul><li>When one client causes the interface to change, all other clients are forced to recompile.:<ul><li>Solution: Break the interface into cohesive groups</li></ul></li></ul></li><li>ISP solves non-cohesive interfaces:<ul><li>Clients should know only abstract base classes that have cohesive interfaces</li></ul></li></ul><h3 id=summary-2>Summary</h3><ul><li>SOLID:<ul><li>Single-Responsibility Principle</li><li>Open-Closed Principle</li><li>Liskov Substitution Principle</li><li>Dependency Inversion Principle</li><li>Interface Segregation Principle</li></ul></li><li>Design Principles:<ul><li>Help manage dependency</li><li>Better maintainability, flexivility, robustness, and reusability</li><li>Abstraction is important</li></ul></li></ul><h2 id=11-iterator-pattern>11. Iterator Pattern</h2><h3 id=the-iterator-pattern>The Iterator Pattern</h3><ul><li>Also Known As:<ul><li>Cursor</li></ul></li><li>Purpose:<ul><li>Allows for access to the elements of an aggregate object without allowing access to its underlying representation.</li></ul></li><li>Use When:<ul><li>Access to elements is needed without access to the entire representation.</li><li>Multiple or concurrent traversals of the elements are needed.</li><li>A uniform interface for traversal is needed.</li><li>Subtle differences exist between the implementation details of various iterators.</li></ul></li></ul><h3 id=iterator-pattern>Iterator Pattern</h3><ul><li>Provides a way to access the elemetns of an aggregate object sequentially without expsoing its underlying representation.</li></ul><h3 id=related-patterns-2>Related Patterns</h3><ul><li>Iterator can traverse a Composite. Visitor can apply an operation over a Composite.</li><li>Polymorphic iterators rely on Factory Methods to instantiate the appropriate Iterator subclass.</li><li>Memento is often used in conjunction with Iterator. An Iterator can use a Memento to capture the state of an interation. The Iterator stores the Memento internally.</li></ul><h3 id=summary-3>Summary</h3><ul><li>Single Responsibility Principle:<ul><li>A class should have only one reason to chnage</li></ul></li><li>Iterator Pattern:<ul><li>Provide a way to access the elemtns of an aggregate object sequentialy without exposing its underlying representation</li></ul></li></ul><h2 id=12-composite-pattern>12. Composite Pattern</h2><ul><li>Purpose:<ul><li>Facilitates the creation of object hierarchies when each object can be treated independently or as a set of nested objects through the same interface.</li></ul></li><li>Use When:<ul><li>Hierarchical representations of objects are needed.</li><li>Objects and compositions of objects should be treated uniformly.</li></ul></li></ul><h3 id=things-to-consider>Things to Consider</h3><ul><li>A composite object stores the information about its contained components:<ul><li>It depends on applications. Having these references supports the Chain of Responsibility pattern</li></ul></li></ul><h3 id=related-patterns-3>Related Patterns</h3><ul><li>Composite vs Decorator:<ul><li>Both have similar structure diagrams:<ul><li>recursive composition to organize an open-ended number of objects</li></ul></li><li>Different intentions:<ul><li>Decorator lets you add responsibilities to objects without subclassing</li><li>Composite&rsquo;s focus is not on embellishement but on representation</li><li>They are complementary; hence, Composite and Decorator are often used in concert</li></ul></li></ul></li><li>Iterator:<ul><li>Provide a way to access the elements of an aggregate object (=typically uses composite pattern) sequentially without exposing its underlying representation</li></ul></li></ul><h3 id=summary-4>Summary</h3><ul><li>Composite Pattern:<ul><li>compose objects into tree structures to represent whole-part hierarchies.</li><li>lets clients treate individual objects and compositions of objects uniformly</li></ul></li></ul><h2 id=decorator-pattern>Decorator Pattern</h2><ul><li>Purpose:<ul><li>Allows for the dynamic wrapping of objects in order to modify their existing responsibilities and behaviors.</li></ul></li><li>Use When:<ul><li>Object responsibilities and behaviors should be dynamically modifiable.</li><li>Concreate implementations should be decoupled from responsibilities and behaviors.</li><li>Subclassing to achieve modification is impractical of impossible.</li><li>Specific functionality should not reside high in the object hierarchy.</li><li>A lot of little objects surrounding a concrete implementation is acceptable.</li></ul></li></ul><h3 id=design-princple-ocp>Design Princple: OCP</h3><ul><li>Open Closed Principle:<ul><li>Classes should be open for extension, but closed for modification</li><li>Allow classes to be easily extended to incorporate new behavior without modifying existing code.</li><li>resilient to change and flexible enough to take on new functionality to meet chaning requirements.</li></ul></li><li>Caution: Don&rsquo;t try applying the Open-Closed Principle (OCP) to every single case. Keep simple designs if possible!</li></ul><h3 id=review-of-decorator-idea>Review of Decorator Idea</h3><ul><li>The decorator adds its own behvior.</li><li>You can use one or more decorators to wrap an object.</li><li>We can pass around a decorated object in place of the original (wrapped) object.</li><li>Decorators have the same super type as the objects they decorate.</li><li>We can decorate objects dynamically at runtime with as many decorators as we want</li></ul><h3 id=the-definition-of-the-decorator>The Definition of the Decorator</h3><ul><li>The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionaliy.</li></ul><h3 id=related-patterns-4>Related Patterns</h3><ul><li>Regarding the interfaces:<ul><li>Adapter provides a different interface to its subject</li><li>Proxy provides the same interface</li><li>Decorator provides an enhanced interface</li></ul></li></ul><h3 id=summary-5>Summary</h3><ul><li>Design Principle: Open-Closed Principle (OCP)</li><li>Advantages:<ul><li>attaches additional responsibilities to an object dynamically</li><li>flexible alternative to subclassing for extending functionality</li></ul></li><li>Key mechanism:<ul><li>Uses object composition and delegation</li><li>Decorator class mirrors the type of components they are decorating<ul><li>We can wrap a component with any number of decorators</li></ul></li></ul></li><li>Disadvantage:<ul><li>can generate a lot of small classes</li><li>hard to understand if not familiar with the pattern</li></ul></li></ul><h2 id=state-pattern>State Pattern</h2><ul><li>Purpose:<ul><li>Ties object circumstances to its behavior, allowing the object to behave in different ways based upon its internal state.</li></ul></li><li>Use When:<ul><li>The behavior of an object should be influenced by its state.</li><li>Complex conditions tie object behavior to its state.</li><li>Transitions between states need to be explicit.</li></ul></li></ul><h3 id=applicaility-of-the-state-pattern>Applicaility of the State Pattern</h3><ul><li>Use the State pattern when:<ul><li>An object&rsquo;s behavior depends on its state, and it must change its behavior at run-time depending on that state</li><li>Operations have large, multipart conditional statements that depend on the object&rsquo;s state. The State pattern puts each branch of the conditional in a separate class.</li></ul></li></ul><h3 id=consequences-of-the-state-pattern>Consequences of the State Pattern</h3><ul><li>Benefits:<ul><li>Puts all behvior associated with a state into one object</li><li>Allows state transition logic to be incorporated into a state object rather than in a monolithic if or switch statement</li><li>Helps avoid inconsistent states since state changes occur using just the one state object and not several objects or attributes</li></ul></li><li>Liabilities:<ul><li>Increased number of objects</li></ul></li></ul><h3 id=state-vs-strategy>State vs. Strategy</h3><ul><li>Note the similarities between the State and Strategy patterns!:<ul><li>The difference is one of intent.</li></ul></li><li>A State object encapsulates a state-dependent behavior (and possibly state transitions):<ul><li>The context&rsquo;s behavior chnages over tim</li><li>An alternative to putting lots of conditionals in the context</li></ul></li><li>A Strategy object encapsulates an algorithm:<ul><li>Often, there is a strategy object that is most appropriate for a context object</li><li>A flexible alternative to subcalssing</li></ul></li><li>They are both examples of Composition with Delegation!</li></ul><h3 id=summary-6>Summary</h3><ul><li>State Pattern:<ul><li>Encapsulate state-based behavior and delegate behavior to the current state</li></ul></li><li>Strategy Pattern:<ul><li>Encapsulate interchangeable behaviors and use delegation to decide which behavior to use</li></ul></li><li>Template Method:<ul><li>Subclasses decide how to implement steps in an algorithm</li></ul></li></ul><h2 id=builder-pattern>Builder Pattern</h2><ul><li>Purpose:<ul><li>Allows for the dynamic creation of objects based upon easily interchangeable algorithms.</li></ul></li><li>Use When:<ul><li>Runtime control over the creation process is required.</li><li>Multiple representations of creation algorithms are required.</li><li>Object creation algorithms should be decoupled form the system.</li><li>The addtion of new creation funcitonality without changing the core code is necessary.</li></ul></li></ul><h3 id=builder---participants>Builder - Participants</h3><ul><li>Client:<ul><li>selects director and concrete builder to build the product</li><li>asks concrete builder to return final constructed product</li></ul></li><li>Director:<ul><li>knows what steps it takes to build a product</li><li>but it does not know how each step is to be carried out</li></ul></li><li>Builder:<ul><li>specifies an abstract interface for creating parts of a Product object</li></ul></li><li>Concrtete Builder:<ul><li>constructs and assembles parts of the product by implementing the Builder interface</li><li>defines and keeps tractk of the representation it creates</li><li>provides an interface for retrieving the product</li></ul></li><li>Product:<ul><li>represents the complex object under construction</li></ul></li></ul><h3 id=when-a-builder-shouldnt-be-used>When a Builder Shouldn&rsquo;t Be Used</h3><ul><li>If the interface is not stable the Builder has few benefits:<ul><li>Every interface change requires a change to the Controller and impacts the abstract base class or its objects</li><li>A new method would require changing the base class and all concrete classes that will need to override the new method</li><li>A specific method interface change would require all concrete clases supporting the old method to change</li></ul></li></ul><h3 id=related-patterns-and-summary-1>Related Patterns and Summary</h3><ul><li>A Composite is what the Builder often builds</li><li>A Builder is a Strategy that is specialized to create a composite object or data struct</li><li>Comparison with Abstract Factory:<ul><li>Builder constructs the object step-by-step and the reulst is requested at a later stage</li><li>Abstract factory returns the requested object immediately</li><li>Abstract factory does not have an abstract builder; application calls the factory methods directly</li></ul></li></ul><h2 id=template-method-pattern>Template Method Pattern</h2><ul><li><p>Purpose:</p><ul><li>Identifies the framework of an algorithm, allowing implementing classes to define the actual behavior.</li></ul></li><li><p>Use When:</p><ul><li>A single abstract implementation of an algorithm is needed.</li><li>Common behavior among subclasses should be localized to a common class.</li><li>Parent classes should be able to uniformly invoke behavior in their subclasses.</li><li>Most of all subclasses need to implement the behavior</li></ul></li><li><p>The template pattern defines the steps of an algorithm and allows the subcalsses to implement one or more of the steps.</p></li><li><p>Encapsulates an algorithm by creating a template for it.</p></li><li><p>Defines the skeleton of an algorithm as a set of steps.</p></li><li><p>Some methods of the algorithm have to be implemented by the subclasses - these are abstract methods in the super class.</p></li><li><p>The subclasses can redefine certain steps of the algorithm without changing the algorithm&rsquo;s structure.</p></li><li><p>Some steps of the algorithm are concrete methods defined in the super class.</p></li></ul><h3 id=design-princi8ple-hollywood-principle>Design Princi8ple: Hollywood Principle</h3><ul><li>The Hollywood Principle: Don&rsquo;t call us, we&rsquo;ll call you!:<ul><li>It prevents &ldquo;Dependency rot&rdquo;</li><li>Dependency rot: high-level components depend on low-level components, and vice versa.</li></ul></li><li>With the Hollywood principle:<ul><li>We allow low level components to hook themselves into a system</li><li>But high level components determine when they are needed and how.</li><li>High level components give the low-level components a &ldquo;don&rsquo;t call use, we&rsquo;ll call you&rdquo; treatement.</li></ul></li></ul><h3 id=related-patterns-5>Related Patterns</h3><ul><li>Template Method uses inheritance to vary part of an algorithm.</li><li>Strategy uses delegation to vary the entire algorithm.</li><li>Factory Method is a specialization of Template Method</li></ul><h3 id=summary-7>Summary</h3><ul><li>Hollywood Principle:<ul><li>Don&rsquo;t call us, we&rsquo;ll call you</li></ul></li><li>Template Method Pattern:<ul><li>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.</li><li>Template Method lets subclsses redefine certain steps of an algorithm without changing the algorithm&rsquo;s structure.</li></ul></li></ul><h2 id=proxy-pattern>Proxy Pattern</h2><ul><li>Purpose:<ul><li>Allows for object level access control by acting as a pass through entity or a placeholder object.</li></ul></li><li>Use When:<ul><li>Access control for the original object is required.</li><li>Added funcitonality is required when an object is accessed.</li></ul></li><li>Proxy Pattern provides a surrogate or placeholder for another object to control access to it.</li></ul><h3 id=proxy-pattern-collaborations>Proxy Pattern Collaborations</h3><ul><li>Subject:<ul><li>defines the common interface for RealSubject and Proxy so that a Proxy can be used anywherer a RealSubject is expected</li></ul></li><li>RealSubject:<ul><li>defines the real object that the proxy represents</li></ul></li><li>Proxy:<ul><li>maintains a reference that lets the proxy access the real subject</li><li>provides an interface identical to Subject&rsquo;s so that a proxy can by substitued for the real subject</li><li>controls access to the real subject and may be responsible for creating and deleting it</li></ul></li></ul><h3 id=applicability>Applicability</h3><ul><li>whenever there is a need for a more versatile or sophisticated reference to an object than a simple pointer:<ul><li>remote proxy:<ul><li>responsible for encoding a request and its arguments and for sending the encoded request to the real subject in a different address space</li></ul></li><li>virtual proxy:<ul><li>may cache additional information about the real subject so that they can postpone accessing it</li></ul></li><li>protection proxy:<ul><li>checks that the caller has the access permissions required to perform a request</li></ul></li></ul></li></ul><h3 id=distributed-computing>Distributed Computing</h3><ul><li>Distributed Computing:<ul><li>involves the design and implementation of applications as a set of cooperating software entities (processes, threads, objects) that are distributed across a network of machines</li></ul></li><li>Advantages to Distributed Computing:<ul><li>Performance</li><li>Scalability</li><li>Resource Sharing</li><li>Fault Tolerance</li></ul></li><li>Difficulties in developing Distributed Computing systems:<ul><li>Latency</li><li>Synchronization</li><li>Partial Failure</li></ul></li></ul><h3 id=client-server-model-and-programming>Client-Server Model and Programming</h3><ul><li>Client-Server Model:<ul><li>Client - entity that makes a request for a service</li><li>Server - entity that responds to a request and provides a service</li><li>The predominant networking protocol in use today is the Internet Protocol (IP). The main API for writing client-server programs using IP is the Berkeley socket API.</li></ul></li><li>Programming:<ul><li>Dealing with all of the details of the socket library calls can be tedious.</li><li>The java.net package provides classes to abstract away many of the detials of socket-level programing, making it simple to write client-server applications</li></ul></li></ul><h3 id=remote-procedure-call-rpc>Remote Procedure Call (RPC)</h3><ul><li>Disadvantage of Client-Server model:<ul><li>Both the client and server had to be aware of the socket level details</li></ul></li><li>Wouldn&rsquo;t it be nice if even these details were abstracted away and the request to the server looked like a local procedure call from the viewpoint of the client?</li><li>That&rsquo;s the idea behind a Remote Procedure Call (RPC), a technology introduced in the late 1970&rsquo;s.</li></ul><h3 id=serialization-basics>Serialization basics</h3><ul><li>Serialization:<ul><li>the process of transforming an in-memory object to a byte stream.</li></ul></li><li>Deserialization:<ul><li>the inverse process of reconstructing an object from a byte stream to the same state in which the object was previously serialized.</li></ul></li><li>For an object to be serializable:<ul><li>its class or some ancestor must implement the empty <code>Serializable</code> interface</li></ul></li><li>An empty interface is called a marker interface</li></ul><h3 id=object-graphs-and-transient-fields>Object graphs and transient fields</h3><ul><li>If an object has references to other objects or arrays, the entire object graph is serialized when the object is serialized.:<ul><li>The object graph consists of the object directly serialized and any other objects or arrays to which the object has direct or indirect references.</li></ul></li><li>A field marked as <code>transient</code> is not impaced by serialization.:<ul><li>During deserialization, transient fields are restored to their default values</li></ul></li></ul><h3 id=related-patterns-6>Related Patterns</h3><ul><li><p>w.r.t. Interface:</p><ul><li>Adapter provides a different interface to its subject</li><li>Proxy provides the same interface</li><li>Decorator provides an enhanced interface</li></ul></li><li><p>w.r.t. Structure:</p><ul><li>Decorator and Proxy have similar structures</li><li>Both describe how to provide a level of indireciton to another object, and the implementations keep a reference to the object to which they forward requests</li></ul></li></ul><h2 id=chain-of-responsibility-pattern>Chain of Responsibility Pattern</h2><ul><li><p>Purpose:</p><ul><li>Gives more than one object an opportunity to handle a request by linking receiving objects together.</li></ul></li><li><p>Use When:</p><ul><li>Multiple objects may handle a request and the handler doesn&rsquo;t have to be a specific object.</li><li>A set of objects should be able to handle a request with the handler determined at runtime.</li><li>A request not being handled is an acceptable potential outcome.</li></ul></li><li><p>Each object in the chain:</p><ul><li>receives the request</li><li>handle it or forward it to the next object</li></ul></li><li><p>Notice:</p><ul><li>Object making the request has no knowledge of which object is handling the request</li><li>The request has an implicit receiver</li></ul></li></ul><h3 id=helphandler-class-diagram>HelpHandler class diagram</h3><ul><li>Each object in the chain shares a cmmon interface for handling requests and accessing its successor on the chain</li></ul><h3 id=participants-1>Participants</h3><ul><li>Handler:<ul><li>defines an interface for handling the requests</li><li>(optional) implements the successor link</li></ul></li><li>Concrete Handler:<ul><li>handles requests it is responsible for</li><li>can access its successor</li><li>if the COncrete Handler can handle the request, it does so; other wise it forwards the request to its successor</li></ul></li><li>Client:<ul><li>initiates the reuqest to a COncrete Handler object on the chain</li></ul></li></ul><h3 id=consequences>Consequences</h3><ul><li>Benefits:<ul><li>Decoupling of senders and receivers</li><li>Added flexibility</li><li>Sender doesn&rsquo;t need to know specifically who the handlers are</li></ul></li><li>Potential Drawbacks:<ul><li>Client can&rsquo;t explicitly specify who handles a request</li><li>No guarantee of request being handled (requirest falls off end of chain)</li></ul></li></ul><h3 id=implementation>Implementation</h3><ul><li>Implementing the successor chain:<ul><li>Option 1 : Define new links (in Handler or COncreteHandler)</li><li>Option 2 : Use existing links (such as the parent references from the Composite pattern)</li></ul></li><li>Connecting successors</li><li>Representing requests</li></ul><h3 id=related-pattern>Related pattern</h3><ul><li>Chain of responsibility is often applied in conjuction with Composite.</li><li>Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different tradeoffs.:<ul><li>Chain of Responsibility passes a sender request along a chain of potential receivers.</li></ul></li><li>Chain of Responsibility can use Command to represent requests as objects.</li></ul><h2 id=bridge-pattern>Bridge Pattern</h2><ul><li>Purpose:<ul><li>Defines an abstract object structure independently of the implementation object structure in order to limit coupling.</li></ul></li><li>Use When:<ul><li>Abstractions and implementations should not be bound at compile time.</li><li>Abstractions and implementations should be independently extensible.</li><li>Implementation details should be hidden from the client.</li></ul></li></ul><h3 id=problem-analysis>Problem Analysis</h3><ul><li>Problem: the class explosion, because:<ul><li>the coupling of the abstraction and the implementation is tight</li><li>each type of shape must know what type of drawing program it is using.</li></ul></li><li>Solution:<ul><li>Need to separate the variations in abstraction from the variations in implementation so that the number of classes only grows linearly</li></ul></li></ul><h3 id=introducing-bridge-pattern>Introducing Bridge Pattern</h3><ul><li>Intent of the Bridge pattern:<ul><li>decouples an abstraction from its implementation so that the two can vary independently</li></ul></li></ul><h3 id=structure-of-bridge-pattern>Structure of Bridge Pattern</h3><ul><li>Abstraction (and RefinedAbstraction) is a high-level control layer for some entity</li><li>This layer isn&rsquo;t supposed to do any real work on its own.</li><li>It should delegate the work to the implementation layer (also called platform).</li></ul><h3 id=participants--collaborations>Participants & Collaborations</h3><ul><li>Abstraction:<ul><li>defines the abstraction&rsquo;s interface</li><li>maintains a reference to the Implementor</li><li>forwards requests to the Implementator (collaboration)</li></ul></li><li>RefinedAbstraction:<ul><li>extends absraction interface</li></ul></li><li>Implementator:<ul><li>defines interface for implementations</li></ul></li><li>ConcreteImplementor:<ul><li>implemnts Implementor interface</li></ul></li></ul><h3 id=comparision-with-adapter>Comparision with Adapter</h3><ul><li>Similarities:<ul><li>Both used to hide the details of the underlying implementation.</li></ul></li><li>Difference:<ul><li>The adapter pattern is geared towards making unrelated components work together:<ul><li>Applied to systems after they&rsquo;re designed (reengineering, interface engineering).</li></ul></li><li>The bridge pattern is used up-front in a design to let abstractions and implementations vary independently.:<ul><li>Designing &ldquo;extensible system&rdquo;</li></ul></li><li>Structural difference:<ul><li>Bridge can abstract a complex entity from its implementation</li><li>Adapter only abstracts a single interface</li></ul></li></ul></li></ul><h3 id=summary-8>Summary</h3><ul><li>Bridge pattern:<ul><li>lets you split a large class or a set of closely related classes into two separate hierarchies - abstraction and implementation - which can be developed independently of each other.</li></ul></li></ul><h2 id=prototype-pattern>Prototype Pattern</h2><ul><li>Purpose:<ul><li>Create objects based upon a template of an existing objects through cloning.</li></ul></li><li>Use When:<ul><li>Composition, creation, and representation of objects should be decoupled from a system.</li><li>Classes to be created are specified at runtime.</li><li>Objects or object structures are required that are identical or closely resemble other existing objects or object structures.</li><li>The initial creation of each object is an expensive operation.</li><li>When to avoid building a class hierarchy of factories that parallels the class hierarchy of products.</li></ul></li></ul><h3 id=prototype---participants>Prototype - participants</h3><ul><li>Prototype:<ul><li>defines the interface (an operation) of cloning itself.</li></ul></li><li>ConcreteProduct1 and ConcreteProduct2:<ul><li>Concrete objects that can clone themselves.</li></ul></li><li>Client:<ul><li>Obtain more objects by asking them to clone themselves.</li></ul></li></ul><h3 id=whats-so-special-about-the-pattern>What&rsquo;s so special about the pattern?</h3><ul><li>Advantages of creational patterns:<ul><li>Hides concrete product classes from clients</li><li>Decouples the clients from the creational process</li></ul></li><li>Unique feature of Prototype:<ul><li>Prototypes can be supplied and changed at runtime</li><li>Thus, it provides great flexibility in configuring and changing a program at runtime:<ul><li>Adding and removing products at run-time</li><li>Reduced subclassing</li><li>Configuring an application with classes dynamically:<ul><li>Loading the classes dynamically</li></ul></li></ul></li></ul></li></ul><h3 id=cloning-in-java>Cloning in JAVA</h3><ul><li>Java provides support from cloning with <code>Cloneable</code> interface and a protected method clone method in the Object class.</li><li>Any class using the built-in cloning mechanism is supposed to:<ul><li>Implement the Cloneable interface</li><li>Define a concrete public or protected <code>clone()</code> operation</li><li>In the <code>clone()</code> operation, obtain a new object by calling <code>super.clone()</code></li></ul></li><li>Default <code>clone()</code> operation makes a shallow copy!</li></ul><h3 id=review>Review</h3><ul><li>Be aware of the shallow cloning VS deep cloning</li><li>Prototypes are useful when object initialization is expensive, and you anticipate few variations on the initialization parameters. In this context, Prototype can avoid expensive &ldquo;creation from scratch&rdquo;, and support cheap cloning of a pre-initialized prototype.</li><li>Abstract Factory and Prototype can be used together:<ul><li>Abstract Factory can store set of prototypes which are cloned to return product objects</li></ul></li><li>Very useful with Composite and Decorator patterns</li></ul><h2 id=visitor-pattern>Visitor Pattern</h2><ul><li>Purpose:<ul><li>Allowing one or more operations to be applied to a set of objects at runtime</li><li>Decoupling the operations from the object structure (= the set of objects)</li></ul></li><li>Use when:<ul><li>An object structure must have many unrelated operations performed upon it</li><li>The object structure can&rsquo;t change but operations on it can</li><li>Operations must be performed on the ocncrete classes of an object structure</li><li>Operations should be albe to operate on multiple object structures that implement the same interface sets</li></ul></li></ul><h3 id=motivations-and-benefits>Motivations and Benefits</h3><ul><li>Motivations:<ul><li>An object structure contains many classes of objects</li><li>Many distinct and unrelated operations on these objects -> We want to avoid &ldquo;polluting&rdquo; their classes</li><li>Classes defining the object structure rarely change, but operations change frequently</li></ul></li><li>Benefits:<ul><li>Makes adding new operations easy</li><li>Gathers related operations and separates unrelated operations</li><li>Visitors can visit objects that don&rsquo;t have a common parent class</li></ul></li></ul><h3 id=participants-2>Participants</h3><ul><li>Visitor:<ul><li>declares a visit operation for each class of ConcreteElement in the ojbect structure</li></ul></li><li>ConcreteVisitor:<ul><li>implements each operation declared by Visitor</li></ul></li><li>Element:<ul><li>defines an Accept operation that takes a visitor as an argument</li></ul></li><li>ConcreteElement:<ul><li>implements an Accept operation that takes a visitor as an argument</li></ul></li><li>ObjectStructure:<ul><li>can enumerate its elements</li><li>may provide a high-level interface to allow the visitor to visit its elements</li><li>may be a composite or a collection like a set or list</li></ul></li></ul><h3 id=collaborations>Collaborations</h3><ul><li>A client must create ConcreteVisitor object and then traverse the object structure, visiting each element with the visitor</li><li>When the element is visited, it calls the Visitor operation that corresponds to its class.</li><li>The element supplies itself as an argument to this operation to let the visitor access its state, if necessary</li></ul><h3 id=method-overloading>Method Overloading</h3><ul><li>Method overloading, however, is done at compile time:<ul><li>useing &ldquo;name mangling&rdquo; where the internal name of the method has the argument&rsquo;s type encoded in it</li><li>Different from method overriding (run-time polymorphism)</li></ul></li></ul><h3 id=technical-details>Technical Details</h3><ul><li>Double Dispatch:<ul><li>special form of multiple dispatch</li><li>a mechanism that dispatches a method call to different concrete methods depending on the runtime types of two objects involved in the call</li></ul></li><li>Single Dispatch:<ul><li>In most object-oriented systems, the concrete method that is called from a method call in the code depends on the dynamic type of a single object and therefore they are known as single dispatch calls or simply virtual function(method) calls</li></ul></li></ul><h3 id=how-double-dispatch-is-implemented-in-visitor-pattern>How Double-dispatch is implemented in Visitor Pattern</h3><ul><li>Consequently, the implementation of the visit method is chosen based on both:<ul><li>The dynamic type of the element</li><li>The dynamic type of the visitor</li></ul></li><li>This effectively implemnts double dispatch:<ul><li>Common Lisp language&rsquo;s object system supports multiple dispatch (not just single dispatch), and implementing the visitor pattern in Common Lisp is trivial</li></ul></li></ul><h3 id=benefits-1>Benefits</h3><ul><li>Visitor makes adding new operations easy:<ul><li>You can define a new operation simply by adding a new visitor</li><li>In contrast, if you spread funcitonality over many classes, then you must change each class to define a new operation</li></ul></li><li>A visitor gathers related operations and separates unrelated ones:<ul><li>Related behavior is not spread over the classes defining the object strcture; it&rsquo;s localized in a visitor</li><li>Unrelated sets of behavior are partitioned in their own visitor classes</li></ul></li></ul><h3 id=liabilities>Liabilities</h3><ul><li>Adding new ConcreteElement classes is hard:<ul><li>The Visitor pattern makes it hard to add new subclasses of Element</li><li>Each new COncreteElement gives rise to a new abstract operation on Visitor and a corresponding implementation in every ConcreteVisitor class</li></ul></li><li>Breaking encapsulation:<ul><li>Visitor&rsquo;s approach assumes that the ConcreteElement interface is powerful enough to let visitors do their job</li><li>The pattern often ofrces you to provide public operations that access an element&rsquo;s internal state, which may compromise its encapsulation.</li></ul></li></ul><h3 id=implementation-of-traversal>Implementation of Traversal</h3><ul><li>Who is responsible for traversing the object structure?:<ul><li>A visitor must visit each elemnt of the object structure.</li><li>We can put responsibility for traversal in any of three places:<ul><li>In the object structure</li><li>In the visitor</li><li>In a seperate Iterator object</li></ul></li><li>Having the traversal code in the visitor is the least preferred option, as it forces you to repeat the code in every ConcreteVisitor for each ConcreteElement</li></ul></li></ul><h3 id=summary-9>Summary</h3><ul><li>The Visitor Design Pattern:<ul><li>(+) makes adding new operations easy</li><li>(+) gathers related operations and separates unrelated ones</li><li>(-) adding new COncreteElement classes is hard</li><li>(-) Breaks encapsulation</li></ul></li><li>Implementation Issues:<ul><li>Who is responsible for traversing the object structure?</li></ul></li></ul><h2 id=design-patterns-review>Design Patterns Review</h2><h3 id=abstraction>Abstraction</h3><ul><li>Hiding details:<ul><li>for the purpose of simplifying and managing the design of complex software.</li></ul></li><li>Allows to separate categories and concepts related to problems from specific instances of implementation.:<ul><li>It means that code can be written so that:<ul><li>it does not depend on the specific detials (e.g. supporting applications, operating system software or hardware)</li><li>but it depends on an abstract concept of the solution to the problem that can be integrated with the system with minimal additional work.</li></ul></li></ul></li></ul><h3 id=information-hiding-and-encapsulation>Information hiding and Encapsulation</h3><ul><li>Design principles for hiding internal design decisions related to the selected algorithm and data structures of a module from the outside world.:<ul><li>the internal design decisions are most likely to change</li><li>Thus, reduce the side effects of any future maintenance or modification of the design and hence minimizing the effect on the other modules in the design</li></ul></li><li>Information hiding : Encapsulation = Principle : Technique</li></ul><h3 id=separation-of-concerns-soc>Separation of COncerns (SoC)</h3><ul><li>Deisgn principle for separating a computer program into distinct sections, such that each section address a separate concern.</li><li>A concern is a set of information that affects the code of a computer program.</li><li>Can be traced back to &ldquo;divide and conqure&rdquo;</li><li>A program that embodies SoC well is called modular.</li><li>Modularity, and hence separation of concerns, is achieved by encapsulating information inside a section of code that has a well-defined interface</li></ul><h3 id=interfaces>Interfaces</h3><ul><li>Interfaces are the points of accesses through which modules or systems communicated.</li><li>Each abstraction should possess a well defined interface clearly describing the expected inputs to and outputs from the abstraction.</li><li>If the objects are fully encapsulated then the interface will describe the only way in which objects may be accessed by other objects.</li></ul><h3 id=modularity>Modularity</h3><ul><li>Goal of design:<ul><li>partition the system into modules and assign responsibility among the components</li></ul></li><li>MOdularity reduces the total complexity a programmer has to deal with at any one time:<ul><li>Functions are assigned to modules in a way that groups similar functions together (Separation of Concerns), and</li><li>There are small, simple, well-defined interfaces between modules (Infromation Hiding)</li></ul></li></ul><h3 id=measuring-mdoularity>Measuring Mdoularity</h3><ul><li>Coupling is a measure of the dependencies between modules</li><li>Cohesion is a measure of how strongly the elements in a module are related.</li></ul><h3 id=copuling>Copuling</h3><ul><li>Low (or loose) coupling : Good:<ul><li>refers to a relationship in which one module interacts with another module through a stable interface and does not need to be concerned with the otehr module&rsquo;s internal implementation</li></ul></li><li>High (or tight) coupling: Bad:<ul><li>Systems migh experience the following difficulties:<ul><li>Change in one module forces a ripple of changes in other modules.</li><li>Modules are difficult to understand in isolation.</li><li>Modules are difficult to reuse or test becase dependent modules msut be included.</li></ul></li></ul></li><li>Low coupling can be achieved by:<ul><li>eliminating unncessary relationships</li><li>reducing the number of necessary relationships</li></ul></li></ul><h3 id=cohesion>Cohesion</h3><ul><li>Definition:<ul><li>The degree to which all elements of a module are directed towards a single task.</li><li>The degree to which all elements directed towards a task are contained in a single modules</li></ul></li></ul><h3 id=review-of-behavioral-patterns>Review of Behavioral Patterns</h3><h4 id=encapsulating-varitions>Encapsulating Varitions</h4><ul><li><p>Encapsulate an aspect that changes frequently:</p><ul><li>Strategy: algorithms</li><li>State: state-dependent behaviors</li><li>Mediator: protocols between objects</li><li>Iterator: the way you access and traverse componenets of aggregate object</li></ul></li><li><p>Two kinds of objects in teh above patterns:</p><ul><li>new object(s) that encapsulate the aspect</li><li>existing object(s) that use the new ones</li><li>functionality of new obecjts was integeral part of the existing objects:<ul><li>ex) Strategy and State code : originally in Context class</li></ul></li><li>Not all object behavioral patterns like this:<ul><li>ex) COR: all of the objects already exist in the system</li></ul></li></ul></li></ul><h4 id=object-as-arguments>Object as ARguments</h4><ul><li>Several patterns introduce an object that&rsquo;s used as an argument:<ul><li>Visitor:<ul><li>visitor object is the argument to polymorphic <code>accept()</code> operation on the objects it visits</li></ul></li><li>Command:<ul><li>act as tokens toe be passed around and invoked later</li><li>the token represents a request</li></ul></li></ul></li></ul><h4 id=decoupling-senders-and-receviers>Decoupling Senders and Receviers</h4><ul><li><p>Related Patterns:</p><ul><li>Command</li><li>Observer</li><li>Mediator</li><li>Chain of Responsibility</li></ul></li><li><p>Command Pattern:</p><ul><li>decouples invokers and receivers by command objects</li><li>allow senders to work with different receivers</li><li>a subclass for a sender-receiver connection</li></ul></li><li><p>Observer Pattern:</p><ul><li>decouples subjects and observers by an interface for signaling changes</li><li>a subject may have multiple observers</li><li>the number of observers can vary at run-time</li><li>best for decoupling objects with data dependencies</li></ul></li><li><p>Mediator Pattern:</p><ul><li>decouple objects (Colleagues) through a Mediator object</li><li>routes requests between Colleague objects</li><li>centralizes communication between Colleague objects</li></ul></li><li><p>Chain of Responsibility (COR) Pattern:</p><ul><li>decouple client and handler by passing the request along a chain</li><li>when the chain is part of the system&rsquo;s structure</li><li>when one of several objects may be in a position to handler the request</li></ul></li></ul><h4 id=communication-encapsulate-vs-distribute>Communication: Encapsulate vs. Distribute</h4><ul><li>Mediator:<ul><li>encapsulates communication between objects</li><li>centralizes communications</li><li>maintains a communication constraint in the mediator</li><li>(-) mediators are hardly ever reusable</li><li>(+) easire to understand the flow of communication</li></ul></li><li>Observer:<ul><li>distributes communication by introducing Observer and Subject objects</li><li>observer and subject cooperate to maintain a constraint</li><li>(+) easire to make reusable observers and subjects</li><li>(-) difficult to understand the flow of communication</li></ul></li></ul><h3 id=review-of-structural-patterns>Review of Structural Patterns</h3><h4 id=adapter-vs-bridge>Adapter vs. Bridge</h4><ul><li><p>Common:</p><ul><li>Both promote flexibility by providing a level of indirection to another object</li></ul></li><li><p>Adapter:</p><ul><li>Focuses on resolving incompatibilities between two existing interfaces:<ul><li>Not focus on how those interfaces are implemented</li><li>Nor does it consider how they might evolve independently</li></ul></li><li>It&rsquo;s a way of making two indepdently designed classes work together without re-implementing one ro the other</li></ul></li><li><p>Bridge:</p><ul><li>Linking an abstraction and its (potentially numerous) implementations</li><li>It provides a stable interface to clients even as it lets you vary the classes that implement it:<ul><li>It also acoomodates new implementations as the system evolves</li></ul></li></ul></li><li><p>Using points of Adapter:</p><ul><li>Becomes necessary when you discover that two incompatible classes should work together</li><li>The coupling is unforeseen</li><li>The Adapter pattern makes things work after they&rsquo;re designed</li></ul></li><li><p>Using points of Bridge:</p><ul><li>The user of a bridge understands up-front that an abstraction must have several implementations, and both may evolve independently</li><li>The Bridge pattern makes them work before they are</li></ul></li></ul><h4 id=adapter-vs-facde>Adapter vs. Facde</h4><ul><li>Common:<ul><li>Both act as wrappers of a pre-existing class</li><li>Both tkae an interface that we don&rsquo;t need and convert it to an interface that we can use</li></ul></li><li>Facade:<ul><li>simplify the existing interface</li><li>defines a new interface</li></ul></li><li>Adapter:<ul><li>we have a target interface that we are converting to</li><li>reuses an old interface:<ul><li>Often want the dapter to plug into an exsiting framework and behave polymorphically</li></ul></li></ul></li></ul><h4 id=composite-vs-decorator>Composite vs. Decorator</h4><ul><li>Common:<ul><li>recursive composition</li></ul></li><li>Decorator:<ul><li>add responsibilities to objects without subclassing</li><li>avoids the explosion of subclasses that can arise from trying to cover every combination of responsibilities statically</li></ul></li><li>Composite:<ul><li>related objects can be treated uniformly, and multiple objects can be treated as one</li><li>focus not on embellishment but on representation</li></ul></li></ul><h4 id=decorator-vs-proxy>Decorator vs. Proxy</h4><ul><li>Common:<ul><li>Both provide a level of indirection to an object</li><li>Both keep an reference to another object</li><li>Both provide an identical interface to clients</li></ul></li><li>Proxy:<ul><li>control access to an object:<ul><li>A subject defines functionality</li><li>A proxy provides (or refuses) access of funcitonality of a subject</li></ul></li><li>focus on the relationship between the proxy and its subject</li></ul></li><li>Decorator:<ul><li>add responsibilities to an object:<ul><li>A component provides only part of the functionality</li><li>One or more decorators add functionalities to a component in runtime.</li></ul></li></ul></li></ul><h3 id=review-of-creational-patterns>Review of Creational Patterns</h3><h4 id=parameterizing-a-system>Parameterizing a System</h4><ol><li>Subclassing:</li></ol><ul><li>Require creating a new subclass just to change the class of the product</li><li>Factory Method</li></ul><ol start=2><li>Object composition:</li></ol><ul><li>Define an object responibile for knowing the class of the product objects and make it a parameter of the system</li><li>Abstract Factory:<ul><li>the factory object produces objects of several classes</li></ul></li><li>Builder:<ul><li>the factory object builds a complex product incrementally using a correspondingly complex protocol</li></ul></li><li>Prototype:<ul><li>the factory object builds a product by copying a prototype object</li><li>the factory object and the prototype are the same object</li></ul></li></ul><h4 id=facotry-method-vs-abstract-factory>Facotry Method vs Abstract Factory</h4><ul><li>Factory Method:<ul><li>Define an interface for creating an object, but let subclasses decide which class to instantiate.</li><li>Let a class defer instantiation to be subclasses</li><li>Uses inheritance (subclassing)</li></ul></li><li>Abstract Factory:<ul><li>Provide an interface for creating familites of related or dependent objects without specifying their concrete classes.</li><li>Uses composition</li></ul></li></ul><h4 id=evolution-of-creational-patterns>Evolution of Creational Patterns</h4><ul><li>Factory Method makes a design more customizable and only a little more complicated, since other design patterns require new classes</li><li>Use Factory Method as the staring point to creat objects</li><li>Abstract Factory, Prototype, or Builder are more flexible but also more complex.:<ul><li>They can be used when more flexibility is needed</li></ul></li></ul><h4 id=removing-conditional-statements>Removing Conditional Statements</h4><ul><li>Object Type:<ul><li>Polymorphism</li></ul></li><li>Action name:<ul><li>Command pattern</li></ul></li><li>Algorithms:<ul><li>Strategy pattern</li></ul></li><li>State dependent behaviors:<ul><li>State patterns</li></ul></li><li>Exceptional cases:<ul><li>Null Object pattern</li></ul></li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>