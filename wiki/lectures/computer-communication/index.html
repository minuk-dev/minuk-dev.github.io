<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>컴퓨터통신 |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>컴퓨터통신 -
minuk dev wiki</div></header><main><aside class=sidebar><ul class=section-tree><li class="dir opened-dir"><span class=dir-text>Front Page</span><ul class=section-tree><li class=file><a href=https://minuk.dev/wiki/kubernetes-community-day-korea/ title=./wiki/kubernetes-community-day-korea/>Kubernetes Community Day 2024</a></li><li class=file><a href=https://minuk.dev/wiki/observability-engineering-kr/ title=./wiki/observability-engineering-kr/>Observability Engineering</a></li><li class=file><a href=https://minuk.dev/wiki/learning-opentelemetry/ title=./wiki/learning-opentelemetry/>Learning OpenTelemetry</a></li><li class=file><a href=https://minuk.dev/wiki/prometheus-native-histograms-in-production/ title=./wiki/prometheus-native-histograms-in-production/>prometheus-native-histograms-in-proudction</a></li><li class=file><a href=https://minuk.dev/wiki/making-sense-of-your-vital-signals-the-future-of-pod-and-containers-monitoring/ title=./wiki/making-sense-of-your-vital-signals-the-future-of-pod-and-containers-monitoring/>Making Sense of Your Vital Signals - The Future of Pod and Containers Monitoring</a></li><li class=file><a href=https://minuk.dev/wiki/defining-a-common-observability-query-language-and-other-observability-tag-updates/ title=./wiki/defining-a-common-observability-query-language-and-other-observability-tag-updates/>Defining A Common Observability Query Language and Other observability TAG Updates</a></li><li class=file><a href=https://minuk.dev/wiki/beyond-tracing-what-do-we-do-with-all-this-data/ title=./wiki/beyond-tracing-what-do-we-do-with-all-this-data/>Beyond Tracing - What do we do with all this data</a></li><li class=file><a href=https://minuk.dev/wiki/grafanacon/ title=./wiki/grafanacon/>grafanacon</a></li><li class=file><a href=https://minuk.dev/wiki/observability-engineering/ title=./wiki/observability-engineering/>Observability Engineering</a></li><li class=file><a href=https://minuk.dev/wiki/rust/ title=./wiki/rust/>rust</a></li><li class=file><a href=https://minuk.dev/wiki/opentelemetry-metrics-deep-dive/ title=./wiki/opentelemetry-metrics-deep-dive/>opentelemetry metrics deep dive</a></li><li class=file><a href=https://minuk.dev/wiki/armeria/ title=./wiki/armeria/>armeria</a></li><li class=file><a href=https://minuk.dev/wiki/kotlin/ title=./wiki/kotlin/>kotlin</a></li><li class=file><a href=https://minuk.dev/wiki/loki-best-practices/ title=./wiki/loki-best-practices/>loki label best practices</a></li><li class=file><a href=https://minuk.dev/wiki/loki/ title=./wiki/loki/>loki</a></li><li class=file><a href=https://minuk.dev/wiki/grafana-loki-like-prometheus-but-for-logs/ title=./wiki/grafana-loki-like-prometheus-but-for-logs/>Grafana Loki - Like Prometheus, But for logs.</a></li><li class=file><a href=https://minuk.dev/wiki/spring-boot-cli/ title=./wiki/spring-boot-cli/>spring boot cli</a></li><li class=file><a href=https://minuk.dev/wiki/autoconf/ title=./wiki/autoconf/>autoconf</a></li><li class=file><a href=https://minuk.dev/wiki/re-minuk-k8s/ title=./wiki/re-minuk-k8s/>다시 시작하는 쿠버네티스 세팅</a></li><li class=file><a href=https://minuk.dev/wiki/cloud-native-go/ title=./wiki/cloud-native-go/>Cloud Native Go</a></li><li class=file><a href=https://minuk.dev/wiki/overlayfs/ title=./wiki/overlayfs/>overlayfs</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/design-pattern/ title=./wiki/lectures/design-pattern/>lectures/design-pattern</a></li><li class=file><a href=https://minuk.dev/wiki/site-reliability-engineering/ title=./wiki/site-reliability-engineering/>사이트 신뢰성 엔지니어링</a></li><li class=file><a href=https://minuk.dev/wiki/to-ipv6-the-dual-stack-adoption-advisory-panel/ title=./wiki/to-ipv6-the-dual-stack-adoption-advisory-panel/>To IPv6 - The Dual-stack Adoption Advisory Panel</a></li><li class=file><a href=https://minuk.dev/wiki/prometheus-intro-and-deep-dive/ title=./wiki/prometheus-intro-and-deep-dive/>Prometheus Intro and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/cs/ title=./wiki/cs/>cs 기본</a></li><li class=file><a href=https://minuk.dev/wiki/coredns/ title=./wiki/coredns/>learning-coredns</a></li><li class=file><a href=https://minuk.dev/wiki/coredns-into-and-deep-dive/ title=./wiki/coredns-into-and-deep-dive/>CoreDNS - Intro and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/deep-dive-into-minikube/ title=./wiki/deep-dive-into-minikube/>Deep Dive into Minikube</a></li><li class=file><a href=https://minuk.dev/wiki/making-your-apps-and-infrastructure-services-failure-resilient-with-dapr/ title=./wiki/making-your-apps-and-infrastructure-services-failure-resilient-with-dapr/>Making Your Apps and Infrastructure Services Failure-Resilient with Dapr</a></li><li class=file><a href=https://minuk.dev/wiki/make-cloud-native-chaos-engineering-easier-deep-dive-into-chaos-mesh/ title=./wiki/make-cloud-native-chaos-engineering-easier-deep-dive-into-chaos-mesh/>Make Cloud Native Chaos Engineering Easier Deep Dive into Chaos Mesh</a></li><li class=file><a href=https://minuk.dev/wiki/selinux/ title=./wiki/selinux/>selinux</a></li><li class=file><a href=https://minuk.dev/wiki/http-go/ title=./wiki/http-go/>go snippet for go</a></li><li class=file><a href=https://minuk.dev/wiki/curl/ title=./wiki/curl/>curl</a></li><li class=file><a href=https://minuk.dev/wiki/volcano-intro-and-deep-dive/ title=./wiki/volcano-intro-and-deep-dive/>Volcano - Intro & Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/intro-to-kubernetes-gitops-and-observability-hands-on-tutorial/ title=./wiki/intro-to-kubernetes-gitops-and-observability-hands-on-tutorial/>Intro to Kubernetes, GitOps, and Observability Hands-On Tutorial</a></li><li class=file><a href=https://minuk.dev/wiki/kubespray/ title=./wiki/kubespray/>kubespray</a></li><li class=file><a href=https://minuk.dev/wiki/spark-on-kubernetes-the-elastic-story/ title=./wiki/spark-on-kubernetes-the-elastic-story/>Spark on Kubernetes - The Elastic Story</a></li><li class=file><a href=https://minuk.dev/wiki/devops%EC%99%80-se%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%9D%B4%EC%95%BC%EA%B8%B0/ title=./wiki/devops%EC%99%80-se%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%9D%B4%EC%95%BC%EA%B8%B0/>DevOps와 SE를 위한 리눅스 커널 이야기</a></li><li class=file><a href=https://minuk.dev/wiki/running-containerd-and-k3s-on-macos/ title=./wiki/running-containerd-and-k3s-on-macos/>Running Containerd and k3s on MacOS</a></li><li class=file><a href=https://minuk.dev/wiki/twelve-factor-app/ title=./wiki/twelve-factor-app/>12요소 어플리케이션</a></li><li class=file><a href=https://minuk.dev/wiki/vim-go/ title=./wiki/vim-go/>vim/vim-go</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-patterns/ title=./wiki/kubernetes-patterns/>쿠버네티스 패턴</a></li><li class=file><a href=https://minuk.dev/wiki/horizontalpodautoscaler/ title=./wiki/horizontalpodautoscaler/>Horizontal Pod AutoScaler</a></li><li class=file><a href=https://minuk.dev/wiki/what-if-kube-apiserver-could-be-extended-via-webassembly/ title=./wiki/what-if-kube-apiserver-could-be-extended-via-webassembly/>What If… Kube-Apiserver Could be Extended Via WebAssembly?</a></li><li class=file><a href=https://minuk.dev/wiki/the-future-of-reproducible-research-powered-by-kubeflow/ title=./wiki/the-future-of-reproducible-research-powered-by-kubeflow/>The Future Of Reproducible Research - Powered by Kubeflow</a></li><li class=file><a href=https://minuk.dev/wiki/this-is-the-way-a-crash-course-on-intricacies-of-managing-cpus/ title=./wiki/this-is-the-way-a-crash-course-on-intricacies-of-managing-cpus/>This is The Way- A Crash Course on the Intricacies of Managing CPUs in K8s</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-graceful-shutdown/ title=./wiki/kubernetes-graceful-shutdown/>kubernetes-graceful-shutdown</a></li><li class=file><a href=https://minuk.dev/wiki/dockerfile/ title=./wiki/dockerfile/>dockerfile</a></li><li class=file><a href=https://minuk.dev/wiki/automated-progressive-delivery-using-gitops-and-service-mesh/ title=./wiki/automated-progressive-delivery-using-gitops-and-service-mesh/>Automated Progressive Delivery Using GitOps and Service Mesh</a></li><li class=file><a href=https://minuk.dev/wiki/containerd-proejct-update-and-deep-dive/ title=./wiki/containerd-proejct-update-and-deep-dive/>containerd Project Update and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/http2/ title=./wiki/http2/>http2 탐구</a></li><li class=file><a href=https://minuk.dev/wiki/grpc-for-microservices/ title=./wiki/grpc-for-microservices/>gRPC For Microservices Service-mesh and Observability</a></li><li class=file><a href=https://minuk.dev/wiki/kubecon/ title=./wiki/kubecon/>kubecon</a></li><li class=file><a href=https://minuk.dev/wiki/go-http/ title=./wiki/go-http/>go-http</a></li><li class=file><a href=https://minuk.dev/wiki/go/ title=./wiki/go/>go</a></li><li class=file><a href=https://minuk.dev/wiki/cri/ title=./wiki/cri/>CRI(Container Runtime Interface)</a></li><li class=file><a href=https://minuk.dev/wiki/vagrant/ title=./wiki/vagrant/>vagrant</a></li><li class=file><a href=https://minuk.dev/wiki/jsonpath/ title=./wiki/jsonpath/>jsonpath</a></li><li class=file><a href=https://minuk.dev/wiki/systemctl/ title=./wiki/systemctl/>systemctl 중요한것만 정리</a></li><li class=file><a href=https://minuk.dev/wiki/init/ title=./wiki/init/>linux init 요약</a></li><li class=file><a href=https://minuk.dev/wiki/process-cli/ title=./wiki/process-cli/>process 관련된 명령어 모음</a></li><li class=file><a href=https://minuk.dev/wiki/process-status/ title=./wiki/process-status/>process-status</a></li><li class=file><a href=https://minuk.dev/wiki/teamnote-go/ title=./wiki/teamnote-go/>teamnote-go</a></li><li class=file><a href=https://minuk.dev/wiki/cgroups/ title=./wiki/cgroups/>cgroup</a></li><li class=file><a href=https://minuk.dev/wiki/namespaces/ title=./wiki/namespaces/>namespaces</a></li><li class=file><a href=https://minuk.dev/wiki/lxc/ title=./wiki/lxc/>LXC</a></li><li class=file><a href=https://minuk.dev/wiki/devops/ title=./wiki/devops/>devops</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/supply-and-demand/ title=./wiki/ringle/supply-and-demand/>Supply and Demand</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/the-metaverse/ title=./wiki/ringle/the-metaverse/>ringle/The metaverse</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/microsoft-x-activision-blizzard/ title=./wiki/ringle/microsoft-x-activision-blizzard/>ringle/Microsoft x Activision Blizzard</a></li><li class=file><a href=https://minuk.dev/wiki/topcit/ title=./wiki/topcit/>topcit 간략 공부</a></li><li class=file><a href=https://minuk.dev/wiki/software-engineering-at-google/ title=./wiki/software-engineering-at-google/>구글 엔지니어는 이렇게 일한다</a></li><li class=file><a href=https://minuk.dev/wiki/k8s-in-rpi/ title=./wiki/k8s-in-rpi/>k8s-in-rpi</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes/ title=./wiki/kubernetes/>kubernetes</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/numerical_analysis/ title=./wiki/lectures/numerical_analysis/>수치해석</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/information_security_theory/ title=./wiki/lectures/information_security_theory/>2022-1 정보보호이론</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/ title=./wiki/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/>제텔카스텐</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A7%81%EA%B8%80/autonomous/ title=./wiki/%EB%A7%81%EA%B8%80/autonomous/>링글/Autonomous</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A7%81%EA%B8%80/metaverse/ title=./wiki/%EB%A7%81%EA%B8%80/metaverse/>링글/Metaverse</a></li><li class=file><a href=https://minuk.dev/wiki/algorithm/ title=./wiki/algorithm/>algorithm</a></li><li class=file><a href=https://minuk.dev/wiki/study-note/ title=./wiki/study-note/>study-note</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/machine-learning/ title=./wiki/lectures/machine-learning/>2022 1학기 머신러닝</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-in-action/ title=./wiki/kubernetes-in-action/>Kubernetes in action</a></li><li class=file><a href=https://minuk.dev/wiki/effective-java/ title=./wiki/effective-java/>Effective Java</a></li><li class=file><a href=https://minuk.dev/wiki/kafka/ title=./wiki/kafka/>Kafka</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/ title=./wiki/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/>면접 준비 자료</a></li><li class=file><a href=https://minuk.dev/wiki/zsh/ title=./wiki/zsh/>zsh</a></li><li class=file><a href=https://minuk.dev/wiki/simple-file/ title=./wiki/simple-file/>Simple한 File Server</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-12-03/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-12-03/>회고/2021-12-03</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week3/ title=./wiki/lectures/bayesian/week3/>bayesian/week3</a></li><li class=file><a href=https://minuk.dev/wiki/jupyter/ title=./wiki/jupyter/>jupyter notebook</a></li><li class=file><a href=https://minuk.dev/wiki/ffmpeg/ title=./wiki/ffmpeg/>ffmpeg 를 사용한 convert 요약</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week2/ title=./wiki/lectures/bayesian/week2/>bayesian/week2</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week1/ title=./wiki/lectures/bayesian/week1/>bayesian/week1</a></li><li class=file><a href=https://minuk.dev/wiki/pdf-test/ title=./wiki/pdf-test/>pdf-test</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/automata/ title=./wiki/lectures/automata/>오토마타와 형식언어 정리</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/computer-communication/ title=./wiki/lectures/computer-communication/>컴퓨터통신</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/introduction-to-statistical-learning/ title=./wiki/lectures/introduction-to-statistical-learning/>통계학습개론(Introduction to statistical learnning) 수업 정리</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian-statistics/ title=./wiki/lectures/bayesian-statistics/>베이지안 통계학(Bayesian Statistics)</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/multi-variant-statistical-analysis/ title=./wiki/lectures/multi-variant-statistical-analysis/>Multi Variant Statistical Analysis</a></li><li class=file><a href=https://minuk.dev/wiki/comment/ title=./wiki/comment/>주석 관련 좋은 글</a></li><li class=file><a href=https://minuk.dev/wiki/ssh/ title=./wiki/ssh/>ssh 관련 명령어 모음</a></li><li class=file><a href=https://minuk.dev/wiki/msk/ title=./wiki/msk/>amazon msk 삽질</a></li><li class=file><a href=https://minuk.dev/wiki/keras-book/ title=./wiki/keras-book/>케라스 창시자에게 배우는 딥러닝 책 공부</a></li><li class=file><a href=https://minuk.dev/wiki/msa-from-ddd/ title=./wiki/msa-from-ddd/>도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-07-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-07-18/>2021-07-21 회고</a></li><li class=file><a href=https://minuk.dev/wiki/iamroot19/ title=./wiki/iamroot19/>아이엠루트 스터디 자료 정리</a></li><li class=file><a href=https://minuk.dev/wiki/boj-9019/ title=./wiki/boj-9019/>boj-9019</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-06-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-06-19/>2021년 6월 19일 회고</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%8F%85%EC%84%B1%EB%A7%90%ED%88%AC/ title=./wiki/%EB%8F%85%EC%84%B1%EB%A7%90%ED%88%AC/>독성말투</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/regression/ title=./wiki/lectures/regression/>Regression Analysis</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%94%BC%EC%8B%9C%EC%8B%A4/ title=./wiki/%ED%94%BC%EC%8B%9C%EC%8B%A4/>피시실</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/multicore/ title=./wiki/lectures/multicore/>Multicore Computing</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/ns3/ title=./wiki/lectures/ns3/>Network Simulator 3</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/nonparametric-statistic/ title=./wiki/lectures/nonparametric-statistic/>비모수 통계학</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/wireless/ title=./wiki/lectures/wireless/>wireless 무선이동통신 수업</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/database_system/ title=./wiki/lectures/database_system/>Database System</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/ title=./wiki/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/>카카오워크</a></li><li class=file><a href=https://minuk.dev/wiki/soma/ title=./wiki/soma/>소프트웨어 마에스트로</a></li><li class=file><a href=https://minuk.dev/wiki/linux_kakaotalk/ title=./wiki/linux_kakaotalk/>리눅스 카카오톡</a></li><li class=file><a href=https://minuk.dev/wiki/latina/ title=./wiki/latina/>라틴어</a></li><li class=file><a href=https://minuk.dev/wiki/blk-mq/ title=./wiki/blk-mq/>Multi-Queue Block IO Queueing (blk-mq)</a></li><li class=file><a href=https://minuk.dev/wiki/linux-study/ title=./wiki/linux-study/>linux-study</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-12-20/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-12-20/>2020-12-20 회고</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/scheduling/ title=./wiki/linux-debug/scheduling/>linux-debug/scheduling</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/synchronization/ title=./wiki/linux-debug/synchronization/>linux-debug/synchronization</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/timer/ title=./wiki/linux-debug/timer/>linux-debug/timer</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/workqueue/ title=./wiki/linux-debug/workqueue/>linux-debug/workqueue</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/interrupt/ title=./wiki/linux-debug/interrupt/>linux-debug/interrupt</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/process/ title=./wiki/linux-debug/process/>linux-debug/process</a></li><li class=file><a href=https://minuk.dev/wiki/input-method/ title=./wiki/input-method/>linux input-method 삽질</a></li><li class=file><a href=https://minuk.dev/wiki/assembly/ title=./wiki/assembly/>assembly</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-10-24/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-10-24/>2020-10-24 회고</a></li><li class=file><a href=https://minuk.dev/wiki/contextmenu/ title=./wiki/contextmenu/>contextmenu</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-10-09/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-10-09/>2020-10-09 회고</a></li><li class=file><a href=https://minuk.dev/wiki/others/ title=./wiki/others/>others</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-09-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-09-18/>2020-09-18 회고</a></li><li class=file><a href=https://minuk.dev/wiki/seccomp/ title=./wiki/seccomp/>seccomp</a></li><li class=file><a href=https://minuk.dev/wiki/debug-linux/ title=./wiki/debug-linux/>디버깅을 통해 배우는 리눅스 커널의 구조와 원리</a></li><li class=file><a href=https://minuk.dev/wiki/fuse/ title=./wiki/fuse/>Filesystem in Userspace</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-08-30/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-08-30/>회고/2020-08-30</a></li><li class=file><a href=https://minuk.dev/wiki/raid/ title=./wiki/raid/>RAID(Redundant Array of Independent Disks)</a></li><li class=file><a href=https://minuk.dev/wiki/storage/ title=./wiki/storage/>Storage</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-08-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-08-17/>2020-08-17 회고</a></li><li class=file><a href=https://minuk.dev/wiki/teamnote/ title=./wiki/teamnote/>teamnote</a></li><li class=file><a href=https://minuk.dev/wiki/git/ title=./wiki/git/>git</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-07-31/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-07-31/>2020년 7월 31일자 회고</a></li><li class=file><a href=https://minuk.dev/wiki/3%EA%B3%B5%EB%85%B8%ED%8A%B8/ title=./wiki/3%EA%B3%B5%EB%85%B8%ED%8A%B8/>3공 노트</a></li><li class=file><a href=https://minuk.dev/wiki/nas/ title=./wiki/nas/>NAS</a></li><li class=file><a href=https://minuk.dev/wiki/lfs/ title=./wiki/lfs/>LFS Paper</a></li><li class=file><a href=https://minuk.dev/wiki/ftl/ title=./wiki/ftl/>Flash Translation Layer</a></li><li class=file><a href=https://minuk.dev/wiki/ppn/ title=./wiki/ppn/>PPN(Physical Page Number)</a></li><li class=file><a href=https://minuk.dev/wiki/lpn/ title=./wiki/lpn/>LPN(Logical Page Number)</a></li><li class=file><a href=https://minuk.dev/wiki/load-balance/ title=./wiki/load-balance/>Load Balance</a></li><li class=file><a href=https://minuk.dev/wiki/cache/ title=./wiki/cache/>Cache</a></li><li class=file><a href=https://minuk.dev/wiki/uart/ title=./wiki/uart/>UART (Universal asynchronous receiver/transmitter)</a></li><li class=file><a href=https://minuk.dev/wiki/vhdci/ title=./wiki/vhdci/>VHDCI (Very-high-dencity cable interconnect)</a></li><li class=file><a href=https://minuk.dev/wiki/boxplot/ title=./wiki/boxplot/>boxplot</a></li><li class=file><a href=https://minuk.dev/wiki/quartile/ title=./wiki/quartile/>quartile (사분위수)</a></li><li class=file><a href=https://minuk.dev/wiki/statistics/ title=./wiki/statistics/>statistics</a></li><li class=file><a href=https://minuk.dev/wiki/fsm/ title=./wiki/fsm/>FSM (Finite State machine)</a></li><li class=file><a href=https://minuk.dev/wiki/open-nvm/ title=./wiki/open-nvm/>open-nvm</a></li><li class=file><a href=https://minuk.dev/wiki/mram/ title=./wiki/mram/>MRAM (Magnetic Random Access Memory)</a></li><li class=file><a href=https://minuk.dev/wiki/file/ title=./wiki/file/>vfs - file</a></li><li class=file><a href=https://minuk.dev/wiki/kiocb/ title=./wiki/kiocb/>kiocb</a></li><li class=file><a href=https://minuk.dev/wiki/vfs/ title=./wiki/vfs/>VFS-Virtual File System</a></li><li class=file><a href=https://minuk.dev/wiki/linux/ title=./wiki/linux/>linux</a></li><li class=file><a href=https://minuk.dev/wiki/f2fs-paper/ title=./wiki/f2fs-paper/>F2FS- A New File System for Flash Storage</a></li><li class=file><a href=https://minuk.dev/wiki/english/proverb/ title=./wiki/english/proverb/>english/proverb</a></li><li class=file><a href=https://minuk.dev/wiki/english/ title=./wiki/english/>english</a></li><li class=file><a href=https://minuk.dev/wiki/tool/ title=./wiki/tool/>tool</a></li><li class=file><a href=https://minuk.dev/wiki/verilog/ title=./wiki/verilog/>verilog (베릴로그)</a></li><li class=file><a href=https://minuk.dev/wiki/iommu/ title=./wiki/iommu/>IOMMU (Input Output Memory Management Unit)</a></li><li class=file><a href=https://minuk.dev/wiki/delayed_work/ title=./wiki/delayed_work/>delayed work</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/>회고/2020-06-21</a></li><li class=file><a href=https://minuk.dev/wiki/jwt/ title=./wiki/jwt/>json web token(jwt)</a></li><li class=file><a href=https://minuk.dev/wiki/tmuxinator/ title=./wiki/tmuxinator/>tmuxinator</a></li><li class=file><a href=https://minuk.dev/wiki/vim-staritfy/ title=./wiki/vim-staritfy/>vim-startify</a></li><li class=file><a href=https://minuk.dev/wiki/my-page/ title=./wiki/my-page/>my-page (나만의 홈페이지 만들기)</a></li><li class=file><a href=https://minuk.dev/wiki/blk_mq/ title=./wiki/blk_mq/>blk_mq</a></li><li class=file><a href=https://minuk.dev/wiki/prp/ title=./wiki/prp/>PRP (Physical Region Page)</a></li><li class=file><a href=https://minuk.dev/wiki/numa/ title=./wiki/numa/>NUMA</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/>회고/2020-06-17</a></li><li class=file><a href=https://minuk.dev/wiki/block-layer/ title=./wiki/block-layer/>block layer</a></li><li class=file><a href=https://minuk.dev/wiki/workqueue/ title=./wiki/workqueue/>workqueue</a></li><li class=file><a href=https://minuk.dev/wiki/nvme/ title=./wiki/nvme/>nvme</a></li><li class=file><a href=https://minuk.dev/wiki/gem5/ title=./wiki/gem5/>gem5</a></li><li class=file><a href=https://minuk.dev/wiki/simplessd/ title=./wiki/simplessd/>simple-ssd</a></li><li class=file><a href=https://minuk.dev/wiki/mmap/ title=./wiki/mmap/>mmap</a></li><li class=file><a href=https://minuk.dev/wiki/b+tree/ title=./wiki/b+tree/>B+ Tree</a></li><li class=file><a href=https://minuk.dev/wiki/database/ title=./wiki/database/>Database</a></li><li class=file><a href=https://minuk.dev/wiki/memory-cache-clean/ title=./wiki/memory-cache-clean/>memory cache 비우기 (linux command)</a></li><li class=file><a href=https://minuk.dev/wiki/free/ title=./wiki/free/>free (linux command)</a></li><li class=file><a href=https://minuk.dev/wiki/clflush/ title=./wiki/clflush/>clflush (cache line flush)</a></li><li class=file><a href=https://minuk.dev/wiki/c++/ title=./wiki/c++/>C++ Language</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/ title=./wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/>사지방</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/ title=./wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/>2020년 3월 회고</a></li><li class=file><a href=https://minuk.dev/wiki/mysql/ title=./wiki/mysql/>mysql (storage engine)</a></li><li class=file><a href=https://minuk.dev/wiki/block-group/ title=./wiki/block-group/>block group</a></li><li class=file><a href=https://minuk.dev/wiki/journal/ title=./wiki/journal/>journal(journaling)</a></li><li class=file><a href=https://minuk.dev/wiki/group-descriptor-table/ title=./wiki/group-descriptor-table/>group descriptor table</a></li><li class=file><a href=https://minuk.dev/wiki/inode/ title=./wiki/inode/>inode</a></li><li class=file><a href=https://minuk.dev/wiki/superblock/ title=./wiki/superblock/>Superblock</a></li><li class=file><a href=https://minuk.dev/wiki/ext4/ title=./wiki/ext4/>The new ext4 filesystem: current status and future plans</a></li><li class=file><a href=https://minuk.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/ title=./wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/>계룡 개발 모임</a></li><li class=file><a href=https://minuk.dev/wiki/ssd/ title=./wiki/ssd/>SSD</a></li><li class=file><a href=https://minuk.dev/wiki/gutentags/ title=./wiki/gutentags/>gutentags</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-18--%EB%A9%94%EB%A9%98%ED%86%A0/ title=./wiki/modern-c++-design-pattern/chapter-18--%EB%A9%94%EB%A9%98%ED%86%A0/>Modern C++ Design Pattern/Chatper 18. 메멘토</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-17--%EB%A7%A4%EA%B0%9C%EC%9E%90/ title=./wiki/modern-c++-design-pattern/chapter-17--%EB%A7%A4%EA%B0%9C%EC%9E%90/>Modern C++ Design Pattern/Chatper 17. 매개자</a></li><li class=file><a href=https://minuk.dev/wiki/boj/ title=./wiki/boj/>boj</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-16--%EB%B0%98%EB%B3%B5%EC%9E%90/ title=./wiki/modern-c++-design-pattern/chapter-16--%EB%B0%98%EB%B3%B5%EC%9E%90/>Modern C++ Design Pattern/Chatper 16. 반복자</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-04-20/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-04-20/>회고/2020.04.20</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-15--%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-15--%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/>Modern C++ Design Pattern/Chatper 15. 인터프리터</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-14--%EC%BB%A4%EB%A7%A8%EB%93%9C/ title=./wiki/modern-c++-design-pattern/chapter-14--%EC%BB%A4%EB%A7%A8%EB%93%9C/>Modern C++ Design Pattern/Chatper 14. 커맨드</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-13--%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/ title=./wiki/modern-c++-design-pattern/chapter-13--%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/>Modern C++ Design Pattern/Chatper 13. 책임사슬(Chain of Responsibility)</a></li><li class=file><a href=https://minuk.dev/wiki/coc/ title=./wiki/coc/>coc (vim plugin coc)</a></li><li class=file><a href=https://minuk.dev/wiki/regex/ title=./wiki/regex/>Regular Expression (regex)</a></li><li class=file><a href=https://minuk.dev/wiki/glob/ title=./wiki/glob/>glob</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-12--%ED%94%84%EB%A1%9D%EC%8B%9C/ title=./wiki/modern-c++-design-pattern/chapter-12--%ED%94%84%EB%A1%9D%EC%8B%9C/>Modern C++ Design Pattern/Chapter 12. 프록시</a></li><li class=file><a href=https://minuk.dev/wiki/hugo/ title=./wiki/hugo/>hugo</a></li><li class=file><a href=https://minuk.dev/wiki/tee/ title=./wiki/tee/>tee (Linux Command)</a></li><li class=file><a href=https://minuk.dev/wiki/rm/ title=./wiki/rm/>rm (Linux Command)</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-11--%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/ title=./wiki/modern-c++-design-pattern/chapter-11--%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/>Modern C++ Design Pattern/Chapter 11. 플라이웨이트</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-10--%ED%8D%BC%EC%82%AC%EB%93%9C/ title=./wiki/modern-c++-design-pattern/chapter-10--%ED%8D%BC%EC%82%AC%EB%93%9C/>Modern C++ Design Pattern/Chapter 10. 퍼사드</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-7--%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-7--%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chatper 7. 컴파일 시간 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-8--%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/ title=./wiki/effective-debugging/chapter-8--%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/>Effective Debugging/Chatper 8. 멀티스레드 코드 디버깅</a></li><li class=file><a href=https://minuk.dev/wiki/todo/ title=./wiki/todo/>TODO Lists</a></li><li class=file><a href=https://minuk.dev/wiki/vim/ title=./wiki/vim/>vim</a></li><li class=file><a href=https://minuk.dev/wiki/vimwiki/ title=./wiki/vimwiki/>vimwiki</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-04-08/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-04-08/>회고/2020-04-08</a></li><li class=file><a href=https://minuk.dev/wiki/cloudatcost/ title=./wiki/cloudatcost/>cloudatcost</a></li><li class=file><a href=https://minuk.dev/wiki/web/ title=./wiki/web/>web</a></li><li class=file><a href=https://minuk.dev/wiki/nginx/ title=./wiki/nginx/>nginx</a></li><li class=file><a href=https://minuk.dev/wiki/understanding-linux-kernel/ title=./wiki/understanding-linux-kernel/>Understanding Linux Kernel</a></li><li class=file><a href=https://minuk.dev/wiki/mathematical-statistics/ title=./wiki/mathematical-statistics/>Mathematical Statistics</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/ title=./wiki/effective-debugging/>Effective Debugging</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-1--%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/ title=./wiki/effective-debugging/chapter-1--%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/>Effective Debugging/Chapter 1. 고차원 전략</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-2--%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-2--%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 2. 범용적인 디버깅 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-3--%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-3--%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 3. 범용 도구를 활용한 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-5--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-5--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 5. 프로그래밍 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chatper-4--%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/ title=./wiki/effective-debugging/chatper-4--%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/>Effective Debugging/Chatper 4. 디버거 활용법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chatper-6--%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chatper-6--%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chatper 6. 컴파일 시간 기법</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/ title=./wiki/modern-c++-design-pattern/>Modern C++ Design Pattern</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-1--%EA%B0%9C%EC%9A%94/ title=./wiki/modern-c++-design-pattern/chapter-1--%EA%B0%9C%EC%9A%94/>Modern C++ Design Pattern/Chatper 1. 개요</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-2--%EB%B9%8C%EB%8D%94/ title=./wiki/modern-c++-design-pattern/chapter-2--%EB%B9%8C%EB%8D%94/>Modern C++ Design Pattern/Chatper 2. 빌더</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-4--%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/ title=./wiki/modern-c++-design-pattern/chapter-4--%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/>Modern C++ Design Pattern/Chatper 4. 프로토타입</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-5--%EC%8B%B1%EA%B8%80%ED%84%B4/ title=./wiki/modern-c++-design-pattern/chapter-5--%EC%8B%B1%EA%B8%80%ED%84%B4/>Modern C++ Design Pattern/Chatper 5. 싱글턴</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-6--%EC%96%B4%EB%8C%91%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-6--%EC%96%B4%EB%8C%91%ED%84%B0/>Modern C++ Design Pattern/Chatper 6. 어댑터</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-7--%EB%B8%8C%EB%A6%BF%EC%A7%80/ title=./wiki/modern-c++-design-pattern/chapter-7--%EB%B8%8C%EB%A6%BF%EC%A7%80/>Modern C++ Design Pattern/Chatper 7. 브릿지</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-8--%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/ title=./wiki/modern-c++-design-pattern/chapter-8--%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/>Modern C++ Design Pattern/Chatper 8. 컴포지트</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-9--%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-9--%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/>Modern C++ Design Pattern/Chatper 9. 데코레이터</a></li><li class=file><a href=https://minuk.dev/wiki/book-reviews/ title=./wiki/book-reviews/>Book Review</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/algorithm/ title=./wiki/lectures/algorithm/>lectures/algorithm</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/computer-architecture/ title=./wiki/lectures/computer-architecture/>lectures/computer architecture</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/image-processing/ title=./wiki/lectures/image-processing/>lectures/image processing</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/ title=./wiki/lectures/>학교 수업</a></li><li class=file><a href=https://minuk.dev/wiki/tool-configuration/ title=./wiki/tool-configuration/>Tool configuration</a></li><li class=file><a href=https://minuk.dev/wiki/ssh-server/ title=./wiki/ssh-server/>SSH Server Configuration</a></li><li class=file><a href=https://minuk.dev/wiki/firewall/ title=./wiki/firewall/>Firewall (방화벽) Configuration</a></li><li class=file><a href=https://minuk.dev/wiki/ftp/ title=./wiki/ftp/>ftp server command</a></li><li class=file><a href=https://minuk.dev/wiki/user/ title=./wiki/user/>linux user command</a></li><li class=file><a href=https://minuk.dev/wiki/brightness/ title=./wiki/brightness/>Brightness (화면 밝기 조절) command</a></li><li class=file><a href=https://minuk.dev/wiki/wifi-command-line/ title=./wiki/wifi-command-line/>Wifi commands</a></li><li class=file><a href=https://minuk.dev/wiki/wifi/ title=./wiki/wifi/>Wifi commands</a></li><li class=file><a href=https://minuk.dev/wiki/linux-command/ title=./wiki/linux-command/>Linux Command 모음</a></li><li class=file><a href=https://minuk.dev/wiki/docker/ title=./wiki/docker/>docker</a></li><li class=file><a href=https://minuk.dev/wiki/sql/ title=./wiki/sql/>SQL</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/function/ title=./wiki/typescript/function/>Typescript/Function</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/class/ title=./wiki/typescript/class/>Typescript/Class</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/interface/ title=./wiki/typescript/interface/>Typescript/Interface</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/variable-declaration/ title=./wiki/typescript/variable-declaration/>Typescript/Variable Declaration</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/types/ title=./wiki/typescript/types/>Typescript/Types</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/ title=./wiki/typescript/>Typescript</a></li><li class=file><a href=https://minuk.dev/wiki/graphql-typescript/ title=./wiki/graphql-typescript/>graphql typescript (deprecated)</a></li><li class=file><a href=https://minuk.dev/wiki/winston/ title=./wiki/winston/>winston</a></li><li class=file><a href=https://minuk.dev/wiki/jest/ title=./wiki/jest/>Jest</a></li><li class=file><a href=https://minuk.dev/wiki/sequelize/ title=./wiki/sequelize/>Sequelize</a></li><li class=file><a href=https://minuk.dev/wiki/fetch/ title=./wiki/fetch/>Fetch 문법 간단 정리</a></li><li class=file><a href=https://minuk.dev/wiki/promise/ title=./wiki/promise/>Promise 정리</a></li><li class=file><a href=https://minuk.dev/wiki/javascript/ title=./wiki/javascript/>JavaScript</a></li><li class=file><a href=https://minuk.dev/wiki/nexus/ title=./wiki/nexus/>Nexus</a></li><li class=file><a href=https://minuk.dev/wiki/ssdsolid-state-drive/ title=./wiki/ssdsolid-state-drive/>SSD(Solid-State Drive)</a></li><li class=file><a href=https://minuk.dev/wiki/pintos/ title=./wiki/pintos/>Pintos</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/ title=./wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/>Bus 시간 메모</a></li><li class=file><a href=https://minuk.dev/wiki/5-articles-per-week/ title=./wiki/5-articles-per-week/>5 articles per week</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/ title=./wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/>썩어버린 Query Language</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/ title=./wiki/%ED%9A%8C%EA%B3%A0/>회고 모음</a></li><li class=file><a href=https://minuk.dev/wiki/memory_leak/ title=./wiki/memory_leak/>Javascript Memory Leak</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/ title=./wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/>송편 생성기 (추석 대회)</a></li><li class=file><a href=https://minuk.dev/wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/ title=./wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/>Endurable Transient Inconsistency in Byte Addressable Persistent B+-Tree</a></li><li class=file><a href=https://minuk.dev/wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/ title=./wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/>SSD 공부 자료 모음</a></li><li class=file><a href=https://minuk.dev/wiki/%EA%B0%9C%EB%B0%9C_todo/ title=./wiki/%EA%B0%9C%EB%B0%9C_todo/>개발 TODO</a></li><li class=file><a href=https://minuk.dev/wiki/f2fs/ title=./wiki/f2fs/>F2FS</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/ title=./wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/>설대회</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-01-01/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-01-01/>회고/2020-01-01</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-01-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-01-17/>회고/2020-01-17</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-11-24/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-11-24/>회고/2019.11.24</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-10-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-10-19/>회고/2019.10.19</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-09-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-09-19/>회고/2019.09.19</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-09-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-09-18/>회고/2019.09.18</a></li><li class=file><a href=https://minuk.dev/wiki/2024-12-23/ title=./wiki/2024-12-23/></a></li><li class=file><a href=https://minuk.dev/wiki/2025-01-05/ title=./wiki/2025-01-05/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/2025-01-10/ title=./wiki/daily/2025-01-10/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.41.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.41.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.49.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.49.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.59.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.59.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-05-05.12.23.excalidraw/ title=./wiki/drawings/drawing-2025-01-05-05.12.23.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-05-05.54.32.excalidraw/ title=./wiki/drawings/drawing-2025-01-05-05.54.32.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/excalidraw/test-draw/ title=./wiki/excalidraw/test-draw/></a></li><li class=file><a href=https://minuk.dev/wiki/ipad/ title=./wiki/ipad/></a></li><li class=file><a href=https://minuk.dev/wiki/jekyll-%EA%B8%B0%EB%B0%98-wiki-%EC%97%90%EC%84%9C-hugo-%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EA%B8%B0/ title=./wiki/jekyll-%EA%B8%B0%EB%B0%98-wiki-%EC%97%90%EC%84%9C-hugo-%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EA%B8%B0/></a></li><li class=file><a href=https://minuk.dev/wiki/lectures/compiler/ title=./wiki/lectures/compiler/></a></li><li class=file><a href=https://minuk.dev/wiki/lectures/signal_and_system/ title=./wiki/lectures/signal_and_system/></a></li><li class=file><a href=https://minuk.dev/wiki/macos-initialization/ title=./wiki/macos-initialization/></a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-3--%ED%8C%A9%ED%86%A0%EB%A6%AC/ title=./wiki/modern-c++-design-pattern/chapter-3--%ED%8C%A9%ED%86%A0%EB%A6%AC/></a></li><li class=file><a href=https://minuk.dev/wiki/test.excalidraw/ title=./wiki/test.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/test/ title=./wiki/test/></a></li><li class=file><a href=https://minuk.dev/wiki/ucpc_2018_%EC%98%88%EC%84%A0/ title=./wiki/ucpc_2018_%EC%98%88%EC%84%A0/></a></li><li class=file><a href=https://minuk.dev/wiki/%EB%8D%B0%EC%A4%91%EC%96%B4%EC%84%A4/ title=./wiki/%EB%8D%B0%EC%A4%91%EC%96%B4%EC%84%A4/></a></li><li class=file><a href=https://minuk.dev/wiki/%EC%9D%98%EA%B2%AC-%EB%A9%94%EB%AA%A8/ title=./wiki/%EC%9D%98%EA%B2%AC-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%EC%A3%BC%EC%9E%A5-%EB%A9%94%EB%AA%A8/ title=./wiki/%EC%A3%BC%EC%9E%A5-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%A9%94%EB%AA%A8/ title=./wiki/%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9/ title=./wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/></a></li><li class=file><a href=https://minuk.dev/wiki/tags/ title=./wiki/tags/>tag page</a></li></ul></li><li class=file><a href=https://minuk.dev/about/ title=./about/>about</a></li></ul></aside><aside class=exapandable></aside><article class=main><button class=sidebar-toggle-btn type=menu aria-expanded=false aria-haspopup=true>
<i class="bi bi-list"></i></button><div class=title><h1 class=title-header>컴퓨터통신</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/lectures/computer-communication.md><h5>created : Fri, 15 Oct 2021 23:07:20 +0900</h5><h5>modified : Sun, 12 Dec 2021 19:40:50 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
Front Page
[[lectures]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#컴퓨터에서-의미란-데이터>컴퓨터에서 의미란? 데이터</a></li><li><a href=#데이터-전달교환이란-신호송수신>데이터 전달/교환이란? 신호송수신</a></li><li><a href=#직접-신호-교환의-한계-스위칭>직접 신호 교환의 한계: 스위칭</a></li><li><a href=#서로-다른-통신망-연결-이질성-극복>서로 다른 통신망 연결: 이질성 극복</a></li><li><a href=#컴퓨터-통신-기술-재정의>컴퓨터 통신 기술 재정의</a></li><li><a href=#네트위크를-보는-관점-관심사항에-따른-관점>네트위크를 보는 관점: 관심사항에 따른 관점</a></li><li><a href=#컴퓨터-통신네트워크-분야>컴퓨터 통신/네트워크 분야</a></li></ul><ul><li><a href=#연결connectivity>연결(Connectivity)</a><ul><li><a href=#연결-직접-링크direct-links>연결: 직접 링크(Direct Links)</a></li><li><a href=#간접-연결-switched-networking>간접 연결: Switched Networking</a></li><li><a href=#간접-연결방법--스위칭-정책>간접 연결방법 : 스위칭 정책</a></li></ul></li><li><a href=#어드레싱addressing-및-라우팅routing>어드레싱(Addressing) 및 라우팅(Routing)</a></li><li><a href=#비용-효율적인-자원-공유resource-sharing>비용 효율적인 자원 공유(Resource Sharing)</a><ul><li><a href=#multiplexing>Multiplexing</a></li><li><a href=#주파수분할-다중화frequency-division-multiplexing>주파수분할 다중화(Frequency Division Multiplexing)</a></li><li><a href=#시분할-다중화time-division-multiplexing>시분할 다중화(Time-Division Multiplexing)</a></li><li><a href=#다중화-fdm-and-tdm>다중화: FDM and TDM</a></li><li><a href=#통계적-다중화statistical-multiplexing>통계적 다중화(Statistical Multiplexing)</a></li><li><a href=#통계적-다중화와-패킷스위칭>통계적 다중화와 패킷스위칭</a></li><li><a href=#통신-서비스-제공>통신 서비스 제공</a></li><li><a href=#통신-서비스-통신-장애극복>통신 서비스: 통신 장애극복</a></li><li><a href=#프로토콜-protocol>프로토콜 (Protocol)</a></li><li><a href=#계층화-layering>계층화 (Layering)</a></li><li><a href=#프로토콜-계층개체>프로토콜 계층/개체</a></li><li><a href=#전체-프로토콜-정의-프로토콜-그래프>(전체) 프로토콜 정의: 프로토콜 그래프</a></li><li><a href=#계층적-프로토콜-동작원칙>(계층적) 프로토콜: 동작원칙</a></li><li><a href=#추상화계층화-개념-정리>추상화/계층화 개념 정리</a></li><li><a href=#표준구조-standard-architectures>표준구조 (Standard Architectures)</a></li><li><a href=#성능performance--대역폭>성능(Performance) : 대역폭</a></li><li><a href=#성능-소요-시간--지연-시간>성능: 소요 시간 / 지연 시간</a></li><li><a href=#timing-of-circuit-switching>Timing of Circuit Switching</a></li><li><a href=#timing-of-packet-switching>Timing of Packet Switching</a></li><li><a href=#packet-segmentation-pipelining>Packet Segmentation: Pipelining</a></li></ul></li><li><a href=#성능-performance>성능 (Performance)</a></li><li><a href=#지연시간-x-대역폭-delay-x-bandwidth-product>지연시간 x 대역폭 (Delay x Bandwidth Product)</a></li><li><a href=#frames>Frames</a></li><li><a href=#통신-성능을-높이는-방법>통신 성능을 높이는 방법?</a></li><li><a href=#대역폭을-높이는-방법>대역폭을 높이는 방법?</a></li><li><a href=#소요시간을-줄이는-방법>소요시간을 줄이는 방법?</a></li></ul><ul><li><a href=#데이터링크-계층>데이터링크 계층</a></li><li><a href=#하드웨어-구성요소-노드nodes>하드웨어 구성요소: 노드(Nodes)</a></li><li><a href=#링크link>링크(Link)</a></li><li><a href=#모듈레이션-데이터의-신호화>모듈레이션: 데이터의 신호화</a></li><li><a href=#전자기-스펙트럼과-매체-특성>전자기 스펙트럼과 매체 특성</a></li><li><a href=#사용가능한-유선-링크의-종류>사용가능한 유선 링크의 종류</a></li><li><a href=#광케이블--optical-fiber>광케이블 : Optical Fiber</a></li><li><a href=#가입자선로last-mile-links>가입자선로(Last-Mile Links)</a></li><li><a href=#무선링크wireless-links--일반>무선링크(Wireless Links) : 일반</a><ul><li><a href=#이동-통신cellular-network>이동 통신(Cellular Network)</a></li><li><a href=#고정-무선-통신wireless-field-linked>고정 무선 통신(Wireless Field linked)</a></li><li><a href=#위성통신satellite-system>위성통신(Satellite system)</a></li><li><a href=#단거리-무선통신short-range>단거리 무선통신(Short Range)</a></li></ul></li><li><a href=#인코딩>인코딩</a><ul><li><a href=#인코딩encoding>인코딩(Encoding)</a></li><li><a href=#디지털-전송transmission>디지털 전송(Transmission)</a></li></ul></li><li><a href=#데이터-전송transmission>데이터 전송(Transmission)</a></li><li><a href=#pulse-code-modulation>Pulse Code Modulation</a></li><li><a href=#pcm>PCM</a></li><li><a href=#변조--amplitude-modulation>변조 : Amplitude Modulation</a></li><li><a href=#디지털-전송transmission-1>디지털 전송(Transmission)</a><ul><li><a href=#non-return-to-zeronrz>Non-Return to Zero(NRZ)</a></li><li><a href=#nrzi-and-manchester>NRZI and Manchester</a></li><li><a href=#4b5b>4B/5B</a></li><li><a href=#프레이밍framing>프레이밍(Framing)</a></li><li><a href=#바이트-중심-프로토콜byte-oriented-protocol>바이트 중심 프로토콜(Byte-Oriented Protocol)</a></li><li><a href=#비트-중심-프로토콜-bit-oriented-protocol>비트 중심 프로토콜 (Bit-Oriented Protocol)</a></li><li><a href=#오류-검출-코드error-detecting-code>오류 검출 코드(Error Detecting Code)</a></li><li><a href=#오류-검출율>오류 검출율</a></li><li><a href=#error-pattern-ex>Error Pattern: E(X)</a></li><li><a href=#crc에-대해-간단히-설명하시오>CRC에 대해 간단히 설명하시오</a></li><li><a href=#복구--개요>복구 : 개요</a></li><li><a href=#오류-수정-코드error-correcting-codes>오류 수정 코드(Error Correcting Codes)</a></li><li><a href=#재전송을-통한-오류-복구>재전송을 통한 오류 복구</a></li><li><a href=#arq>ARQ</a></li><li><a href=#stop-and-wait--tming-분석>Stop and Wait : Tming 분석</a></li><li><a href=#슬라이딩-윈도우>슬라이딩 윈도우</a></li><li><a href=#sliding-window-protocol의-성능>Sliding Window Protocol의 성능</a></li><li><a href=#슬라이딩-윈도우의-오류-복구>슬라이딩 윈도우의 오류 복구</a></li><li><a href=#go-back-n-구현-옵션>Go-Back-N (구현) 옵션</a></li><li><a href=#오류처리-정책--go-back-n-재검토>오류처리 정책 : Go-Back-N 재검토</a></li><li><a href=#오류처리-정책--selective-repeat>오류처리 정책 : Selective Repeat</a></li><li><a href=#sliding-window-세부사항>Sliding Window 세부사항</a></li><li><a href=#프로토콜의-구현>프로토콜의 구현</a></li><li><a href=#슬라이딩윈도우gobackn-세부알고리즘>슬라이딩윈도우(GoBackN) 세부알고리즘</a></li><li><a href=#순서-번호-공간-sequence-number-space>순서 번호 공간 (Sequence Number Space)</a></li><li><a href=#동시-논리-채널concurrent-logical-channels>동시 논리 채널(Concurrent Logical Channels)</a></li><li><a href=#sliding-window-구현>Sliding Window 구현</a></li></ul></li><li><a href=#이더넷-ethernet-개요>이더넷 (Ethernet) 개요</a><ul><li><a href=#물리적-특성-버스-토폴로지>물리적 특성 (버스 토폴로지)</a></li><li><a href=#10baset-network>10BaseT Network</a></li><li><a href=#프레임-형식frame-format>프레임 형식(Frame Format)</a></li><li><a href=#전송-알고리즘transmitter-algorithm>전송 알고리즘(Transmitter Algorithm)</a></li><li><a href=#전송-알고리즘--충돌collision>전송 알고리즘 : 충돌(Collision)</a></li><li><a href=#cdmacd-평가>CDMA/CD 평가</a></li><li><a href=#이론과-실제>이론과 실제</a></li><li><a href=#이더넷-확장>이더넷 확장</a></li></ul></li><li><a href=#토큰링>토큰링</a><ul><li><a href=#토큰링의-연결>토큰링의 연결</a></li><li><a href=#토큰링-mac-기본-개념>토큰링 MAC 기본 개념</a></li><li><a href=#매체-접근-제어-세부사항>매체 접근 제어 세부사항</a></li><li><a href=#토큰링-관리>토큰링 관리</a></li><li><a href=#프레임-형식>프레임 형식</a></li></ul></li><li><a href=#무선wireless-lans>무선(Wireless) LANs</a><ul><li><a href=#확산-스펙트럼-spread-spectrum>확산 스펙트럼 (Spread Spectrum)</a></li><li><a href=#매체-접근>매체 접근</a></li><li><a href=#ieee-80211-multiple-access>IEEE 802.11: multiple access</a></li><li><a href=#충돌-회피collisions-avoidance>충돌 회피(Collisions Avoidance)</a></li><li><a href=#이동성mobility-지원>이동성(Mobility) 지원</a></li><li><a href=#bss-접속가입-이동-감지>BSS 접속/가입 (이동 감지)</a></li><li><a href=#매체접근제어mac-비교>매체접근제어(MAC) 비교</a></li></ul></li><li><a href=#네트워크-어댑터>네트워크 어댑터</a><ul><li><a href=#호스트의-관점제어>호스트의 관점(제어)</a></li><li><a href=#호스트와-어댑터-사이에서의-프레임데이터-이동>호스트와 어댑터 사이에서의 프레임(데이터) 이동</a></li></ul></li></ul><ul><li><a href=#확장성-있는-네트워크scalable-networks>확장성 있는 네트워크(Scalable Networks)</a></li><li><a href=#데이터그램-datagrams>데이터그램 (Datagrams)</a></li><li><a href=#가상회선-스위칭virtual-circuit-switching>가상회선 스위칭(Virtual Circuit Switching)</a></li><li><a href=#가상회선-대-데이터그램>가상회선 대 데이터그램</a></li><li><a href=#소스-라우팅source-routing>소스 라우팅(Source Routing)</a></li><li><a href=#스위치-성능>스위치 성능</a></li><li><a href=#브리지-및-확장-lan-bridges-and-extended-lans>브리지 및 확장 LAN (Bridges and Extended LANs)</a><ul><li><a href=#브리지bridge의-동작>브리지(Bridge)의 동작</a></li><li><a href=#계층-2level-2-연결>계층-2(Level-2) 연결</a></li><li><a href=#학습-브리지learning-bridges>학습 브리지(Learning Bridges)</a></li><li><a href=#switching-hub-traffic-isolation>Switching Hub: traffic isolation</a></li><li><a href=#브리지lan-스위치의-한계>브리지/LAN 스위치의 한계</a></li></ul></li><li><a href=#셀스위칭-cell-switching-atm>셀스위칭 (Cell Switching): ATM</a><ul><li><a href=#개요>개요</a></li><li><a href=#cells>Cells</a></li><li><a href=#atm-셀>ATM 셀</a></li><li><a href=#셀-형식cell-format>셀 형식(Cell Format)</a></li></ul></li></ul><ul><li><a href=#인터넷-서비스-모델>인터넷 서비스 모델</a></li><li><a href=#패킷-전달-서비스-모델>패킷 전달 서비스 모델</a></li><li><a href=#ip-패킷-헤더-형식>IP 패킷 헤더 형식</a></li><li><a href=#단편화와-재조립fragmenation-and-reassembly>단편화와 재조립(Fragmenation and Reassembly)</a></li><li><a href=#전역-주소global-addresses>전역 주소(Global Addresses)</a></li><li><a href=#데이터그램-포워딩--ip의-실제-동작>데이터그램 포워딩 : IP의 실제 동작</a></li><li><a href=#주소-번역address-translation>주소 번역(Address Translation)</a><ul><li><a href=#arp-프로토콜>ARP 프로토콜</a></li></ul></li><li><a href=#호스트-구성configuration--dhcp>호스트 구성(Configuration) : DHCP</a><ul><li><a href=#dhcp-동작>DHCP 동작</a></li></ul></li><li><a href=#공유기>공유기</a></li><li><a href=#icmpinternet-control-message-protocol>ICMP(Internet Control Message Protocol)</a></li><li><a href=#가상-네트워크virtual-networks>가상 네트워크(Virtual Networks)</a></li><li><a href=#ip-터널링ip-tunneling>IP 터널링(IP Tunneling)</a></li><li><a href=#터널링가상-네트워크-사용이유>터널링/가상 네트워크 사용이유</a></li><li><a href=#확장성-문제scalability-issues>확장성 문제(Scalability Issues)</a><ul><li><a href=#서브네팅subnetting>서브네팅(Subnetting)</a></li><li><a href=#포워딩-알고리즘>포워딩 알고리즘</a></li></ul></li><li><a href=#classless-라우팅cidr>Classless 라우팅(CIDR)</a></li><li><a href=#차세대-ip-next-generation-ipipv6>차세대 IP (Next Generation IP(IPv6))</a><ul><li><a href=#ipv6-주소>IPv6 주소</a></li><li><a href=#ipv6-헤더>IPv6 헤더</a></li><li><a href=#ip-nextheader>IP NextHeader</a></li></ul></li><li><a href=#이통-호스트에-대한-라우팅>이통 호스트에 대한 라우팅</a></li><li><a href=#mobile-ip>Mobile IP</a><ul><li><a href=#mobile-ip의-패킷-전달>Mobile IP의 패킷 전달</a></li><li><a href=#세부-문제기술>세부 문제/기술</a></li><li><a href=#경로-최적화>경로 최적화</a></li></ul></li></ul></nav></aside><div class=content><h2 id=컴퓨터에서-의미란-데이터>컴퓨터에서 의미란? 데이터</h2><ul><li>문자 (디지털데이터)</li><li>음성 (아날로그 데이터) => 실제로는 디지털화 시켜서 사용</li><li>컴퓨터 기반 기기에서 모든 의미는 디지털 데이터로 표현되어야 한다. 따라서 의미교환이란 디지털 데이터를 교환한다는 것이다.</li></ul><h2 id=데이터-전달교환이란-신호송수신>데이터 전달/교환이란? 신호송수신</h2><ul><li>0/1은 추상적인 표시이다.:<ul><li>0/1로 추상화했다고 해서 실제로 전달하는 매체가 디지털이라는 것이 아니다. 약속을 한다면 아날로그를 쓰더라도 디지털데이터를 전달하는 데에는 문제가 없다.</li></ul></li><li>0/1을 유선/무선을 통해 전달하려면 신호화가 필요하다.</li><li>신호는 디지털 신호/아날로그 신호가 존재한다.</li><li>매체: 신호를 전달하는 물체. 예) 공중, 케이블</li><li>유선(구리선, 광케이블), 무선(전파):<ul><li>매체에 따라 디지털이 잘 전송되지 않는다.</li><li>무선에서는 특히 아날로그를 선택해서 전달한다.</li></ul></li></ul><h2 id=직접-신호-교환의-한계-스위칭>직접 신호 교환의 한계: 스위칭</h2><ul><li>통신 상대방과 직접 신호교환을 할 것인가?:<ul><li>블루투스 스피커</li><li>대부분은 기지국/공유가와 신호를 교환한다.</li><li>직접적으로 신호를 교환하는 것은 특수한 경우이고, 오히려 간접적으로 교환하는 것이 보편적이다.</li></ul></li><li>거리가 멀다면 결국에는 중계기를 설치할 수 밖에 없다.</li><li>연결할 수 있는 규모 - 스위치:<ul><li>통신자간 수많은 기기들(라우터 등)을 통해 통신하며, 이때 수많은 기기들을 망(Network)라고 한다.</li></ul></li><li>컴퓨터 통신을 하기 위해서는 망을 거치는 것이 필수적이다.</li><li>직접 통신의 한계:<ul><li>물리적 한계(거리에 따라 세기가 감소하는 등) : 중간에 있는 기기들이 이를 극복하기 위해서 중계를 해주어야한다.</li><li>통신의 용이성(통신자가 바뀌어도 전달 가능) : 중간에 있는 기기들은 스위칭, 라우팅 등을 통해 올바른 목적지를 향해 데이터를 보내주는 것이다.</li></ul></li></ul><h2 id=서로-다른-통신망-연결-이질성-극복>서로 다른 통신망 연결: 이질성 극복</h2><ul><li>통신하는 양쪽의 통신망이 서로 다를 수 있다.:<ul><li>기술, 관리, 정책 측면에서</li></ul></li><li>극복방법 필요:<ul><li>네트워크 간의 네트워크(internet)이 필요하다. Internet</li></ul></li></ul><hr><h2 id=컴퓨터-통신-기술-재정의>컴퓨터 통신 기술 재정의</h2><ul><li>컴퓨터 기반 기기를 통한 의미 교환</li><li>= 컴퓨터 기반 응용들을 통한 의미교환 (컴퓨터 기반 응용들의 의미 교환)</li><li>= 컴퓨터 기반 응용들의 디지털데이터 교환</li><li>= 컴퓨터 기반 응용들의 디지털데이터를 담고 있는 신호 교환</li><li>= 컴퓨터 기반 응용들의 디지털데이터를 담고 있는 신호를, 필요에 따라서 중계기, 스위치를 경유하면서 교환</li><li>= <strong>컴퓨터 기반 기기/응용들</strong>이 필요에 따라서 <strong>중계기/스위치</strong>를 경유하면서, <strong>디지털데이터</strong>를 담고있는 <strong>신호</strong>를 교환해서 의미를 교환하는 것</li></ul><h2 id=네트위크를-보는-관점-관심사항에-따른-관점>네트위크를 보는 관점: 관심사항에 따른 관점</h2><ul><li>네트워크 사용자: 통신 응용이 필요로 하는 서비스:<ul><li>즉, 보낸 메시지가 오류 없이 어떤 정해진 시간 안에 전달되는 것을 보장하는 서비스</li></ul></li><li>네트워크 설계자: 효과적인 설계:<ul><li>즉, 네트워크 자원들이 효율적으로 이용되며 각각의 사용자에게 공평하게 할당되는 설계</li></ul></li><li>네트워크 제공자: 운영 및 관리가 용이한 시스템:<ul><li>즉, 통신 장애가 쉽게 분산되며, 사용량에 따른 요금 부과가 용이한 시스템</li></ul></li></ul><h2 id=컴퓨터-통신네트워크-분야>컴퓨터 통신/네트워크 분야</h2><ul><li>컴퓨터공학 전공자의 시각:<ul><li>컴퓨터 통신 응용의 개발:<ul><li>통신 응용들의 사례 및 발전 추세</li><li>(통신의 기본 개념 + 컴퓨터 통신 시스템 동작원리) 필요</li></ul></li><li>컴퓨터 통신 시스템의 이해 및 개발:<ul><li>개발 과정, 관리측면에서 컴퓨터 전문가가 필요하다.</li></ul></li></ul></li></ul><hr><h1 id=1장-기본개념>1장 기본개념</h1><ul><li><p>요구사항:</p><ul><li>네트워크가 제공해야 하는 것</li><li>네트워크에 대한 기능적 정의</li></ul></li><li><p>네트워크 구조:</p><ul><li>네트워크를 만드는 방법</li><li>체계적인 접근이 필수</li></ul></li><li><p>성능:</p><ul><li>네트워크 비교/평가 기준 (성능의 기준)</li><li>빠른 네트워크란?</li></ul></li><li><p>노드(node):</p><ul><li>단말(terminal), 호스트(host)</li><li>스위치(switch), 라우터(router)</li></ul></li></ul><h2 id=연결connectivity>연결(Connectivity)</h2><ul><li>통신 첫단계 - 통신 주체를 연결하는 것</li><li>따라서, 통망이 해야하는 제1업무 : 연결</li><li>통신주체 :<ul><li>전화기 등 단말기(terminal)</li><li>일반화하여 통신 응용</li><li>실제로 통신 응용에서 고려하면 어렵기 때문에 단말기로 가정</li></ul></li></ul><h3 id=연결-직접-링크direct-links>연결: 직접 링크(Direct Links)</h3><ul><li>점대점 연결(Point-to-Point):<ul><li>가장 간단한 네트워크</li><li>불특정 다수와 연결해야하는데, 현실성이 떨어진다.</li></ul></li><li>다중 접근(multiple access):<ul><li>직접연결의 특성을 살리면서 사용하려는 것</li><li>링크 1개를 사용해서 여러개가 공유하는 것</li><li>장점 : 비용</li><li>단점 : 사용성</li></ul></li></ul><h3 id=간접-연결-switched-networking>간접 연결: Switched Networking</h3><ul><li>간접 연결(Indirect Connectivity): Switched Network</li><li>스위칭 네트워크(Switching Network)</li><li>인터네트워크(internetworks) : Network of Networks</li></ul><h3 id=간접-연결방법--스위칭-정책>간접 연결방법 : 스위칭 정책</h3><ul><li>회선 스위칭(circuit switching): 전화네트워크:<ul><li>스위치가 사전에 output link에 전용(dedicated) 회선(용량) 확보</li><li>비트스트림을 중단/간섭 없이 송/수신(흘려보냄)</li><li>기본적으로 point-to-point 연결</li></ul></li><li>패킷 스위치(packet switching) : 인터넷/우편:<ul><li>데이터를 묶음으로 전송: 패킷</li><li>스위치의 동작: store-and-forward</li><li>장점 : Bursty Traffic</li></ul></li><li>컴퓨터 통신에 적합한 것은?:<ul><li>사용자 입장 vs 네트워크입장</li><li>bursty traffic에 적합한 것은?</li></ul></li></ul><h2 id=어드레싱addressing-및-라우팅routing>어드레싱(Addressing) 및 라우팅(Routing)</h2><ul><li>상대방을 지정, 즉, ID 지정</li><li>주소(address) : 노드를 식별하는 바이트열:<ul><li>대개 유일하다</li></ul></li><li>참고: 라우팅:<ul><li>목적지 노드를 향해 메시지를 어떻게 포워딩할지를 주소에 입각해서 결정하는 직업</li></ul></li><li>주소의 종류(즉, 연결 형태):<ul><li>유니캐스트(unicast): 특정노드를 가정</li><li>방송/브로드캐스트(broadcast) : 네트워크의 모든 노드</li><li>멀티캐스트(multicase) : 네트워크의 일부 노드 집합을 지정</li></ul></li></ul><h2 id=비용-효율적인-자원-공유resource-sharing>비용 효율적인 자원 공유(Resource Sharing)</h2><ul><li>여러 사용자들의 네트워크 자원(노드 및 링크)을 공유하도록 하여야한다.</li><li>통신용어로는, 다중화(Multiplexing) 지원</li><li>흔히 사용되는 다중화 선택:<ul><li>시분할 다중화(Time-Deivision Multiplexing : TDM)</li><li>주파수 분할 다중화(Frequency-Division Multiplexing:FDM)</li><li>코드 분할 다중화(Code-Division Multiplexing: CDM)</li></ul></li></ul><h3 id=multiplexing>Multiplexing</h3><ul><li>link = physical</li><li>channel = logical</li></ul><h3 id=주파수분할-다중화frequency-division-multiplexing>주파수분할 다중화(Frequency Division Multiplexing)</h3><ul><li>주파수 사이에 틈(gap)이 있어야한다.</li></ul><h3 id=시분할-다중화time-division-multiplexing>시분할 다중화(Time-Division Multiplexing)</h3><ul><li>동기식(Synchronous) 시분할 다중화</li></ul><h3 id=다중화-fdm-and-tdm>다중화: FDM and TDM</h3><ul><li>Frequency Division Multiplexing</li><li>Time Division Multiplexing</li></ul><h3 id=통계적-다중화statistical-multiplexing>통계적 다중화(Statistical Multiplexing)</h3><ul><li>시분할 방법의 일종: 고정 분할이 아닌 요구에 따른 분할(On-demand):<ul><li>비동기식 다중화</li></ul></li><li>Demux key/select?</li><li>항상 좋은가?</li></ul><h3 id=통계적-다중화와-패킷스위칭>통계적 다중화와 패킷스위칭</h3><ul><li>통계적 다중화는 링크를 공유하는 방법</li><li>패킷 스위칭은 노드가 목적지를 향해 데이터를 전달하는 방법</li><li>패킷 스위칭: 패킷 단위로 링크 사용을 재스케줄링:<ul><li>패킷스위칭의 결과, 링크로 (거의) 통계적 다중화</li><li>링크에서 통계적 다중화를 하려면, 노드에서는 패킷스위칭 필요</li></ul></li><li>다른 출발지/소스(source)로부터의 패킷들이 링크에서 섞이게 됨.</li><li>링크로 나가기 위해 경쟁하는 패킷들을 저장: 버퍼링(buffering):<ul><li>서로간 독립적으로 동작시키기 위해서 경쟁상태에서 buffering이 이를 가능케함.</li></ul></li><li>패킷은 FIFO로 처리되거나, 기타 다른 방식으로 처리</li><li>버퍼 오버플로우(overflow)를 혼잡(congestion)이라 부름.:<ul><li>혼잡은 전파되는 경향이 있음.</li></ul></li></ul><h3 id=통신-서비스-제공>통신 서비스 제공</h3><ul><li>통신의 주체는 응용프로그램</li><li>따라서, 네트워크는 응용프로그램이 원할히 통신할 수 있는 기능을 제공:<ul><li>통신 기술을 기반으로 응용프로그램이 요구하는 기능을 구현/제공</li><li>Network Transparency : 실제 통신과정과 상관 없이, Host 간 연결을 투명하게, 추상화되도록 하는것</li><li>즉, 호스트 간의 연결을 프로세스 간의 통신 형태로 변환</li></ul></li><li>네트워크는 프로세스와 프로세스 간의 채널을 지원한다.</li></ul><h3 id=통신-서비스-통신-장애극복>통신 서비스: 통신 장애극복</h3><ul><li>네트워크가 정상적으로 동작하지 않는 경우:<ul><li>비트 수준 오류(전자가 간섭/방해)</li><li>패킷 수준 오류(혼잡)</li><li>링크/노드 고장</li><li>메시지의 지연</li><li>메시지의 순서가 바뀌어 전달(out-of-order)</li><li>제삼자의 도청</li></ul></li></ul><h3 id=프로토콜-protocol>프로토콜 (Protocol)</h3><ul><li>통신에 사용되는 약속:<ul><li>예) 수신호, 언어</li><li>양쪽이 같아야함. 즉, 반드시 대칭 관</li></ul></li><li>다양한 컴퓨터 통신 시스템/응용:<ul><li>프로토콜의 복잡화</li><li>불명확한 해석</li><li>변경 등 관리의 어려움</li><li>새로운 프로토콜이 필요할 때마다 반복</li></ul></li><li>복잡성을 해결하는 구조적인 기법이 필요</li></ul><h3 id=계층화-layering>계층화 (Layering)</h3><ul><li>복잡한 문제를 한번에 풀 수 없다.:<ul><li>복잡한 내용/문제를 숨겨서 문서를 단순화 -> 추상화(abstraction)</li><li>추상화된 문제/내용의 해결 -> 추상화를 recursive하게 적용</li></ul></li><li>추상화는 자연스럽게 계층화를 유도한다.</li><li>각 계층은 하나의 기능을 하는 부품/개체로서 다른 프로토콜에서 재사용 가능</li></ul><h3 id=프로토콜-계층개체>프로토콜 계층/개체</h3><ul><li>프로토콜 계층/개체:<ul><li>(전체) 프로토콜을 구성하는 계층, 즉, 프로토콜의 구성요소</li><li>자체도 프로토콜이라고 부름</li></ul></li><li>각 프로토콜 개체는 두 개의 다른 인터페이스를 갖는다.:<ul><li>서비스 인터페이스(service interface) : 해당 프로토콜의 작업을 정의</li><li>동료 인터페이스(peer-to-peer interface): 동료간에 교환되는 메시지를 정의</li><li>대부분의 구현은 procedure signiture이다.</li><li>상위 계층에서 줘야하는 parameter를 알려주어야하기 때문이다.</li></ul></li></ul><h3 id=전체-프로토콜-정의-프로토콜-그래프>(전체) 프로토콜 정의: 프로토콜 그래프</h3><ul><li><p>프로토콜 그래프 (또는 프로토콜 스택):</p><ul><li>프로토콜 모음(collection)과 그들 사의의 의존관계(dependency)</li><li>동료 간의 통신은 대개 간접적으로 이루어진다.:<ul><li>실제 통신은 하위 계층을 사용하여 (즉, 위임하여) 이루어진다.</li><li>하드웨어 수준에서만 동료간이 직접적임</li></ul></li></ul></li><li><p>하위 프로토콜 공유:</p><ul><li>다중화(Multiplexing) 및 역다중화(Demultiplexing) - demux key</li></ul></li></ul><h3 id=계층적-프로토콜-동작원칙>(계층적) 프로토콜: 동작원칙</h3><ul><li>포장/캡슐화 (Encapsulation):<ul><li>헤더(Header)</li><li>바디(Body)</li></ul></li></ul><h3 id=추상화계층화-개념-정리>추상화/계층화 개념 정리</h3><ul><li>추상화 : 기능이 있다고 가정하자</li><li>계층화 : 여러 계층으로 나누어 각 계층이 해당 기능을 담당한다</li></ul><h3 id=표준구조-standard-architectures>표준구조 (Standard Architectures)</h3><ul><li>Open System Interconnect (OSI) Architecture:<ul><li>International Standards Organization (ISO)</li><li>International Telecommuications Union(ITU) : formerly CCITT</li><li>참조 모델(Reference Model): 통신 문제를 나누어 생각하는 틀</li></ul></li></ul><h4 id=7계층기능-정의>7계층(기능) 정의</h4><ul><li>Application 7 응용 계층: 응용 자체와 관련된 사항만</li><li>Presentation 6 표현 계층 : 데이터 표현 방법과 관련된 사항</li><li>Session 5 세선 계층 : 대화 패턴과 관련된 사항 담당</li><li>Trasnport 4 트랜스포트 계층: 통신 응용 사이의 신뢰성 있는 메시지 교환</li><li>Network 3 네트워크 계층 : 네트워크를 통해 연결된 호스트(단말) 사이의 데이터(패킷) 교환</li><li>Link 2 링크계층 : 하나의 링크로 연결된 노드 사이의 비트 묶음(프레임) 교환</li><li>Pysical 1 물리 계층: 물리적인 신호 교환과 관련된 사항 담당</li></ul><h4 id=인터넷internet-구조>인터넷(Internet) 구조</h4><ul><li><p>Internet Engineering Task Force (IETF)</p></li><li><p>5,6 계층은 탈락</p></li><li><p>Internet Protocol (IP)는 3-4 계층 사이에 존재하며, 서로 다른 네트워크를 연결하지만 3계층에 가까움</p></li><li><p>성능상의 문제</p></li><li><p>OSI(7계층) 모델 : 컴퓨터 네트워크 설계/구현 및 구조 체계 표준이지만, 실제 구현과 동일하지 않고, 문제 인식/ 설계의 참조모델로서 사용한다.</p></li><li><p>각 계층 설명:</p><ol><li>물리 계층 : 직접 연결된 노드 사이의 비트 전송</li><li>링크 계층 : 직접 연결 노드 사이 프레임(비트 묶음) 전송</li><li>네트워크 계층 : 스위치로 간접연결 된 호스트 사이의 패킷 전성</li><li>트랜스포트 계층 : 종단간(end-to-end) 신뢰성 있는 전송</li></ol></li></ul><h3 id=성능performance--대역폭>성능(Performance) : 대역폭</h3><ul><li>대역폭(Bandwidth) &ndash; 처리량/처리속도(throughput):<ul><li>단위 시간 당 전송될 수 있는 데이터의 양:<ul><li>예) 10Mbps (bits-per-second)</li></ul></li><li>링크 간 대 종단간</li><li>표기 방법:<ul><li>KB - 2^10 bytes</li><li>Mbps - 10^6 bits per second</li></ul></li><li>대역폭은 비트 폭(bit width)과 관련이 있다.:<ul><li>속도가 높아지면 비트폭이 작아진다. 즉, 비트 사이가 좁아진다.</li></ul></li></ul></li></ul><h3 id=성능-소요-시간--지연-시간>성능: 소요 시간 / 지연 시간</h3><ul><li>소요시간(Latency) / 지연시간(Delay)</li><li>A지점에서 B지점으로 메시지를 송신하는 데 걸리는 시간:<ul><li>예: 24 milliseconds(ms)</li></ul></li><li>때로 왕복지연시간(round-trip time:RTT)이 중요할 수 있다.</li><li>시간 소요 항목:<ul><li>소요시간 : Propagation(고정항목, 상수) + Transmit(보내는 양에 따라 변화) + Queue (변수 항목) (+ 스위칭 시간)</li><li>Propagation (전파지연시간) = Distance / Speed of Light</li><li>Transmit (전송 시간) = Size / Bandwidth</li></ul></li><li>광속(Speed of light) - 전파의 속도</li><li>직접 링크에서는 큐잉 지연(queueing delay)은 없음.</li></ul><h3 id=timing-of-circuit-switching>Timing of Circuit Switching</h3><ul><li>아무리 빨라도 받는데에 시간 소요가 있음(Propagation Delay)</li><li>Address를 다 보내는 동안은 Node 1도 Node 2에게 전송하지 못하고 기다려야한다</li><li>circuit switch는 데이터를 보내기 전에 충발지로부터 도착지까지 적어도 한번은 갔다와야된다. : RTT = 2 * total 전파 지연 시간</li><li>circuit switch에서 초기 연결시간이 있다는 것</li></ul><h3 id=timing-of-packet-switching>Timing of Packet Switching</h3><ul><li>Store and Forward -> 동시에 일어나는게 아니라 store를 다하고 forward한다.</li><li>processing and queueing delay 시간이 필요함.</li></ul><h3 id=packet-segmentation-pipelining>Packet Segmentation: Pipelining</h3><ul><li>Circuit Switch의 data와 비슷한 모습이 된다.</li></ul><h2 id=성능-performance>성능 (Performance)</h2><ul><li><p>대역폭과 소요시간의 상대적 중요성:</p><ul><li>작은 메시지(예: 1byte) : 소요시간 중요<ul><li>1ms vs 100ms dominates 1Mbps vs 100Mbps</li></ul></li><li>큰 메시지 (예: 25MB) : 대역폭 중요:<ul><li>1Mbps vs 100Mbps dominates 1ms vs 100ms</li></ul></li></ul></li><li><p>무한대 대역폭:</p><ul><li>총 소요시간이 중요:<ul><li>Throughput : Tansfer Size / Transfer Time (전송완료시간)</li><li>Transfer Time = RTT + (1 / Bandwidth) x TransferSize</li></ul></li><li>1-MB file to 1-Gbps link as 1-KB packet to 1-Mbps link</li><li>데이터도 같이 증가</li><li>대역폭이 증가해서 소요시간이 더 중요해지거나 싶지만 주고 받는 데이터의 양도 증가했다. 따라 여전히 대역폭과 소요시간 두개의 다 중요하다.</li></ul></li></ul><h2 id=지연시간-x-대역폭-delay-x-bandwidth-product>지연시간 x 대역폭 (Delay x Bandwidth Product)</h2><ul><li>&ldquo;in flight&rdquo; or &ldquo;in the pipe&rdquo; 데이터양</li><li>비트로 나타내는 링크의 길이(bit length):<ul><li>링크의 부피</li><li>대역폭이 반영된 지연시간</li></ul></li><li>예: 100ms x 45Mbps = 560 KB</li></ul><h2 id=frames>Frames</h2><ul><li>대역폭을 키운다고 바로 사용하는 것이 아닌 대역폭을 활용하기 위해 크기를 조절해야한다.</li></ul><h2 id=통신-성능을-높이는-방법>통신 성능을 높이는 방법?</h2><ul><li><p>처리량(대역폭)을 높이는 방법</p></li><li><p>소요시간(지연시간)을 줄이는 방법</p></li><li><p>두 방법이 같은 것은 아님:</p><ul><li>대역폭을 높이면, 소요시간이 일부개선</li><li>그러나 소요시간은 다른 요소 포함.</li><li>또한, 데이터양이 적으면 대역폭 확장은 효과 미미</li></ul></li><li><p>실제 생활 문제로 대체하여 이해:</p><ul><li>두 지점 사이에 탑승자/물류 이송의 성능 문제</li></ul></li></ul><h2 id=대역폭을-높이는-방법>대역폭을 높이는 방법?</h2><ul><li>한번에 보내는 양을 높인다.:<ul><li>데이터를 신호화하는 작업의 효율 증대</li></ul></li><li>보내는 속도를 높인다.:<ul><li>고주파 채널을 사용한다.</li></ul></li><li>채널을 넓힌다.:<ul><li>넓은 대역 채널을 사용한다</li><li>여러 통신 채널을 병렬 사용</li></ul></li></ul><h2 id=소요시간을-줄이는-방법>소요시간을 줄이는 방법?</h2><ul><li>신호(전파, 광파)의 속도를 높일수는 없다.</li><li>지역처리를 높여서 실질적인 거리를 줄인다.</li><li>트래픽을 조절해서 큐잉 대기 시간을 줄인다.</li></ul><h1 id=2장-데이터-링크-네트워크-data-link-network>2장. 데이터 링크 네트워크 (Data-Link Network)</h1><h2 id=데이터링크-계층>데이터링크 계층</h2><ul><li>OSI 7계층의 1,2 계층은 무엇을 담당?:<ul><li>하나의 링크로 연결된 두 노드 사이의 비트 묶음(프레임) 교환</li></ul></li><li>하나의 링크로 연결된 두 노드:<ul><li>점대점 연결 네트워크: 가장 간단한 네트워크</li><li>일반적인 네트워크 구성의 기본 block</li></ul></li></ul><h2 id=하드웨어-구성요소-노드nodes>하드웨어 구성요소: 노드(Nodes)</h2><ul><li>단말/호스트, 스위치/라우터</li><li>범용(프로그래밍할 수 있는) 컴퓨터로 구성된다고 가정:<ul><li>예) PC</li></ul></li><li>때때로 특수한 목적의 하드웨어로 대체되기도 한다.</li><li>유한 메모리(제한된 버퍼공간을 의미)</li><li>네트워크 어뎁터(or NIC:Network Interface Cache)fㅡㄹ 통해서 네트워크에 연결</li><li>프로세서는 빠르고, 메모리는 느림</li></ul><h2 id=링크link>링크(Link)</h2><ul><li>데이터(신호) 전달을 위한 물리적 매체, 예) 케이블, 공기</li><li>Wired vs Wireless</li><li>전송모드:<ul><li>Simplex, Half-duplex, Full-duplex</li></ul></li><li>링크는 논리적 통로:<ul><li>하나의 케이블에 여러링크. 예)ADSL</li></ul></li></ul><h2 id=모듈레이션-데이터의-신호화>모듈레이션: 데이터의 신호화</h2><ul><li>데이터를 링크, 즉, 물리적 매체를 통해서 전달하기 위해서</li><li>인코딩/모듈레이션(Modulation) : data -> signal</li><li>수신 쪽에서는 반대작업(Demodulation) : signal-> data</li><li>모뎀(Modem)</li><li>신호의종류 : 전자기파 스펙트럼:<ul><li>주파수, 파장</li></ul></li></ul><h2 id=전자기-스펙트럼과-매체-특성>전자기 스펙트럼과 매체 특성</h2><ul><li>저주파일수록 전송 특성이 좋다. (장애물을 잘 통과한다)</li><li>저주파는 고속의 데이터 전송에 한계가 존재한다.:<ul><li>통신속도(대역폭)과 비트폭(length)</li></ul></li><li>통신의 발전: 저주파 -> 고주파</li></ul><h2 id=사용가능한-유선-링크의-종류>사용가능한 유선 링크의 종류</h2><ul><li>Category 5 twisted pair : 흔히 말하는 UTP 케이블, 10~100Mbps, 100m</li><li>50-ohm coax (ThinNet) : 10~100Mbps, 200m (동축케이블)</li><li>75-ohm coax (ThickNet) : 10~100Mbps, 500m (동축케이블)</li><li>Multimode filter : 100Mbps, 2km (광케이블)</li><li>Single-mode filter : 100~2400Mbps, 40km (광케이블)</li><li>전화회사로부터 선을 임대하는 경우:<ul><li>ISDN : 64kbps</li><li>T1 : 1544 Mpbs</li><li>T3 : 44736 Mbps</li><li>STS-1 : 51840 Mbps</li><li>STS-3 : 155250 Mbps</li><li>STS-12 : 622080 Mbps</li><li>STS-24 : 1.244160 Gpbs</li><li>STS-48 : 2.488320 Gpbs</li></ul></li></ul><h2 id=광케이블--optical-fiber>광케이블 : Optical Fiber</h2><ul><li>Index of reflection = Speed of vaccum/Speed in medium Modes</li></ul><h2 id=가입자선로last-mile-links>가입자선로(Last-Mile Links)</h2><ul><li>집(사용자)와 인터넷공급자 사이를 마지막으로 연결하는 링크</li><li>사용자가 선택해서 사용하는 링크이므로 중요</li><li>과거 : 모뎀을 통한 음성전화 링크</li><li>xDSL(Digital Subscriber Loop) : 음성과 data를 FDM 방식으로 동시에:<ul><li>ADSL</li><li>VDSL</li></ul></li><li>Cable Modem: asymmetric, shared bandwidth</li></ul><h2 id=무선링크wireless-links--일반>무선링크(Wireless Links) : 일반</h2><ul><li>장점 : 고정된 링크가 없음:<ul><li>이동성 지원</li><li>즉시 사용가능</li></ul></li><li>단점 : 공중으로 퍼져나감:<ul><li>고주파 vs 저주파</li><li>인접한 링크 사이에 간섭이 일어날 수 있음:<ul><li>전화 사용에 규재가 필요 - 라이센스 제도</li></ul></li><li>Multipath problem</li></ul></li></ul><h3 id=이동-통신cellular-network>이동 통신(Cellular Network)</h3><ul><li>기지국 &lt;-> 단말기:<ul><li>셀 : 하나의 기지국이 관할하는 지역</li><li>한드오프(hand-off) 문제</li></ul></li><li>기술발전:<ul><li>AMPS => PCS(GSM/CDMA) => W-CDMA => 4세대 이동통신 => 5G</li><li>Overlapping circular cells, Idealized hexagonal netowrk, Microcells within a network</li></ul></li></ul><h3 id=고정-무선-통신wireless-field-linked>고정 무선 통신(Wireless Field linked)</h3><ul><li>무선 고속 전용링크</li><li>무선 가입자망:<ul><li>소수의 이용자를 위해서, 선깔기는 아쉬울때 사용. 안태나에 지향성을 부과해서 공간을 분할한다.</li></ul></li></ul><h3 id=위성통신satellite-system>위성통신(Satellite system)</h3><ul><li>정지궤도 방송/전화 -> 대부분 고정식</li><li>정지궤도 데이터(VSAT)</li><li>저궤도 전화 : 양방향 원할, 이동가능 (셀이 작아지고, 많은 양의 위성이 필요하다.)</li><li>위성방송/DMB : 위성은 단순히 스위치, 중계만 하도록 사용했다. 지연시간 등의 속도적 문제점은 있을 수 있지만, 위성을 재활용해서 지상에서 업데이트가 가능하다는 장점이 있다.</li></ul><h3 id=단거리-무선통신short-range>단거리 무선통신(Short Range)</h3><ul><li>Public (licensefree) band 이용</li><li>적외선통신</li><li>무선 LAN - IEEE 802.11</li><li>Bluethooth</li><li>ZigBee/IEEE 802.15.4</li></ul><h2 id=인코딩>인코딩</h2><h3 id=인코딩encoding>인코딩(Encoding)</h3><ul><li>신호(Signal)는 물리적 매체를 통해 전달된다.:<ul><li>디지털 신호, 아날로그 신호</li></ul></li><li>데이터는 디지털 데이터만 취급:<ul><li>아날로그 데이터는 디지털 데이터를 변환</li></ul></li><li>문제: 발신지에서 목적지로 보내려는 이전 데이터를 전달될 수 있는 신호로 인코딩 해야함.</li><li>보다 일반적인 용어로는 변조(Modulation)이라고 한다.</li></ul><h3 id=디지털-전송transmission>디지털 전송(Transmission)</h3><ul><li>신호 중계방법:<ul><li>아날로그 전송:<ul><li>신호를 단순 증폭만 한다.</li><li>즉, 앰프(Amplifier)를 사용한다.</li></ul></li><li>디지털 전송:<ul><li>신호에서 데이터를 복원하여 다시 신호화:<ul><li>디지털 데이터를 담은 신호만 사용가능</li></ul></li><li>즉, 리피터(Repeater) 사용</li></ul></li><li>거의 모든 전송 방법이 디지털 전송 사용:<ul><li>noise 제거</li><li>기기비용, 부가기능 추가기능 등을 고려하여 사용</li></ul></li></ul></li></ul><h2 id=데이터-전송transmission>데이터 전송(Transmission)</h2><ul><li>전송할 때 Analog를 Digital로 변환하여 보낸다.</li></ul><h2 id=pulse-code-modulation>Pulse Code Modulation</h2><ul><li>sampling의 주기를 줄이면, 손실을 줄일 수 있다. 즉, sampling 주기는 각 샘플을 얼마나 정확하게 저장할 것이냐를 의미한다.</li></ul><h2 id=pcm>PCM</h2><ul><li>Sampling Theorem:<ul><li>Sampling rate = 2 * Highest Signal Frequency</li></ul></li><li>4 kHz Voice = 8 kHz sampling rate</li><li>Represent samples as pulses (PAM)</li><li>Quantize the samples (PCM)</li><li>8 k samples/sec * 8 bits/ smaple = 64 kbps</li></ul><h2 id=변조--amplitude-modulation>변조 : Amplitude Modulation</h2><ul><li><p>하나의 신호로 많은 비트를 보낼 수 없다.</p></li><li><p>주파수 변조(Frequency Modulation), 위상 변조(Phase Modulation)</p></li><li><p>이동통신의 속도가 2배 증가시킬려면?:</p><ul><li>Shannon의 법칙</li><li>AM, FM, PSM을 동시에 적용한다.</li></ul></li></ul><h2 id=디지털-전송transmission-1>디지털 전송(Transmission)</h2><ul><li>Analog Data, Digital Data</li><li>Digital Transmission</li><li>Modulation : Data -> A-Signal</li></ul><h3 id=non-return-to-zeronrz>Non-Return to Zero(NRZ)</h3><ul><li>노드 내부의 데이터 표현과 일치(즉, 별도의 인코딩 필요 없음)</li><li>문제점 : 1 또는 0이 연속되는 경우:<ul><li>Low Signal(0)인 경우 수신자는 신호가 없는 것으로 오해할 수 있음</li><li>High Signal(1)인 경우 전류가 계속 흐르게되고, 기저 전압의 혼돈이 생김.</li><li>Clock 복구가 불가능:<ul><li>송신자와 수신자의 Clock이 맞지 않으면 잘못된 비트 인식</li><li>수신자가 송신자의 Clock의 자신의 Clock을 맞추는 작업</li></ul></li></ul></li></ul><h3 id=nrzi-and-manchester>NRZI and Manchester</h3><ul><li>Non-return to Zero Inverted(NRZI):<ul><li>1을 인코딩할 경우 현재의 신호로부터 중앙지점에서 전이(mid transition)을 하고, 0을 인코딩할 경우 현재의 신호 상태를 유지함:<ul><li>연속되는 1 문제를 해결하는 방법</li></ul></li></ul></li><li>Manchester:<ul><li>0 : uptransition, 1: down transition</li><li>NRZ 방식으로 인코딩 데이터와 클럭을 베타적 논리합(XOR)을 시켜서 바꾼다.:<ul><li>50% 효율 문제</li></ul></li></ul></li></ul><h3 id=4b5b>4B/5B</h3><ul><li>아이디어:<ul><li>데이터를 매 4bits 마다 5-bit의 코드로 인코드한다. 이 5-bit 코드는 앞에 1개, 뒤에는 2개까지의 0이 나오도록 제한하여 선택된 코드이다. (따라서, 0이 4개 이상 연속되게 나올 수 없다.)</li><li>5-bit 코드는 NRZI 인코딩을 이용해서 전송된다.</li><li>효율을 80% 달성한다.</li></ul></li></ul><h3 id=프레이밍framing>프레이밍(Framing)</h3><ul><li>데이터를 끝없이 보낼수는 없음(특히, 패킷 네트워크에서는)</li><li>문제:<ul><li>비트(bit)들의 연속을 하나의 묶음(frame)으로 자르는 것</li><li>수신 쪽이 프레임을 인식할 수 있도록 묶는 것</li><li>프레임의 처음과 끝 인식</li></ul></li><li>전형적으로 네트워크 어뎁터에서 구현된다.</li><li>어뎁터는 호스트메모리로부터 프레임을 넣고 가져옴.</li></ul><h3 id=바이트-중심-프로토콜byte-oriented-protocol>바이트 중심 프로토콜(Byte-Oriented Protocol)</h3><ul><li>보초 방법(Sentinel Approach):<ul><li>BICYNC</li><li>IMP-IMP, PPP</li><li>문제점 : 프레임의 데이터부에서 ETX 문자가 나올 경우</li><li>해결 : 확장문자(escaping character) 사용:<ul><li>BICSYNC의 경우 DLE 문자를 ETX문자를 앞에 부착</li><li>IMP-IMP의 경우에는 DLE 문자 앞에 DLE문자를 부착</li></ul></li></ul></li><li>바이트 수 방법(Byte Counting Approach) - DDCMP:<ul><li>문제: 개수(count) 합이 잘못된 경우(training error)</li><li>해결 : 순회 중복검사(CRC)가 실패하므로 오류 검출</li></ul></li></ul><h3 id=비트-중심-프로토콜-bit-oriented-protocol>비트 중심 프로토콜 (Bit-Oriented Protocol)</h3><ul><li>HDLC : High-level Data Link Control (also SDLC and PPP):<ul><li>특별한 bit-sequence를 프레임의 앞과 뒤에 붙여서 프레임을 구현(01111110)</li></ul></li><li>비트 삽입(bit stuffing):<ul><li>송신자 : 메시지의 중간에 연속되는 5개의 1이 나오면 0을 생성함.</li><li>수신자 : 1을 연속해서 5개 받았을 때, 다음 비트를 본다.:<ul><li>다음 비트가 0이라면 그 비트를 삭제한다.</li><li>다음 비트가 10이라면 프레임의 끝</li><li>다음 비트가 11이라면 오류</li></ul></li></ul></li></ul><h3 id=오류-검출-코드error-detecting-code>오류 검출 코드(Error Detecting Code)</h3><ul><li>데이터 영역 안에 오류가 있는지 없는지를 알아내는 부가 데이터</li><li>예):<ul><li>크기면에서 EDC &#171; data : 오류가 없는 경우 단순 부하이므로</li><li>효율면에서, 오류 검출율이 높아야함</li><li>비용면에서, f() 연산에 시간이 적게 소모되어야함.</li></ul></li></ul><h3 id=오류-검출율>오류 검출율</h3><ul><li>EDC가 완벽하게 오류를 검출할 수 있을까?</li><li>검출 실패 : 시스템 integrity 상실</li><li>매우 높은 오류 검출율 + 중복 오류 검사</li></ul><h4 id=2차원-패리티two-demsional-parity>2차원 패리티(Two-Demsional Parity)</h4><h4 id=인터넷-체크섬-알고리즘internet-checksum-algorithm>인터넷 체크섬 알고리즘(Internet Checksum Algorithm)</h4><ul><li>아이디어 : 메시지를 16-bit의 정수의 연속으로 간주하고, 각 정수들을 16-bit 1의 보수 연산을 사용하여 모두 더한다. 그리고 그 결과 값의 1의 보수를 얻는다.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="u_short%20cksum%28u_short%20*buf,%20count%29%0a%7b%0a%20%20register%20u_long%20sum%20=%200;%0a%20%20while%20%28count%20--%29%20%7b%0a%20%20%20%20sum%20+=%20*buf;%0a%20%20%20%20if%20%28sum%20&%200xFFFF0000%29%20%7b%0a%20%20%20%20%20%20/*%20carry%20occured,%20so%20wrap%20around%20*/%0a%20%20%20%20%20%20sum%20&=%200xFFFF;%0a%20%20%20%20%20%20sum%20++;%0a%20%20%20%20%7d%0a%20%20%7d%0a%20%20return%20~%28sum%20&%200xFFFF%29;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>u_short <span style=color:#a6e22e>cksum</span>(u_short <span style=color:#f92672>*</span>buf, count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>register</span> u_long sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>    sum <span style=color:#f92672>+=</span> <span style=color:#f92672>*</span>buf;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sum <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFF0000</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* carry occured, so wrap around */</span>
</span></span><span style=display:flex><span>      sum <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0xFFFF</span>;
</span></span><span style=display:flex><span>      sum <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>~</span>(sum <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFF</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h4 id=순회-중복-검사9cyclic-redundancy-check-crc>순회 중복 검사9Cyclic Redundancy Check: CRC)</h4><ul><li><p>더하기보다 복잡한 나누기 사용 : 나머지 오류 검출코드로 전송</p></li><li><p>갯수로 사용될 송수신 사이에 약속된 비트 패턴: C</p></li><li><p>보낼 메시지 : M</p></li><li><p>오류 검출을 위해 추가되는 정보 : F(즉, EDC)</p></li><li><p>송신쪽:</p><ul><li>(M || F) % C == 0 이 되도록 F를 설정, 즉 (F에 나머를 넣어서) 전체 프레임이 C로 나누어 떨어지도록 함.</li><li>(M || F)를 전송</li><li>예) C=1101, M=10011010 이면, F=101 생성, 10011010101 전송</li></ul></li><li><p>수신쪽:</p><ul><li>수신된 메시지 전체를 C로 나누어서:<ul><li>나누어 떨어지지 않으면 오류 발생</li><li>나누어 떨어지면 오류가 없는 것으로 간주</li></ul></li></ul></li><li><p>성능:</p><ul><li>오류검출율:<ul><li>비트 C의 선택이 좌우</li><li>수학적 분석에 의해 잘 잡으면 32bit 코드 사용하면, 1500bytes 이상의 데이터에 대해서도 99.99의 검출율</li></ul></li><li>연산속도:<ul><li>전송 속도보다 늦으면 곤란하기 때문에 네트워크 카드내에서 하드웨어적으로 처리</li></ul></li><li>빠른 연산과 분석을 위해서 xor로 구현</li></ul></li></ul><h3 id=error-pattern-ex>Error Pattern: E(X)</h3><ul><li>전송하는 프레임 : P(X)</li><li>수신하는 프레임 : P&rsquo;(X)</li><li>전송 중 발생한 오류를 프레임에 대응되는 형태로 나타내면 : E(X)</li><li>관계:<ul><li>P(X) xor P&rsquo;X() = E(X)</li></ul></li><li>주의:<ul><li>E(X) 값을 구하는 것이 목적이 아님</li><li>오류가 없었다면, E(X) = 0 이고, P(X)=P&rsquo;(X)라는 사실</li></ul></li></ul><h3 id=crc에-대해-간단히-설명하시오>CRC에 대해 간단히 설명하시오</h3><ul><li>전송되는 데이터의 오류 여부확인을 위해 부가되어 보내지는 오류 검출 코드</li><li>송신자가 계산해서 추가, 수신자가 이를 확인</li><li>오류 검출율이 매우 높고, 하드웨어 구현이 가능해서 거의 모든 링크 전송에서 사용</li></ul><h3 id=복구--개요>복구 : 개요</h3><ul><li>오류에 의해 변질된 프레임의 복구</li><li>오류 수정 코드(Error Correction Codes: ECC):<ul><li>순방향 수정(Forward Error Correction :FEC)</li></ul></li><li>자동반복 요청(Automatic Repeat reQuest: ARQ): 재전송:<ul><li>ACK와 타임아웃(Acknowledgements and Timeouts)</li><li>역방향 수정(Backward Error Correction)</li></ul></li><li>참고 : 오류 중에는 프레임 자체가 성립하지 않는 framing error 도 있음:<ul><li>이 경우 수신 쪽이 frame 수신 여부를 인식하지 못함.(frame loss)</li></ul></li></ul><h3 id=오류-수정-코드error-correcting-codes>오류 수정 코드(Error Correcting Codes)</h3><ul><li>Forward Error Correction(FEC)</li><li>재전송이 용이하지 않는 경우 유용:<ul><li>전화 같은 실시간 통신, 재전송이 의미가 없는 경우</li></ul></li></ul><h3 id=재전송을-통한-오류-복구>재전송을 통한 오류 복구</h3><ul><li>타임아웃, 재전송용 버퍼처리 등 필요</li><li>어뎁터에서 단독으로 처리하는데 한계</li><li>2계측이 제공해야하는 기능이지만, 노느 내의 소프트웨어로 처리한다.</li></ul><h3 id=arq>ARQ</h3><ul><li>응답(ACK) 및 타임아웃</li><li>순서번호(Seq):<ul><li>ACK의 분실 경우 중복 데이터 문제 발생:<ul><li>순서번호 필요</li><li>수신된 중복 data는 무시한다.</li><li>반드시 ACK을 전송한다</li></ul></li></ul></li><li>Automatic Repeat Request(ARQ):<ul><li>Error detection</li><li>Acknowledgement</li><li>Retransmission after timeout</li><li>Negative acknowledgement (optional)</li></ul></li></ul><h3 id=stop-and-wait--tming-분석>Stop and Wait : Tming 분석</h3><ul><li>Utilization of Link = (frame size / bit rate) / (distance / speed of signal) = frame size / (distance x bit rate)</li><li>문제점 : 파이프를 꽉 채운채로 유지하지 못함.</li></ul><h3 id=슬라이딩-윈도우>슬라이딩 윈도우</h3><ul><li>아이디어 : 송신자가 ACK를 받기 전에 여러 프레임을 전송할 수 있도록 한다.</li><li>ACK를 받지 않은 상태에서 보내지는 프레임(outstanding frame)이 복수로 늘어난다. 그 수는 제한된다.(window size):<ul><li>모두 오류 제어 대상, 순서 번호 필요</li><li>stop & wait는 sliding window의 window size가 1인 경우</li></ul></li><li>각각의 프레임에 대해서는 ARQ, 즉 ACK/timeout & retransmission<ul><li>ACK #n의 의미를 일관성 있도록 정의해서 사용</li></ul></li><li>즉, 효율 높은 오류제어: 버퍼링보다는 오류제어가 핵심이다.</li></ul><h3 id=sliding-window-protocol의-성능>Sliding Window Protocol의 성능</h3><ul><li>$U(Utilization) \propto N, 1/t_{prop}, t_{frame}$</li><li>윈도우 크기(N)이 충분히 크면, 효율이 증가한다.</li><li>즉, ACK가 돌아올 때까지 윈도우가 모두 소진되지 않으면 기다리는 시간 없이 100% 통신이 가능하다.</li></ul><h3 id=슬라이딩-윈도우의-오류-복구>슬라이딩 윈도우의 오류 복구</h3><ul><li>복수의 outstanding frame 중 어느 프레임에서도 오류 발생 가능:<ul><li>따라서 모든 프레임은 개별적으로 재전송준비가 되어야한다.</li></ul></li><li>오류 처리 정책:<ul><li>Go-Back-N : 오류가 발생한 지점부터 새출발</li><li>Selective - Repeat : 오류가 발생한 프레임만 재전송</li></ul></li></ul><h3 id=go-back-n-구현-옵션>Go-Back-N (구현) 옵션</h3><ul><li>Go-Back-N에는 여러가지 옵션이 가능하다.</li><li>수신 쪽에서 out-of-order 프레임을 어떻게 처리하는가에 따라서:<ul><li>ACK를 보낼 것인가?</li><li>저장을 할 것인가?</li></ul></li><li>저장 안하고 ACK도 보내지 않는다. -> stop & wait</li><li>저장하고 ACK는 안보낸다. -> 이를 가정하고 설명한다.</li><li>저장 안하고 ACK를 보낸다. -> 중복 ACK</li><li>저장하고 ACK도 보낸다. -> 중복 ACK</li><li>송신 쪽은 동일하게 동작:<ul><li>각 outstanding 프레임에 대해:<ul><li>재전송 버퍼에 저장 : 타임아웃 설정</li></ul></li><li>오류 발생 인지 이후 : 모든 outstanding frame을 동시 전송? 각 frame의 timeout에 전송</li></ul></li><li>어떤 옵션으로 구현되어도 연동가능, 즉 오류 복구 가능</li></ul><h3 id=오류처리-정책--go-back-n-재검토>오류처리 정책 : Go-Back-N 재검토</h3><ul><li>오류가 발생한 N부터 다시 출발(N이하를 무조건 다시 보낸다는 의미가 아님)</li><li>핵심 : ACK는 &ldquo;~까지 잘받았다"는 의미의 누적(cumulative) ACK 사용</li><li>수신쪽에서의 버퍼링은 수신자가 독립적으로 결정:<ul><li>버퍼링 안해도 된다.</li></ul></li></ul><h3 id=오류처리-정책--selective-repeat>오류처리 정책 : Selective Repeat</h3><ul><li>필요조건:<ul><li>수신쪽은 out-of-order 프레임 수신. 버퍼링 필수</li><li>수신쪽이 정확한 수신 상황ㅈ 정보를 송신 쪽에 알려주어야 함.</li><li>~는 잘 받았다는 개별(individual)/선택(selective) ACK 필수</li></ul></li></ul><h3 id=sliding-window-세부사항>Sliding Window 세부사항</h3><ul><li>Sliding Window는 오류 제어 프로토콜:<ul><li>각각의 outstanding frame에 대해 기본적으로 ARQ수행</li><li>복수 개의 outstanding frame 처리를 위해 buffering 추가</li></ul></li><li>(Go-Back-N, Selective-Repeat) 선택은 송신자의 결정:<ul><li>송신자의 재전송 방법 : 수신자의 buffering은 별도문제</li><li>Sending Buffer : 필수 (재전송)</li><li>Receiving Buffer:<ul><li>Selective-Repeat : 필수 (out-of-order 프레임 반드시 저장)</li><li>Go-Back-N : 성능 향상을 위한 option</li></ul></li><li>수신자가 out-of-order를 저장한다고 Selective Repeat은 아님</li></ul></li><li>송신자가 Selective-Repeat을 하기 위해서는 수신 상황 정보가 필요:<ul><li>수신 쪽에서 송신 쪽으로 selective/individual ACK를 보내야한다. 송신쪽에서 Selective Repeat 가능</li></ul></li></ul><h3 id=프로토콜의-구현>프로토콜의 구현</h3><ul><li>오류제어 이전까지는 Adaptor(NIC)에서 하드웨어로 구현</li><li>오류제어는 소프트웨어로 구현되는 첫 프로토콜</li><li>송수신 양쪽에서 보는 것은 이론적 설명에서만 실제론:<ul><li>송수신이 각각 독립적으로 동작</li><li>프로토콜의 동작에 대해서 확실한 이해 필요</li><li>특히, 비정상 상황에 대해서</li></ul></li><li>난이도:<ul><li>Concurrent and distributed program</li></ul></li></ul><h3 id=슬라이딩윈도우gobackn-세부알고리즘>슬라이딩윈도우(GoBackN) 세부알고리즘</h3><ul><li>송신자:<ul><li>각 프레임에서 순서번호를 할당(SeqNum) : 각 outstanding frame의 ID</li><li>세 개의 상태 변수를 유지:<ul><li>송신창 - send window size(SWS)</li><li>마지막으로 받은 ACK 의 프레임 번호 - last acknowledgement received (LAR)</li><li>마지막으로 보낸 프레임 - last frame sent (LFS)</li></ul></li><li>다음 항등식(invariant)을 유지 : LFS - LAR + 1 &lt;= SWS</li><li>상위 계층에서 전송 요청을 받으면, 1) LFS를 증가시키고 (LFS 증가가 불가능하면 wait), 2) 타임아웃을 설정한 뒤, 3) 프레임을 전송</li><li>ACK를 받으면 1) 타임아웃을 해지하고, 2) LAR을 증가시키며, 3) 이에 따라 새로 창이 열리며 전송이 가능</li><li>타임아웃이 걸리면 1) 타임아웃을 설정한 뒤, 2) 프레임을 재전송</li><li>SWS만큼의 프레임은 버퍼에 유지 &ndash; 재전송에 필요</li></ul></li><li>수신자:<ul><li>Out-of-order 프레임을 저장하는 GoBackN 알고리즘</li><li>세 개의 상태 변수를 유지:<ul><li>수신창 - receive window size(RWS)</li><li>받아들일 수 있는 마지막 프레임 - last frame acceptable (LFA)</li><li>수신 예상 프레임 - next frame expected (NFE)</li></ul></li><li>항등식(invariant)을 유지: LFA - NFE + 1 &lt;= RWS</li><li>SeqNum의 프레임이 도착하면:<ul><li>If NFE &lt;= SeqNum &lt;= NFA -> 받아들임(accept):<ul><li>중간에 빈 곳 없는 연속되는 데이터는 상위 계층으로 deliver</li></ul></li><li>If (SeqNum &lt; NF) or (SeqNum > NFA) -> 버림 (discard):<ul><li>SeqNum &lt; NFE 는 ACK 전송 필요</li></ul></li><li>누적 ACK(cumulative ACK)를 보낸다. (NFE 값으로)</li></ul></li></ul></li></ul><h3 id=순서-번호-공간-sequence-number-space>순서 번호 공간 (Sequence Number Space)</h3><ul><li>순서번호는 오류제어에서 필수</li><li>프레임 헤더의 필드는 한정된 공간 (많이 사용할 수록 overhead 증가): 결국 일정한 숫자에서 순서번호는 순환되며 사용</li><li>순서번호공간 : 가능한 순서번호 구간:<ul><li>예 : 4-bit 필드 => [0..15]</li></ul></li><li>문제 : 순서번호 필드를 얼마로 잡아야 안전하겠는가?:<ul><li>반대로, 주어진 순서번호 공간에서 최대 outstanding 프레임, 즉, 송신자 기준 WindowSize는 얼마까지 늘릴 수 있나?</li></ul></li><li>순서 번호 공간은 현재 전송 중인 프레임의 수보다 커야한다.:<ul><li>어떤 프레임이 오류 및 재전송의 대상이 될지 모르므로, outstanding Frame 각각은 서로 다른 SeqNum를 갖고 있어야한다.</li></ul></li><li>outstanding 프레임의 최대 수 = SendingWindowSize(SWS)</li><li>따라서, 순서번호공간 크기 > SWS</li><li>하지만 단순히, SWS &lt;= 순서번호공간에서는 다른 문제가 생긴다.:<ul><li>순서가 순환되었음에도 수신자가 이를 인지하지 못하고 새로운 데이터를 재전송된 데이터라고 판단하는 문제</li></ul></li><li>결론 : SWS &lt; 순서번호 공간 / 2:<ul><li>즉, WindowSize는 최대로 보낼 수 있는 outstanding 프레임의 수이고 이는 순서번호공간의 반보다 작아야한다.</li><li>정확하게는 SWS &lt; (MaxSeqNum + 1) / 2</li></ul></li><li>직관적으로 설명하면, SeqNum는 순서 번호 공간의 1/2 사이를 오고간다.</li></ul><h3 id=동시-논리-채널concurrent-logical-channels>동시 논리 채널(Concurrent Logical Channels)</h3><ul><li>하나의 점대점(point-to-point) 링크를 통해 여러 개의 논리적 채널을 동시/다중 송신함.</li><li>각각의 논리적 채널은 정지 대기(stop-and-wait)방식으로 운영된다.</li><li>각 지상 링크에 대해서 8개의 논리적 채널을 유지한다.</li><li>각 프레임의 헤더에는 3-bit 채널 번호와 1-bit 순서 번호, 총 4비트가 포함되어 있으며, 이는 슬라이딩 윈도우 프로토콜가 8개의 송신창을 유지하는데 필요한 것과 같다.</li><li>신뢰성 문제를 흐름제어(flow control)와 프레임 순서(frame order) 문제와 분리:<ul><li>Sliding Window Protocol은 all-in-one approach이기에, 오류 문제, 버퍼링 문제, 순서 문제를 한번에 처리하여 복잡하다.</li></ul></li></ul><h3 id=sliding-window-구현>Sliding Window 구현</h3><ul><li>목적:<ul><li>통신 알고리즘이 어떻게 구현되는가에 대한 궁금증 해결 (계층 구조는 어떻게 구현되는가?)</li><li>슬라이딩 윈도우 알고리즘 구현을 통한 확실한 이해</li></ul></li><li>어디서, 즉, 시스템의 어느 단계에서, 동작하는 프로그램인가?:<ul><li>프레임 하나 하나의 송수신은 NIC(Network Interface Card)이 담당</li><li>슬라이딩 윈도우는 바로 그 위에서 동작 -> 디바이스 드라이버</li></ul></li><li>프로토콜 내부동작의 실체는?:<ul><li>계층구조에 따라, 헤더 정보를 써넣고, 읽고 처리하는 것이 기본</li><li>담당 기능에 따라 세부 동작이 정해짐 (슬라이딩 윈도우 - 오류 제어)</li></ul></li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="typedef%20u_char%20SwpSeqno;%0atypedef%20struct%20%7b%0a%20%20SwpSeqno%20SeqNum;%20/*%20sequence%20number%20of%20this%20packet%20*/%0a%20%20SwpSeqno%20AckNum;%20/*%20allows%20window%20sizes%20of%20up%20to%20128%20*/%0a%20%20u_char%20%20%20flags;%20%20/*%20up%20to%2016%20bits%20worth%20of%20flags%20*/%0a%7d%20SWPHdr;%0a%0atypedef%20struct%20%7b%0a%20%20/*%20sender%20side%20state;%20*/%0a%20%20SwpSeqno%20%20%20%20LAR;%20%20%20%20%20%20/*%20seqno%20of%20last%20ACK%20received%20*/%0a%20%20SwpSeqno%20%20%20%20LFS;%20%20%20%20%20%20/*%20last%20frame%20sent%20*/%0a%20%20Semaphore%20%20%20sendWindowNotFull;%0a%20%20SWPHdr%20%20%20%20%20%20hdr;%20%20%20%20%20%20/*%20pre-initialized%20header%20*/%0a%20%20struct%20txq_slot%20%7b%0a%20%20%20%20Event%20%20%20timeout;%20%20%20%20/*%20event%20associated%20with%20send-timeout%20*/%0a%20%20%20%20Msg%20%20%20%20%20msg;%0a%20%20%7d%20sendQ[SWS];%0a%0a%20%20/*%20receiver%20side%20state:%20*/%0a%20%20SWPSeqno%20%20%20%20NFE;%20%20%20%20%20%20/*%20seqno%20of%20next%20frame%20expected%20*/%0a%20%20struct%20rxq_slot%20%7b%0a%20%20%20%20int%20%20%20%20%20recieved;%20/*%20is%20msg%20valid?%20*/%0a%20%20%20%20Msg%20%20%20%20%20msg;%0a%20%20%7d%20recvQ[RWS];%0a%7d%20SwpState;%0a%0astatic%20XkHandle%0asendSWP%28SwpState%20*state,%20Msg%20*frame%29%0a%7b%0a%20%20struct%20sendQ_slot%20*slot;%0a%20%20hbuf[HLEN];%0a%20%20/*%20wait%20for%20send%20window%20to%20open%20*/%0a%20%20semWait%28&amp;state-%3esendWindowNotFull%29;%0a%20%20state-%3ehdr.SeqNum%20=%20++state-%3eLFS;%0a%20%20slot%20=%20&amp;state-%3esendQ[state-%3ehdr.SeqNum%20%25%20SWS];%0a%20%20store_swp_hdr%28state-%3ehdr,%20hbuf%29;%0a%20%20msgAddHdr%28frame,%20hbuf,%20HLEN%29;%0a%20%20msgSaveCopy%28&amp;slot-%3emsg,%20frame%29;%0a%20%20slot-%3etimeout%20=%20evSchedule%28swpTimeout,%20slot,%20SWP_SEND_TIMEOUT%29;%0a%20%20return%20send%28LINK,%20frame%29;%0a%7d%0a%0astatic%20int%0adeliverSWP%28SwpState%20*state,%20Msg%20*frame%29%0a%7b%0a%20%20hbuf%20=%20msgStripHdr%28frame,%20HLEN%29;%0a%20%20load_swp_hdr%28&amp;hdr,%20hbuf%29;%0a%20%20if%20%28hdr.Flags%20&%20FLAG_ACK_VALID%29%0a%20%20%7b%0a%20%20%20%20/*%20received%20an%20acknowledgment%20---%20do%20SENDER-side%20*/%0a%20%20%20%20if%20%28swpInWindow%20%28hdr.AckNum,%20state-%3eLAR+1,%20state-%3eLFS%29%29%0a%20%20%20%20%7b%0a%20%20%20%20%20%20do%0a%20%20%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20struct%20sendQ_slot%20*slot;%0a%20%20%20%20%20%20%20%20slot%20=%20&amp;state-%3esendQ[++state-%3eLAR%20%25%20SWS];%0a%20%20%20%20%20%20%20%20evCancel%28slot-%3etimeout%29;%0a%20%20%20%20%20%20%20%20msgDestroy%28&amp;slot-%3emsg%29;%0a%20%20%20%20%20%20%20%20semSignal%28&amp;state-%3esendWindowNotFull%29;%0a%20%20%20%20%20%20%7d%20while%20%28state-%3estateLAR%20!=%20hdr.AckNum%29;%0a%20%20%20%20%7d%0a%20%20%7d%0a%20%20//%20%ec%86%a1%ec%8b%a0%20%ec%aa%bd,%20timeout%20%ec%b2%98%eb%a6%ac%eb%8a%94%20%ec%83%9d%eb%9e%b5%0a%20%20if%20%28hdr-%3eFlags%20&%20FLAG_HAS_DATA%29%0a%20%20%7b%0a%20%20%20%20struct%20recvQ_slot%20*slot;%0a%20%20%20%20/*%20received%20data%20packet%20--%20do%20RECEIVER-side%20*/%0a%20%20%20%20slot%20=%20&amp;state-%3erecvQ[hdr.SeqNum%20&%20RWS];%0a%20%20%20%20if%20%28!swpInWindow%28hdr.SeqNum,%20state-%3eNFE,%20state-%3eNFE%20+%20RWS%20-%201%29%29%0a%20%20%20%20%7b%0a%20%20%20%20%20%20/*%20drop%20the%20message%20*/%0a%20%20%20%20%20%20return%20SUCCESS;%0a%20%20%20%20%7d%0a%20%20%20%20msgSaveCopy%28&amp;slot-%3emsg,%20frame%29;%0a%20%20%20%20slot-%3ereceived%20=%20TRUE;%0a%20%20%20%20if%20%28hdr.SeqNum%20==%20state-%3eNFE%29%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20Msg%20m;%0a%20%20%20%20%20%20%20while%20%28slot-%3ereceived%29%0a%20%20%20%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20%20deliver%28HLP,%20&amp;slot-%3emsg%29;%0a%20%20%20%20%20%20%20%20%20msgDestroy%28&amp;slot-%3emsg%29;%0a%20%20%20%20%20%20%20%20%20slot-%3ereceived%20=%20FALSE;%0a%20%20%20%20%20%20%20%20%20slot%20=%20&amp;state-%3erecvQ[++state-%3eNFE%20%25%20RWS];%0a%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20/*%20send%20ACK;%20*/%0a%20%20%20%20%20%20%20prepare_ack%28&amp;m,%20state-%3eNFE%29;%0a%20%20%20%20%20%20%20send%28LINK,%20&amp;m%29;%0a%20%20%20%20%20%20%20msgDestroy%28&amp;m%29;%0a%20%20%20%20%7d%0a%20%20%20%20return%20SUCCESS;%0a%20%20%7d%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> u_char SwpSeqno;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  SwpSeqno SeqNum; <span style=color:#75715e>/* sequence number of this packet */</span>
</span></span><span style=display:flex><span>  SwpSeqno AckNum; <span style=color:#75715e>/* allows window sizes of up to 128 */</span>
</span></span><span style=display:flex><span>  u_char   flags;  <span style=color:#75715e>/* up to 16 bits worth of flags */</span>
</span></span><span style=display:flex><span>} SWPHdr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* sender side state; */</span>
</span></span><span style=display:flex><span>  SwpSeqno    LAR;      <span style=color:#75715e>/* seqno of last ACK received */</span>
</span></span><span style=display:flex><span>  SwpSeqno    LFS;      <span style=color:#75715e>/* last frame sent */</span>
</span></span><span style=display:flex><span>  Semaphore   sendWindowNotFull;
</span></span><span style=display:flex><span>  SWPHdr      hdr;      <span style=color:#75715e>/* pre-initialized header */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> txq_slot {
</span></span><span style=display:flex><span>    Event   timeout;    <span style=color:#75715e>/* event associated with send-timeout */</span>
</span></span><span style=display:flex><span>    Msg     msg;
</span></span><span style=display:flex><span>  } sendQ[SWS];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* receiver side state: */</span>
</span></span><span style=display:flex><span>  SWPSeqno    NFE;      <span style=color:#75715e>/* seqno of next frame expected */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rxq_slot {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>     recieved; <span style=color:#75715e>/* is msg valid? */</span>
</span></span><span style=display:flex><span>    Msg     msg;
</span></span><span style=display:flex><span>  } recvQ[RWS];
</span></span><span style=display:flex><span>} SwpState;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> XkHandle
</span></span><span style=display:flex><span><span style=color:#a6e22e>sendSWP</span>(SwpState <span style=color:#f92672>*</span>state, Msg <span style=color:#f92672>*</span>frame)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sendQ_slot <span style=color:#f92672>*</span>slot;
</span></span><span style=display:flex><span>  hbuf[HLEN];
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* wait for send window to open */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>semWait</span>(<span style=color:#f92672>&amp;</span>state<span style=color:#f92672>-&gt;</span>sendWindowNotFull);
</span></span><span style=display:flex><span>  state<span style=color:#f92672>-&gt;</span>hdr.SeqNum <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>state<span style=color:#f92672>-&gt;</span>LFS;
</span></span><span style=display:flex><span>  slot <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>state<span style=color:#f92672>-&gt;</span>sendQ[state<span style=color:#f92672>-&gt;</span>hdr.SeqNum <span style=color:#f92672>%</span> SWS];
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>store_swp_hdr</span>(state<span style=color:#f92672>-&gt;</span>hdr, hbuf);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>msgAddHdr</span>(frame, hbuf, HLEN);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>msgSaveCopy</span>(<span style=color:#f92672>&amp;</span>slot<span style=color:#f92672>-&gt;</span>msg, frame);
</span></span><span style=display:flex><span>  slot<span style=color:#f92672>-&gt;</span>timeout <span style=color:#f92672>=</span> <span style=color:#a6e22e>evSchedule</span>(swpTimeout, slot, SWP_SEND_TIMEOUT);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>send</span>(LINK, frame);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>deliverSWP</span>(SwpState <span style=color:#f92672>*</span>state, Msg <span style=color:#f92672>*</span>frame)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  hbuf <span style=color:#f92672>=</span> <span style=color:#a6e22e>msgStripHdr</span>(frame, HLEN);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>load_swp_hdr</span>(<span style=color:#f92672>&amp;</span>hdr, hbuf);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (hdr.Flags <span style=color:#f92672>&amp;</span> FLAG_ACK_VALID)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* received an acknowledgment --- do SENDER-side */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>swpInWindow</span> (hdr.AckNum, state<span style=color:#f92672>-&gt;</span>LAR<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, state<span style=color:#f92672>-&gt;</span>LFS))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> sendQ_slot <span style=color:#f92672>*</span>slot;
</span></span><span style=display:flex><span>        slot <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>state<span style=color:#f92672>-&gt;</span>sendQ[<span style=color:#f92672>++</span>state<span style=color:#f92672>-&gt;</span>LAR <span style=color:#f92672>%</span> SWS];
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>evCancel</span>(slot<span style=color:#f92672>-&gt;</span>timeout);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>msgDestroy</span>(<span style=color:#f92672>&amp;</span>slot<span style=color:#f92672>-&gt;</span>msg);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>semSignal</span>(<span style=color:#f92672>&amp;</span>state<span style=color:#f92672>-&gt;</span>sendWindowNotFull);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>while</span> (state<span style=color:#f92672>-&gt;</span>stateLAR <span style=color:#f92672>!=</span> hdr.AckNum);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 송신 쪽, timeout 처리는 생략
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (hdr<span style=color:#f92672>-&gt;</span>Flags <span style=color:#f92672>&amp;</span> FLAG_HAS_DATA)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> recvQ_slot <span style=color:#f92672>*</span>slot;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* received data packet -- do RECEIVER-side */</span>
</span></span><span style=display:flex><span>    slot <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>state<span style=color:#f92672>-&gt;</span>recvQ[hdr.SeqNum <span style=color:#f92672>&amp;</span> RWS];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>swpInWindow</span>(hdr.SeqNum, state<span style=color:#f92672>-&gt;</span>NFE, state<span style=color:#f92672>-&gt;</span>NFE <span style=color:#f92672>+</span> RWS <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* drop the message */</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> SUCCESS;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>msgSaveCopy</span>(<span style=color:#f92672>&amp;</span>slot<span style=color:#f92672>-&gt;</span>msg, frame);
</span></span><span style=display:flex><span>    slot<span style=color:#f92672>-&gt;</span>received <span style=color:#f92672>=</span> TRUE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hdr.SeqNum <span style=color:#f92672>==</span> state<span style=color:#f92672>-&gt;</span>NFE)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       Msg m;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>while</span> (slot<span style=color:#f92672>-&gt;</span>received)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>deliver</span>(HLP, <span style=color:#f92672>&amp;</span>slot<span style=color:#f92672>-&gt;</span>msg);
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>msgDestroy</span>(<span style=color:#f92672>&amp;</span>slot<span style=color:#f92672>-&gt;</span>msg);
</span></span><span style=display:flex><span>         slot<span style=color:#f92672>-&gt;</span>received <span style=color:#f92672>=</span> FALSE;
</span></span><span style=display:flex><span>         slot <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>state<span style=color:#f92672>-&gt;</span>recvQ[<span style=color:#f92672>++</span>state<span style=color:#f92672>-&gt;</span>NFE <span style=color:#f92672>%</span> RWS];
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#75715e>/* send ACK; */</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>prepare_ack</span>(<span style=color:#f92672>&amp;</span>m, state<span style=color:#f92672>-&gt;</span>NFE);
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>send</span>(LINK, <span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>msgDestroy</span>(<span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> SUCCESS;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h2 id=이더넷-ethernet-개요>이더넷 (Ethernet) 개요</h2><ul><li>LAN(Local Area Networks)의 대명사</li><li>역사:<ul><li>skip</li></ul></li><li>CSMA/CD:<ul><li>Carrier Sense : 반송 신호 감지</li><li>Multiple access : 다중 접근</li><li>Collision detection : 충돌 검출</li></ul></li><li>버스 토폴로지: 다중 접근 연결</li><li>문제 : 공유 매체에 공평하게 접근할 수 있는 분산(distributed) 알고리즘:<ul><li>즉, 매체접근 (MAC: Medium Access Contorol) 필요</li></ul></li></ul><h3 id=물리적-특성-버스-토폴로지>물리적 특성 (버스 토폴로지)</h3><ul><li>고전적 이더넷 (Classicial Ethernet) : Thick-net:<ul><li>현재는 거의 사용하지 않지만, 이더넷 동작을 이해하기 위해서 알 필요가 있다.</li><li>최대 세그먼트 500m</li><li>transceiver taps은 적어도 2.5m 떨어져야함.</li><li>중계기(repeaters)로 여러 개의 세그먼트를 연결</li><li>두 노드 사이에서 중계기가 4개를 초과하여 있을 수 없다.:<ul><li>총 길이 : 2500m</li></ul></li><li>호스트의 최대 개수는 1024개</li><li>10Base5라고도 불림(10 Mbps, 500m)</li></ul></li></ul><h3 id=10baset-network>10BaseT Network</h3><ul><li>대안 기술:<ul><li>10Base2 (thin-net) : 200m : 데이지 체인(daisy-chain) 형태</li><li>10BaseT (twisted-pair): 100m : 성형(star configuration)</li></ul></li></ul><h3 id=프레임-형식frame-format>프레임 형식(Frame Format)</h3><ul><li>주소 (Addresses) : MAC 주소:<ul><li>각각의 어댑터에 유일한 48-bit 유니캐스트 주소가 할당됨</li><li>브로드캐스트(Broadcast) : 모든 비트가 1</li><li>멀티캐스트(Multicast) : 첫 비트가 1</li></ul></li><li>어댑터는 모든 프레임을 수신: 다음 경우에 받아들임 (즉, 호스트로 보냄):<ul><li>주소항이 자신의 유니캐스트 주소인 프레임</li><li>브로드캐스트 주소로 지정된 프레임</li><li>수신하도록 프로그램된 멀티캐스트 주소로 지정된 프레임</li><li>무차별 모드(promiscuous mode)일 때는 모든 프레임</li></ul></li></ul><h3 id=전송-알고리즘transmitter-algorithm>전송 알고리즘(Transmitter Algorithm)</h3><ul><li>다중 매체접근제어(MAC) : 기본적으로, 경쟁 방식:<ul><li>즉, 제어방식, 예약방식이 아님</li></ul></li><li>CS: carrier sense:<ul><li>전송 전에 회선의 상태를 확인</li></ul></li><li>회선이 유휴(idle) 상태이면:<ul><li>즉시 전송</li><li>메시지 사이즈의 상한선은 1500 바이트</li><li>연속해서 프레임을 보낼 때는 $9.6 \mu s$를 기다려야함.</li></ul></li><li>회선이 사용중이라면:<ul><li>유휴 상태가 될 때까지 대기하였다가 즉시 전송</li><li>1-persistent라 불림 (p-persistent의 특정 형태)</li></ul></li></ul><h3 id=전송-알고리즘--충돌collision>전송 알고리즘 : 충돌(Collision)</h3><ul><li>CD(Collision Detection) : 전송 중에도 회선 점검:<ul><li>최소 얼마 동안 감지해야 확실한 충돌감지:<ul><li>최악의 충돌 시나리오 - 51.2 $\mu s$</li></ul></li><li>51.2 $\mu s$ 전에 전송이 끝나면?:<ul><li>수신자 위치에 따라 충돌 없는 수신도 발생 가능. 즉, 충돌 여부가 확실하지 않음.</li><li>따라서, 10Mbps 기준, 전송 최소 프레임의 길이는 512bit, 즉, 64 바이트</li></ul></li></ul></li><li>충돌(collision)이 생긴다면:<ul><li>잼(jam) 신호를 발송하고, 프레임 전송을 멈춤</li><li>지연시간(delay)을 가진 후 재시도:<ul><li>첫번째: (0, 51.2) 중 택일</li><li>두번째 : (0, 1 * 51.2, 2 * 51.2, 3 * 51.2) 중에서 택일</li><li>N번째 : rnadomly select k * 51.2, k=0..2^n -1</li><li>여러번 시도 후에 포기(일반적으로 16번)</li></ul></li><li>지수 백오프(exponential backoff)</li></ul></li></ul><h3 id=cdmacd-평가>CDMA/CD 평가</h3><ul><li>여러 MAC 정책을 평가하는데에 있어서, 적절한 지표:<ul><li>확장성 등</li></ul></li><li>충돌에 소모되는 총 비용은 무엇의 함수:</li><li>1-persistent 정책 : Detecting 계속해서 하다가 아무도 안보낸다 싶으면 바로 전송</li><li>CD를 하지 않는다면? CD로 얻게되는 이익은 어디서 나오는 것인가: 충돌을 감지해서 충돌 발생시 소모되는 비용을 감소시킨다.</li><li>충돌이 감지된 후 1-persistent인가? : 지수적 백오프(exponential backoff)로 전송하기 때문에 1-persistent가 아니다.</li><li>CDMA/CD가 유요한 환경은? : Bursty Traffic이 발생하는 곳. (평소에는 충돌 가능성이 낮은)</li></ul><h3 id=이론과-실제>이론과 실제</h3><ul><li>10-200 개의 호스트</li><li>길이는 1500m보다 짧다. (RTT의 경우 51$\mu$ 보다는 5$\mu$에 가깝다)</li><li>패킷의 길이는 bimodal distribution을 따른다. (최대 크기인 1500에 가깝거나, 아주 짧은 80에 가까운 값들이 많은 분포)</li><li>상위 수준의 흐름제어(flow control)와 호스트 성닝이 부하를 제한한다.</li><li>권장사항:<ul><li>과부화를 피할 것(최대 30%의 효율)</li><li>컨트롤러(controller)를 정확하게 구현</li><li>큰 패킷을 사용</li></ul></li></ul><h3 id=이더넷-확장>이더넷 확장</h3><ul><li>속도:<ul><li>FastEthernet, Gigabit Ethernet 등</li></ul></li><li>스위칭 기능:<ul><li>Repeater 대신 Bridge:<ul><li>각 세그먼트가 독립적으로 사용가능하도록</li></ul></li><li>Multiport Bridge(= LAN Switch)</li><li>Switched Ethernet:<ul><li>HUB에 Switch로 동작</li><li>각 호스트는 대역폭을 점유해서 사용가능</li></ul></li></ul></li></ul><h2 id=토큰링>토큰링</h2><ul><li>토큰링 네트워크(Token Ring Networks):<ul><li>PRONET: 10Mbps와 80Mbps 링</li><li>IBM: 4Mbps 토큰링</li><li>16Mbps IEEE 802.5/토큰링</li><li>100Mbps Fiber Distributed Data Interface(FDDI)</li><li>현재는 많이 사용되지 않지만, 이더넷의 반대 정책으로 유명</li></ul></li></ul><h3 id=토큰링의-연결>토큰링의 연결</h3><ul><li>relay를 이용한 bypass</li><li>다중 접속 장치:<ul><li>외부에서 보면 HUB와 유사</li></ul></li></ul><h3 id=토큰링-mac-기본-개념>토큰링 MAC 기본 개념</h3><ul><li>프레임은 한 방향으로 돈다.:<ul><li>upstream to downstream</li></ul></li><li>특별한 비트 패턴(token)이 링을 회전한다.</li><li>전송하기 전에 토큰을 획득해야 함</li><li>전송을 마치면 토큰 방출(release)</li><li>프레임이 되돌아 오면 프레임을 제거</li><li>지국들은 라운드 로빈(round-robin) 서비스를 받게 됨</li></ul><h3 id=매체-접근-제어-세부사항>매체 접근 제어 세부사항</h3><ul><li>1 비트 버퍼 + 모니터(monitor) 지국</li><li>토큰 보유 시간 제한</li><li>전송 우선순위 지원:<ul><li>예약 비트</li><li>우선순위 복구</li></ul></li><li>토큰 방출:<ul><li>즉시 방출</li><li>지연 방출</li></ul></li></ul><h3 id=토큰링-관리>토큰링 관리</h3><ul><li>모니터 지국 : 링의 정상적 동작을 감시/유지:<ul><li>토큰의 회전을 감시; 문제 발생시 재생성</li><li>변질/orphan 프레임의 제거</li><li>Dead station의 검출</li></ul></li><li>모니터 지국의 선출:<ul><li>모너티로부터 announce가 없을 경우</li><li>감지한 노드가 claim frame 발송</li><li>자신이 보낸 claim frame을 받으면 => 링의 모든 노드 인정 => 모니터 지국으로 동작</li><li>동률 규정 : high address wins</li></ul></li></ul><h3 id=프레임-형식>프레임 형식</h3><ul><li>식별자 (delimiter):<ul><li>illegal Manchester Coding</li></ul></li><li>접근 제어(Access Control):<ul><li>프레임 우선순위, 예약 우선순위</li></ul></li><li>프레임 제어(Frame Control):<ul><li>상위 계층 프로토콜에 대한 역다중화 키</li></ul></li><li>프레임 상태(Frame status):<ul><li>A bit: 수신자가 송신자에게로 ACK</li><li>C bit: 수신자가 프레임을 copy했음</li></ul></li></ul><h2 id=무선wireless-lans>무선(Wireless) LANs</h2><ul><li>IEEE 802.11</li><li>대역폭:<ul><li>1 or 2 Mbps: 11M(802.11b), 54M(802.11g/a), 300M(802.11n), 1G+(802.11ac)</li></ul></li><li>물리적 매체:<ul><li>확산 스펙트럼(spread spectrum) radio : 2.4GHz, 5GHz</li><li>발산 적외선 (diffused infrared) : 10m</li></ul></li><li>infrastructure mode:<ul><li>wireless host communicates with base station</li><li>base station = access point(AP)</li><li>Basic Service Set(BSS):<ul><li>wireless hosts</li><li>access point (AP)</li></ul></li><li>Ad hoc mode:<ul><li>host only</li></ul></li></ul></li></ul><h3 id=확산-스펙트럼-spread-spectrum>확산 스펙트럼 (Spread Spectrum)</h3><ul><li>개념:<ul><li>공용대역(public band) 사용을 위한 기술적 요구사항:<ul><li>다른 사용자를 지속적으로 방해하면 안된다.</li><li>특정 주파수 대역만을 사용하면, 간섭/충돌이 지속되어서 다른 사용자와 동시 사용 불가능</li></ul></li></ul></li><li>넓은 주파수 대역으로 확산해서 신호를 전송:<ul><li>간섭/충돌은 일시적, 동시 사용을 해도 통신 가능</li><li>확산 사용 방식은 사용자별로 다르게</li></ul></li><li>원래, 신호 방해를 무산시키기 위한 군사용으로 설계</li><li>Code Division Multiplexing도 포함</li></ul><h4 id=확산-스펙트럼-예--블루투스>확산 스펙트럼 예 : 블루투스</h4><ul><li>주파수 호핑(Frequency Hopping):<ul><li>임의의 주파수 시퀀스로 전송</li><li>송신자와 수신자는 다음을 공유:<ul><li>Psudo random number generator</li><li>초기값 (seed)</li></ul></li><li>Bluetooth 사용</li><li>초기 802.11은 79 x 1MHz-wide 주파수 대역을 사용</li></ul></li></ul><h4 id=확산-스펙트럼-예--무선-lan>확산 스펙트럼 예 : 무선 LAN</h4><ul><li>직접 시퀀스(Direct Sequence):<ul><li>각 비트에 대해, 해당 비트를 n개의 임의 비트와 XOR한 비트열을 전송</li><li>송/수신자는 임의의 n비트 시퀀스를 알고 있음.:<ul><li>n-bit chipping code</li></ul></li><li>802.11은 11-bit chipping code 사용</li></ul></li></ul><h3 id=매체-접근>매체 접근</h3><ul><li>다른 무선기기와의 주파수 공유 문제는 Spread Spectrum으로 해결</li><li>같은 BSS, 또는 주변의 같은 802.11 기기 사이에서의 채널 사용문제는 여전히 해결 필요 => 접근 제어, 즉, MAC 필요</li><li>기본적으로 이더넷과 유사</li><li>단, 매체 특성 때문에:<ul><li>충돌 인식(Collision Detection)에 hidden node, exposed node라는 새로운 문제가 발생</li></ul></li></ul><h3 id=ieee-80211-multiple-access>IEEE 802.11: multiple access</h3><ul><li>avoid collisions : 2* nodes transmitting at same time</li><li>802.11 : CSMA - sense before transmitting:<ul><li>don&rsquo;t collide with ongoing transmission by other node</li></ul></li><li>802.11 : no collision detection:<ul><li>difficult to receive (sense collisions) when transmitting due to weak received signals(fading)</li><li>can&rsquo;t sense all collisions in any case : hidden terminal, fading</li><li>goal : avoid collisions : CMSA/CA</li></ul></li></ul><h3 id=충돌-회피collisions-avoidance>충돌 회피(Collisions Avoidance)</h3><ul><li>MACAW (Multiple Access with Collision Avoidance for Wireless)</li><li>송신자는 RequestToSend(RTS) frame을 전송</li><li>수신자는 ClearToSend(CTS) frame을 전송</li><li>다른 노드:<ul><li>CTS를 들으면 : keep quite</li><li>RTS는 들리지만, CTS는 들리지 않는다면 : ok to transmit</li></ul></li><li>수신자는 프레임을 받은 후, ACK를 전송 (MAC 수준의 ACK):<ul><li>다른 노드들은 ACK가 전송될 때까지 기다린다.</li></ul></li><li>충돌 문제:<ul><li>두 개 이상의 노드가 RTS를 동시에 보낼 때</li><li>충돌 인식 방법 없음 : 일정 시간 안에 CTS를 받지 못하면 충돌</li><li>exponential backoff</li></ul></li><li>충돌 비용 개선</li><li>RTS/CTS threashold:<ul><li>작은 프레임은 RTS/CTS 교환 없이 보내는 것이 유리</li></ul></li></ul><h3 id=이동성mobility-지원>이동성(Mobility) 지원</h3><ul><li>Case 1 : ad hoc networking</li><li>Case 2 : access poitns (AP):<ul><li>고정 위치</li><li>각 이동 노드는 하나의 AP와 연계</li></ul></li></ul><h3 id=bss-접속가입-이동-감지>BSS 접속/가입 (이동 감지)</h3><ul><li>스캐닝 (Scanning) : AP 선정 작업:<ul><li>이동 노드가 Probe frame 전송</li><li>Probe를 받은 모든 AP는 ProbeResponse frame 응답</li><li>노드가 AP를 선택: AssociateRequest frame 전송</li><li>AP는 AssociationResponse frame을 응답</li><li>새 AP가 이전 AP에게 유선 네트워크를 통해 이를 통보</li></ul></li><li>스캐닝 시점:<ul><li>능동적 : when join or move</li><li>수동적 : AP가 주기적으로 Beacon frame을 전송</li></ul></li><li>이동 경우, 프레임 포워딩(forwarding) 문제는 별도</li></ul><h3 id=매체접근제어mac-비교>매체접근제어(MAC) 비교</h3><ul><li>이더넷 : CSMA/CD</li><li>토큰링 : Token Passing</li><li>무선LAN : CSMA/CA</li><li>충돌에 대비하는 방법 :<ul><li>이더넷 : 소모 비용 감소</li><li>토큰링 : 충돌 감소</li><li>무선 LAN : 소모 비용 감소</li></ul></li><li>MAC Overhead : 토큰 방식은 오버헤드가 크다.</li></ul><h2 id=네트워크-어댑터>네트워크 어댑터</h2><ul><li>데이터 링크 기능이 구현되는 곳:<ul><li>프레이밍(Framing)</li><li>오류 검출(Error Detection)</li><li>매체 접근 제어(Media Access Control)</li></ul></li></ul><h3 id=호스트의-관점제어>호스트의 관점(제어)</h3><ul><li>상태 제어 레지스터 (Control Status Register) (CSR):<ul><li>특정 메모리 주소로 사용가능</li><li>CPU는 읽고 쓸 수 있음</li><li>CPU는 어댑터에게 명령</li><li>어댑터는 CPU에게 정보를 알려줌</li></ul></li></ul><h3 id=호스트와-어댑터-사이에서의-프레임데이터-이동>호스트와 어댑터 사이에서의 프레임(데이터) 이동</h3><ul><li>직접 메모리 접근(DMA)</li><li>프로그램 I/O (PIO)</li></ul><h1 id=3장-패킷스위칭packet-switching>3장 패킷스위칭(Packet Switching)</h1><h2 id=확장성-있는-네트워크scalable-networks>확장성 있는 네트워크(Scalable Networks)</h2><ul><li>교환기: 입력 포트에서 출력 포트로 패킷을 보냄. 출력 포트는 패킷 헤더의 목적지 주소에 기초해서 선택됨</li><li>지리적으로 광범위한 네트워크 구성 가능</li><li>많은 수의 호스트를 지원하는 네트워크 구성 가능</li><li>기존 호스트들의 성능에 영향을 주지 않고새로운 호스트를 추가 가능(스위치 용량의 한도내에서)</li></ul><h2 id=데이터그램-datagrams>데이터그램 (Datagrams)</h2><ul><li>연결 설정 단계가 없음</li><li>각각의 패킷은 독립적으로 포워드</li><li>우편 시스템과 유사한 형태</li><li>비연결성(connectionless) 모델</li><li>각 스위치는 포워딩(라우팅) 테이블을 유지</li></ul><h2 id=가상회선-스위칭virtual-circuit-switching>가상회선 스위칭(Virtual Circuit Switching)</h2><ul><li>명시적인 연결 설정 및 해지 과정</li><li>이어지는 패킷 역시 같은 경로를 따라 전달</li><li>전화와 유사한 형태</li><li>연결성(connection-oriented)모델이라고도 불림</li><li>각 스위치는 가상회선 테이블을 유지</li></ul><h2 id=가상회선-대-데이터그램>가상회선 대 데이터그램</h2><table><thead><tr><th></th><th>VC(가상회선)</th><th>DG(데이터그램)</th></tr></thead><tbody><tr><td>연결설정시간</td><td>일반적으로 첫번째 데이터를 보내기 전에 연결 설정을 위한 왕복 지연시간(RTT)을 기다려야함. (해당 가상 회선에 대한 테이블 entry) 생성</td><td>연결 설정을 위한 왕복 지연시간을 기다릴 필요가 없음; 호스트는 데이터가 준비가 되자마자 바로 보낼 수 있음</td></tr><tr><td>주소 오버헤드</td><td>연결 요청에는 목적지의 완전한 주소를 포함하지만, 데이터 패킷에는 작은 식별자(identifier)만 포함하면 되므로 패킷 헤더의 오버헤드가 작다.</td><td>매 패킷은 목적지의 완전한 주소를 가져야 하기 때문에, 패킷당 오버헤드가 연결성 모델보다 크다</td></tr><tr><td>패킷 포워딩 시간</td><td>간단한 VC-ID 테이블 검색 => 빠른 시간에 가능(HW 처리도 가능)</td><td>모든 주소에 대한 포워딩 테이블 검색 -> 늦어질 가능성 높음</td></tr><tr><td>장애극복</td><td>스위치/링크가 고장나거나 비정상적으로 연결이 끊어지면, 새로운 연결을 설정해야 함 -> stateful</td><td>패킷이 독립적으로 다루어지기 때문에 고장난 링크나 노드를 우회하여 라우팅 가능 -> stateless of soft state</td></tr><tr><td>자원 예약</td><td>연결 설정시 자원 예약이 가능</td><td>발신지 호스트는 네트워크가 패킷을 전달할 수 있는지, 또는 목적지 호스트가 동작 중인지도 알 수 없음</td></tr></tbody></table><h2 id=소스-라우팅source-routing>소스 라우팅(Source Routing)</h2><ul><li>주소는 발신지로부터 목적지까지 경로의 포트번호를 포함하고 있음</li></ul><h2 id=스위치-성능>스위치 성능</h2><ul><li>스위치는 범용 워크스테이션으로 만들 수 있다</li><li>총 대역폭(Aggregate bandwidth):<ul><li>I/O 버스 대역폭의 1/2</li><li>용량은 스위치에 연결된 모든 호스트에서 공유됨</li><li>예: 800Mbps 버스는 100Mbps 포트 4개를 지원할 수 있음</li></ul></li><li>초당 처리할 수 있는 패킷 수:<ul><li>스위치의 패킷 처리 능력:<ul><li>pps(packet per second)</li></ul></li><li>초당 15,000 - 100,000 패킷 정도</li><li>예: 64-byte 패킷이라면:<ul><li>7.69-51.2Mbps을 의미함</li></ul></li><li>작은 패킷을 스위치하는 경우 성능 결정 요소</li></ul></li></ul><h2 id=브리지-및-확장-lan-bridges-and-extended-lans>브리지 및 확장 LAN (Bridges and Extended LANs)</h2><ul><li>LAN의 물리적인 제한 + 트래픽 분리</li><li>두개 또는 그 이상의 LAN들을 repeater/bridge를 이용하여 연결</li><li>브리지에 의해서 연결된 LAN의 집합을 extended LAN(확장 LAN0이라고 함)</li><li>확장 LAN이 보편화:<ul><li>(LAN, extended LAN) => (LAN segment, LAN)</li></ul></li></ul><h3 id=브리지bridge의-동작>브리지(Bridge)의 동작</h3><ul><li>동작: 수신(Accept) 및 포워딩(forward) : 스위치 => 필터링(filtering); 리피터와 차이</li><li>여러 개의 포트를 가지는 브리지 => LAN 스위치</li><li>Level-2 (패킷 헤더를 붙이지 않음); (라우터와의 큰 차이점)</li></ul><h3 id=계층-2level-2-연결>계층-2(Level-2) 연결</h3><ul><li>브리지는 네트워크 주소를 갖지 않음:<ul><li>또, 별도의 헤더도 붙이지 않음</li><li>네트워크 계층에서 보면, 브리지는 invisible; 즉, link component</li><li>따라서, 브리지로 연결된 (확장)LAN 은 하나의 네트워크</li></ul></li></ul><h3 id=학습-브리지learning-bridges>학습 브리지(Learning Bridges)</h3><ul><li>불필요할 때는 포워드를 하지 않음</li><li>포워딩 테이블의 유지</li><li>발신지 주소에 기초해서 테이블의 엔트리를 작성</li><li>표는 성능 개선이 목적이므로 완벽할 필요 없다.</li><li>브로드캐스트 프레임은 항상 포워드</li><li>Soft-state table</li></ul><h3 id=switching-hub-traffic-isolation>Switching Hub: traffic isolation</h3><ul><li>switch installation breaks subnet into LAN segments</li><li>switch filter packets:<ul><li>same-LAN-segment frames not usually forwarded onto other LAN segments</li><li>segments become separate collision domains</li></ul></li></ul><h3 id=브리지lan-스위치의-한계>브리지/LAN 스위치의 한계</h3><ul><li>확장성이 없음:<ul><li>스패닝 트리 알고리즘은 확장성이 부족함</li><li>브로드캐스팅도 확장성에 제약</li><li>=> VLAN (Virtual LAN)</li></ul></li><li>이질성(heterogenity)을 허용하지 않음</li><li>투명성에 주의; 즉, 노드에서 브리지는 보이지 않음</li></ul><h2 id=셀스위칭-cell-switching-atm>셀스위칭 (Cell Switching): ATM</h2><h3 id=개요>개요</h3><ul><li>ATM(비동기 전송 모드)</li><li>전화회사가 만든 패킷스위칭 네트워크 (극단적인 연결성 패킷 스위치)</li><li>작은 고정길이 패킷:<ul><li>cell이라고도 함 : 5-byte 헤더 + 48-byte 페이로드</li></ul></li><li>Signalling(연결 설정) 프로토콜 : Q.2931</li><li>한때, WAN과 LAN 환경에서 모두 사용 : 인터넷 대체 추진</li><li>현재 LAN에서는 Switching Ethernet에 의해 퇴출</li><li>보통 광케이블을 사용하는 장거리 연결에 사용:<ul><li>SONET interface 카드를 이용</li></ul></li><li>현재는 인터넷의 아래 계층, 즉 이더넷 수준의 역할을 수행</li></ul><h3 id=cells>Cells</h3><ul><li>가변길이 대 고정 길이:<ul><li>최적의 고정길이는 없음:<ul><li>작다면 데이터에 비해 헤더가 차지하는 오버헤드가 크다</li><li>크다면 작은 메시지에 대해서 효율이 낮다.</li></ul></li><li>고정 길이는 하드웨어로 스위치하는 것이 쉽다:<ul><li>보다 간단함</li><li>병렬 처리가 가능</li></ul></li></ul></li><li>작은 길이가 큐잉을 개선:<ul><li>링크를 스케쥴링하는데 보다 세밀한 선점(preemption)이 가능</li></ul></li><li>즉시 전달과 유사하게 동작</li></ul><h3 id=atm-셀>ATM 셀</h3><ul><li>패킷화에 소요되는 시간(packetizing delay) : 가장 중요한 cell size 선택 이유</li><li>셀로 음성을 전송하는 경우:<ul><li>전화는 delay에 민감: 음성 전송에 소요되는 총 지연시간은 500ms 이하이어야 함</li><li>음성은 64Kbps로 디지탈 인코드를 함(8KHz를 8-bit로 샘플)</li><li>셀을 전송하기 전에 셀을 채울 만큼의 샘플이 필요</li></ul></li></ul><h3 id=셀-형식cell-format>셀 형식(Cell Format)</h3><ul><li>호스트와 스위치 사이의 형식(host-to-swtich format)</li><li>GFC : Generic Flow Control</li><li>VCI : Virtual Circuit Identifier</li><li>VPI : Virtual Path Identifier</li><li>Type</li><li>CLP : Cell Loss Priority</li><li>HEC : Header Error Check</li></ul><h1 id=4장-인터네트워킹internetworking>4장 인터네트워킹(Internetworking)</h1><h2 id=인터넷-서비스-모델>인터넷 서비스 모델</h2><ul><li>인터네트워크:<ul><li>네트워크의 연속</li><li>Concatenation of Networks</li></ul></li><li>네트워크 계층 위에서 표준화:<ul><li>다양한 네트워크들을 링크로 간주해서 그대로 사용</li><li>전역 주소 체계(Global Addressing Cheme) 필요</li></ul></li><li>프로토콜 스택</li></ul><h2 id=패킷-전달-서비스-모델>패킷 전달 서비스 모델</h2><ul><li>전역 주소 체계 (Global Addressing Scheme)</li><li>비연결성 (데이터그램-기반)</li><li>최선 노력 전달 (신뢰성 없는 서비스):<ul><li>패킷이 상실될 수 있음</li><li>패킷이 순서가 뒤바뀌어 올 수 있음</li><li>중복된 패킷이 올 수 있음</li><li>패킷이 오랜 시간 동안 지연될 수 있음</li></ul></li><li>단편화 및 재조립</li></ul><h2 id=ip-패킷-헤더-형식>IP 패킷 헤더 형식</h2><ul><li>버전 Version : 4bit</li><li>Hlen(4) : Header Length</li><li>TOS(8) : 서비스의 종류, 일반적으로 사용되지 않음</li><li>Length(16) : 데이터그램 전체의 바이트 단위 길이</li><li>Ident(16) : 단편화(fragmentation)에 사용됨</li><li>Flags/Offset(16) : 단편화에 사용됨</li><li>TTL(8) : 데이터그램이 최대로 방문할 수 있는 홉의 수</li><li>Protocol(8) : 역다중화키</li><li>Checksum(16) : 헤더의 체크섬</li><li>DestAddr & SrcAddr(32) : 발신지 및 목적지 주소</li></ul><h2 id=단편화와-재조립fragmenation-and-reassembly>단편화와 재조립(Fragmenation and Reassembly)</h2><ul><li>각 네트워크는 나름대로의 MTU(Maximum Transmission Unit)을 가진다.</li><li>방법:<ul><li>필요할 때만 분할(MTU &lt; Datagram)</li><li>발신지에서의 단편화는 지양 (cf. IPv6에서는 발신지에서 PathMTU)</li><li>재단편화(refragmentation) 가능</li><li>분할된 단편은 독립적인(self-contained) 데이터그램</li><li>목적지까지 재조립을 미룸</li><li>상실된 단편이 있으면 재조립 불가능</li></ul></li></ul><h2 id=전역-주소global-addresses>전역 주소(Global Addresses)</h2><ul><li>특성:<ul><li>전역적으로 유일하다</li><li>계층적(hierarchical): 네트워크 + 호스트:<ul><li>같은 네트워크에 있는 노드들의 네트워크 주소부분은 같아야한다.</li></ul></li></ul></li><li>Class:<ul><li>A class : 0으로 시작, 초기 0을 제외 7비트가 네트워크 주소 (나머지 24 비트가 호스트부)</li><li>B class : 10으로 시작, 초기 10을 제외한 14비트가 네트워크 주소 (나머지 16비트가 호스트부)</li><li>C class : 110으로 시작, 초기 110을 제외한 21비트가 네트워크 주소(나머지 8비트가 호스트부)</li></ul></li></ul><h2 id=데이터그램-포워딩--ip의-실제-동작>데이터그램 포워딩 : IP의 실제 동작</h2><ul><li>방법:<ul><li>모든 데이터그램은 목적지의 주소를 포함한다.</li><li>데이터그램을 받은 IP는:<ul><li>목적지 네트워크가 직접 연결되어 있다면, 호스트로 직접 포워드 함.</li><li>목적지 네트워크가 직접 연결되어 있지 않다면, 다른 라우터에게 포워드함</li></ul></li><li>포워딩 테이블은 네트워크 번호에 대한 다음 홉을 가리키고 있다.</li><li>각 호스트는 디폴트 라우터를 가지고 있다.</li><li>각 라우터는 포워딩 테이블을 유지</li></ul></li></ul><h2 id=주소-번역address-translation>주소 번역(Address Translation)</h2><ul><li>인터네트는 논리적(가상) 네트워크:<ul><li>계층 하위에 있는 물리적 네트워크/링크에게 전달을 위임</li></ul></li><li>위임할 때, IP 주소를 해당 물리적(physical) 주소로 변환해야 함.</li><li>필요한 주소를 어떻게 알아내는가?:<ul><li>테이블 기반(IPv4)</li><li>IP 주소의 호스트 부분에 물리적 주소를 인코드 시켜서 넣어줌(IPv6)</li></ul></li><li>ARP(Address Resolution Protocol):<ul><li>IP주소와 물리적 주소가 바인딩되어 있는 테이블 구축 담당</li><li>IP주소가 테이블에 없다면 요청을 브로드캐스트</li><li>해당 호스트는 자신의 물리적 주소를 보내줌</li><li>오랫동안 사용되지 않은 엔트리는 없애준다.</li><li>프로토콜 계층에서 2계층과 3계층 사이에 존재한다.</li></ul></li></ul><h3 id=arp-프로토콜>ARP 프로토콜</h3><ul><li>Request format:<ul><li>HardwareType, ProtocolType, HLEN & PLEN, Operation, Source/Target Physcial/Protocol Addresses</li></ul></li><li>특징:<ul><li>테이블의 엔트리는 약 10분의 타임아웃</li><li>요청에 대한 목적지에서는 발신지 주소로 테이블을 갱신</li><li>엔트리가 이미 있다면 테이블을 갱신(+ 타임아웃 연장)</li></ul></li></ul><h2 id=호스트-구성configuration--dhcp>호스트 구성(Configuration) : DHCP</h2><ul><li>IP 주소 배정의 문제:<ul><li>IP 주소는 네트워크의 구조를 반영하여야함</li><li>즉, 같은 네트워크에 있는 다른 호스트들의 주소와 앞 부분이 같아야한다.</li></ul></li><li>IP주소 이외에도 구성 정보가 필요하다(default router, name server)</li><li>자동 구성 기능 필요 : DHCP(Dynamic Host Configuration Protocol)</li></ul><h3 id=dhcp-동작>DHCP 동작</h3><ul><li>DHCP 서버:<ul><li>a pool of available address를 관리</li><li>클라이언트의 요청에 대해 구성 정보를 제공</li><li>address lease도 가능</li></ul></li><li>DHCP relay:<ul><li>구성 정보 요청을 서버로 relay</li></ul></li><li>Server discovery:<ul><li>DHCPDISCOVER 메시지를 브로드케스트</li></ul></li></ul><h2 id=공유기>공유기</h2><ul><li>하나의 인터넷 주소를 여러 호스트가 공유해서 사용한다는 말에서 유래</li><li>대부분 wireless router 기능을 포함한다.</li><li>인터넷 서비스 업체(ISP)는 인터넷 링크 연결을 제공하면서, 하나의 IP주소를 DHCP로 할당</li><li>공유기는 내부 LAN의 여러 호스트들에게 인터넷 접근을 제공:<ul><li>IP 패킷을 내외부로 전달: IP라우터</li><li>LAN 내부에서 사설 IP 주소 사용 지원 : DHCP 서버</li><li>하나의 IP주소를 여러 호스트가 사용: NAT(Network Address Translation)</li><li>유선 LAN 지원 : switch</li><li>무선 LAN 지원 : AP(Access Point)</li><li>보안 지원 : firewall(방화벽)</li></ul></li></ul><h2 id=icmpinternet-control-message-protocol>ICMP(Internet Control Message Protocol)</h2><ul><li>IP 동작을 보조하기 위한 제어 프로토콜:<ul><li>IP 자체에 포함시키지 않고, 별도의 프로토콜 (out-of-band 기법)</li></ul></li><li>기능 면에서 보며,ㄴ IP의 동료(companion protocol)</li><li>힌트 수준: 반드시 필요하지는 않음 => IP로 전송</li><li>제어 작업 내용:<ul><li>응답(echo) - ping</li><li>라우터의 변경(라우터에서 발신지로)</li><li>목적지에 도착하는 것이 불가능:<ul><li>프로토콜, 포트, 호스트 등의 이유</li></ul></li><li>TTL을 초과한 경우:<ul><li>데이터그램이 계속 네트워크 배회하는 일이 없음</li></ul></li><li>체크섬이 실패한 경우</li><li>재조립을 실패한 경우</li><li>단편화를 할 수 없는 경우</li></ul></li></ul><h2 id=가상-네트워크virtual-networks>가상 네트워크(Virtual Networks)</h2><ul><li>실제의 물리적 연결과 독립적으로 연결/구축되는 네트워크:<ul><li>물리적 네트워크 위에 떠있는 가상의 네트워크</li></ul></li><li>VPN(Virtual Pivate Networks):<ul><li>전용선 대신 공용 네트워크를 이용하여 사설망 구축</li><li>IP 망을 통한 사설망 구축:<ul><li>IP는 모든 노드가 서로 통신; connectivity 제어가 안됨</li><li>IP 터널링 기법</li></ul></li></ul></li></ul><h2 id=ip-터널링ip-tunneling>IP 터널링(IP Tunneling)</h2><ul><li>임의의 네트워크 사이에 두고 있는 한쌍의 노드 사이를 연결하는 점대점 링크</li><li>즉, 라우터 간의 가상 링크(virtual link)</li><li>구현:<ul><li>링크 양 끝 노드를 발신지/목적지로 하여 IP encapsulation</li></ul></li></ul><h2 id=터널링가상-네트워크-사용이유>터널링/가상 네트워크 사용이유</h2><ul><li>보안:<ul><li>공용 네트워크 안에서 사설 링크 구현</li><li>암호화와 함께 사용 가능</li></ul></li><li>특수 기능 구현:<ul><li>특수 기능을 가지는 가상 네트워크 구현</li><li>ex) 멀티캐스트 라우팅 기능을 가지는 라우터들의 네트워크 구축</li></ul></li><li>비 IP 패킷의 IP망을 통한 전달:<ul><li>ex) IPv6 패킷의 전달</li></ul></li></ul><h2 id=확장성-문제scalability-issues>확장성 문제(Scalability Issues)</h2><ul><li>Flat vs hierarchical address</li><li>IP는 주소를 계층화하여 중간 라우터에서는 호스트 주소를 알 필요 없이 설계 되었으나 다음과 같은 문제가 발생한다:<ul><li>주소 공간의 비효율성:<ul><li>예 : 두 개의 호스트만을 가진 C클래스 네트워크</li></ul></li><li>너무 많은 수의 네트워크 개수:<ul><li>오늘날 인터넷은 수만개의 네트워크를 가지고 있다.</li><li>라우팅 테이블의 크기에 확장성 문제가 발생하며, 이는 라우트 전달 프로토콜에서도 발생한다.</li></ul></li></ul></li></ul><h3 id=서브네팅subnetting>서브네팅(Subnetting)</h3><ul><li>주소/라우팅 계층 구조에 따른 다른 단계를 추가시키는 기능</li><li>서브넷 마스크(subnet mask)는 클래스의 가변적인 분할을 정의한다.</li><li>IP 주소에서 네트워크 주소를 떼어내는 방법이 변경되었다.:<ul><li>과거에는 IP의 초기 비트를 기준으로 네트워크 주소를 분리하였지만, 이제는 비트마스킹을 통해 처리한다.</li></ul></li><li>서브넷은 외부네트워크에서 보이지 않는다.</li></ul><h3 id=포워딩-알고리즘>포워딩 알고리즘</h3><ul><li>특징:<ul><li>대응되는 것을 찾을 수 없다면 디폴트 라우터를 사용</li><li>서브넷 마스크에서 모든 1이 연속적일 필요는 없음</li><li>하나의 물리적인 네트워크에 여러 개의 서브넷이 존재할 수 있음</li><li>서브넷은 인터넷의 나머지 부분에서 보이지 않음</li></ul></li></ul><h2 id=classless-라우팅cidr>Classless 라우팅(CIDR)</h2><ul><li><p>수퍼넷팅(Supernetting), CIDR(Classless Inter-Domain Routing)</p></li><li><p>기본적으로, 기존 A,B,C class와 무관하게 필요한 만큼 할당</p></li><li><p>단, 지역적으로 가까운 네트워크에 대해서 연속적이 네트워크 번호 묶음을 할당</p></li><li><p>각 묶음(block)은 다음과 같은 쌍으로 표현 (first_network_address, count)</p></li><li><p>현실적으로, 묶음(블록) 크기는 2의 제곱 형태로 제한:</p><ul><li>블록 사이즈를 알아내기 위해서 비트마스크를 사용(CIDR mask) => prefix 길이로 표현 가능</li></ul></li><li><p>결론: prefix 길이로 어느 자리에서나 네트워크 주소 경계를 정의</p></li><li><p>Classless 라우팅 : Aggregation (병합)</p></li></ul><h2 id=차세대-ip-next-generation-ipipv6>차세대 IP (Next Generation IP(IPv6))</h2><ul><li>주요 기능:<ul><li>128-bit 주소</li><li>멀티캐스트</li><li>실시간 서비스(Real-time service) 대비</li><li>인증 및 보안 (Authentication and security)</li><li>자동 구성 (Autoconfiguration)</li><li>종단간 단편화(End-to-end fragmentation)</li><li>프로토콜 확장</li></ul></li></ul><h3 id=ipv6-주소>IPv6 주소</h3><ul><li>Classless 주소/라우팅(CIDR과 유사)</li><li>표기법:<ul><li>연속적인 0은 압축됨</li><li>IPv6은 IPv4 주소와 호환 가능</li></ul></li><li>주소 할당(네트워크 제공자 기반):<ul><li>Aggregatable Global Unicast Addressing</li><li>Subnet / Classless 개념 모두 도입</li></ul></li></ul><h3 id=ipv6-헤더>IPv6 헤더</h3><ul><li>40-바이트 기본 헤더</li><li>확장 헤더:<ul><li>고정된 순서, 대부분 고정 길이</li><li>단편화(fragmenation)</li><li>소스 라우팅</li><li>인증 및 보안</li></ul></li><li>flow:<ul><li>같은 수준의 서비스로 처리되어야하는 패킷의 연속(sequence of packets)</li></ul></li><li>FlowLabel: 단순 식별자</li></ul><h3 id=ip-nextheader>IP NextHeader</h3><ul><li>상위 프로토콜 DemuxKey</li><li>optional header 유무/종료 표시 및 payload 시작점 표시</li></ul><h2 id=이통-호스트에-대한-라우팅>이통 호스트에 대한 라우팅</h2><ul><li>문제:<ul><li>IP 주소는 계층적; 주소에 네트워크 주소 부분 포함</li><li>호스트가 이동하여 다른 네트워크에 접속되면, 패킷 전달 불가능</li></ul></li><li>접근 방법:<ul><li>새 IP 주소 할당 => 통신 중단; 서비스 중단</li><li>Mobile IP:<ul><li>호스트의 이동이 투명하도록</li><li>기존 통신 소프트웨어 및 라우터에 변경 없이 이동 호스트 지원</li></ul></li></ul></li></ul><h2 id=mobile-ip>Mobile IP</h2><ul><li>구성 요소:<ul><li>home address : 이동 호스트의 영구적인 IP 주소</li><li>Home Agent(HA) : 이동 호스트의 홈 네트워크에 있는 라우터</li><li>Foreign Agent(FA) : 이동 호스트가 접속되어 있는 외부 네트워크의 라우터</li><li>care-of-address(COA) : 이동 호스트에 대한 패킷을 보낼 주소; 대개 FA 주소</li></ul></li><li>구성 설정:<ol><li>HA와 FA는 주기적으로 자신의 존재를 홍보</li><li>이동 호스트는 HA의 주소 인식</li><li>이동 호스트가 어떤 외부 네트워크에 접속하면 => FA 인식; HA의 주소를 알림</li><li>FA는 HA에게 care-of-address 통보</li></ol></li></ul><h3 id=mobile-ip의-패킷-전달>Mobile IP의 패킷 전달</h3><ul><li>이동 호스트에서 송신하는 패킷의 전달:<ul><li>IP 패킷 포워딩 과정에서 source address는 참조되는 않음.</li><li>따라서, 기존과 동일(보안, 멀티캐스트 제외)</li></ul></li><li>이동 호스트로의 패킷 전달</li></ul><h3 id=세부-문제기술>세부 문제/기술</h3><ul><li>HA가 이동호스트로 향하는 패킷을 가로채는 방법: Proxy ARP</li><li>HA가 이동호스트로의 패킷을 FA에게 보내는 방법: 터널링</li><li>FA가 수신된 패킷을 이동호스트로 전달하는 방법 : IP 포워딩을 사용하지 않고, Hardware 주소로 직접</li><li>FA와 이동호스트가 동일한 경우 (Collocated COA):<ul><li>FA가 없는 네트워크로 이동 등</li><li>처리 간단; 단, 동적으로 IP 주소를 배정 받을 수 있어야 함.</li></ul></li><li>보안 문제:<ul><li>제3자가 FA를 자처하며, 이동호스트로의 패킷을 interception</li></ul></li></ul><h3 id=경로-최적화>경로 최적화</h3><ul><li>triangle routing problem</li><li>HA가 송신자에게:<ul><li>binding update 메시지를 보내서</li><li>이동호스트의 care-of-address를 알려줌</li></ul></li><li>송신자는:<ul><li>Binding cache를 유지하면서</li><li>FA로 직접 터널링</li></ul></li></ul></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/sidebar.js></script><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>