<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://unpkg.com/simpledotcss/simple.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>2022-1 정보보호이론 |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>2022-1 정보보호이론</div></header><main><article class=main><div class=title><h1 class=title-header>2022-1 정보보호이론</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/lectures/information_security_theory.md><h5>created : Mon, 18 Apr 2022 08:59:34 +0900</h5><h5>modified : Tue, 14 Jun 2022 02:49:32 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
[[lectures]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i>
<a href=/tags/lectures class=tag-btn>lectures</a></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#chapter-1-introduction>Chapter 1 Introduction</a><ul><li><a href=#11-security-goals>1.1. Security goals</a></li><li><a href=#12-attacks>1.2 Attacks</a></li><li><a href=#13-services-and-mechanisms>1.3. Services and Mechanisms</a></li></ul></li><li><a href=#chapter-2-mathematics-of-cryptography>Chapter 2. Mathematics of Cryptography</a><ul><li><a href=#21-integer-arithmetic>2.1 Integer Arithmetic</a></li><li><a href=#22-modular-arithmetic>2.2. Modular Arithmetic</a></li></ul></li><li><a href=#chapter-3-traidtional-symmetric-key-ciphers>Chapter 3. Traidtional Symmetric-Key Ciphers</a><ul><li><a href=#31-introduction>3.1. Introduction</a></li><li><a href=#32-substitution-ciphers-대치암호>3.2. Substitution ciphers (대치암호)</a></li><li><a href=#33-transposition-ciphers-치환-암호>3.3. Transposition Ciphers (치환 암호)</a></li><li><a href=#34-stream-and-block-ciphers>3.4. Stream and block ciphers</a></li></ul></li><li><a href=#chapter-6-data-encryption-standard-des>Chapter 6. Data Encryption Standard (DES)</a><ul><li><a href=#61-introduction>6.1. Introduction</a></li><li><a href=#62-des-structure>6.2. DES structure</a></li><li><a href=#63-des-analysis>6.3 DES Analysis</a></li><li><a href=#64-multiple-des>6.4 Multiple DES</a></li><li><a href=#65-security-of-des>6.5. Security of DES</a></li></ul></li><li><a href=#chapter-4-mathematics-of-cryptography>Chapter 4. Mathematics of Cryptography</a><ul><li><a href=#41-algebraic-strucutres>4.1. Algebraic strucutres</a></li><li><a href=#42-gf2n-fields>4.2. $GF(2^n)$ Fields</a></li></ul></li><li><a href=#chapter-7-advanced-encryption-standard-aes>Chapter 7. Advanced Encryption Standard (AES)</a><ul><li><a href=#71-introduction>7.1. Introduction</a></li><li><a href=#72-transformations>7.2. Transformations</a></li><li><a href=#73-key-expansion>7.3. Key Expansion</a></li><li><a href=#74-ciphers>7.4. Ciphers</a></li></ul></li><li><a href=#chapter-9-mathematics-of-cryptography>Chapter 9. Mathematics of Cryptography</a><ul><li><a href=#91-primes>9.1. Primes</a></li><li><a href=#92-primality-testing>9.2. Primality Testing</a></li><li><a href=#93-factorization>9.3. Factorization</a></li><li><a href=#96-exponentiation-and-logarithm>9.6. Exponentiation and Logarithm</a></li></ul></li><li><a href=#chapter-10-asymmetric-key-public-key-cryptography>Chapter 10. Asymmetric-Key (Public-Key) Cryptography</a><ul><li><a href=#101-introduction>10.1 Introduction</a></li><li><a href=#102-rsa-cryptosystem>10.2. RSA Cryptosystem</a></li><li><a href=#104-elgamal-cryptosystem>10.4. ElGamal Cryptosystem</a></li><li><a href=#105-elliptic-curve-cryptosystems>10.5. Elliptic Curve Cryptosystems</a></li></ul></li><li><a href=#chapter-11-message-integrity-and-message-authentication>Chapter 11. Message Integrity and Message Authentication</a><ul><li><a href=#111-message-integrity>11.1 Message Integrity</a></li><li><a href=#112-random-oracle-model>11.2. Random Oracle Model</a></li><li><a href=#113-message-authentication>11.3 Message Authentication</a></li></ul></li><li><a href=#chapter-12-cryptographic-hash-functions>Chapter 12. Cryptographic Hash Functions</a><ul><li><a href=#121-introduction>12.1 Introduction</a></li><li><a href=#122-sha-512>12.2 SHA-512</a></li></ul></li><li><a href=#chapter-13-digital-signature>Chapter 13. Digital Signature</a><ul><li><a href=#131-comparision>13.1. Comparision</a></li><li><a href=#132-process>13.2. Process</a></li><li><a href=#133-services>13.3 Services</a></li><li><a href=#135-digitial-signature-schemes>13.5. Digitial Signature Schemes</a></li><li><a href=#136-variations-and-application>13.6. Variations and Application</a></li></ul></li><li><a href=#chapter-14-entity-authentication>Chapter 14. Entity Authentication</a><ul><li><a href=#141-introduction>14.1. Introduction</a></li><li><a href=#142-passwords>14.2. Passwords</a></li><li><a href=#143-challenge-response>14.3. Challenge-Response</a></li><li><a href=#144-zero-knowledge>14.4. Zero-Knowledge</a></li></ul></li></ul></nav></aside><div class=content><h2 id=chapter-1-introduction>Chapter 1 Introduction</h2><h3 id=11-security-goals>1.1. Security goals</h3><ul><li>Confidentiality : 기밀성, 비밀성:<ul><li>most common aspect of information security</li><li>protect our confidential information</li><li>guard aginst those malicious actions that endanger the confidentiality of the information</li></ul></li><li>Integrity: 무결성:<ul><li>information needs to be changed constantly</li><li>changes need to be done only by authorized entities and through authorized mechanisms</li></ul></li><li>Availability: 가용성:<ul><li>information needs to be available to authorized entities</li></ul></li></ul><h3 id=12-attacks>1.2 Attacks</h3><ul><li>Attacks Threatening Confidentiality:<ul><li>Snooping: unauthorized access to or interception of data. 도청, 엿보기</li><li>Traffic analysis: to obtain some other type of information by monitoring. 통신량 분석</li></ul></li><li>Attacks Threatening Integrity:<ul><li>Modification: attacker intercepts the message and changes it. Insertion, deletion attack 변조</li><li>Masquerading or spoofing: attacker impersonates somebody else. 신원(명의)도용</li><li>Replaying: attacker obtains a copy of a message sent by a user and later tries to replay it. 다시 사용하기</li><li>Repudiation: 부인, 부정:<ul><li>sender of a message denies that she has sent it.</li><li>receiver of a message denies that he has received it</li></ul></li></ul></li><li>Attacks Threatening Availability:<ul><li>Denial of service (DoS): slows down or totally interrupts the service of a system.</li></ul></li></ul><h3 id=13-services-and-mechanisms>1.3. Services and Mechanisms</h3><ul><li>ITU-T(International Telecommunication Union:Telecommunication Standardization Sector, 국제전기통신연합) provides some security services and seom mechanisms to implement those services. Security services and mechanisms are closely related because a mechanism or combination of mechanisms are used to provide a service.</li></ul><h4 id=131-security-services>1.3.1. Security Services</h4><ul><li>Data confidentiality: 메시지 전체 혹은 일부에 대한 기밀성을 유지하는 수단</li><li>Data integirty: modification, insertion, deletion 예방하는 수단</li><li>Authentication: peer entity 인증, data origin 인증하는 수단</li><li>Nonrepudiation: proof of origin, proof of delivery 보장하는 수단</li><li>Access control: unauthorized access 방지하는 수단</li></ul><h2 id=chapter-2-mathematics-of-cryptography>Chapter 2. Mathematics of Cryptography</h2><h3 id=21-integer-arithmetic>2.1 Integer Arithmetic</h3><ul><li>In integer arithmetic, we use a set and a few operations. You are familiar with this set and the corresponding operations, but they are reviewed here to create a background for modular arithmetic.</li></ul><h4 id=211-set-of-integers>2.1.1. Set of Integers</h4><ul><li>The set of integers, denoted by $Z$, contains all integral numbers (with no fraction) from negative infinity to positive infinity</li><li>$$Z = {&mldr;, -2, -1, 0, 1, 2, &mldr;}$$</li></ul><h4 id=212-binary-operations>2.1.2. Binary Operations</h4><ul><li>In cryptography, we are interesed in three binary operations applied to the set of integers. A binary operation takes two inputs and creates one output.</li></ul><h4 id=213-integer-division>2.1.3. Integer Division</h4><ul><li>In integer arithmetic, if we divide $a$ by $n$ ($a/n$), we can get $q$ and $r$. The relationship between these four integers can be shown as</li><li>$$a = q \times n + r$$</li><li>$n$ : positive</li><li>$r$ : nonnegative</li></ul><h4 id=214-divisbility>2.1.4. Divisbility</h4><ul><li><p>If $a$ is not zero and we let $r=0$ in the division relation, we get</p></li><li><p>$$a = q \times n$$</p></li><li><p>If the remainder is zero, $n \mid a$ (n divides a)</p></li><li><p>If the remainder is not zero, $n \not \mid a$ (n does not divide a)</p></li><li><p>Properties:</p><ul><li>Property 1 : if $a \mid 1$, then $a = \pm 1$</li><li>Property 2 : if $a \mid b$ and $b \mid a$, then $a = \pm b$</li><li>Property 3 : if $a \mid b$ and $b \mid c$, then $a \mid c$.</li><li>Property 4 : if $a \mid b$ and $a \mid c$, then $a \mid (m \times b + n \times c)$, where $m$ and $n$ are arbitrary integers</li></ul></li><li><p>Facts 양의 양수만을 고려하였을때:</p><ul><li>The integer 1 has only one divisor, itself.</li><li>Any positive integer has at least two divisors, 1 and itself(but if can have more).</li></ul></li><li><p>GCD(Greatest Common Divisor):</p><ul><li>The greatest common divisor of two positive integers is the largest integer that can divide both integers.</li></ul></li><li><p>Euclidean Algorithm:</p><ul><li>Fact 1. $gcd(a, 0) = a$</li><li>Fact 2. $gcd(a, b) = gcd(b, a % b), \text{ for } a \ge b > 0$.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=r_1%20%3c-%20a;%20r_2%20%3c-%20b;%20%28initialization%29%0awhile%20%28r_2%20%3e%200%29%0a%7b%0a%20%20q%20%3c-%20r_1%20/%20r_2;%0a%20%20r%20%3c-%20r_1%20-%20q%20*%20r_2;%0a%20%20r_1%20%3c-%20r_2;%20r_2%20%3c-%20r;%0a%7d%0agcd%28a,%20b%29%20%3c-%20r_1>
<i class="bi bi-copy"></i></button></div><pre><code>r_1 &lt;- a; r_2 &lt;- b; (initialization)
while (r_2 &gt; 0)
{
  q &lt;- r_1 / r_2;
  r &lt;- r_1 - q * r_2;
  r_1 &lt;- r_2; r_2 &lt;- r;
}
gcd(a, b) &lt;- r_1</code></pre></div></li><li><p>Extended Euclidean Algorithm:</p><ul><li>Given two integers $a$ and $b$, we often need to find other two integers, $s$ and $t$, such that</li><li>$$s \times a + t \times b = gcd(a, b)$$</li><li>The extended Eculidean algorithm can calculate the $gcd(a, b)$ and at the same time calculate the value of $s$ and $t$.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=r_1%20%3c-%20a;%20r_2%20%3c-%20b;%0as_1%20%3c-%201;%20s_2%20%3c-%200;%0at_1%20%3c-%200;%20t_2%20%3c-%201;%0awhile%20%28r_2%20%3e%200%29%0a%7b%0a%20%20q%20%3c-%20r_1%20/%20r_2;%0a%20%20r%20%3c-%20r_1%20-%20q%20*%20r_2;%0a%20%20r_1%20%3c-%20r_2;%20r_2%20%3c-%20r;%0a%0a%20%20s%20%3c-%20s_1%20-%20q%20*%20s_2;%0a%20%20s_1%20%3c-%20s_2;%20s_2%20%3c-%20s;%0a%0a%20%20t%20%3c-%20t_1%20-%20q%20*%20t_2;%0a%20%20t_1%20%3c-%20t_2;%20t_2%20%3c-%20t;%0a%7d%0agcd%28a,%20b%29%20%3c-%20r_1;%20s%20%3c-%20s_1;%20t%20%3c-%20t_1;>
<i class="bi bi-copy"></i></button></div><pre><code>r_1 &lt;- a; r_2 &lt;- b;
s_1 &lt;- 1; s_2 &lt;- 0;
t_1 &lt;- 0; t_2 &lt;- 1;
while (r_2 &gt; 0)
{
  q &lt;- r_1 / r_2;
  r &lt;- r_1 - q * r_2;
  r_1 &lt;- r_2; r_2 &lt;- r;

  s &lt;- s_1 - q * s_2;
  s_1 &lt;- s_2; s_2 &lt;- s;

  t &lt;- t_1 - q * t_2;
  t_1 &lt;- t_2; t_2 &lt;- t;
}
gcd(a, b) &lt;- r_1; s &lt;- s_1; t &lt;- t_1;</code></pre></div></li></ul><h3 id=22-modular-arithmetic>2.2. Modular Arithmetic</h3><ul><li>The division relationship ($a=q \times n + r$) discussed in the previous section has two inputs ($a$ and $n$) and two outputs ($q$ and $r$). In modular arithmetic, we are intereseted in only one of the outputs, the remainder $r$.</li></ul><h4 id=221-modulo-operator>2.2.1. Modulo Operator</h4><ul><li>The modulo operator is shown as mod. THe second input($n$) is called the modulus. The output $r$ is called the residue</li></ul><h4 id=223-congruence>2.2.3. Congruence</h4><ul><li>To show that two integers are congruent, we use the congruence operator ($\equiv$):<ul><li>$2 \equiv 12 (\text{ mod } 10)$</li></ul></li></ul><h4 id=224-operation-in-z_n>2.2.4. Operation in $Z_n$</h4><ul><li>The three binary operations that we discussed for the set $Z$ can also be defined for the set $Z_n$. The result may need to be mapped to $Z_n$ using the mod operator.</li><li>$$Z_n = { 0, 1, 2, &mldr;, (n-1)}$$</li><li>Properties:<ul><li>Property 1 : $(a + b) \text{ mod } n = [(a \text{ mod } n) + (b \text{ mod } n)] \text{ mod } n$</li><li>Property 2 : $(a - b) \text{ mod } n = [(a \text{ mod } n) - (b \text{ mod } n)] \text{ mod } n$</li><li>Property 3 : $(a \times b) \text{ mod } n = [(a \text{ mod } n) \times (b \text{ mod } n)] \text{ mod } n$</li></ul></li></ul><h4 id=225-inverses>2.2.5. Inverses</h4><ul><li>Additive Inverse:<ul><li>In $Z_n$, two numbers $a$ and $b$ are the additive inverse of each other if<ul><li>$$(a + b) \text{ mod } n = 0$$</li></ul></li></ul></li><li>Multiplicative Inverse:<ul><li>In $Z_n$, two numbers $a$ and $b$ are the multiplicative inverse of each other if<ul><li>$$(a * b) \text{ mod } n = 1$$</li></ul></li><li>An integer $b$ in $Z_n$ has a multiplicative inverse:<ul><li>if and only if $gcd(n, b) = 1$</li><li>n과 b가 서로소(n and b are relatively prime)</li></ul></li></ul></li></ul><h4 id=226-additive-and-multiplication-tables>2.2.6. Additive and Multiplication Tables</h4><h4 id=227-different-sets>2.2.7. Different Sets</h4><ul><li>We need to use $Z_n$ when additive inverses are needed; we need to use $Z_n^*$</li></ul><h4 id=228-two-more-sets>2.2.8. Two More sets</h4><ul><li>Cryptography often uses two more sets: $Z_p$ and $Z_p^*$. p is a prime number</li><li>$$Z_p = Z_p^* \cup { 0 }$$</li></ul><h2 id=chapter-3-traidtional-symmetric-key-ciphers>Chapter 3. Traidtional Symmetric-Key Ciphers</h2><h3 id=31-introduction>3.1. Introduction</h3><h4 id=311-kerckhoffs-principle>3.1.1. Kerckhoff&rsquo;s Principle</h4><ul><li>Based on Kerckhoff&rsquo;s principle, one should always assume that the adversary, Eve, knows the encryption/decryption algorith. The reisistance of the cipher to attack must be based only one the secrecy of the key.</li><li>Shanon : The enemy knows the system.</li></ul><h4 id=312-cryptanalysis>3.1.2. Cryptanalysis</h4><ul><li>As cryptography is the science and art of creating secret codes, Cryptanalysis is the science and art of breaking those codes.</li></ul><h3 id=32-substitution-ciphers-대치암호>3.2. Substitution ciphers (대치암호)</h3><ul><li>A substitution cipher replaces one symbol with another. Subsitution ciphers can be categorized as either monoalphabetic ciphers or polyalphabetic ciphers.</li></ul><h4 id=321-monoalphabetic-ciphers>3.2.1. Monoalphabetic Ciphers</h4><ul><li>In monoalphabetic substitution, the relationship between a symbol in the plaintext to a symbol in the ciphertext is always one-to-one.</li><li>Additive Cipher(= Caesar cipher) 덧셈 암호:<ul><li>The simplest monoalphabetic cipher is the additive cipher. This cipher is sometimes called a shift cipher and sometimes a Caesar cipher, but the term additive cipher better reveals it mathematical nature.</li><li>$$C = (P + k) \text{ mod } 26$$</li><li>$$P = (C - k) \text{ mod } 26$$</li><li>Historically, additive ciphers are called shift ciphers. Julius Caesar used an additive cipher to communicate with his officers. For this reason, additive ciphers are sometimes referred to as the Caesar cipher. Caesar used a key of 3 for his communications.</li><li>Statistical Attack</li></ul></li><li>Multiplicative Ciphers<ul><li>$$C = (P \times k) \text{ mod } 26$$</li><li>$$P = (C \times k^{-1}) \text{ mod } 26$$</li></ul></li><li>Affine Ciphers (덧셈 곱셈 혼합)<ul><li>$$T = (P \times k_1) \text{ mod } 26$$</li><li>$$C = (T + k_2) \text{ mod } 26$$</li><li>$$T = (C - k_2) \text{ mod } 26$$</li><li>$$P = (T \times k_1^{-1}) \text{ mod } 26$$</li></ul></li><li>Monoalphabetic Substitution Cipher:<ul><li>Because additive, multiplicative, and affine ciphers have small key domains, they are very vulnerable to brute-force attack.</li><li>A better solution is to create a mapping between each plaintext character and the corresponding ciphertext character. Alice and Bob can agree on a table showing the mapping for each character.</li></ul></li></ul><h4 id=322-polyalphabetic-ciphers>3.2.2. Polyalphabetic Ciphers</h4><ul><li><p>In polyalphabetic substitution, each occurrence of a character may have ad ifferent substitute. The relationship between a character in the plaintext to a character in the ciphertext is one-to-many.</p></li><li><p>Autokey Ciphers:</p><ul><li>$$k = (k_1, P_1, P_2, &mldr;)$$</li><li>$$C_i = (P_i + k_i) \text{ mod } 26$$</li><li>$$P_i = (C_i - k_i) \text{ mod } 26$$</li></ul></li><li><p>Playfair Cipher : 영국 1차 세계 대전 사용</p><ul><li>5 x 5 의 Secret Key 존재</li><li>J 는 잘 안쓰기 때문에 i와 같은 칸 차지</li><li>두 글자씩 암호:<ul><li>같은 글자가 연속으로 나오면 미리 약속한 글자를 삽입</li><li>같은 row : 각 글자의 오른쪽 글자 대치</li><li>같은 column : 각 글자의 아래 글자 대치</li><li>그 외 : 직사각형에서 같은 row의 반대편 글자로 대치</li></ul></li></ul></li><li><p>Vigenere Cipher : 비지네르 프랑스 수학자:</p><ul><li>secret key 가 문자열이고, 이를 돌아가면서 키로 사용</li></ul></li><li><p>Hill Cipher:</p><ul><li>secret key 가 m x m 정사각 행렬</li><li>글자수가 안맞으면 끝에 z(약속된 문자) 삽입</li><li>복호화는 secret key 의 역행렬을 사용한다.</li></ul></li><li><p>One-Time Pad:</p><ul><li>One of the goals of cryptography is perfect secrecy. A study by Shannon has shown that perfect secrecy can be achieved if each plaintext symbol is encrypted with a key randomly chosen from a key domain. This idea is used in a cipher called one-time pad, invented by Vernam.</li></ul></li></ul><h3 id=33-transposition-ciphers-치환-암호>3.3. Transposition Ciphers (치환 암호)</h3><ul><li>A transposition cipher does not substitute one symbol for another, instead it changes the location of the symbols.</li></ul><h4 id=331-keyless-transposition-ciphers>3.3.1. Keyless Transposition Ciphers</h4><ul><li>Split odd and even</li><li>example. meet me at the park -> memateaketethpr</li></ul><h4 id=332-keyed-transposition-ciphers>3.3.2. Keyed Transposition Ciphers</h4><ul><li>The key used for encryption and decryption is a permutation key, which shows how the character are permuted.<ul><li>For example, key = (3 1 4 5 2)</li></ul></li></ul><h4 id=333-combining-two-approaches>3.3.3. Combining Two Approaches</h4><ul><li>keyless + keyed</li></ul><h3 id=34-stream-and-block-ciphers>3.4. Stream and block ciphers</h3><ul><li>The literature divides the symmetric ciphers into two broad categories: stream ciphers and block ciphers.</li><li>Although the definitions are normally applied to modern ciphers, this categorization also applies to traditional ciphers.</li></ul><h4 id=341-stream-ciphers>3.4.1. Stream Ciphers</h4><ul><li>Call the plaintext stream P, the ciphertext stream C, and the key stream K.</li><li>$P=P_1P_2P_3&mldr;$, $C=C_1C_2C_3&mldr;$, $K=(k_1, k_2, k_3, &mldr;)$</li></ul><h4 id=342-block-ciphers>3.4.2. Block Ciphers</h4><ul><li><p>In a block cipher, a group of plaintext symbols of size $m (m> 1)$ are encrypted together creating a group of ciphertext of the same size. A single key is used to encrypt the whole block even if the key is made of multiple values.</p></li><li><p>Playfair cipher, Hill cipher</p></li></ul><h2 id=chapter-6-data-encryption-standard-des>Chapter 6. Data Encryption Standard (DES)</h2><h3 id=61-introduction>6.1. Introduction</h3><ul><li>The Data Encryption Standard (DES) is a symmetric-key block cipher published by the National Institute of Standards and Technology (NIST).</li></ul><h4 id=611-history>6.1.1. History</h4><ul><li>1973, NIST 미국 표준 대칭 키 암호 공모</li><li>IBM의 Lucifer 당선. DES라 부름</li><li>DES 1975 미국 표준 발표.</li><li>현재 : 표준 탈락</li></ul><h4 id=612-overview>6.1.2. Overview</h4><ul><li>DES is a block cipher.</li><li>symmetric-key cipher(대칭키 암호)</li><li>동일 plaintext라고 key에 따라 다른 ciphertext가 생성</li></ul><h3 id=62-des-structure>6.2. DES structure</h3><ul><li>The encryption process is made of two permutations(P-boxes), which we call initial and final permutations, and sixteen Feistel rounds.</li></ul><h4 id=621-initial-and-final-permutations>6.2.1. Initial and Final Permutations</h4><ul><li>1~64 정수들의 permutation</li><li>규칙적</li><li>IP와 FP는 서로 역 permutation</li></ul><h4 id=622-rounds>6.2.2. Rounds</h4><ul><li><p>$L_i = R_{i - 1}$</p></li><li><p>$R_i = f(R_{i-1}, K_i}) \oplus L_{i-1}$</p></li><li><p>DES Function:</p><ul><li>The heart of DES is the DES function. The DES function applies a 48-bit key to the rightmost 32 bits to produce a 32-bit output.</li></ul></li><li><p>Expansion P-box:</p><ul><li>Since $R_{i-1}$ is a 32-bit input and $K_i$ is a 48-bit key, we first need to expand $R_{i-1}$ to 48bits.</li><li>Although the relationship between the input and output can be defined mathematically, DES uses Table.</li></ul></li><li><p>XOR:</p><ul><li>After the expansion permutation, DES uses the XOR operation on the expanded right section and the round key.</li><li>Note that both the right section and the key are 48-bits in length.</li><li>Also note that the round key is used only in this operation.</li></ul></li><li><p>S-Boxes (substitution-box, 48bits -> 32bits):</p><ul><li>The S-boxes do the real mixing (confusion). DES uses 8 S-boxes, each with a 6-bit input and a 4-bit output.</li><li>불규칙적</li></ul></li><li><p>Straight P-box(Permutation box):</p><ul><li>불규칙적</li></ul></li></ul><h4 id=623-cipher-and-reverse-cipher>6.2.3. Cipher and Reverse Cipher</h4><ul><li><p>Using mixers and swappers, we can create the cipher and reverse cipher, each having 16 rounds.</p></li><li><p>To achieve this goal, one approach is to make the last round (round 16) different from the others; it has only a mixer and no swapper.</p></li><li><p>cipher와 reverse cipher는 같은 코드 사용</p></li><li><p>Pseudocode for DES cipher</p></li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="Cipher%20%28plainBlock[64],%20RoundKeys[16,%2048],%20cipherBlock[64]%29%0a%7b%0a%20%20permute%2864,%2064,%20plainBlock,%20inBlock,%20InitialPermutationTable%29%0a%20%20split%2864,%2032,%20inBlock,%20leftBlock,%20rightBlock%29%0a%20%20for%20%28round%20=%201%20to%2016%29%0a%20%20%7b%0a%20%20%20%20mixer%28leftBlock,%20rightBlock,%20RoundKeys[round]%29%0a%20%20%20%20if%20%28round%20!=%2016%29%20swapper%28leftBlock,%20rightBlock%29%0a%20%20%7d%0a%20%20combine%2832,%2064,%20leftBlock,%20rightBlock,%20outBlock%29%0a%20%20permute%2864,%2064,%20outBlock,%20cipherBlock,%20FinalPermutationTable%29%0a%7d%0a%0amixer%28leftBlock[32],%20rightBlock[32],%20RoundKey[48]%29%0a%7b%0a%20%20copy%2832,%20rightBlock,%20T1%29%0a%20%20function%28T1,%20RoundKey,%20T2%29%0a%20%20exclusiveOr%2832,%20leftBlock,%20T2,%20T3%29%0a%20%20copy%2832,%20T3,%20leftBlock%29%0a%7d%0a%0aswapper%28leftBlock[32],%20rightBlock[32]%29%0a%7b%0a%20%20copy%2832,%20leftBlock,%20T%29%0a%20%20copy%2832,%20rightBlock,%20leftBlock%29%0a%20%20copy%2832,%20T,%20rightBlock%29%0a%7d%0a%0afunction%28inBlock[32],%20RoundKey[38],%20outBlock[32]%29%0a%7b%0a%20%20permute%2832,%2048,%20inBlock,%20T1,%20ExpansionPermutationTable%29%0a%20%20exclusiveOr%2848,%20T1,%20RoundKey,%20T2%29%0a%20%20substitute%28T2,%20T3,%20SubstituteTables%29%0a%20%20permute%2832,%2032,%20T3,%20outBlock,%20StraightPermutationTable%29%0a%7d">
<i class="bi bi-copy"></i></button></div><pre><code>Cipher (plainBlock[64], RoundKeys[16, 48], cipherBlock[64])
{
  permute(64, 64, plainBlock, inBlock, InitialPermutationTable)
  split(64, 32, inBlock, leftBlock, rightBlock)
  for (round = 1 to 16)
  {
    mixer(leftBlock, rightBlock, RoundKeys[round])
    if (round != 16) swapper(leftBlock, rightBlock)
  }
  combine(32, 64, leftBlock, rightBlock, outBlock)
  permute(64, 64, outBlock, cipherBlock, FinalPermutationTable)
}

mixer(leftBlock[32], rightBlock[32], RoundKey[48])
{
  copy(32, rightBlock, T1)
  function(T1, RoundKey, T2)
  exclusiveOr(32, leftBlock, T2, T3)
  copy(32, T3, leftBlock)
}

swapper(leftBlock[32], rightBlock[32])
{
  copy(32, leftBlock, T)
  copy(32, rightBlock, leftBlock)
  copy(32, T, rightBlock)
}

function(inBlock[32], RoundKey[38], outBlock[32])
{
  permute(32, 48, inBlock, T1, ExpansionPermutationTable)
  exclusiveOr(48, T1, RoundKey, T2)
  substitute(T2, T3, SubstituteTables)
  permute(32, 32, T3, outBlock, StraightPermutationTable)
}</code></pre></div><ul><li>Key Generation:<ul><li>The round-key generator creates sixteen 48-bit keys out of a 56-bit cipher key.</li></ul></li></ul><h3 id=63-des-analysis>6.3 DES Analysis</h3><ul><li>Critics have used a strong manifier to analyze DES.</li><li>Tests have been done to measure the strength of some desired properties in a block cipher.</li></ul><h4 id=631-properties>6.3.1. Properties</h4><ul><li>Two desired properties of a block cipher are the (1)avalanche effect and the (2)completeness.</li><li>To check the (1)avalanche effect in DES, let us encrypt two plaintext blocks (with the same key) that differ only in one bit and observe the differences in the number of bits in each round.</li><li>Although the two plaintext blocks differ only in the rightmost bit, the ciphertext blocks differ in 29 bits. This means that chaning one bit of the plaintext creates a change of approximately 45 percent in hte ciphertext.</li><li>Completeness effect means that each bit of the ciphertext needs to depend on many bits on the plaintext.</li></ul><h4 id=632-design-criteria>6.3.2. Design Criteria</h4><ul><li><p>Shannon, 1949</p></li><li><p>Diffusion(확산) : ciphertext와 plaintext의 관계를 숨기는 것</p></li><li><p>Confusion(혼돈) : ciphertext와 key의 관계를 숨기는 것</p></li><li><p>Product cipher: Substitution과 Transposition(Permutation)을 결합하여 만든 cipher</p></li><li><p>Feistel ciphers are a class of product cipher.</p></li><li><p>S-Boxes 와 P-Boxes:</p><ul><li>confusion과 diffusion을 잘 만들고 있다.</li></ul></li><li><p>Number of Rounds:</p><ul><li>DES uses sixteen rounds of Feistel ciphers. After eight rounds, the ciphertext is throughly a random function of plaintext and key. DES with less than 16 rounds are more vulnerable to attacks.</li></ul></li></ul><h4 id=633-des-weaknesses>6.3.3. DES Weaknesses</h4><ul><li>During the last few years critics have found some weaknesses in DES.</li><li>Weaknesses in Key:<ul><li>Key size (56bits) is too small: 2^56 keys</li><li>Weak keys exist.</li></ul></li><li>Key complement:<ul><li>In the key domain (2^56), definitely half of the keys are complement of the other half. A key complement can be made by inverting (changing 0 to 1 or 1 to 0) each bit in the key. Does a key complement simplify the job of the cryptanalysis? It happens that it does. The attacker can use only half of the possible keys (2^55) to perform brute-force attack.</li><li>$$C=E(K, P) \rightarrow \bar C = E(\bar K, \bar P)$$</li></ul></li></ul><h3 id=64-multiple-des>6.4 Multiple DES</h3><ul><li>The major criticism of DES regards its key length. This means that we can use double or triple DES to increase the key size.</li></ul><h4 id=641-double-des>6.4.1. Double DES</h4><ul><li>The first approach is to use double DES(2DES)</li><li>Use two different keys k1 and k2 (= 112 bits)</li><li>Meet-in-the-Middle Attack:<ul><li>However, using a known-plaintext attack called meet-in-the-middle attack proves that double DES improves this vulnerability slightly (to 2^57 tests), but not tremendously (to 2^112).</li><li>즉 112 bit인데 57 bit 효과만 나타남</li></ul></li></ul><h4 id=642-triple-des>6.4.2. Triple DES</h4><ul><li>Triple DES with Three keys:<ul><li>Triple DES with three keys is used by many applications such as PGP.</li><li>$$E_{k3}(D_{k2}(E_{k1}(P))) = C$$</li><li>$$D_{k1}(E_{k2}(D_{k3}(C))) = P$$</li></ul></li></ul><h3 id=65-security-of-des>6.5. Security of DES</h3><ul><li>DES, as the first important block cipher, has gone through much scrutiny. Among the attempted attacks, three are of interest: brute-force, differential cryptanalysis, and linear cryptanalysis.</li></ul><h2 id=chapter-4-mathematics-of-cryptography>Chapter 4. Mathematics of Cryptography</h2><h3 id=41-algebraic-strucutres>4.1. Algebraic strucutres</h3><ul><li>Cryptography requires sets of integers and specific operations that are defined for those sets. The combination of the set and the operations that are applied to the elements of the set is called an algebraic struture.</li></ul><h4 id=411-groups>4.1.1. Groups</h4><ul><li><p>$&lt;G, \cdot>$ is a group:</p><ul><li>$G$ : a set elements</li><li>$\cdot$ : a binary operation</li><li>if it satisifes four properties (or axioms).</li></ul></li><li><p>A commutative (or abelian) group satisfies an extra property, commutativity.</p></li><li><p>Closure(닫힘) : $a \cdot b \in G$ for any $a, b \in G$</p></li><li><p>Associativity(결합) : $a \cdot (b \cdot c) = (a \cdot b) \cdot c$</p></li><li><p>Commuativity(교환) : $a \cdot b = b \cdot a$ for any $a, b \in G$ (abelian group)</p></li><li><p>Existence of identity(항등원) : there is $e \in G$ such that $a \cdot e = e \cdot a = a$ for all $a \in G$</p></li><li><p>Existence of inverse(역) : there is $a&rsquo; \in G$ such that $a \cdot a&rsquo; = a&rsquo; \cdot a = e$ for each $a \in G$</p></li><li><p>Finite Group: the set has a finite number of elements.</p></li><li><p>Order of group: $\vert G \vert$ = number of elements (집합의 크기)</p></li></ul><h4 id=413-field-체>4.1.3. Field (체)</h4><ul><li><p>A field, denoted by $&lt;G, \cdot, \square>$, satisfies 11 properties:</p><ul><li>G: set</li><li>$\cdot, \square$ : two binary operators</li></ul></li><li><p>$&lt;G, \cdot>$ is an abelian group</p></li><li><p>$&lt;G, \square>$ is an abelian group</p></li><li><p>Distribution(배분) : $a \square (b \cdot c) = (a \square b) \cdot (a \square c)$ for any $a,b,c \in G$</p></li><li><p>Example :</p><ul><li>$&lt;R, +, *>$ is a field.</li><li>정수들로 이루어진 field 필요. $GF(p), GF(2^n)$</li></ul></li><li><p>GF(p) field (Galois Field, p는 소수)</p></li><li><p>$GF(p) = &lt;Z_p, +, \times>$, p는 소수</p></li></ul><h3 id=42-gf2n-fields>4.2. $GF(2^n)$ Fields</h3><ul><li>In cryptography, we often need to use four operations (addition, subtraction, ultiplicationh, and division). In other words, we need to use fields.</li></ul><h4 id=421-polynomials-다항식>4.2.1. Polynomials 다항식</h4><ul><li><p>A polynomial of degree(차수) n-1 is</p></li><li><p>$$f(x) = a_{n-1}x^{n-1} + a_{n-2} x^{n-2} + \cdots + a_1 x^1 + a_0 x^0$$</p></li><li><p>where $x^i$ is called the i-th term and $a_i$ is called the coefficient of the i-th term.</p></li><li><p>Addition and subtraction on polynomials are the same operation.</p></li><li><p>Additive identity: 0</p></li><li><p>Additive inverse: itself</p></li><li><p>Polynomial multiplication:</p><ol><li>The coefficent multiplication is done is GF(2).</li><li>The multiplying $x^i$ by $x^j$ results in $x^{i+j}$.</li><li>The multiplication may create terms with degree more than $n-1$, which means the result needs to be reduced using a modulus polynomial (or irreducible polynomial).</li></ol></li><li><p>Multiplicative identity: 1</p></li><li><p>Multiplicative inverse: use the extended Euclidean algorithm</p></li></ul><h4 id=423-summary>4.2.3. Summary</h4><ul><li>The finite field GF(2^n) can be used to define four operations of addition, subtraction, multiplication and division over n-bit words.</li></ul><h2 id=chapter-7-advanced-encryption-standard-aes>Chapter 7. Advanced Encryption Standard (AES)</h2><h3 id=71-introduction>7.1. Introduction</h3><ul><li>The Advanced Encryption Standard (AES) is a symmetric-key block cipher published by the National Institute of Standards and Technology(NIST) in December 2001.</li></ul><h4 id=711-history>7.1.1. History</h4><ul><li>NIST: DES를 대체할 새 대칭 키 블록 암호 선정 절차</li><li>벨기에: Vincent Rijmen and Joan Daemen의 Rijndael 암호에 기반</li><li>In February 2001, NIST announced that a draft of the Federal Information Processing Standard (FIPS) was available for public review and comment.</li><li>Finally, AES was published as FIPS 197 in the Federal Register in December 2001.</li></ul><h4 id=713-rounds>7.1.3. Rounds</h4><ul><li>AES is a non-Feistel cipher that encrypts and decrypts a data block of 128 bits. It uses 10, 12, or 14 rounds. The key size, which can be 128, 192, or 256 bits, depends on the number of rounds.</li><li>AES has defined three versions (AES-128, -192, -256), with 10, 12, and 14 rounds.</li><li>Each version uses a different cipher key size (128, 192, or 256 bits), but the round keys are always 128 bits.</li></ul><h4 id=714-data-units>7.1.4. Data Units</h4><ul><li>1 byte = 8bits</li><li>1 word = 4 bytes =32 bits</li><li>1 block = 4 words = 16 bytes = 128 bits</li></ul><h4 id=715-strucutre-of-each-round>7.1.5. Strucutre of Each Round</h4><ul><li>AES-128 version: 10 rounds</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="Cipher%28InBlock[16],%20OutBlock[16],%20w[0%20...%2043]%29%0a%7b%0a%20%20BlockToState%28InBlock,%20S%29%0a%0a%20%20S%20%3c-%20AddRoundKey%28S,%20w[0...3]%29%0a%20%20for%20%28round%20=%201%20to%2010%29%0a%20%20%7b%0a%20%20%20%20S%20%3c-%20SubBytes%28S%29%0a%20%20%20%20S%20%3c-%20ShiftRows%28S%29%0a%20%20%20%20if%20%28round%20!=%2010%29%20S%20%3c-%20MixColumns%28S%29%0a%20%20%20%20S%20%3c-%20AddRoundKey%28S,%20w[4%20*%20round,%204%20*%20round%20+%203]%29%0a%20%20%7d%0a%20%20StateToBlock%28S,%20OutBlock%29;%0a%7d">
<i class="bi bi-copy"></i></button></div><pre><code>Cipher(InBlock[16], OutBlock[16], w[0 ... 43])
{
  BlockToState(InBlock, S)

  S &lt;- AddRoundKey(S, w[0...3])
  for (round = 1 to 10)
  {
    S &lt;- SubBytes(S)
    S &lt;- ShiftRows(S)
    if (round != 10) S &lt;- MixColumns(S)
    S &lt;- AddRoundKey(S, w[4 * round, 4 * round &#43; 3])
  }
  StateToBlock(S, OutBlock);
}</code></pre></div><h3 id=72-transformations>7.2. Transformations</h3><ul><li>To provide security, AES uses four types of transformations:<ul><li>substitution(SubBytes), permutation(ShiftRows), mixing(MixColumns), and key-adding(AddRoundKey)</li></ul></li></ul><h4 id=721-substitution>7.2.1. Substitution</h4><ul><li>AES, like DES, uses substitution. AES uses two invertible transformations.</li><li>SubBytes:<ul><li>The first transformation, SubBytes, is used at the encryption site. To subsitute a byte, we interpret the byte as two hexadecimal digits.</li><li>SubBytes table</li><li>Transformation Using GF(2^8) Field</li><li>AES also defines the transformation algebraically using the GF(2^8) field with the irreducible polynomial ($x^8 + x^4 + x^3 + x + 1$)</li><li>$d = X \cdot s^{-1} \oplus y$</li></ul></li><li>InvSubBytes:<ul><li>$s=(X^{-1} \cdot (d \oplus y))^{-1}$</li></ul></li></ul><h4 id=722-permutation>7.2.2. Permutation</h4><ul><li>Another transformation found in a round is shifting, which permutes the bytes.</li><li>ShiftRows:<ul><li>In the encryption, the transformation is called ShiftRows.</li></ul></li><li>InvShiftRows:<ul><li>In the decryption, the transformation is called InvShiftRows and the shifting is to the right.</li></ul></li></ul><h4 id=723-mixing>7.2.3. Mixing</h4><ul><li><p>We need an interbyte transformation that changes the bits inside a byte, based on the bits inside the neighboring bytes.</p></li><li><p>MixColumns:</p><ul><li>The MixColumns transformation operates at the column level; it transforms each coulmn of the stae to a new column.</li></ul></li><li><p>InvMixColumns:</p><ul><li>The InvMixColumns transformation is basically the same as the MixColumns transformation.</li><li>The MixColumns and InvMixColumns transformations are inverses of each other.</li></ul></li></ul><h4 id=724-key-adding>7.2.4. Key Adding</h4><ul><li>AddRoundKey:<ul><li>AddRoundKey proceeds one column at a time. AddRoundKey adds a round key word with each state column matrix; the operation in AddRoundKey is matrix addition.</li><li>The AddRoundKey transformation is the inverse of itself.</li></ul></li></ul><h3 id=73-key-expansion>7.3. Key Expansion</h3><ul><li>To create round keys for each round, AES uses a key-expansion process. If the number of rounds is $N_r$, the key-expansion routine creates $N_r + 1$ 128-bit round keys from one single 128-bit cipher key.</li></ul><h4 id=731-key-expansion-in-aes-128>7.3.1. Key Expansion in AES-128</h4><ul><li>RotWord(w) : one-byte circular left shift, i.e., [b0, b1, b2, b3] is transformed into [b1, b2, b3, b0]</li><li>SubWord(w) : SubBytes transformation applied to four bytes</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="KeyExpansion%28[key_0%20to%20key_%7b15%7d],%20[w_0%20to%20w_%7b43%7d]%29%0a%7b%0a%20%20for%20%28i%20=%200%20to%203%29%0a%20%20%20%20w_i%20%3c-%20key_%7b4i%7d%20+%20key_%7b4i+1%7d%20+%20key_%7b4i+2%7d%20+%20key_%7b4i+3%7d%0a%0a%20%20for%20%28i%20=%204%20to%2043%29%0a%20%20%7b%0a%20%20%20%20if%20%28i%20mod%204%20!=%200%29%20w_i%20%3c-%20w_%7bi-1%7d%20%5coplus%20w_%7bi-4%7d%0a%20%20%20%20else%0a%20%20%20%20%7b%0a%20%20%20%20%20%20t%20%3c-%20SubWord%28RotWord%28w_%7bi-1%7d%29%29%20%5coplus%20RCon_%7bi/4%7d%0a%20%20%20%20%20%20w_i%20%3c-%20t%20%5coplus%20w_%7bi-4%7d%0a%20%20%20%20%7d%0a%20%20%7d%0a%7d">
<i class="bi bi-copy"></i></button></div><pre><code>KeyExpansion([key_0 to key_{15}], [w_0 to w_{43}])
{
  for (i = 0 to 3)
    w_i &lt;- key_{4i} &#43; key_{4i&#43;1} &#43; key_{4i&#43;2} &#43; key_{4i&#43;3}

  for (i = 4 to 43)
  {
    if (i mod 4 != 0) w_i &lt;- w_{i-1} \oplus w_{i-4}
    else
    {
      t &lt;- SubWord(RotWord(w_{i-1})) \oplus RCon_{i/4}
      w_i &lt;- t \oplus w_{i-4}
    }
  }
}</code></pre></div><ul><li>Each round key in AES depends on the previous round. The dependency, however, is nonlinear because of SubWord transformation. The addition of the round constants also guarantees that each round key will be different from the previous one.</li></ul><h3 id=74-ciphers>7.4. Ciphers</h3><ul><li>AES uses four types of transformations for encryption and decryption. In the standard, the encryption algorithm is referred to as the cipher and the decryption algorithm as the inverse cipher.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="Cipher%20%28InBlock[16],%20OutBlock[16],%20w[0...43]%29%0a%7b%0a%20%20BlockToState%28InBlock,%20S%29%0a%0a%20%20S%20%3c-%20AddRoundKey%28S,%20w[0...3]%29%0a%20%20for%20%28round%20=%201%20to%2010%29%0a%20%20%7b%0a%20%20%20%20S%20%3c-%20SubBytes%28S%29%0a%20%20%20%20S%20%3c-%20ShiftRows%28S%29%0a%20%20%20%20if%20%28round%20!=%2010%29%20S%20%3c-%20MixColums%28S%29%0a%20%20%20%20S%20%3c-%20AddRoundKey%28S,%20w[4%20*%20round,%204%20*%20round%20+%203]%29%0a%20%20%7d%0a%0a%20%20StateToBlock%28S,%20OutBlock%29;%0a%7d">
<i class="bi bi-copy"></i></button></div><pre><code>Cipher (InBlock[16], OutBlock[16], w[0...43])
{
  BlockToState(InBlock, S)

  S &lt;- AddRoundKey(S, w[0...3])
  for (round = 1 to 10)
  {
    S &lt;- SubBytes(S)
    S &lt;- ShiftRows(S)
    if (round != 10) S &lt;- MixColums(S)
    S &lt;- AddRoundKey(S, w[4 * round, 4 * round &#43; 3])
  }

  StateToBlock(S, OutBlock);
}</code></pre></div><h2 id=chapter-9-mathematics-of-cryptography>Chapter 9. Mathematics of Cryptography</h2><h3 id=91-primes>9.1. Primes</h3><ul><li>Asymmetric-key cryptography uses primes extensively. The topic of primes is a large part of any book on number theory.</li></ul><h4 id=911-definition>9.1.1. Definition</h4><ul><li>Positive integers:<ul><li>Number 1, Primes, Composites</li><li>A prime is divisible only by itself and 1.</li></ul></li></ul><h4 id=912-cardinality-of-primes>9.1.2. Cardinality of Primes</h4><ul><li>Infinite Number of Primes</li><li>Number of Primes:<ul><li>$$\frac{n}{ln(n)} &lt; \pi(n) &lt; \frac{n}{ln(n) - 1.08366}$$<ul><li>for large n</li></ul></li><li>$$\pi(n) \approx \frac{n}{ln(n)}$$<ul><li>for large n</li></ul></li></ul></li></ul><h4 id=913-checking-for-primeness>9.1.3. Checking for Primeness</h4><ul><li>Given a number n, how can we determine if n is a prime?</li><li>We need to see if the number is divisible by all primes less than $\sqrt n$</li><li>We know that this method is inefficient, but it is a godo start.</li><li>Any composite integer can be expressed as a product of prime numbers.</li></ul><h4 id=914-eulers-phi-function>9.1.4. Euler&rsquo;s Phi-Function</h4><ul><li><p>$\phi(n)$ : Euler&rsquo;s phi-function:</p><ul><li>number of positive integers that are both smaller than n and relatively prime to n.</li></ul></li><li><p>Properties:</p><ul><li>$\phi(1) = 0$</li><li>$\phi(p) = p - 1$, if p is a prime.</li><li>$\phi(m \times n) = \phi(m) \times \phi(n)$, if m and n are relatively prime. $m \ge 2, n \ge 2$</li><li>$phi(p^e) = p^e - p^{e - 1}$, if p is a prime</li></ul></li></ul><h4 id=915-fermats-little-theorem>9.1.5. Fermat&rsquo;s Little Theorem</h4><ul><li><p>First Version:</p><ul><li>If $p$ is a prime and $a$ is an integer such that $p$ does not divide $a$, then:</li><li>$$a^{p-1} \text{ mod } p = 1$$</li></ul></li><li><p>Second Version:</p><ul><li>if $p$ is a prime and $a$ is an integer, then:<ul><li>$$a^p \text{ mod } p = a \text{ mod } p$$</li></ul></li></ul></li><li><p>Multiplicative Inverse:</p><ul><li>If $p$ is a prime and $0 &lt; a &lt; p$, then:<ul><li>$$a^{-1} \text{ mod } p = a^{p - 2} \text{ mod } p$$</li></ul></li></ul></li></ul><h4 id=916-eulers-theorem>9.1.6. Euler&rsquo;s THeorem</h4><ul><li>If $a$ and $n$ are relatively prime, then:<ul><li>$$a^{\phi(n)} \text{ mod } n = 1$$</li><li>n이 소수이면, Fermat&rsquo;s Little Theorem이 됨.</li></ul></li></ul><h4 id=917-generatign-primes>9.1.7. Generatign Primes</h4><ul><li>Mersenne Primes:<ul><li>A number in the form $M_p = 2^p - 1$, $p$ prime, is called a Mersenne number and may or may not be a prime.</li></ul></li></ul><h3 id=92-primality-testing>9.2. Primality Testing</h3><ul><li>Finding an algorithm to correctly and efficiently test a very large integer and output a prime or a composite has always been a challenge in number theory, and consequently in cryptography. However, recent developments look very promising.</li></ul><h4 id=921-deterministic-algorithms>9.2.1. Deterministic Algorithms</h4><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=Divisibility_Test%28n%29%0a%7b%0a%20%20r%20%3c-%202%0a%20%20while%20%28r%20%3c%20sqrt%20%28n%29%29%0a%20%20%7b%0a%20%20%20%20if%20%28r%20%7c%20n%29%20return%20%22a%20composite%22%0a%20%20%20%20r%20%3c-%20r%20+%201%0a%20%20%7d%0a%20%20return%20%22a%20prime%22%0a%7d>
<i class="bi bi-copy"></i></button></div><pre><code>Divisibility_Test(n)
{
  r &lt;- 2
  while (r &lt; sqrt (n))
  {
    if (r | n) return &#34;a composite&#34;
    r &lt;- r &#43; 1
  }
  return &#34;a prime&#34;
}</code></pre></div><ul><li>수행시간 : $n_b$ = no. of bits of n</li></ul><h4 id=922-probabilistic-algorithms>9.2.2. Probabilistic Algorithms</h4><ul><li><p>Fermat test</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><pre><code>repeat k times:
  pick a randomly from [2, n-2]
  if a^{n-1} mod n != 1, then return &#34;composite&#34;
return &#34;prime&#34;</code></pre></div></li><li><p>Square Root Test:</p><ul><li>If n is a prime, then $sqrt 1$ mod n = {1, n-1}</li></ul></li><li><p>Miller-Rabin Test: Fermat test + Square Root test:</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="Miller-Rabin%28n,%20a%29%0a%0afind%20m%20and%20k%20such%20that%20n%20-%201%20=%20m%20*%202%5ek%0aT%20%3c-%20a%5em%20mod%20n%0aif%20%28T%20=%201%20or%20n%20-%201%29%20return%20%22prime%22%0a%0afor%20%28i=1%20to%20k-1%29%0a%20%20T%20%3c-%20T%5e2%20mod%20n%0a%20%20if%20%28T=1%29%20return%20%22composite%22%0a%20%20if%20%28T=n-1%29%20return%20%22prime%22%0a%0areturn%20%22composite%22">
<i class="bi bi-copy"></i></button></div><pre><code>Miller-Rabin(n, a)

find m and k such that n - 1 = m * 2^k
T &lt;- a^m mod n
if (T = 1 or n - 1) return &#34;prime&#34;

for (i=1 to k-1)
  T &lt;- T^2 mod n
  if (T=1) return &#34;composite&#34;
  if (T=n-1) return &#34;prime&#34;

return &#34;composite&#34;</code></pre></div></li></ul><h4 id=923-recommended-primality-test>9.2.3. Recommended Primality Test</h4><ul><li>Today, one of the most popular primality test is combination of the divisibility test and the Miller-Rabin test.<ol><li>Choose an odd integer, n.</li><li>Do the divisibility tests on primes 3,5,7,11,13,17,19,23.</li><li>Choose a set of bases, say 10 bases.</li><li>Do the Miller-Rabin test on each of these bases.:</li></ol><ul><li>If any of them failes, then go to step 1.</li><li>If the test passes for all 10 bases, then declare n as a prime.</li></ul></li></ul><h3 id=93-factorization>9.3. Factorization</h3><ul><li>Factorization has been the subject of continuous research in the past; such research is likely to continue in the future. Factorization plays a very important role in the security of several public-key cryptosystems.</li></ul><h4 id=931-fundamental-theorem-of-arithmetic>9.3.1. Fundamental Theorem of Arithmetic</h4><ul><li>Any positive integer n can be written uniquely in a prime factorization form. $p_1, p_2, &mldr; p_k$ are primes, and $e_1, e_2, &mldr;, e_k$ are positive integers.:<ul><li>$$n = p_1^{e_1} \times p_2^{e_2} \times \cdots \times p_k^{e_k}$$</li></ul></li></ul><h3 id=96-exponentiation-and-logarithm>9.6. Exponentiation and Logarithm</h3><ul><li>Fast Exponentiation</li></ul><h2 id=chapter-10-asymmetric-key-public-key-cryptography>Chapter 10. Asymmetric-Key (Public-Key) Cryptography</h2><h3 id=101-introduction>10.1 Introduction</h3><ul><li><p>Symmetric and public-key cryptography will exist in parallel and continue to serve the community. We actually belive that they are complements of each other; the advantages of one can compensate for the disadvantages of the other.</p></li><li><p>Symmetric-key cryptography : sharing secrecy</p></li><li><p>public-key cryptography : personal secrecy</p></li></ul><h4 id=1011-keys>10.1.1. Keys</h4><ul><li>PUblic key cryptography uses two separate keys:<ul><li>one private key and one public key</li></ul></li></ul><h4 id=1012-general-idea>10.1.2. General Idea</h4><ul><li>Plaintext/Ciphertext:<ul><li>Plaintext and ciphertext are treated as integers in public-key cryptography.</li></ul></li><li>Encryption/Decryption:<ul><li>$C=f(K_{pulibc}, P), P = g(K_{private}, C)$</li></ul></li></ul><h4 id=1013-need-for-both>10.1.3. Need for Both</h4><ul><li>There is a very important fact that is cometimes misunderstood: The advent of public-key cryptogrpahy does not eliminate the need for symmetric-key cryptography.</li><li>Symmetric-key: faster. Good for encryption of large messages</li><li>Public-key: slow, but needed for authentication, digital signature, and key exchange.</li></ul><h4 id=1014-trapdoor-one-way-function>10.1.4. Trapdoor One-Way Function</h4><ul><li><p>The main idea behind public-key cryptogaphy is the concept of the trapdoor one-way function</p></li><li><p>One-Way Function: $y=f(x)$</p><ul><li>$f$ is easy to compute. Given $x,y=f(x)$ can be easily computed.</li><li>$f^{-1}$ is difficult to compute. Given $y$, it is computationally infeasible to compute $x=f^{-1}(y)$</li></ul></li><li><p>Trapdoor One-way Function:</p><ul><li>Given $y$ and $a$ trapdoor (secret), $x$ can be computed easily $x=f^{-1}(y)$.</li></ul></li><li><p>Every public-key cryptography depends on a trapdoor one-way function.</p></li></ul><h3 id=102-rsa-cryptosystem>10.2. RSA Cryptosystem</h3><ul><li>The most common public-key algorithm is the RSA cryptosystem, named for its inventors (Rivest, Shamir, and Adleman, 1977).</li></ul><h4 id=1021-introduction>10.2.1. Introduction</h4><ul><li>Plaintext : $P$, $P$ is an integer and $P &lt; n$<ul><li>Encryption: $C=P^e \text{ mod } n$</li></ul></li><li>Ciphertext : $C$, $C$ is an integer and $C &lt; n$:<ul><li>Decryption: $P=C^d \text{ mod } n$</li></ul></li><li>$e,n$ : public key</li><li>$d$ : private key</li></ul><h4 id=1022-procedure>10.2.2. Procedure</h4><ul><li><p>RSA key generation 키 생성:</p><ol><li>두 소수 p,q, 생성, p != q</li><li>n = p * q 계산</li><li>$\phi(n) = (p - 1)(q - 1)$ 계산</li><li>$e$ 선택: $1 &lt; e &lt; \phi(n)$ 이고, $e$와 $\phi(n)$ 은 서로소</li><li>$d = e^{-1} \text{ mod } \phi(n)$ 계산</li></ol></li><li><p>$p, q, \phi(n)$ 모두 폐기</p></li><li><p>In RSA, $p$ and $q$ must be at least 512 bits; $n$ must be at least 1024 bits.</p></li></ul><h4 id=1024-attacks-on-rsa>10.2.4. Attacks on RSA</h4><ul><li><p>Potential attacks on RSA:</p><ul><li>Factorization:</li><li>Chosen-ciphertext:</li><li>Encryption exponent: Coppersmith, broasdcast, related messages, and short pad</li><li>Decryption exponent: Revealed and low exponent</li><li>Plaintext: SHort message ,cyclic, and unconcealed</li><li>Modulus: Common modulus</li><li>Implementation: Timing and power</li></ul></li><li><p>Factorization attack:</p><ul><li>$n$ is so large that it is infeasible to factor it in a reasonable time.</li><li>If Eve can factor $n$ and obtaion $p$ and $q$, she can calculate $\phi(n) = (p - 1)(q - 1)$. She then calculates $d=e^{-1} \text{ mod } \phi(n)$ because $e$ is public.</li><li>There are many factorization algorithms, but none of them can factor a large integer with polynomial time complexity. $n$ must be at least 1024 bits.</li><li>RSA is secure as long as an efficient algorithm for factorization has not been found.</li></ul></li><li><p>RSA reommendations based on theoretical and experimental results:</p><ol><li>The number of bits for $n$ should be at least 1024.</li><li>$p$ and $q$ must each be at least 512 bits</li><li>n must not be shared.</li><li>$e$ should be $2^{16} + 1$ or an integer close to this.</li><li>If $d$ is leaked, we must change $n$ as well as both $e$ and $d$.</li></ol></li></ul><h4 id=1026-oaep>10.2.6. OAEP</h4><ul><li><p>Optimal asymmetric encryption padding</p></li><li><p>Encryption:</p><ol><li>m-bit message M이 mbit가 안되면 padding하여 m bit로 만든다.</li><li>random number r of k bits 생성</li><li>G(r) 계산. G는 public one-way 함수(k bit를 m bit로 확대, k &lt; m)</li><li>$P_1 = M \bigoplus$ G(r)$ 계산. $P_1$ : masked message (m bit)</li><li>$P_2 = H(P_1) \bigoplus r$. H는 another public one-way 함수(m bit를 k bit로 축소)</li><li>$C=(P_1 \vert \vert P_2)^e \text{ mod } n$으로 암호</li></ol></li><li><p>Decryption:</p><ol><li>복호 $P = C^d \text{ mod } n = P_1 \vert \vert P_2$. $P_1$와 $P_2$를 얻음.</li><li>$r$ 얻음. $H(P_1) \bigoplus H(P_1) \bigoplus r = r$</li><li>마스크 없앰. $G(r) \bigoplus P_1 = G(r) \bigoplus M \bigoplus G(r) = M$</li><li>M에서 padding을 없애면 원래 메시지 얻음</li></ol></li><li><p>Applications:</p><ul><li>RSA is slow if the message is long.</li><li>RSA is useful for short messages.</li><li>RSA is used in digital signatures and others that often need to encrypt a small message without having access to a symmetric key.</li></ul></li></ul><h3 id=104-elgamal-cryptosystem>10.4. ElGamal Cryptosystem</h3><ul><li>Besides RSA and Rabin, another public-key cryptosystem is ElGamal. ElGamel is based on the discrete logarithm problem</li><li>Discrete Logarithm (이산 대수):<ul><li>$y= g^x \text{ mod } p$:<ul><li>Given $p,g$ and $x$, it is easy to compute y.</li><li>Given $p, g$ and $y$, however, it is computationally infeasible to compute $x$.</li></ul></li></ul></li><li>discrete logarithm problem $\approx$ factorization</li><li>Key Geneartion:<ol><li>$p$ : 소수 생성</li><li>$e_1$ 선택, $e_1$ 은 $&lt;Z_p^*, \times>$의 primitive root</li><li>$d$ 선택, $1 \le d \le p-2$</li><li>$e_2=e_1^d \text{ mod } p$ 계산</li></ol></li><li>공개키 : $e_1, e_2, p$</li><li>개인키 : $d$</li><li>$e_1, e_2, p$를 알아도 $d$를 계산하는 것은 어려움</li><li>Encryption:<ol><li>$r$ 랜덤 선택, $1 \le r \le p-1$, $r$ 비밀</li><li>$C_1 = e_1^r \text{ mod } p$ 계산</li><li>$C_2 = M e_2^r \text{ mod } p$ 계산</li></ol></li><li>$(C_1, C_2)$가 $M$의 암호문</li><li>Decryption:<ol><li>$M = C_2 / C_1^d \text{ mod } p$ 계산</li></ol></li><li>RSA와 달리 특별한 정리 필요 없음.</li></ul><h3 id=105-elliptic-curve-cryptosystems>10.5. Elliptic Curve Cryptosystems</h3><ul><li>Although RSA and ElGamal are secure asymmetric-key cryptosystems, their security comes with a price, their large keys. Researchers have looked for alternatives that give the same level of security with smaller key sizes. One of these promising alternatives is the elliptic curve cryptosystem (ECC).</li></ul><h4 id=1051-elliptic-curves-over-real-numbers>10.5.1. Elliptic Curves over Real Numbers</h4><ul><li>The general equiation for an elliptic curve is:<ul><li>$$y^2 + b_1 xy + b_2 y = x^3 + a_1 x^2 + a-2 x + a_3$$</li></ul></li><li>Elliptic curves over real numbers use a special class of elliptic curves of the form:<ul><li>$$y^2 = x^3 + ax + b$$:<ul><li>where $4a^3 + 27b^2 \not = 0$</li></ul></li><li>In this case, the curves have three distinct (real or complex) roots.</li></ul></li></ul><h5 id=point-addition>Point addition</h5><ul><li>Case 1: 두개의 다른점<ul><li>$$\labmda = (y_2 - y_1) / (x_2 - x_1)$$</li><li>$$x_3 = \lambda^2 - x_1 - x_2, y_3 = \lambda(x_1 - x_3) - y_1$$</li></ul></li><li>Case 2: 접선:<ul><li>$$\lambda = (3x_1^2 + a) / (2 y_1)$$</li><li>$$x_3 = \lambda^2 - 2 x_1, y_3 = \lambda(x_1 - x_3) - y_1$$</li></ul></li><li>Case 3: 점과 자기역:<ul><li>$P + (-P) = O$</li></ul></li></ul><h4 id=1052-elliptic-curves-over-gfp>10.5.2. Elliptic Curves over GF(p)</h4><ul><li><p>The coordinates of the points are over the GF(p) field with prime p.</p><ul><li>$$y^2 \text{ mod } p = (x^3 + ax + b) \text{ mod } p$$<ul><li>where $x,y,a$, and $b$ are in $Z_p$, and $(4a^3+27b^2) \text{ mod } p \not = 0$</li></ul></li></ul></li><li><p>$E_p(a, b)$ consists of all points of $(x, y)$ that satisfies the equation, and $O$, the zero point.</p></li><li><p>Finding an Inverse:</p><ul><li>The inverse of a point $(x, y)$ is $(x, -y)$, where $-y$ is the additive inverse of $y \text{ mod } p$.</li></ul></li><li><p>Adding two points:</p><ul><li>We use the elliptic group defined over real numbers, but calculations are done in GF(p).</li><li>Instead of subtraction and division, we use additive and multiplicative inverses.</li></ul></li></ul><h4 id=1054-ecc-simulating-elgamal>10.5.4. ECC Simulating ElGamal</h4><ul><li><p>Generating Public and Private Keys:</p><ol><li>Choose $E_p(a, b)$ over $GF(p)$.</li><li>Choose a point $e_1 = (x_1, y_1)$ in $E_p(a, b)$.</li><li>Choose an integer $d$.</li><li>Calculate $e_2 = (x_2, y_2) = d \times e_1$</li><li>Announce $p,a,b,e_1$ and $e_2$ as public key, keep $d$ as private key.</li></ol></li><li><p>Encryption:</p><ul><li>Select $P$, a point in $E_p(a, b)$, as plaintext.</li><li>Choose a random positive integer $r$.</li><li>Calculate a pair of points:<ul><li>$$C_1 = r \times e_1, C_2 = P + r \times e_2$$</li></ul></li></ul></li><li><p>Decryption:</p><ul><li>$$P = C_2 - (d \times C_1)$$</li></ul></li><li><p>Easy to calculate $e_2$ from $d$ and $e_1$. $e_1$ and $e_2$ are public, but computationally difficult to calculate $d$ from $e_1$ and $e_2$.</p></li><li><p>elliptic curve discrete logarithmic problem(ECDLP)</p></li></ul><h2 id=chapter-11-message-integrity-and-message-authentication>Chapter 11. Message Integrity and Message Authentication</h2><h3 id=111-message-integrity>11.1 Message Integrity</h3><ul><li>The cryptography systems that we have studied so far provide secrecy, or confidentiality, but not integrity. However, there are occasions where we may not even need secrecy but instead msut have integrity.</li></ul><h4 id=1111-document-and-fingerprint>11.1.1. Document and Fingerprint</h4><ul><li>문서(document)의 무결성(integrity) 보장</li><li>도장, 사인, 지장(finger print)</li></ul><h4 id=1112-message-and-message-digest>11.1.2. Message and Message Digest</h4><ul><li>Message : Digital Document</li><li>Message Digest : finger print</li></ul><h4 id=1113-difference>11.1.3. Difference</h4><ul><li>Two pairs (document/fingerprint) and (message/message digest) are similar, with some differences.:<ul><li>document and fingerprint: physically linked together.</li><li>message and message digest : can be unlinked separately.</li></ul></li><li>message digest needs to be safe from change.</li></ul><h4 id=1114-checking-integrity>11.1.4. Checking Integrity</h4><h4 id=1115-cryptographic-hash-function-criteria>11.1.5. Cryptographic Hash Function Criteria</h4><ul><li>Cryptographic hash function h: for a message M, $y=h(M)$:<ol><li>$h$ can be applied to a message of any size</li><li>$h$ produces a fixed-length output.</li><li>Given $M$, it is easy to compute $y$.</li><li>Given $y$, it is computationally difficult to find any message $M$ such that $h(M) = y$. : Primage resistance</li><li>Given $M$ and $y=h(M)$, it is computationally difficult to find another message $M&rsquo;(\not = M)$ such that $h(M&rsquo;) = y$. : Second preimage resistance</li><li>It is computationally difficult to find a pair of messages $M$ and $M&rsquo;(M \not = M&rsquo;)$ such that $h(M) = h(M&rsquo;)$ : Collision resistance</li></ol></li></ul><h3 id=112-random-oracle-model>11.2. Random Oracle Model</h3><ul><li>The Random Oracle Model, which was introduced in 1993 by Bellare and Rogaway, is an ideal mathmatical model for a cryptographic hash function.</li></ul><h4 id=1121-pigeonhole-principle>11.2.1. Pigeonhole Principle</h4><ul><li>If $n$ pigeonholes are occupied by $n+1$ pigeons, then at least one pigeonhole is occupied by two pigeons. The generalized version of the pigeonhole principle is that if $n$ pigeonholes are occupied by $kn +1$ pigeons, then at least one pigeonhole is occupied by $k+1$ pigeons.</li></ul><h4 id=1122-birthday-problems>11.2.2. Birthday Problems</h4><ul><li><p>&ldquo;likely&rdquo; menas &ldquo;with probability $\ge$ 1/2&rdquo;</p></li><li><p>Problem 1:</p><ul><li>What is the minimum number of students, $k$, in a classroom such that it is likely that at least one student has a predefined birthday?</li><li>$$1 - \frac{1}{N} \approx e^{- \frac{1}{N}}$$</li><li>$$e^{-\frac{k}{N}} \le \frac{1}{2}$$</li><li>$$-\frac{k}{N} \le ln \frac{1}{2} = - ln 2$$</li><li>$$k \le ln 2 \times N \approx 0.69 \times N$$</li><li>$$ N = 365, k \ge 253$$</li></ul></li><li><p>Problem 2:</p><ul><li>What is the minimum number of students, $k$, in a classroom such that it is likely that at least one student has the same birthday as the student selected by the professor?</li></ul></li><li><p>Problem 3:</p><ul><li>What is the minmum number of students, $k$, in a classroom such that it is likely that at least two students have the same birthday?</li><li>$$1 - e^{-\frac{k^2}{2N}} \ge \frac{1}{2}$$</li><li>$$k \ge \sqrt{2 N \times ln 2} \approx 1.18 \times \sqrt N$$</li><li>$$N = 365, k = 23$$</li></ul></li><li><p>Problem 4:</p><ul><li>Two classes, each with $k$ students. what is the minimum value of $k$ such that it is likely that at least one student from the first classroom has the same birthday as a student from the second classroom?</li></ul></li><li><p>Preimage Attack:</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><pre><code>for i = 1 ~ k:
  create M_i
  compute t = h(M_i)
  if (t == y) return M_i
return failure</code></pre></div><ul><li>$$k \ge 0.69 \times N = 0.69 \times 2 ^n$$</li></ul></li><li><p>Collision Attack</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><pre><code>for i = 1 ~ k:
  create M_i
  compute y_i = h(M_i)
  for j = 1 ~ i - 1:
    if (y_i == y_j) return M_i and M_j
return failure</code></pre></div><ul><li>$k \ge 1.189 \times N^{-1/2} = 1.18 \times 2^{n / 2}$</li></ul></li></ul><h3 id=113-message-authentication>11.3 Message Authentication</h3><ul><li>A message digest does not authenticate the sender of the message. To provide message authentication, Alice needs to provide proof that it is Alice sending the message and not an impostor. The digest created by a cryptographic hash function is normally called a modification detection code (MDC). What we need for message authetnication is a message authentication code (MAC)</li></ul><h4 id=1131-modification-detection-code-mdc>11.3.1. Modification Detection Code (MDC)</h4><ul><li>MDC: 메시지의 integrity 보장</li><li>Alice에게 Bob에게 메시지를 보내려할 때 메시지가 전송 중에 변하지 않았음 을 보장하려면 MDC를 만드록, 메시지와 MDC를 상대에게 보냄.</li></ul><h4 id=1132-message-authentication-code-mac>11.3.2. Message Authentication Code (MAC)</h4><ul><li><p>메시지의 integirty 와 data origin authentication을 동시에 보장하려면 MDC-> MAC(message authentication code)으로 바꿈</p></li><li><p>둘의 차이점: MAC은 Alice와 Bob 사이에 비밀 사전 공유</p></li><li><p>MAC 의 종류</p><ul><li>HMAC : hash함수를 이용</li><li>CMAC : CBCMAC (대칭키 암호를 이용)</li><li>전용 MAC함수를 따로 개발</li></ul></li></ul><h2 id=chapter-12-cryptographic-hash-functions>Chapter 12. Cryptographic Hash Functions</h2><h3 id=121-introduction>12.1 Introduction</h3><ul><li>A cryptographic hash function takes a message of arbitrary length and creates a message digest of fixed length.</li></ul><h4 id=1111-iterated-hash-function>11.1.1. Iterated Hash Function</h4><ul><li>Merkle-Damagard Scheme:<ul><li>$H_0$: 초기값(미리 정해진 값)</li><li>$H_i = f(H_{i-1}, M_i), 1 \le i \le t$</li><li>$H_t = h(M)$</li><li>$f$ : compression function</li><li>$n$ : block 크기</li><li>$m$ : message digest 길이</li></ul></li></ul><h4 id=1212-two-groups-of-compression-functions>12.1.2. Two Groups of Compression Functions</h4><ol><li>$f$ 함수 : made from scratch(새로 개발):</li></ol><ul><li>Message Digest(MD) : MD2, MD4, MD5 - Rivest 개발</li><li>Secure Hash Algorithm (SHA) : SHA-2, SHA-512 미국 표준</li></ul><ol start=2><li>$f$ 함수 : based on block ciphers:</li></ol><ul><li>Whirlpool</li></ul><h3 id=122-sha-512>12.2 SHA-512</h3><ul><li><p>SHA-512 is the version of SHA with a 512-bit message digest. This version, like the others in the SHA family of algorithms ,is based on the merkle-Damgard scheme.(by NSA and NIST)</p></li><li><p>With a message digest of 512 bits, SHA-512 expected to be resistant to all attacks, including collision attacks.</p></li></ul><h2 id=chapter-13-digital-signature>Chapter 13. Digital Signature</h2><ul><li>Conventional Signatures:<ul><li>A person signs a document to show that it originated from her or was approved by her.</li><li>The signature is a proof to the recipient that the document comes from the correct entity.</li></ul></li><li>Digital Signatures:<ul><li>When Alice sends a message to Bob, Bob needs to check the authenticity of the sender; he needs to be sure that the message comes from Alice and not Eve.</li><li>Bob can ask Alice to sign the mssage electronically. The electornic signature can prove the authenticity of Alice as the sender.</li></ul></li></ul><h3 id=131-comparision>13.1. Comparision</h3><ul><li>Let us begin by looking at the differences between conventional signatures and digital signatures.</li></ul><h4 id=1311-inclusion>13.1.1 Inclusion</h4><ul><li>A conventional signature is included in the document; it is part of the document.</li><li>But when we sign a document digitally, we send th signature as a separate document.</li></ul><h4 id=1312-verification-method>13.1.2. Verification Method</h4><ul><li>For a conventional signature, wehn the recipient receives a document, she compares the signature on the document with the signature on file.</li><li>For a digital signature, the recipient receives the message and the signature. The recipient needs to apply a verification techinique to the combination of the message and the signature to verify the authenticity.</li></ul><h4 id=1313-relationship>13.1.3. Relationship</h4><ul><li>For a conventional signature, there is normally a one-to-many relationship between a signature and documents.</li><li>For a digital signature, there is a one-to-one relationship between a signature and a message.</li></ul><h4 id=1314-duplicity>13.1.4. Duplicity</h4><ul><li>In conventional signature, a copy of the signed document can be distinguished from the original one on file.</li><li>In digital signature, there is no such distinction unless there is a factor of time one the document.</li></ul><h3 id=132-process>13.2. Process</h3><ul><li>The sender uses a signing algorithm to sign the message. The message and teh signature are sent to the receiver. The receiver receives the message and the signature and applies the verifying algorithm to the combination. If the result is true, the message is accepted; otherwise, it is rejected.</li></ul><h4 id=1321-need-for-keys>13.2.1. Need for Keys</h4><ul><li>A digital signature needs a public-key system.</li><li>The signer signs with her private key;</li><li>the verifier verifies with the signer&rsquo;s public key.</li><li>공개 키 암호의 두가지 용도:<ul><li>암호복호(기밀성 유지): the private and public keys of the receiver 사용</li><li>디지털서명(저자 확인) : the private and public keys of the sender 사용</li></ul></li></ul><h4 id=1322-signing-the-digest>13.2.2. Signing the Digest</h4><ul><li>공개키 암호시스템: 긴 메시지에서 속도 느림.</li><li>메시지 대신 메시지 다이제스트에 서명</li></ul><h3 id=133-services>13.3 Services</h3><ul><li>message confidentiality, message authentication, message integrity, and nonrepudiation.</li><li>A digital signature can directly provide the last tree; for message confidentiality we still need encryption/decryption.</li></ul><h4 id=1331-message-authentication>13.3.1. Message Authentication</h4><ul><li>message authentication (or data-origin authentication)</li><li>메시지 인증: 메시지의 저자(보낸 사람) 확인</li></ul><h4 id=1332-message-integrity>13.3.2. Message Integrity</h4><ul><li>메시지와 디지털 서명은 1대1 관계</li><li>미시지가 바뀌면 그에 따라 디지털서명도 바뀌어야 함</li><li>디지털 서명을 새로 만드려면 개인 키 필요</li></ul><h4 id=1333-nonrepudiation>13.3.3. Nonrepudiation</h4><ul><li>디지털 서명을 서명자가 부인할 수 없음</li></ul><h4 id=1334-confidentiality>13.3.4. Confidentiality</h4><ul><li>디지털 서명은 기밀성을 제공하지 못한다.</li><li>기밀성 보장은 반드시 암복호화가 적용된 다른 레이어를 통해서 제공되야한다.</li></ul><h3 id=135-digitial-signature-schemes>13.5. Digitial Signature Schemes</h3><ul><li>Several digital signature schemes have evolved during the last few decades. Some of them have been implemented.</li></ul><h3 id=136-variations-and-application>13.6. Variations and Application</h3><h4 id=1361-variations>13.6.1. Variations</h4><ul><li>Time Stamped Signatures:<ul><li>시간 정보를 포함한 서명(replay attack 방지)</li></ul></li><li>Blind Signatures:<ul><li>문서 내용을 보여주지 않고 서명하기</li></ul></li></ul><h2 id=chapter-14-entity-authentication>Chapter 14. Entity Authentication</h2><h3 id=141-introduction>14.1. Introduction</h3><ul><li>Entity authentication is a technique designed to let one party prove the identity of another party. AN entity can be a person, a process, a client, or a server. The entity whose identity needs to be proved is called the claimant; the party that tries to prove the identity of the claimant is called the verifier.</li></ul><h4 id=1411-message-versus-entity-authentication>14.1.1. Message Versus Entity Authentication</h4><ul><li>Two differences between message authentication (data-origin authentication), and entity authentication:<ol><li>Message authentication might not happen in real time; entity authentication does. When Bob authenticates the message, Alice may or may not be present in the communication process. MAC, 디지털 서명의 경우
In Entity authentication, Alice needs to be online and to take part in the process. Only after she is authenticated message can be communicated between them.</li><li>Message authentication simply authenticates one message; the process needs to be repeated for each new message.
Entity authentication authenticates the claimant for the entire duration of a session.</li></ol></li></ul><h4 id=1412-verification-categories>14.1.2. Verification Categories</h4><ul><li>Something known:<ul><li>Password, PIN, secret key, private key</li></ul></li><li>Something possessed:<ul><li>ID card, Passport</li></ul></li><li>Something inherent:<ul><li>Fingerprint, voice, handwriting</li></ul></li></ul><h3 id=142-passwords>14.2. Passwords</h3><ul><li><p>The simplest and old method of entity authentication is the password-based authentication, where the password is something that the claimant knows.</p></li><li><p>Hashing the password</p></li><li><p>Dictionary Attack:</p><ul><li>Salting the password</li></ul></li></ul><h3 id=143-challenge-response>14.3. Challenge-Response</h3><ul><li>In password authentication, the claimant proves her identity by demonstrating that she knows a secret, the password. In challenge-reponse authentication, the claimant proves that she knows a secret without sending it.</li></ul><h4 id=1431-using-a-symmetric-key-cipher>14.3.1. Using a Symmetric-Key Cipher</h4><ul><li>일방향 인증:<ul><li>verifier가 평문을 보냄, claimant는 이를 암호화 해서 보내고 verifier는 대칭키로 이를 해제함으로써 claimant가 key를 알고있다고 판단.</li></ul></li><li>양방향 인증:<ul><li>verifier가 평문을 보냄, claimant가 생성한 평문과 받은 평문을 붙여서 암호화 해서 보냄. 이를 verifier가 복호화후 평문의 순서를 바꿔 암호화하여 전송</li><li>상호 인증</li></ul></li></ul><h4 id=1433-using-a-public-key-cipher>14.3.3. Using a Public-Key Cipher</h4><h3 id=144-zero-knowledge>14.4. Zero-Knowledge</h3><ul><li>In zero-knowledge authentication, the claimant does not reveal anything that might endanger the confidentiality of the secret. The claimant proves to the verifier that she knows a secret, without revealing it. The interactions are so designed that they cannot lead to revealing or guessing the secret.</li><li>Cave Example, Two balls and the color-blind friend</li></ul></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>