<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>오토마타와 형식언어 정리</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>오토마타와 형식언어 정리</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[lectures]]</button></div></div></div><div><h2>오토마타와 형식언어 정리</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/lectures/automata.md><h5>created : Tue, 19 Oct 2021 21:46:37 +0900</h5><h5>modified : Sun, 26 Dec 2021 17:51:01 +0900</h5></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#12-three-basic-concepts-languages>1.2 Three basic concepts Languages</a></li><li><a href=#string-operations>String Operations</a></li><li><a href=#languages>Languages</a></li><li><a href=#grammars>Grammars</a></li><li><a href=#automata>Automata</a></li></ul><ul><li><a href=#21-deterministic-finite-automata-dfa>2.1 Deterministic Finite Automata (DFA)</a></li><li><a href=#determistic-finite-automata-dfa>Determistic Finite Automata (DFA)</a></li><li><a href=#extended-transition-function-sigma>Extended Transition Function $\sigma^*$</a></li><li><a href=#languages-accepted-by-dfas>Languages Accepted by DFAs</a></li><li><a href=#regular-languages>Regular Languages</a></li><li><a href=#non-determistic-automatanfa>Non-determistic automata(NFA)</a><ul><li><a href=#lambda---transition>$\lambda$ - transition</a></li><li><a href=#formal-definition-of-nfas>Formal Definition of NFAs</a></li><li><a href=#extened-transition-function-sigma>Extened Transition Function $\sigma^*$</a></li><li><a href=#why-nondeterminism>Why Nondeterminism?</a></li><li><a href=#equivalence-of-dfas-and-nfas>Equivalence of DFAs and NFAs</a></li></ul></li></ul><ul><li><a href=#61-methods-for-transforming-grammars>6.1 Methods for transforming grammars</a><ul><li><a href=#a-substitution-rule-치환-규칙>A Substitution Rule (치환 규칙)</a></li><li><a href=#parsing>Parsing</a></li><li><a href=#1-removing-lambda---productions>1) Removing $\lambda$ - productions</a></li></ul></li><li><a href=#92-combining-turing-machines-for-complicated-tasks>9.2 Combining Turing machines for complicated tasks</a><ul><li><a href=#combining-tms>Combining TMs</a></li></ul></li><li><a href=#93-turings-thesis-튜링-명제가설>9.3 Turing&rsquo;s Thesis, 튜링 명제(가설))</a><ul><li><a href=#turings-thesis-뒷받침-하는-것들>Turing&rsquo;s Thesis 뒷받침 하는 것들</a></li><li><a href=#definition-of-algorithm>Definition of Algorithm</a></li></ul></li></ul><ul><li><a href=#the-standard-model>The Standard model</a></li><li><a href=#101-102-variations-of-the-standard-model>10.1, 10.2: Variations of the Standard Model</a></li><li><a href=#103-nondeterministic-turing-machines>10.3 Nondeterministic Turing Machines</a><ul><li><a href=#theorem-102>Theorem 10.2</a></li></ul></li><li><a href=#104-a-universal-turing-machine>10.4 A Universal Turing Machine</a><ul><li><a href=#universal-turing-machine>Universal Turing Machine</a></li></ul></li><li><a href=#set-theory집합론-uncountable-sets-enumeration-procedure>Set Theory(집합론), (Un)countable Sets, Enumeration Procedure</a><ul><li><a href=#theorem-103>Theorem 10.3:</a></li><li><a href=#enumeration-proceduer>Enumeration Proceduer</a></li></ul></li></ul><ul><li><a href=#recursively-enumerablere-languages>Recursively Enumerable(r.e.) Languages</a></li><li><a href=#recursive-languages>Recursive Languages</a></li><li><a href=#languages-that-are-not-recursively-enumerable>Languages that are Not Recursively Enumerable</a><ul><li><a href=#theorem-111>Theorem 11.1</a></li></ul></li><li><a href=#112-113-unrestricted-grammars--context-sensitive-grammars>11.2, 11.3 Unrestricted Grammars & Context-sensitive grammars</a><ul><li><a href=#unrestricted-grammar>Unrestricted Grammar</a></li><li><a href=#context-sensitive-grammar>Context-sensitive Grammar</a></li><li><a href=#context-sensitive-language>Context-sensitive language</a></li></ul></li><li><a href=#114-the-chomsky-hierarchy>11.4 The Chomsky Hierarchy</a></li></ul><ul><li><a href=#121-problems-that-cannot-be-solved-by-tms>12.1 Problems that cannot be solved by TMs</a><ul><li><a href=#the-halting-problemhp>The Halting Problem(HP)</a></li><li><a href=#undecidable-problems-for-cfl>Undecidable problems for CFL</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h1 id=chapter-1-introduction>Chapter 1. Introduction</h1><h2 id=12-three-basic-concepts-languages>1.2 Three basic concepts Languages</h2><ul><li>String : A sequence of symbolx</li><li>Alphabet : $\Sigma = { a, b }$</li></ul><h2 id=string-operations>String Operations</h2><ul><li>Concatenation(연결):<ul><li>$w = a_1 a_2 &mldr; a_n$</li><li>$v = b_1 b_2 &mldr; b_m$</li><li>$wv = a_1 a_2 &mldr; a_n b_1 b_2 &mldr; b_m$</li><li>교환법칙 성립X</li></ul></li><li>Reverse(역):<ul><li>$w = a_1 a_2 &mldr; a_n$</li><li>$w^R = a_n &mldr; a_2 a_1$</li></ul></li><li>Length(길이):<ul><li>$w = a_1 a_2 &mldr; a_n$</li><li>$\vert w \vert = n$</li></ul></li><li>Length of concatenation:<ul><li>$\vert u v \vert = \vert u \vert + \vert v \vert$</li></ul></li><li>Empty Strings(공스트링):<ul><li>A string with no symbools : $\lambda$</li><li>Observation : $\vert \lambda \vert = 0, \lambda w = w \lambda = w$</li></ul></li><li>Substring:<ul><li>Substring of string: a subsequnce of consecutive characters</li></ul></li><li>Prefix and Suffix:<ul><li>prefix와 suffix는 substring이다.</li><li>$\lambda$도 substring이기 때문에 prefix, suffix에 포함된다.</li></ul></li><li>Power(제곱):<ul><li>$w^n = w w &mldr; w$</li><li>Definition: $w^0 = \lambda$</li></ul></li><li>The * operation(스타 연산):<ul><li>$\Sigma^*$ : the set of all possible strings from alphabet $\Sigma$</li><li>무한집합이다.</li></ul></li><li>The + operation(플러스 연산):<ul><li>$\Sigma^+$ : the set of all possible strings from alphabet $\Sigma$ except $\lambda$</li></ul></li></ul><h2 id=languages>Languages</h2><ul><li>Languages:<ul><li>A language is any subset of $\Sigma^*$</li></ul></li><li>Operations on Lanugages:<ul><li>The usual set operations:<ul><li>union, intersection, complement, relative complement</li></ul></li><li>Reverse:<ul><li>Definition $L = { w^R : w \in L }$</li></ul></li><li>Concatenation:<ul><li>Definition: $L_1 L_2 = {xy : x \in L_1, y \in L_2 }$</li><li>교환법칙이 성립하지 않는다.</li></ul></li><li>Another Operation:<ul><li>Definition $L^n = L L &mldr; L$</li><li>Special case $L^0 = { \lambda }$</li></ul></li><li>Star-Closure:<ul><li>Definition: $L^* = L^0 \cup L^1 \cup L^2 \cup \cdots$</li></ul></li><li>Positive Closure:<ul><li>Definition: $L^+ = L^1 \cup L^2 \cup \cdots$</li></ul></li></ul></li></ul><h2 id=grammars>Grammars</h2><ul><li>Grammar: $S \rightarrow aSb, S \rightarrow \lambda$</li><li>Derivation of sentence string:<ul><li>$S \Rightarrow aSb \Rightarrow ab$</li></ul></li><li>Language of the Grammer:<ul><li>example: $S \rightarrow aSb, S \rightarrow \lambda$:<ul><li>$L = { a^n b^n : n \le 0 }$</li></ul></li></ul></li><li>More Notation:<ul><li>Grammar:$G=(V, T, S, P)$:<ul><li>V : Set of variables</li><li>T : Set of terminal symbols</li><li>S : Start variable</li><li>P : Set of Productions</li></ul></li></ul></li><li>Sentential Form:<ul><li>A setence that contains variables and terminals</li><li>$S \stackrel{*}{\Rightarrow} aaabbb$</li></ul></li></ul><h2 id=automata>Automata</h2><ul><li>Different kinds of automata:<ul><li>Automata are distinguished by the temporary memory</li><li>Finite Automata : no temporary memory</li><li>Pushdown Automata : stack</li><li>Turing Machines : random access memory</li></ul></li><li>Power of Automata:<ul><li>Finite Automata &lt; Pushdown Automata &lt; Turing Machine</li><li>More power means it can solve more compational problems</li></ul></li></ul><h1 id=chatper-2-finite-automata>Chatper 2. Finite Automata</h1><h2 id=21-deterministic-finite-automata-dfa>2.1 Deterministic Finite Automata (DFA)</h2><ul><li>Transition Graph</li></ul><h2 id=determistic-finite-automata-dfa>Determistic Finite Automata (DFA)</h2><ul><li>$M = (Q, \Sigma, \sigma, q_0, F)$:<ul><li>$Q$ : set of states</li><li>$\Sigma$: input alphabet</li><li>$\sigma$: transition $\sigma : Q \times \Sigma \rightarrow Q$</li><li>$q_0$ : initial (or start) state</li><li>$F$ : set of final states $F \subseteq Q$</li></ul></li></ul><h2 id=extended-transition-function-sigma>Extended Transition Function $\sigma^*$</h2><ul><li>$\sigma^* : Q \times \Sigma^* \rightarrow Q$</li></ul><h2 id=languages-accepted-by-dfas>Languages Accepted by DFAs</h2><ul><li>Definition:<ul><li>The language L(M) contains all inputs strings accepted by M</li></ul></li></ul><h2 id=regular-languages>Regular Languages</h2><ul><li>Definition:<ul><li>A language L is regular if there is a DFA M such that L=L(M)</li></ul></li></ul><h2 id=non-determistic-automatanfa>Non-determistic automata(NFA)</h2><ul><li>An NFA accepts a string:<ul><li>when there is a computation of the NFA that accepts the string</li></ul></li><li>An NFA rejects a string:<ul><li>when there is no computation of the NFA that accepts the string</li></ul></li></ul><h3 id=lambda---transition>$\lambda$ - transition</h3><h3 id=formal-definition-of-nfas>Formal Definition of NFAs</h3><ul><li>$M = (Q, \Sigma, \sigma, q_0, F)$:<ul><li>$Q$ : Set of states</li><li>$\Sigma$ : Input alphabet</li><li>$\sigma$ : Transition function $\sigma : Q \times (\Sigma \cup { \lambda }) \rightarrow 2^Q$</li><li>$q_0$ : Initial state</li><li>$F$ : Final state</li></ul></li></ul><h3 id=extened-transition-function-sigma>Extened Transition Function $\sigma^*$</h3><ul><li>Informally:<ul><li>$q_j \in \sigma^*(q_i, w)$ : there is a walk from $q_i$ to $q_j$ with label w</li></ul></li><li>Formally:<ul><li>The language accepted by NFA M is:<ul><li>$L(M) = {w, &mldr;}$</li><li>where $\sigma^* (q_0, w) = {q_i, &mldr; }$ and there is some $q_k \in F$</li></ul></li></ul></li></ul><h3 id=why-nondeterminism>Why Nondeterminism?</h3><ul><li>Best case in multiple choices:<ul><li>Automatic backtracking</li><li>Hide unncessary detils</li></ul></li><li>Good fit to (transform) other notations</li><li>Basically, close to human:<ul><li>Easy to design.</li></ul></li></ul><h3 id=equivalence-of-dfas-and-nfas>Equivalence of DFAs and NFAs</h3><ul><li>Equivalence of Machines:<ul><li><p>Definition for automata:</p><ul><li>Machine $M_1$ is equivalent to machine $M_2$ if $L(M_1) = L(M_2)$</li></ul><h1 id=chapter-6-simplifications-of-context-free-grammars>Chapter 6. Simplifications of Context-Free Grammars</h1></li></ul></li></ul><h2 id=61-methods-for-transforming-grammars>6.1 Methods for transforming grammars</h2><h3 id=a-substitution-rule-치환-규칙>A Substitution Rule (치환 규칙)</h3><p>$$
\begin{aligned}
A \rightarrow aB \
A \rightarrow aaA \
A \rightarrow abBC \
B \rightarrow aA \
B \rightarrow b
\end{aligned}
$$</p><ul><li><p>Equivalent grammar (Substitution $B \rightarrow b$)
$$
\begin{aligned}
S \rightarrow aB \vert ab \
A \rightarrow aaA \
A \rightarrow abBC \vert abbc \
B \rightarrow aA
\end{aligned}
$$</p></li><li><p>Equivalent grammar (Substitution $B \rightarrow aA$)
$$
\begin{aligned}
S \rightarrow aB \vert ab \vert aaA \
A \rightarrow aaA \
A \rightarrow abBc \vert abbc \vert abaAc
\end{aligned}
$$</p></li><li><p>Equivalent grammer (Erase unused variable)</p></li></ul><p>$$
\begin{aligned}
S \rightarrow ab \vert aaA \
A \rightarrow aaA \
A \rightarrow abbc \vert abaAc
\end{aligned}
$$</p><ul><li>In general:<ul><li>$$\begin{aligned} A \rightarrow xBz \ B \rightarrow y_1 \vert y_2 \vert \cdots \vert y_n \end{aligned}$$</li><li>Substitute $B \rightarrow y_1 \vert y_2 \vert \cdots y_n$</li><li>$$A \rightarrow xy_1 z \vert x y_2 z \vert \cdots \vert x y_n z$$</li></ul></li></ul><h3 id=parsing>Parsing</h3><ul><li>$\lambda$ - productions, unit productions 은 없는 것이 parsing에 좋음.</li></ul><h3 id=1-removing-lambda---productions>1) Removing $\lambda$ - productions</h3><ul><li>가정: $\lambda \not \in L(G)$</li><li>Nullable Variables 정의:<ul><li>Nullable Variables: 공스트링을 만들 수 있는 변수들</li></ul></li><li>Nullable variables을 포함하는 각 productions 에 대해서 substitution 적용</li></ul><h2 id=92-combining-turing-machines-for-complicated-tasks>9.2 Combining Turing machines for complicated tasks</h2><ul><li>Tranducer
$$ input \rightarrow \text{Turing machine} \rightarrow output$$</li><li>Example:<ul><li>$f(x, y) = \begin{cases} x + y & \text{ if } x \ge y \ 0 & \text{ if } x &lt; y\end{cases}$</li><li>Comparer, Adder, Eraser를 사용해서 구현</li></ul></li></ul><h3 id=combining-tms>Combining TMs</h3><ul><li>앞에서 만든 comparer, adder 이용</li><li>eraser: 모든 1을 blank로 바꾸기</li><li>Example:<ul><li>Multipler:<ul><li>repeat until x contains no more 1:<ul><li>find a 1 in x and replace it with an a</li><li>replace the leftmost 0 by 0y</li></ul></li><li>replace all a&rsquo;s with 1&rsquo;s</li></ul></li></ul></li></ul><h2 id=93-turings-thesis-튜링-명제가설>9.3 Turing&rsquo;s Thesis, 튜링 명제(가설))</h2><ul><li>Any computation that can be done by mechanical means can be done by a Turing Machine</li><li>A computation is mechincal if and only if it can be performed by a Turing Machine</li></ul><h3 id=turings-thesis-뒷받침-하는-것들>Turing&rsquo;s Thesis 뒷받침 하는 것들</h3><ul><li>Anything that can be done on any existing digital computer can also be done by a TM</li><li>No one has yet been able to find a problem, solvable by an algorithm, for which a TM program cannot be written</li><li>Many alternative models have been proposed for mechanical means, but none of them is more powerful than TMs</li></ul><h3 id=definition-of-algorithm>Definition of Algorithm</h3><ul><li>An algorithm for function $f(w)$ is a Turing Machine which computes $f(w)$</li><li>It should complete computation; in other words, it should halt.</li><li>When we say:<ul><li>There exists an algorithm</li></ul></li><li>We mean:<ul><li>There exists a Turing Machine that executes the algorithm</li></ul></li></ul><h1 id=chapter-10-other-models-of-turing-machine>Chapter 10 Other Models of Turing Machine</h1><h2 id=the-standard-model>The Standard model</h2><ul><li>Infinite Tape</li><li>Read-Write Head(Left or Right move)</li><li>Control Unit (Deterministic)</li></ul><h2 id=101-102-variations-of-the-standard-model>10.1, 10.2: Variations of the Standard Model</h2><ul><li>TMs with Stay:<ul><li>The head can stay in the same position</li></ul></li><li>TMs with a Multiple Track Tape:<ul><li>tracks</li></ul></li><li>Semi-Infinite Tape:<ul><li>양방향 무한이 아닌, 왼쪽 끝이 존재한다.</li></ul></li><li>The Off-Line Machine:<ul><li>Input File with Read-only Head</li><li>Control Unit</li><li>Tape with Read-Write Head</li></ul></li><li>Multi-tape Turing Machines:<ul><li>tape이 여러 개 있다.</li></ul></li><li>Two-Dimensional Turing Machines:<ul><li>2차원 tape</li><li>Moves : LRUD</li></ul></li><li>All variants are equally powerful as the standard TM:<ul><li>모든 변형들이 standard와 동등하다는 것을 증명할 수 있음</li><li>Turing&rsquo;s thesis에 의하면 당연하다.</li></ul></li></ul><h2 id=103-nondeterministic-turing-machines>10.3 Nondeterministic Turing Machines</h2><ul><li><p>Standard TM의 Transition Function:</p><ul><li>$\delta(q_1, a) = q_2, b, R)$</li><li>$\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times { L, R }$</li></ul></li><li><p>Nondeterministic Choice:</p><ul><li>$\delta(q_1, a) = {(q_2, b, L), (q_3, c, R) }$</li><li>$\delta : Q \times \Gamma \rightarrow 2^{Q \times \Gamma \times {L, R }}$</li></ul></li><li><p>Input string $w$ is accepted if a computation leading to acceptance exists:</p><ul><li>$q_0 w \overset{*}{\vdash} xq_fy$</li><li>$q_0 w$ : Initial configuration</li><li>$q_f$ : Final state</li><li>$x q_f y$: Final Configuration</li></ul></li><li><p>Nondeterministic Machines simulate Standard(deterministic) Machines:</p><ul><li>Every deterministic machine is also a nondeterministic machine.</li></ul></li><li><p>Deterministic machines simulate Non-deterministic machines:</p><ul><li>Deterministic machine: Keeps track of all possible computations</li></ul></li></ul><h3 id=theorem-102>Theorem 10.2</h3><ul><li>The class of deterministic TMs and the class of nondeterministic TMs are equivalent</li></ul><h2 id=104-a-universal-turing-machine>10.4 A Universal Turing Machine</h2><h3 id=universal-turing-machine>Universal Turing Machine</h3><ul><li>Reprogrammable TM</li><li>General-purposed TM</li><li>Simulates any other Turing Machine</li><li>Universal Turing Machine simulates any other Turing Machine $M$</li><li>Universal TM의 구조:<ul><li>Tape for the description of M</li><li>Tape for the tape contents of M</li><li>Tape for the state of M</li></ul></li><li>State, Tape Alphabet can be encoded as unary formats.</li><li>Transition can be encoded using separator</li><li>In other words, a turing machine is described with a binary string of 0&rsquo;s and 1&rsquo;s</li><li>Therefore:<ul><li>The set of Turing machines forms a lanaguage:<ul><li>each string of the language is the binary encoding of a Turing Machine</li></ul></li></ul></li></ul><h2 id=set-theory집합론-uncountable-sets-enumeration-procedure>Set Theory(집합론), (Un)countable Sets, Enumeration Procedure</h2><ul><li><p>Infinite sets are either:</p><ul><li>Countable(모든 유한 집합, 정수집합) or Uncountable(실수 집합)</li></ul></li><li><p>Countable set:</p><ul><li>Infinite Countable set:<ul><li>There is a one to one correspondence between elements of the set and positive integers</li></ul></li></ul></li><li><p>If for a set there is an enumeration procedure, then the set is countable.</p></li></ul><h3 id=theorem-103>Theorem 10.3:</h3><ul><li>The set of all Turing Machines is countable</li><li>Proof:<ul><li>Any Turing Machine can be encoded with a binary string of 0&rsquo;s and 1&rsquo;s</li><li>Find an enumeration procedure for the set of Turing Machine strings</li></ul></li></ul><h3 id=enumeration-proceduer>Enumeration Proceduer</h3><ul><li>Repeat<ol><li>Generate the next binary string of 0&rsquo;s and 1&rsquo;s in proper order</li><li>Check if the string describes a Turing Machine:<ul><li>if YES: output it</li><li>if NO : ignore it</li></ul></li></ol></li></ul><hr><ul><li>Note<ol><li>Not every langage is countable.</li><li>If there exists an enumeration procedure, the set is countable.</li><li>Not every language is enumerable.</li></ol></li></ul><h1 id=chap-11-a-hierarchy-of-formal-languages-and-automata>Chap 11 A Hierarchy of Formal Languages and Automata</h1><ul><li>Regular Langauges &lt; Context-Free Langages &lt; Languages accepted by Turing Machines</li></ul><h2 id=recursively-enumerablere-languages>Recursively Enumerable(r.e.) Languages</h2><ul><li><p>A TM M defines a language, as usual.</p><ul><li>$L(M) = { w : q_0 w \overset{*}{\vdash} x_1 q_f x_2 }$</li><li>where $q_f$ is a final state.</li></ul></li><li><p>A language is recursively enumerable (r.e.) if there exists a Turing machine that accepts it.</p></li><li><p>For a string w in L(M), M halts in a final state. (halts & says &ldquo;yes&rdquo;)</p></li><li><p>For a string w not in L(M), either M halts in a non-final state (halts & says &ldquo;no&rdquo;) or runs forever (i.e. infinite loop) (no answer)</p></li></ul><h2 id=recursive-languages>Recursive Languages</h2><ul><li><p>A language L on $\Sigma$ is said to be recursive if there exists a Turing machine that accepts L and that halts on every w in $\Sigma^+$</p></li><li><p>In other words, a language is recursive if and only if there exists a membership algorithm for it.</p></li><li><p>non-recursive $\Leftrightarrow$ 알고리즘으로 membership을 판단할 수 없다</p></li><li><p>recursive : always finish</p></li><li><p>Example : Recursive Languages</p><ul><li>Every Context-Free language is a recursive language. because CFL is always applied CYK algorithm</li></ul></li></ul><h2 id=languages-that-are-not-recursively-enumerable>Languages that are Not Recursively Enumerable</h2><ul><li>A Language that has no Turing machine accepting it.</li><li>A class of languages that the Turing Machine cannot accept.</li></ul><h3 id=theorem-111>Theorem 11.1</h3><ul><li><p>Let S be an infinite countable set</p></li><li><p>The powerset $2^S$ of S is uncountable</p></li><li><p>Proof:</p><ul><li>Since $S$ is countable, we can write (enumeration procedure)</li><li>$S = { s_1, s_2, s_3, &mldr; }$</li><li>We encode each element of the power set with a binary string of 0&rsquo;s and 1&rsquo;s (bitvector)</li><li>Let&rsquo;s assume (for contradiction) that the powerset is countable.</li><li>Then, we can enumerate the elements of the powerset by an enumeration procedure.</li><li>We define x is a diagonal component&rsquo;s complement.</li><li>x must be an element of the powerset. Hence, it should also be on the list.</li><li>However, x does not equal to all elements.</li><li>So, it cannot be on the list. $\Rightarrow$ Contradiction!</li><li>Since, we proved that &ldquo;The powerset $2^S$ of $S$ is uncountable&rdquo;</li></ul></li><li><p>Other example:</p><ul><li>$\Sigma = {a, b }$</li><li>The set of all Strings:<ul><li>$S = { a, b }^* = { \lambda, a, b, aa, ab, ba, bb, aaa, aab, &mldr; }$ is infinite and countable.</li><li>The powerset of $S$ contains all languages</li></ul></li></ul></li><li><p>Conclusion:</p><ul><li>There are some languages not accepted by Turing Machines</li><li>Theorem 11.2: There exist languages that are not r.e..</li><li>(These languages cannot be described in mechnical computation methods)</li><li>Lnaguages not accepted by Turing machines</li></ul></li><li><p>Theorem 11.3</p><ul><li>$\Sigma = { a}$</li><li>Consider the set of all TMs with $\Sigma$</li><li>This set is countable by Theorem 10.3</li><li>$M_1, M_2, &mldr;.$ : enumeration of TMs</li><li>$a, a^2, &mldr;$ : all possible strings</li><li>Define a new language & its complement:<ul><li>$L = { a^i : M_i \text{ accepts } a^i}$</li><li>$\bar L = { a^i : M_i \text{ does not accepts } a^i}$</li></ul></li><li>We prove * Will show $\bar L$ is not r.e.*:<ul><li>Assume $\bar L$ is r.e.</li><li>Then therer is a TM $M_k$ that accepts $\bar L$</li><li>Consider string $a^k$:<ul><li>$(M_k, a^k) = 1 \text{ or } 0?$</li><li>$a^k \in L \Leftrightarrow M_k \text{ accepts } a^k \Leftrightarrow a^k \in \bar L \Leftrightarrow a^k \not \in L$</li><li>$a^k \in \bar L \Leftrightarrow M_k \text{ not accepts } a^k \Leftrightarrow a^k \not \in \bar L$</li></ul></li><li>Contradiction! So, $\bar L$ is not r.e.</li></ul></li></ul></li></ul><p>-Theorem 11.5</p><ul><li>$L = { a^i : M_i \text{ accepts } a^i }$ is r.e., but not recursive</li></ul><h2 id=112-113-unrestricted-grammars--context-sensitive-grammars>11.2, 11.3 Unrestricted Grammars & Context-sensitive grammars</h2><h3 id=unrestricted-grammar>Unrestricted Grammar</h3><ul><li>A grammar $G = (V, T, S, P)$ is unrestricted if all the productions are of the form $x \rightarrow y$ where $x \in (V \cup T)^+$ and $y \in (V \cup T)^*$</li><li>unrestricted grammars = TMs = r.e. languages</li><li>Theorem 11.6 and 11.7<ul><li>Any language generated by an unrestricted grammar is recursively enumerable.</li><li>For every recursively enumerable language L, there exists an unrestricted grammar G such that L=L(G)</li></ul></li></ul><h3 id=context-sensitive-grammar>Context-sensitive Grammar</h3><ul><li>A grammar $G = (V, T, S, P)$ is context-sensitive it all productions are of the form $x \rightarrow y$ where $x,y \in (V \cup T)^+$ and $\vert x \vert \le \vert y \vert$</li><li>context-sensitive language = context-sensitive grammar 가 존재한다.</li><li>Every context-free language is context-sensitive.</li><li>Example:<ul><li>$L = { a^n b^n c^n : n \ge 1 }$</li><li>It is not context-free, but context-sensitive.</li></ul></li></ul><h3 id=context-sensitive-language>Context-sensitive language</h3><ul><li>Without proof.</li><li>Every context-sensitive language is recursive.</li><li>There exists a recursive language that is not context-sensitive.</li></ul><h2 id=114-the-chomsky-hierarchy>11.4 The Chomsky Hierarchy</h2><ul><li>fa &lt; pda &lt; lba &lt; TM</li><li>regular grammar &lt; cfg &lt; csg &lt; unrestricted grammar</li><li>type 3 &lt; type 2 &lt; type 1 &lt; type 0</li><li>Extented Hierarchy<ul><li>$L_{REG} &lt; L_{DCF} &lt; L_{CF} &lt; L_{CS} &lt; L_{REC} &lt; L_{RE}$</li></ul></li></ul><h1 id=chap-12-limits-of-algorithmic-computation>Chap 12 Limits of Algorithmic Computation</h1><h2 id=121-problems-that-cannot-be-solved-by-tms>12.1 Problems that cannot be solved by TMs</h2><h3 id=the-halting-problemhp>The Halting Problem(HP)</h3><ul><li>Turing이 증명</li><li>최초의 undecidable problem</li><li>undecidable problem:<ul><li>Problems that cannot be solved by TMs (mechanical means, algorithms)</li></ul></li><li>Proof:<ul><li>Assume there is an algorithm that decides (solves) HP</li></ul><pre tabindex=0><code>halt(string P, i)
	if (program P halts on input i)
		return yes
	else
		return no

trouble (string s)
	if (halt(s, s) = no)
		return yes
	else
		loop forever
</code></pre><ul><li>trouble(trouble) 은 halt 인가? not halt 인가?<ul><li>trouble(trouble) 이 halt 라고 해보자</li><li>halt(trouble, trouble) 은 no를 반환한다는 것을 의미한다.</li><li>이는 trouble(trouble) 이 not halt임을 의미한다.</li><li>반대의 경우에도 마찬가지의 모순 발생</li></ul></li><li>따라서 HP is undecidable</li></ul></li></ul><h3 id=undecidable-problems-for-cfl>Undecidable problems for CFL</h3><ol><li>Is a cfg unambiguous?</li><li>Are two cfg&rsquo;s equivalent?</li><li>Do two cfg&rsquo;s generate any common string?</li></ol></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>