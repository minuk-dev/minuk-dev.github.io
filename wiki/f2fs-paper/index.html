<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>F2FS- A New File System for Flash Storage</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent: #00a3d2;--border-width:  5px }</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on('click',function(){$('.collapse').collapse('hide');})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-98056974-1');</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>F2FS- A New File System for Flash Storage</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:makerdark98@gmail.com><i class="fa fa-envelope-o"></i></a></li><li class=navbar-icon><a href=https://github.com/makerdark98/><i class="fa fa-github"></i></a></li><li><div style=max-width:250px;display:inline-block;max-height:40px><script async src="https://cse.google.com/cse.js?cx=003491619885022567520:wnnypdnx4aj"></script><div class=gcse-search></div></div></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick="(function(elem){elem.querySelector('a').click();})(this);">
<i class="fa fa-arrow-left"></i>[[f2fs]]</button></div></div><div style=margin-left:auto><div style=display:flex><div style=margin-left:auto><div class=wiki-history></div></div></div><script src=/js/localhistory.js></script><script>var now="f2fs-paper"
pushHistory(now);</script></div></div><div><h2>F2FS- A New File System for Flash Storage</h2><a href=https://github.com/makerdark98/makerdark98.github.io/blame/master/src/content/wiki/f2fs-paper.md><h5>created : Thu, 02 Jul 2020 22:31:19 +0900</h5><h5>modified : Thu, 02 Jul 2020 22:35:15 +0900</h5></a><a href=http://makerdark98.dev/tags/f2fs><kbd class=item-tag>f2fs</kbd></a>
<a href=http://makerdark98.dev/tags/paper><kbd class=item-tag>paper</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#a-flash-memory의-한계점>a. Flash Memory의 한계점</a></li><li><a href=#b-flash-memory-사용의-증가>b. Flash Memory 사용의 증가</a></li><li><a href=#c-flash-memory에-대한-이해-부족으로-인한-단점>c. Flash Memory에 대한 이해 부족으로 인한 단점</a></li><li><a href=#d-기존의-연구>d. 기존의 연구</a></li><li><a href=#e-f2fs의-특징>e. F2FS의 특징</a></li></ul><ul><li><a href=#21-on-disk-layout>2.1 On-Disk Layout</a><ul><li><a href=#superblocksb>Superblock(SB)</a></li><li><a href=#checkpointcp>Checkpoint(CP)</a></li><li><a href=#segment-information-tablesit>Segment Information Table(SIT)</a></li><li><a href=#node-address-tablenat>Node Address Table(NAT)</a></li><li><a href=#segment-summary-areassa>Segment Summary Area(SSA)</a></li><li><a href=#main-area>Main Area</a></li></ul></li><li><a href=#22-file-structure>2.2. File Structure</a><ul><li><a href=#node-structure>Node Structure</a></li></ul></li><li><a href=#23-directory-structure>2.3. Directory Structure</a></li><li><a href=#24-multi-head-logging>2.4. Multi-Head Logging</a><ul><li><a href=#ftlflash-translation-layer-algorithm>FTL(Flash Translation Layer) Algorithm</a></li></ul></li><li><a href=#25-cleaning>2.5 Cleaning</a><ul><li><a href=#foreground>Foreground</a></li><li><a href=#cleaning-단계>Cleaning 단계</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><ul><li>Changman Lee, Dongho Sim, Joo-Young Hwang, and Sangyeun Cho, Samsung Electronics Co., Ltd.</li><li>USENIX Conference on File and Stoarage Technologies (FAST 15)</li></ul><hr><h1 id=1-introduction>1. Introduction</h1><h2 id=a-flash-memory의-한계점>a. Flash Memory의 한계점</h2><ul><li>쓰기 작업 전 지우기 (erase-before-write requirement)</li><li>순차적으로 지워진 Blocks에 쓰기 (need to write on erased blocks sequentially)</li><li>제한된 쓰고 지우기 cycles (limited write cycles per erase block)</li></ul><h2 id=b-flash-memory-사용의-증가>b. Flash Memory 사용의 증가</h2><ul><li>이때까지는 HDD를 계속해서 저장 매체로 썻으나 점점 더 많은 저장 매체가 필요하고 빠른걸 원하게 되었다.</li><li>저장 매체의 필요성 증가에 의해 다수의 Flash chips를 controller에 연결해서 사용하는 해결책이 일반적이 되었다. (Flash Chip의 가격 하락으로)</li></ul><h2 id=c-flash-memory에-대한-이해-부족으로-인한-단점>c. Flash Memory에 대한 이해 부족으로 인한 단점</h2><ul><li>위의 a의 문제점에 의해 HDD처럼 계속해서 I/O를 하면 Flash Memory의 특징을 잘 못살리게 된다.</li><li>오히려 I/O latency 가 증가하고 수명을 빠르게 깍게 된다.</li></ul><h2 id=d-기존의-연구>d. 기존의 연구</h2><ul><li>위와 같은 점들을 고려하여 선행연구에서 LFS(Log-Structured File System)의 접근 방법과 Copy-On-Write 전략으로 위의 한계점을 극복할수 있다.</li><li>예시로 BTRFS(B+-Tree File System)과 NILFS2(이건 먼지 모르겠네요 ㅠ)가 NAND Flash SSD에서 잘 동작한다. (cf. NAND 기반과 NOR 기반으로 크게 나뉜다.)</li><li>하지만 기존 선행 연구는 Flash Memory 의 특징을 전부 고려하지 못했고 성능과 수명 측면에서 좋지 않았다.</li><li>따라서 새로운 F2FS를 제시한다.</li></ul><h2 id=e-f2fs의-특징>e. F2FS의 특징</h2><ul><li>Flash-friendly on-disk layout : Segment, section and zone<ul><li>Segment, section 그리고 zone이라는 개념을 통해 Flash에 친화적인 layout을 사용한다.</li></ul></li><li>Cost-effective index structure : NAT (Node address table)<ul><li>비용 측면(시간과 공간 둘다)에서 효율적인 index 구조를 필요로 한다.</li><li>SSD나 Flash Memory는 LBA(Logical Base Address)가 존재하지 않지만, 이를 호환성 측면에서 제공해야하고 (FTL-Flash Translation Layer) 이를 효과적으로 제시한다.</li></ul></li><li>Multi-head Logging<ul><li>기존 연구의 LFS에서 착안하여 Logging Strucutre를 사용하지만 Multi-head를 사용하여 병렬처리를 하고, Hot/Cold 를 분류한다.</li></ul></li><li>Adaptive Logging<ul><li>dirty segment를 Cleaning 하지 않고 새로운 데이터를 기록한다.</li></ul></li><li><code>fsync</code> acceleration with roll-forward recovery<ul><li>예시 상황 : sqlite3</li></ul></li></ul><hr><h1 id=2-design-and-implementation-of-f2fs>2. Design and Implementation of F2FS</h1><p><img src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/001cab83-197f-42b8-892b-0541b17acb77/layout.jpg alt=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/001cab83-197f-42b8-892b-0541b17acb77/layout.jpg></p><h2 id=21-on-disk-layout>2.1 On-Disk Layout</h2><h3 id=superblocksb>Superblock(SB)</h3><ul><li>파티션 정보, F2FS의 default parameter가 들어있으며 format time에 주어지며 바뀌지 않는 값</li></ul><h3 id=checkpointcp>Checkpoint(CP)</h3><ul><li>file system의 상태, 유요한 NAT/SIT set들의 bitmap, orphan inode list들 그리고 활성화된 segment들의 요약 entries</li></ul><h3 id=segment-information-tablesit>Segment Information Table(SIT)</h3><ul><li>valid blocks의 개수 같은 segment information, <code>Main Area</code>의 모든 block의 validity bitmap</li><li>Cleaning process 동안 victim segment를 고르기 위해, valid block을 식별하기 위해 사용된다.</li></ul><h3 id=node-address-tablenat>Node Address Table(NAT)</h3><ul><li>Main Area에 저장된 모든 node block의 위치 Table</li></ul><h3 id=segment-summary-areassa>Segment Summary Area(SSA)</h3><ul><li>Summary entries prepresnting the owner information of all blocks in the Main Area</li><li>Cleaning 과정 동안 valid block 이동하기전 parent node blocks을 구별하게 된다.</li></ul><h3 id=main-area>Main Area</h3><ul><li>4KB 크기의 blocks로 채워져 있다.</li><li>각 block은 node이거나 data이다.</li><li>node block은 inode를 포함하거나 data blocks을 가리킨다.</li><li>data block은 directory이거나 user file data를 가진다.</li><li>block은 동시에 node 이거나 data일수 없다.</li></ul><h2 id=22-file-structure>2.2. File Structure</h2><h3 id=node-structure>Node Structure</h3><ul><li>inode의 확장</li><li>indexing block을 더 두기 위해서 사용</li><li>고유한 nodeID가 존재하고 NAT(Node Address Table)에서 nodeID를 키, Physical Address를 value로 들고 있는다.</li><li>3가지 종류 (inode, direct, indirect)<ul><li>inode : file의 metadata(filename, inode number, atime, dtime)</li><li>direct : data block의 주소</li><li>indirect : 다른 node block들의 nodeID</li><li>데이터가 변경될 때 direct node만 변경하고 NAT entry를 수정해주면 변경을 손쉽게 처리할수 있다.</li></ul></li><li>inlinde data와 inline extended attributes를 지원한다. (inline data란 metadata에서 비어있는, 예약되어 있는 영역의 크기보다 데이터가 더 작을 경우 그곳에 데이터를 넣는 것을 지칭한다.)</li><li>F2FS에서는 200bytes를 extended attributes로 지원하고 있다.</li></ul><h2 id=23-directory-structure>2.3. Directory Structure</h2><ul><li>4KB 크기의 directory entry(앞으로 dentry라고 지칭) block 은 bitmap과 2개의 array of slots를 가지고 있다.<ul><li>bitmap 은 각각의 slot들이 valid한지를 들고 있고, 각 slot은 hash value, inode number, length of filename and filetype을 들고있다.</li></ul></li><li>F2FS에서 directory 내 주어진 filename 찾기 예시<ul><li>filename의 hash value를 계산해서 hash table을 level 0부터서 inode 상 최대 할당된 level까지 돌아다닌다. 각 level에서 2개나 4개의 dentry block들 중 하나를 scan한다.</li><li>위의 과정은 <code>O(log(# of dentries))</code>의 복잡도를 가진다. dentry를 더 빨리 찾기 위해 bitmap, hash value, filename 순으로 접근하여 비교한다.</li></ul></li></ul><h2 id=24-multi-head-logging>2.4. Multi-Head Logging</h2><ul><li>F2FS는 hot/cold data의 분리의 효과를 최대화 하기 위해서 6개의 major log area를 가진다. 또한 F2FS는 다음과 같이 node와 data block의 온도를 나눈다.</li></ul><p><a href=https://www.notion.so/49352a1bed3c4b429d32f750bf16a391>Block의 종류</a></p><ul><li>Log 파일을 총 6개(각각의 Type과 Temp마다), 4개(Hot Node, Hot Data, Other Nodes, Other Data), 2개(Node, Data)</li></ul><h3 id=ftlflash-translation-layer-algorithm>FTL(Flash Translation Layer) Algorithm</h3><ul><li>일반적으로 FTL algorithm은 data와 log flash blocks 사이 연관성에 따라 3가지(block-associative, set-associative, full-associative)로 구별짓는다.</li><li>초기 파일 시스템을 포멧할 때 log flash blocks이 설정된다. 이때 설정된 log flash blocks은 data flash blocks이 할당될 때 생성된다.</li><li>현대 FTL algorithms은 random-write를 다루기 위해서 full-associative나 set-associative를 채택한다.</li><li>F2FS에서 주목할만한것은 multi-head logging을 사용했기 때문에 병렬적으로 로깅이 가능하다는 것이고, 이런 로그들을 분리하기 위해서 FTL에서 서로 다른 zone을 가지고 있다는 것이다.</li></ul><h2 id=25-cleaning>2.5 Cleaning</h2><ul><li>흩뿌려져있는 유요하지 않은 Blocks을 재사용 가능하게 하고 Logging을 위해 free segments를 보장해주는 작업</li><li>F2FS는 Foreground, Background로 구별되게 존재한다.</li></ul><h3 id=foreground>Foreground</h3><ul><li>충분히 빈 공간이 없을 때 시작한다</li></ul><h3 id=cleaning-단계>Cleaning 단계</h3><ol><li><p>Victim selection</p><ul><li><p>비어 있지 않은 sections 중 victim을 고른다.</p></li><li><p>greedy 방법과 cost-benefit 방법 2가지가 존재한다.</p></li><li><p>greedy 방법 : valid blocks 수가 가장 적은 section을 고른다. (Foreground)</p></li><li><p>cost-benefit 방법 : SIT(Segement Information Table)로 부터 last modification time을 가져와 section 안 segments의 평균을 매겨 section의 age를 매긴다 (cost = # valid blocks)</p><p><img src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d5cbabec-e5a7-422b-b522-5176649478b8/age.jpg alt=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d5cbabec-e5a7-422b-b522-5176649478b8/age.jpg></p></li></ul></li><li><p>Valid block identification and migration</p><ul><li>SIT 로부터 segment 당 valid bitmap을 가져와서 valid blocks을 알아낸다.</li><li>SSA 로부터 parent node blocks을 알아낸다</li><li>Foreground로 돌아가고 있다면 free logs 에 옮긴다.</li><li>Background라면 page cache로 blocks을 옮기고 dirty로 표기한다.</li></ul></li><li><p>Post-Cleaning Process</p><ul><li>victim section을 pre-free 라고 체크한 뒤 checkpoint를 만들어 저장한다.</li></ul></li></ol><h1 id=논문을-읽으면서-궁금했던-점>논문을 읽으면서 궁금했던 점.</h1><ul><li><p>LFS가 왜 좋은지, 왜 채택한건지, 어떤 단점이 있고 이 논문에서는 어떻게 극복한건지</p><pre><code>2.1 Log-Structured File System (LFS)
 LFS는 저장장치를 세그먼트 단위로 분할하고, 각 세그
먼트를 다시 블록으로 분할한다. 그리고 쓰기 요청을 처
리할 때 이 블록들을 순차적으로 할당하여 임의 쓰기 요
청들을 순차 쓰기로 변환시킨다. 최근, 이러한 LFS의 순
차 쓰기 방식은 임의 쓰기에 취약한 플래시 메모리에 적
합하기 때문에 플래시 메모리를 위한 파일시스템으로써
널리 연구되고 있다.
 하지만 이 순차 쓰기 방식 때문에 LFS는 invalid 처리
된 블록을 회수하는 Garbage Collection (GC)이라는 작업
이 필요하다. 기존의 많은 연구들은 LFS에서 GC 오버헤
드를 줄이기 위해 In-Place Update (IPU) 정책을 같이 사
용하는 등 다양한 노력을 해왔지만, 여전히 LFS에서 GC
는 파일시스템 성능에 큰 영향을 미치는 요소이다

[출처] F2FS 파일시스템의 버전별 변화 및 성능 영향 분석
이준호O
, 곽현호, 신동군
성균관대학교 반도체시스템공학과
crow6316@skku.edu, gusghrhkr@skku.edu, dongkun@skku.edu
</code></pre></li><li><p>왜 Hot과 Cold는 서로 분리되어야 하는가?</p><ul><li>Hot과 Cold가 서로 같이 존재하면 Hot이 지워지거나 갱신될때마다 Cold도 같이 Copy-On-Write가 일어나서 동시에 쓸수있는 Hot 데이터(위에서 말하는 Data가 아닌, 기록되어야할 모든 정보 의미)의 양이 감소하고, Cold Data는 갱신이 되지 않음에도 불구하고 NAT를 계속해서 갱신해주어야하기 때문에</li></ul></li></ul><h1 id=같이-보면-좋은-자료>같이 보면 좋은 자료</h1><p><a href=http://csl.snu.ac.kr/courses/4190.568/2019-1/25-F2FS.pdf>http://csl.snu.ac.kr/courses/4190.568/2019-1/25-F2FS.pdf</a></p></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=makerdark98/makerdark98.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><footer><p class="copyright text-muted">© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/calintat/minimal>Minimal</a>.</p></footer></body></html>