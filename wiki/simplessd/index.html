<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>simple-ssd</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent: #00a3d2;--border-width:  5px }</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on('click',function(){$('.collapse').collapse('hide');})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-98056974-1');</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>simple-ssd</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:makerdark98@gmail.com><i class="fa fa-envelope-o"></i></a></li><li class=navbar-icon><a href=https://github.com/makerdark98/><i class="fa fa-github"></i></a></li><li><div style=max-width:250px;display:inline-block;max-height:40px><script async src="https://cse.google.com/cse.js?cx=003491619885022567520:wnnypdnx4aj"></script><div class=gcse-search></div></div></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><a href=/wiki><button class="btn btn-link"><i class="fa fa-arrow-left"></i>&nbsp;Front Page</button></a></div><div style=margin-left:auto><div style=display:flex><div style=margin-left:auto><div class=wiki-history></div></div></div><script src=/js/localhistory.js></script><script>var now="simplessd"
pushHistory(now);</script></div></div><div><h2>simple-ssd</h2><a href=https://github.com/makerdark98/makerdark98.github.io/blame/master/src/content/wiki/simplessd.md><h5>created : Wed, 10 Jun 2020 19:39:41 +0900</h5><h5>modified : Mon, 15 Jun 2020 19:48:31 +0900</h5></a><div class=parent-doc style=flex:none></div></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#새롭게-알게된-것>새롭게 알게된 것</a></li><li><a href=#다운로드>다운로드</a></li><li><a href=#문서-읽기>문서 읽기</a><ul><li><a href=#host-interface-layer>Host Interface Layer</a></li><li><a href=#ssd-interface>SSD Interface</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=새롭게-알게된-것>새롭게 알게된 것</h2><ul><li>[[gem5]]</li></ul><h2 id=다운로드>다운로드</h2><ul><li><a href=https://docs.simplessd.org/en/v2.0.12/instructions/start.html>simplessd 공홈</a></li><li>하라는 대로 하면 된다. (FullSystem은 example 을 실행해도 그대로 안되서, 그냥 standalone 을 먼저 봐보기로 했다.)</li></ul><hr><h2 id=문서-읽기>문서 읽기</h2><ul><li>그냥 홈페이지에 있는 문서를 읽어보자. 중요하니까 정리해놨겠지</li></ul><hr><h3 id=host-interface-layer>Host Interface Layer</h3><ul><li>HIL 이라고도 불리는 Host Interface Layer에 대한 설명이다.</li><li>HIL 은 host side에 있는 host controller, host controller 에게 추상화된 API를 제공해주는 SSD Interface</li></ul><h4 id=host-controller>Host Controller</h4><ul><li>NVMe, SATA and UFS를 구현해 놓았으며, Open-Channel SSD 는 NVMe 를 상속받음.</li></ul><h5 id=host-interface>Host Interface</h5><ul><li><code>hil/nvme/interface.hh</code> 에 <code>SimpleSSD::DMAInterface</code>를 상속하여 선언된 <code>SimpleSSD::HIL::NVMe::Interface</code> 를 보자.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DMAInterface</span> {
 <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
  DMAInterface() {}
  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>DMAInterface() {}

  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dmaRead</span>(<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>, DMAFunction <span style=color:#f92672>&amp;</span>,
                       <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dmaWrite</span>(<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>, DMAFunction <span style=color:#f92672>&amp;</span>,
                        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Interface</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> SimpleSSD<span style=color:#f92672>::</span>DMAInterface {
 <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
  Controller <span style=color:#f92672>*</span>pController;

 <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> updateInterrupt(<span style=color:#66d9ef>uint16_t</span>, <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getVendorID</span>(<span style=color:#66d9ef>uint16_t</span> <span style=color:#f92672>&amp;</span>, <span style=color:#66d9ef>uint16_t</span> <span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div><ul><li><code>DMAInterface</code> 에서는 Direct Memory Access 를 위해서 <code>dmaRead</code>, <code>dmaWrite</code> 를 제공한다.</li><li><code>updateInterrupt</code> 는 host의 특정 interrupt vector 에 interrupt를 보낸다.</li><li><code>getVendorId</code> 는 NVMe의 <code>Identify Controller</code>가 vendor Id와 subsystem vendor ID를 필요로 하기 때문에 존재하는 method 이다.</li></ul><h5 id=controller-and-firmware>Controller and Firmware</h5><ul><li>NVMe controller/firmware 는 아래 3가지 컴포넌트 (Controller, Subsystem and Namespace)로 구성된다.<ul><li>Controller는 모든 queue 연산(SQ 에서 request 를 읽고, CQ에 request를 쓰고, 인터럽트를 발생시키는)을 담당한다.</li><li>Subsystem은 모든 NVMe의 admin commands를 다루며, Namespace를 제어하고, SSD Layer에 I/O를 실행한다.</li><li>Namespace는 모든 NVMe의 I/O commands 를 다룬다.</li></ul></li></ul><h6 id=controller>Controller</h6><ul><li><p>모든 queue 연산을 담당하는 Controller는 <code>hil/nvme/controller.hh</code>에 <code>SimpleSSD::HIL::NVMe::Controller</code> 로 정의되어 있다.</p></li><li><p><code>EventEngine</code>은 주기적으로 <code>Controller::work</code>를 유발시키며, 이때 주기는 <code>WorkPeriod</code> 설정값을 참조한다.</p></li><li><p><code>Controller::work</code> 는 설정된 중재 함수(<code>Controller::collectSQueue</code>)를 사용하여 모든 submission queue를 모은다.</p></li><li><p>새로운 <code>Request</code>는 내부의 FIFO Queue(<code>Controller::lSQFIFO</code>) 에 넣어지며, 새로운 Request 가 있다면, <code>Controller:handleRequest</code>를 호출해야 한다. 이때 이 함수는 <code>AbstractSubsystem::submitReqeust</code>를 유발한다.</p></li><li><p><code>AbstractSubsystem</code> 이 request를 처리하고 난 뒤, <code>Controller::submit</code> 함수가 불려지게 되며, 내부적으로 존재하는 FIFO Queue(<code>Controller::lCQFIFO</code>)에 완료된 걸 넣는다.</p></li><li><p><code>Controller::submit</code> 함수는 <code>Controller::completion</code> 함수를 부르는 event를 관리한다.</p></li><li><p><code>Controller::completion</code> 함수는 CQ entry를 채우고, <code>Controller::updateInterrupt</code> 를 사용해서 interrupt를 보낸다.</p></li><li><p><code>Controller::updateInterrupt</code>는 단순히 <code>Interface::updateInterrupt</code>를 호출한다.</p></li></ul><h6 id=subsystem>Subsystem</h6><ul><li><p>admin commmands를 다루는 NVMe Subsystem은 <code>hil/nvme/subsystem.hh</code>에 <code>SimpleSSD::HIL::NVMe::Subsystem</code> 으로 선언되어 있다.</p></li><li><p>Open-channel SSD Subsystem은 <code>hil/nvme/ocssd.hh</code>에 <code>SimpleSSD::HIL::NVMe::OpenChannelSSD</code>로 선언되어 있다.</p></li><li><p>두 subsystem 모두 <code>hil/nvme/abstract_subsystem.hh</code>의 <code>SimpleSSD::HIL::NVMe::AbstractSubsystem</code> 을 상속한다.</p></li><li><p>기본적으로 아래쪽 설명들은 NVMe subsystem 을 기반으로 하고 있는데, Open-Channel SSD 랑 사소한 차이만 있기 때문이다.</p></li><li><p>NVMe Subsystem은 2부분으로 나뉘는데, command handling, I/O request handling.</p></li><li><p>Subsystem이 여러 namespaces를 가질수 있으므로, Subsystem은 반드시 I/O requests 를 Namespaces 로부터 HIL의 SSD Interface로 넘겨줘야 한다.</p></li><li><p>각 NVMe 명령들은</p><ul><li>I/O 명령이라면, <code>Subsystem::submitCommand</code> 함수를 통해서 특정한 Namespace로 가지게 되며.</li><li>관리용(admin) 명령이라면, <code>submitCommand</code> 함수는 OPCODE를 확인한 이후 적절한 함수를 호출하게 된다.</li></ul></li><li><p>모든 명령들은 완료됨을 알리기 위해서 <code>Controller::submit</code> 를 유발한다.</p></li><li><p>특정한 I/O 함수들(<code>Subsystem::read, write, flush and trim</code>)이 불리게 된다면, I/O unit으로 번역된뒤, SSD Intreface의 함수들로 간다. (<code>HIL::HIL::read</code>, <code>HIL::HIL::write</code>, <code>HIL::HIL::flush</code> and <code>HIL::HIL::trim</code>);</p></li><li><p>SSD를 선형적으로 쪼개기 위해서, Subsystem은 multiple Namespaces를 유지한다.</p><ul><li>예를 들어 1TB SSD 가 4K 논리적 block을 사용한다고 하자. 이때 512GB, 256GB, 256GB 용량으로 3개의 Namespaces로 쪼갤수 있다.</li><li>Subsystem은 offset과 length를 찾아서 namespaces를 할당할 것이고, Subsystem은 할당되지 않은 공간을 처음 맞는 Namespaces에 할당한다.(first-fit). 만약 공간이 없다면 할당이 실패한다.</li></ul></li><li><p>각 Namespace 마다 offset과 length를 가지고 있으며, 이 값은 SSD interface를 위해 I/O unit으로 번역될때 쓰인다.</p></li></ul><h6 id=namespace>Namespace</h6><ul><li>I/O 명령을 다루는 NVMe Namespace는 <code>hil/nvme/namespace.hh</code>에 <code>SimpleSSD::HIL::NVMe::Namespace</code>로 선언되어 있으며. NVMe Subsystem과 비슷한 구조를 다룬다.(둘다 command를 다룬다.)</li><li>I/O 명령이 오면, Namespace 는 Subsystem의 해당 함수들을 호출한다.(<code>read</code>, <code>write</code>, <code>flush</code> and <code>trim</code>).</li></ul><h4 id=serial-at-attachment>Serial AT Attachment</h4><ul><li>Serial AT Attachment - SATA 는 SSD와 HDD를 위한 전통적 interface이다.</li><li>SimpleSSD 에서는 Serial ATA Advanced host Controller Interface (AHCI) 1.3.1 에 기반한 STATA HBA를 구현하였고, Serial ATA Revision 3.0 에 기반을 둔 STAT PHY와 프로토콜을 구현하였다.</li></ul><h5 id=host-interface-1>Host interface</h5><ul><li><p><code>hil/sata/interface.hh</code>에 선언된 <code>SimpleSSD::HIL::SATA::Interface</code> 추상 클래스는 simulator에게 common API를 제공한다.</p></li><li><p>SimpleSSD-FUllSystem 에서 <code>src/dev/storage/sata_interrface.hh</code>에 선언된 <code>SATAInterface</code> 에서 어떻게 상속하는지 확인할 수 있다.</p></li><li><p><code>SimpleSSD::HIL::SATA::Interface</code> 은 오직 <code>virtual void updateInterrupt(bool) = 0</code>를 interrupt posting 을 위해서 포함하고 있다.</p></li></ul><h5 id=host-bus-adapter>Host Bus Adapter</h5><ul><li><p>SATA는 Host Bus Adapter(HBA) 라고 불리는 host sid controller 를 필요로 한다.</p></li><li><p>HBA 디자인은 다양하지만, 우리는 누구나 접근할수 있는 AHCI spcification을 사용했다.</p></li><li><p>우리는 단 하나의 SimpleSSD 인스턴스만 HBA에 연결되기 때문에 단 하나의 port 만 구현했다.</p></li><li><p><code>Interface</code>는 AHCI registser(Genetic Host Controller registers and Port registers)를 <code>HBA::writeAHCIRegister</code> 함수를 통해서 쓴다.</p></li><li><p><code>PxCl</code> register에 bits를 쓰는 건 그에 대항하는 NCQ에 새로운 요청이 있다는걸 의미한다.</p></li><li><p><code>HBA</code>는 내부 FIFO(<code>HBA::lRequestQueue</code>)에 request를 넣기 위해서 <code>HBA::processCommand</code> 를 호출한다.</p></li><li><p>NVMe와 동일하게 <em>Event Engine</em>은 주기적으로 <code>HBA::work</code> 함수를 호출하고, 이 함수는 <code>HBA::handleRequest</code> 함수를 호출하고와 <code>Device::submitCommand</code> 함수가 불리게 된다.</p></li><li><p>command handling 이후 <code>Device</code>는 <code>HBA::submitFIS</code> 함수를 FIS 응답을 host에게 돌려주기 위해서 부른다. <code>HBA::submitFIS</code> 함수는 <code>HBA::lResponseQueue</code>에 응답을 넣고, <code>HBA::handleResponse</code> 함수를 호출하는 event를 예약한다. <code>handleResponse</code> 함수는 내부의 FIFO에서부터 첫번째 response를 읽고, NCQ에 써서 <code>Interface::updateInterrupt</code> 함수를 사용해 Interrupt를 보낸다.</p></li></ul><h5 id=device>Device</h5><ul><li><code>hil/sata/device.hh</code> 에 선언된 <code>SimpleSSD::HIL::SATA::Device</code>는 HBA와 연결하는 Device이다.</li><li>Device는 아래 나열된 ATA 명령어(ATA/ATAPI Command Set -2 (ACS-2) 와 (AT Attachment 8 - ATA/ATAPI Command Set (ATA8-ACS))를 다룰수 있다.<ul><li><code>FLUSH CACHE</code></li><li><code>FLUSH CACHE EXT</code></li><li><code>IDENTIFY DEVICE</code></li><li><code>READ DMA</code></li><li><code>READ DMA EXT</code></li><li><code>READ FPDMA QUEUED</code></li><li><code>READ SECTOR</code></li><li><code>READ SECTOR EXT</code></li><li><code>READ VERIFY SECTOR</code></li><li><code>READ VERIFY SECTOR EXT</code></li><li><code>SET FEATURE</code></li><li><code>WRITE DMA</code></li><li><code>WRTIE DMA EXT</code></li><li><code>WRITE FPDMA QUEUED</code></li><li><code>WRTIE SECTOR</code></li><li><code>WRTIE SECTOR EXT</code></li></ul></li><li>Device 의 구현이 NVMe Subsystem에 비해 간단해 보일수 있는데, 이는 Namespace를 관리할 필요가 없기 때문이다.</li><li>모든 명령어들은 <code>Device::submitCommand</code> 함수를 통과하며 적절하게 다루어진다.</li><li>완료 이후, 각 명령어들은 명령의 결과를 <code>HBA</code>에게 보고하기(report) 위해서 <code>HBA::submitFIS</code>를 호출한다.</li><li>I/O 와 관련된 <code>READ*</code>, <code>WRITE*</code> and <code>FLUSH*</code> 는 SSD Interface의 함수 (<code>HIL::HIL::read, write and flush</code>) 를 호출한다.</li></ul><h4 id=universal-flash-storage>Universal Flash Storage</h4><ul><li>Universal Flash Storage - UFS : 모바일용 저장소를 위해 디자인된 interface. 대부분의 스마트폰들이 이 UFS interface를 사용하고 있다.</li><li>SimpleSSD 에서는 <code>Universal Flash Storage (UFS) Host Controller Interface (JESD223)</code>을 기반으로 UFS Host Controller를 구현하였으며, UFS PHY는 <code>Specification for M-PHY Version 4.0</code> 을, UFS protocol은 <code>Universal Flash Storage (UFS) Version 2.1 (JESD220C)</code>를 기반으로 한다.</li></ul><h5 id=host-interface-2>Host Interface</h5><ul><li><code>SimpleSSD::HIL::UFS::Interface</code> 는 simulator에게 common API를 제공하기 위해 추상 클래스로 <code>hil/ufs/interface.hh</code> 에 정의되어 있다. 어떻게 구체화 하는지는 SimpleSSD_FullSystem의 <code>UFSInterface</code> 는 <code>scr/dev/storage/ufs_interface.hh</code> 에 나와 있다.</li><li><code>SimpleSSD::HIL::UFS::Interface</code> 는 단지 <code>generateInterrrupt()</code> 와 <code>clearInterrupt()</code> 를 포함한다.</li></ul><h5 id=host-controller-inteface>Host Controller inteface</h5><ul><li><p>SATA처럼 UFS도 UFS Host Controller Interface - UFSHCI 를 제공한다. 이 인터페이스는 <code>Universal Flash Storage (UFS) Host Controller Interface (JESD223)</code>를 따라간다.</p></li><li><p>UFSHCI 는 <code>hil/ufs/host.hh</code> 에 <code>SimpleSSD::HIL::UFS::Host</code>로 구현되어 있다.</p></li><li><p><code>Interface</code> 는 UFSHCI register에 <code>Host::writeRegister</code> 함수를 사용해서 쓴다.</p></li><li><p>UFS는 3가지 종류의 명령이 있는데</p><ul><li>UFS Trasnport Protocol Transfer (UTP Transfer)</li><li>UFS Transport Protocol Task Management (UTP Task)</li><li>UFS InterConnect Command (UIC Command)</li></ul></li><li><p>각 명령어들은 request를 알리는데 서로 다른 doorbell을 사용하며</p><ul><li><code>REG_UTRLDBR</code> 는 UTP Transfer</li><li><code>REG_UTMRLDBR</code> 는 UTP Task</li><li><code>REG_UICCMDR</code> 는 UIC Command</li></ul></li><li><p>를 확인할때 사용할수 있다.</p></li><li><p>리눅스 커널과 UFS 2.1에서 UTP Task는 구현되지 않았기 때문에 SimpleSSD 에서도 구현하지 않았다.</p></li><li><p>UIC Commands 는 오직 UFS hardware를 초기화 할때만 사용하며(M-PHY link 부팅 등), 그러므로 우린 오직 2가지 기초적 명령어들만 구현했다.</p></li><li><p>NVMe와 SATA처럼 <strong>Event Engine</strong> 은 주기적으로 <code>Host::work</code> 함수를 호출하며. <code>Host::handleRequest</code> 함수는 <code>work</code>에 의해서 호출되고 request가 유효한지를 검증한다. <code>Host::processUTPCommand</code> 는 request를 파싱하고, request에 적합한 handler를 부른다.</p></li><li><p>UFS Transfer는 3가지 유형의 명령어들로 정의된다.</p><ul><li>Command (SCSI protocol)</li><li>Native UFS Command</li><li>Device Management Command</li></ul></li><li><p>Native UFS Command는 UFS 2.1 에서 정의되지 않았기 때문에 우린 Command 와 Device Management Command 만을 구현했다.</p></li><li><p><code>Device::processCommand</code> 함수는 Command 를 다루고 <code>Device::processQueryCommand</code> 함수는 Device Management Command 를 다룬다.</p></li><li><p><code>handleRequest</code> 함수에서 완료 루틴(Completion routine) 이 선언되어 있으며 이는 <code>doRequest</code> 와 <code>doWrite</code> 라는 lambda 함수들을 확인하면 된다. <code>doWrite</code> 함수는 completion routine(<code>Host::completion</code>)을 예약하며, <code>completion</code> 함수는 <code>Interface::updateInterrupt</code> 함수를 사용해서 Interrupt를 보낸다.</p></li></ul><h5 id=device-1>Device</h5><ul><li><p>UFSHCI 와 연결해주는 Device 는 <code>hil/ufs/device.hh</code>에 <code>SimpleSSD::HIL::UFS::Device</code> 를 정의한다.</p></li><li><p>UFS 는 SCSI commands set(<code>SCSI Block Commands - 3 (SBC-3)</code> 와 <code>SCSI Primary Commands - 4(SPC-4)</code>) 을 I/O 하기 위해서 사용gksek.</p></li><li><p>Device 는 아래 나오는 SCSI 명령어들로 다루어진다.</p><ul><li><code>INQUERY</code></li><li><code>MODE SELECT 10</code></li><li><code>MODE SENSE 10</code></li><li><code>READ 6</code></li><li><code>READ 10</code></li><li><code>READ CAPACITY 10</code></li><li><code>READ CAPACITY 16</code></li><li><code>START STOP UNIT</code></li><li><code>TEST UNIT READY</code></li><li><code>REPORT LUNS</code></li><li><code>VERIFY 10</code></li><li><code>WRITE 6</code></li><li><code>WRITE 10</code></li><li><code>SYNCHRONIZE CACHE 10</code></li></ul></li><li><p>Device 의 구현은 SATA와 비슷하지만 2가지 명령어 handling 함수를 가진다. (<code>processCommand</code> 와 <code>processQueryCommand</code>)</p></li><li><p>완료 이후 각 SCI command 함수는 callback handler 를 호출하며, 이때 <code>processCommand</code> 함수의 인자로서 콜백은 제공한다.</p></li><li><p><code>processQueryCommand</code> 는 즉시 결과를 리턴한다. I/O 관련 명령 <code>READ*</code>, <code>WRITE*</code> 와 <code>SYNCHRONIZE CACHE</code> 는 SSD Interface 함수들 (<code>HIL::HIL::read, write and flush</code>) 를 호출한다.</p></li></ul><h3 id=ssd-interface>SSD Interface</h3><ul><li>HIL 의 SSD Interface는 단순한데 <code>hil/hil.hh</code> 에 <code>SimpleSSD::HIL::HIL</code> 로 정의되어 있다.</li><li>I/O request를 host controller로 부터 받아 <code>Interal Cache Layer</code> 에 넘겨준다.</li></ul></div><script>function convertWikiLink(elem){elem.innerHTML=elem.innerHTML.replace(/\[\[(.+?)\]\]\{(.+?)\}/g,(original,matching,display)=>{return `<a href="/wiki/${matching.toLowerCase().replace(/ /g,'-').replace(/[()]/g,'')}">${display}</a>`;});elem.innerHTML=elem.innerHTML.replace(/\[\[(.+?)\]\]/g,(original,matching)=>{var display=matching;if(display==="_index"){display="Front Page";matching="";}
return `<a href="/wiki/${matching.toLowerCase().replace(/ /g,'-').replace(/[()]/g,'')}">${display}</a>`;});};(function(){var content=document.querySelector('.content');convertWikiLink(content);var parent=document.querySelector('.parent-doc');if(parent)convertWikiLink(parent);})();</script><div><script src=https://utteranc.es/client.js repo=makerdark98/makerdark98.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><footer><p class="copyright text-muted">© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/calintat/minimal>Minimal</a>.</p></footer></body></html>