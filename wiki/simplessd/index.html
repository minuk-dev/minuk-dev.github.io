<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>simple-ssd |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>simple-ssd -
minuk dev wiki</div></header><main><aside class=sidebar><ul class=section-tree><li class="dir opened-dir"><span class=dir-text>Front Page</span><ul class=section-tree><li class=file><a href=https://minuk.dev/wiki/daily/2025-01-13/ title=./wiki/daily/2025-01-13/>2025-01-13</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-community-day-korea/ title=./wiki/kubernetes-community-day-korea/>Kubernetes Community Day 2024</a></li><li class=file><a href=https://minuk.dev/wiki/observability-engineering-kr/ title=./wiki/observability-engineering-kr/>Observability Engineering</a></li><li class=file><a href=https://minuk.dev/wiki/learning-opentelemetry/ title=./wiki/learning-opentelemetry/>Learning OpenTelemetry</a></li><li class=file><a href=https://minuk.dev/wiki/prometheus-native-histograms-in-production/ title=./wiki/prometheus-native-histograms-in-production/>prometheus-native-histograms-in-proudction</a></li><li class=file><a href=https://minuk.dev/wiki/making-sense-of-your-vital-signals-the-future-of-pod-and-containers-monitoring/ title=./wiki/making-sense-of-your-vital-signals-the-future-of-pod-and-containers-monitoring/>Making Sense of Your Vital Signals - The Future of Pod and Containers Monitoring</a></li><li class=file><a href=https://minuk.dev/wiki/defining-a-common-observability-query-language-and-other-observability-tag-updates/ title=./wiki/defining-a-common-observability-query-language-and-other-observability-tag-updates/>Defining A Common Observability Query Language and Other observability TAG Updates</a></li><li class=file><a href=https://minuk.dev/wiki/beyond-tracing-what-do-we-do-with-all-this-data/ title=./wiki/beyond-tracing-what-do-we-do-with-all-this-data/>Beyond Tracing - What do we do with all this data</a></li><li class=file><a href=https://minuk.dev/wiki/grafanacon/ title=./wiki/grafanacon/>grafanacon</a></li><li class=file><a href=https://minuk.dev/wiki/observability-engineering/ title=./wiki/observability-engineering/>Observability Engineering</a></li><li class=file><a href=https://minuk.dev/wiki/rust/ title=./wiki/rust/>rust</a></li><li class=file><a href=https://minuk.dev/wiki/opentelemetry-metrics-deep-dive/ title=./wiki/opentelemetry-metrics-deep-dive/>opentelemetry metrics deep dive</a></li><li class=file><a href=https://minuk.dev/wiki/armeria/ title=./wiki/armeria/>armeria</a></li><li class=file><a href=https://minuk.dev/wiki/kotlin/ title=./wiki/kotlin/>kotlin</a></li><li class=file><a href=https://minuk.dev/wiki/loki-best-practices/ title=./wiki/loki-best-practices/>loki label best practices</a></li><li class=file><a href=https://minuk.dev/wiki/loki/ title=./wiki/loki/>loki</a></li><li class=file><a href=https://minuk.dev/wiki/grafana-loki-like-prometheus-but-for-logs/ title=./wiki/grafana-loki-like-prometheus-but-for-logs/>Grafana Loki - Like Prometheus, But for logs.</a></li><li class=file><a href=https://minuk.dev/wiki/spring-boot-cli/ title=./wiki/spring-boot-cli/>spring boot cli</a></li><li class=file><a href=https://minuk.dev/wiki/autoconf/ title=./wiki/autoconf/>autoconf</a></li><li class=file><a href=https://minuk.dev/wiki/re-minuk-k8s/ title=./wiki/re-minuk-k8s/>다시 시작하는 쿠버네티스 세팅</a></li><li class=file><a href=https://minuk.dev/wiki/cloud-native-go/ title=./wiki/cloud-native-go/>Cloud Native Go</a></li><li class=file><a href=https://minuk.dev/wiki/overlayfs/ title=./wiki/overlayfs/>overlayfs</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/design-pattern/ title=./wiki/lectures/design-pattern/>lectures/design-pattern</a></li><li class=file><a href=https://minuk.dev/wiki/site-reliability-engineering/ title=./wiki/site-reliability-engineering/>사이트 신뢰성 엔지니어링</a></li><li class=file><a href=https://minuk.dev/wiki/to-ipv6-the-dual-stack-adoption-advisory-panel/ title=./wiki/to-ipv6-the-dual-stack-adoption-advisory-panel/>To IPv6 - The Dual-stack Adoption Advisory Panel</a></li><li class=file><a href=https://minuk.dev/wiki/prometheus-intro-and-deep-dive/ title=./wiki/prometheus-intro-and-deep-dive/>Prometheus Intro and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/cs/ title=./wiki/cs/>cs 기본</a></li><li class=file><a href=https://minuk.dev/wiki/coredns/ title=./wiki/coredns/>learning-coredns</a></li><li class=file><a href=https://minuk.dev/wiki/coredns-into-and-deep-dive/ title=./wiki/coredns-into-and-deep-dive/>CoreDNS - Intro and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/deep-dive-into-minikube/ title=./wiki/deep-dive-into-minikube/>Deep Dive into Minikube</a></li><li class=file><a href=https://minuk.dev/wiki/making-your-apps-and-infrastructure-services-failure-resilient-with-dapr/ title=./wiki/making-your-apps-and-infrastructure-services-failure-resilient-with-dapr/>Making Your Apps and Infrastructure Services Failure-Resilient with Dapr</a></li><li class=file><a href=https://minuk.dev/wiki/make-cloud-native-chaos-engineering-easier-deep-dive-into-chaos-mesh/ title=./wiki/make-cloud-native-chaos-engineering-easier-deep-dive-into-chaos-mesh/>Make Cloud Native Chaos Engineering Easier Deep Dive into Chaos Mesh</a></li><li class=file><a href=https://minuk.dev/wiki/selinux/ title=./wiki/selinux/>selinux</a></li><li class=file><a href=https://minuk.dev/wiki/http-go/ title=./wiki/http-go/>go snippet for go</a></li><li class=file><a href=https://minuk.dev/wiki/curl/ title=./wiki/curl/>curl</a></li><li class=file><a href=https://minuk.dev/wiki/volcano-intro-and-deep-dive/ title=./wiki/volcano-intro-and-deep-dive/>Volcano - Intro & Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/intro-to-kubernetes-gitops-and-observability-hands-on-tutorial/ title=./wiki/intro-to-kubernetes-gitops-and-observability-hands-on-tutorial/>Intro to Kubernetes, GitOps, and Observability Hands-On Tutorial</a></li><li class=file><a href=https://minuk.dev/wiki/kubespray/ title=./wiki/kubespray/>kubespray</a></li><li class=file><a href=https://minuk.dev/wiki/spark-on-kubernetes-the-elastic-story/ title=./wiki/spark-on-kubernetes-the-elastic-story/>Spark on Kubernetes - The Elastic Story</a></li><li class=file><a href=https://minuk.dev/wiki/devops%EC%99%80-se%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%9D%B4%EC%95%BC%EA%B8%B0/ title=./wiki/devops%EC%99%80-se%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%9D%B4%EC%95%BC%EA%B8%B0/>DevOps와 SE를 위한 리눅스 커널 이야기</a></li><li class=file><a href=https://minuk.dev/wiki/running-containerd-and-k3s-on-macos/ title=./wiki/running-containerd-and-k3s-on-macos/>Running Containerd and k3s on MacOS</a></li><li class=file><a href=https://minuk.dev/wiki/twelve-factor-app/ title=./wiki/twelve-factor-app/>12요소 어플리케이션</a></li><li class=file><a href=https://minuk.dev/wiki/vim-go/ title=./wiki/vim-go/>vim/vim-go</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-patterns/ title=./wiki/kubernetes-patterns/>쿠버네티스 패턴</a></li><li class=file><a href=https://minuk.dev/wiki/horizontalpodautoscaler/ title=./wiki/horizontalpodautoscaler/>Horizontal Pod AutoScaler</a></li><li class=file><a href=https://minuk.dev/wiki/what-if-kube-apiserver-could-be-extended-via-webassembly/ title=./wiki/what-if-kube-apiserver-could-be-extended-via-webassembly/>What If… Kube-Apiserver Could be Extended Via WebAssembly?</a></li><li class=file><a href=https://minuk.dev/wiki/the-future-of-reproducible-research-powered-by-kubeflow/ title=./wiki/the-future-of-reproducible-research-powered-by-kubeflow/>The Future Of Reproducible Research - Powered by Kubeflow</a></li><li class=file><a href=https://minuk.dev/wiki/this-is-the-way-a-crash-course-on-intricacies-of-managing-cpus/ title=./wiki/this-is-the-way-a-crash-course-on-intricacies-of-managing-cpus/>This is The Way- A Crash Course on the Intricacies of Managing CPUs in K8s</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-graceful-shutdown/ title=./wiki/kubernetes-graceful-shutdown/>kubernetes-graceful-shutdown</a></li><li class=file><a href=https://minuk.dev/wiki/dockerfile/ title=./wiki/dockerfile/>dockerfile</a></li><li class=file><a href=https://minuk.dev/wiki/automated-progressive-delivery-using-gitops-and-service-mesh/ title=./wiki/automated-progressive-delivery-using-gitops-and-service-mesh/>Automated Progressive Delivery Using GitOps and Service Mesh</a></li><li class=file><a href=https://minuk.dev/wiki/containerd-proejct-update-and-deep-dive/ title=./wiki/containerd-proejct-update-and-deep-dive/>containerd Project Update and Deep Dive</a></li><li class=file><a href=https://minuk.dev/wiki/http2/ title=./wiki/http2/>http2 탐구</a></li><li class=file><a href=https://minuk.dev/wiki/grpc-for-microservices/ title=./wiki/grpc-for-microservices/>gRPC For Microservices Service-mesh and Observability</a></li><li class=file><a href=https://minuk.dev/wiki/kubecon/ title=./wiki/kubecon/>kubecon</a></li><li class=file><a href=https://minuk.dev/wiki/go-http/ title=./wiki/go-http/>go-http</a></li><li class=file><a href=https://minuk.dev/wiki/go/ title=./wiki/go/>go</a></li><li class=file><a href=https://minuk.dev/wiki/cri/ title=./wiki/cri/>CRI(Container Runtime Interface)</a></li><li class=file><a href=https://minuk.dev/wiki/vagrant/ title=./wiki/vagrant/>vagrant</a></li><li class=file><a href=https://minuk.dev/wiki/jsonpath/ title=./wiki/jsonpath/>jsonpath</a></li><li class=file><a href=https://minuk.dev/wiki/systemctl/ title=./wiki/systemctl/>systemctl 중요한것만 정리</a></li><li class=file><a href=https://minuk.dev/wiki/init/ title=./wiki/init/>linux init 요약</a></li><li class=file><a href=https://minuk.dev/wiki/process-cli/ title=./wiki/process-cli/>process 관련된 명령어 모음</a></li><li class=file><a href=https://minuk.dev/wiki/process-status/ title=./wiki/process-status/>process-status</a></li><li class=file><a href=https://minuk.dev/wiki/teamnote-go/ title=./wiki/teamnote-go/>teamnote-go</a></li><li class=file><a href=https://minuk.dev/wiki/cgroups/ title=./wiki/cgroups/>cgroup</a></li><li class=file><a href=https://minuk.dev/wiki/namespaces/ title=./wiki/namespaces/>namespaces</a></li><li class=file><a href=https://minuk.dev/wiki/lxc/ title=./wiki/lxc/>LXC</a></li><li class=file><a href=https://minuk.dev/wiki/devops/ title=./wiki/devops/>devops</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/supply-and-demand/ title=./wiki/ringle/supply-and-demand/>Supply and Demand</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/the-metaverse/ title=./wiki/ringle/the-metaverse/>ringle/The metaverse</a></li><li class=file><a href=https://minuk.dev/wiki/ringle/microsoft-x-activision-blizzard/ title=./wiki/ringle/microsoft-x-activision-blizzard/>ringle/Microsoft x Activision Blizzard</a></li><li class=file><a href=https://minuk.dev/wiki/topcit/ title=./wiki/topcit/>topcit 간략 공부</a></li><li class=file><a href=https://minuk.dev/wiki/software-engineering-at-google/ title=./wiki/software-engineering-at-google/>구글 엔지니어는 이렇게 일한다</a></li><li class=file><a href=https://minuk.dev/wiki/k8s-in-rpi/ title=./wiki/k8s-in-rpi/>k8s-in-rpi</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes/ title=./wiki/kubernetes/>kubernetes</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/numerical_analysis/ title=./wiki/lectures/numerical_analysis/>수치해석</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/information_security_theory/ title=./wiki/lectures/information_security_theory/>2022-1 정보보호이론</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/ title=./wiki/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/>제텔카스텐</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A7%81%EA%B8%80/autonomous/ title=./wiki/%EB%A7%81%EA%B8%80/autonomous/>링글/Autonomous</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A7%81%EA%B8%80/metaverse/ title=./wiki/%EB%A7%81%EA%B8%80/metaverse/>링글/Metaverse</a></li><li class=file><a href=https://minuk.dev/wiki/algorithm/ title=./wiki/algorithm/>algorithm</a></li><li class=file><a href=https://minuk.dev/wiki/study-note/ title=./wiki/study-note/>study-note</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/machine-learning/ title=./wiki/lectures/machine-learning/>2022 1학기 머신러닝</a></li><li class=file><a href=https://minuk.dev/wiki/kubernetes-in-action/ title=./wiki/kubernetes-in-action/>Kubernetes in action</a></li><li class=file><a href=https://minuk.dev/wiki/effective-java/ title=./wiki/effective-java/>Effective Java</a></li><li class=file><a href=https://minuk.dev/wiki/kafka/ title=./wiki/kafka/>Kafka</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/ title=./wiki/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/>면접 준비 자료</a></li><li class=file><a href=https://minuk.dev/wiki/zsh/ title=./wiki/zsh/>zsh</a></li><li class=file><a href=https://minuk.dev/wiki/simple-file/ title=./wiki/simple-file/>Simple한 File Server</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-12-03/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-12-03/>회고/2021-12-03</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week3/ title=./wiki/lectures/bayesian/week3/>bayesian/week3</a></li><li class=file><a href=https://minuk.dev/wiki/jupyter/ title=./wiki/jupyter/>jupyter notebook</a></li><li class=file><a href=https://minuk.dev/wiki/ffmpeg/ title=./wiki/ffmpeg/>ffmpeg 를 사용한 convert 요약</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week2/ title=./wiki/lectures/bayesian/week2/>bayesian/week2</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian/week1/ title=./wiki/lectures/bayesian/week1/>bayesian/week1</a></li><li class=file><a href=https://minuk.dev/wiki/pdf-test/ title=./wiki/pdf-test/>pdf-test</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/automata/ title=./wiki/lectures/automata/>오토마타와 형식언어 정리</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/computer-communication/ title=./wiki/lectures/computer-communication/>컴퓨터통신</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/introduction-to-statistical-learning/ title=./wiki/lectures/introduction-to-statistical-learning/>통계학습개론(Introduction to statistical learnning) 수업 정리</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/bayesian-statistics/ title=./wiki/lectures/bayesian-statistics/>베이지안 통계학(Bayesian Statistics)</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/multi-variant-statistical-analysis/ title=./wiki/lectures/multi-variant-statistical-analysis/>Multi Variant Statistical Analysis</a></li><li class=file><a href=https://minuk.dev/wiki/comment/ title=./wiki/comment/>주석 관련 좋은 글</a></li><li class=file><a href=https://minuk.dev/wiki/ssh/ title=./wiki/ssh/>ssh 관련 명령어 모음</a></li><li class=file><a href=https://minuk.dev/wiki/msk/ title=./wiki/msk/>amazon msk 삽질</a></li><li class=file><a href=https://minuk.dev/wiki/keras-book/ title=./wiki/keras-book/>케라스 창시자에게 배우는 딥러닝 책 공부</a></li><li class=file><a href=https://minuk.dev/wiki/msa-from-ddd/ title=./wiki/msa-from-ddd/>도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-07-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-07-18/>2021-07-21 회고</a></li><li class=file><a href=https://minuk.dev/wiki/iamroot19/ title=./wiki/iamroot19/>아이엠루트 스터디 자료 정리</a></li><li class=file><a href=https://minuk.dev/wiki/boj-9019/ title=./wiki/boj-9019/>boj-9019</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2021-06-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2021-06-19/>2021년 6월 19일 회고</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%8F%85%EC%84%B1%EB%A7%90%ED%88%AC/ title=./wiki/%EB%8F%85%EC%84%B1%EB%A7%90%ED%88%AC/>독성말투</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/regression/ title=./wiki/lectures/regression/>Regression Analysis</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%94%BC%EC%8B%9C%EC%8B%A4/ title=./wiki/%ED%94%BC%EC%8B%9C%EC%8B%A4/>피시실</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/multicore/ title=./wiki/lectures/multicore/>Multicore Computing</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/ns3/ title=./wiki/lectures/ns3/>Network Simulator 3</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/nonparametric-statistic/ title=./wiki/lectures/nonparametric-statistic/>비모수 통계학</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/wireless/ title=./wiki/lectures/wireless/>wireless 무선이동통신 수업</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/database_system/ title=./wiki/lectures/database_system/>Database System</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/ title=./wiki/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9B%8C%ED%81%AC/>카카오워크</a></li><li class=file><a href=https://minuk.dev/wiki/soma/ title=./wiki/soma/>소프트웨어 마에스트로</a></li><li class=file><a href=https://minuk.dev/wiki/linux_kakaotalk/ title=./wiki/linux_kakaotalk/>리눅스 카카오톡</a></li><li class=file><a href=https://minuk.dev/wiki/latina/ title=./wiki/latina/>라틴어</a></li><li class=file><a href=https://minuk.dev/wiki/blk-mq/ title=./wiki/blk-mq/>Multi-Queue Block IO Queueing (blk-mq)</a></li><li class=file><a href=https://minuk.dev/wiki/linux-study/ title=./wiki/linux-study/>linux-study</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-12-20/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-12-20/>2020-12-20 회고</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/scheduling/ title=./wiki/linux-debug/scheduling/>linux-debug/scheduling</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/synchronization/ title=./wiki/linux-debug/synchronization/>linux-debug/synchronization</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/timer/ title=./wiki/linux-debug/timer/>linux-debug/timer</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/workqueue/ title=./wiki/linux-debug/workqueue/>linux-debug/workqueue</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/interrupt/ title=./wiki/linux-debug/interrupt/>linux-debug/interrupt</a></li><li class=file><a href=https://minuk.dev/wiki/linux-debug/process/ title=./wiki/linux-debug/process/>linux-debug/process</a></li><li class=file><a href=https://minuk.dev/wiki/input-method/ title=./wiki/input-method/>linux input-method 삽질</a></li><li class=file><a href=https://minuk.dev/wiki/assembly/ title=./wiki/assembly/>assembly</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-10-24/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-10-24/>2020-10-24 회고</a></li><li class=file><a href=https://minuk.dev/wiki/contextmenu/ title=./wiki/contextmenu/>contextmenu</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-10-09/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-10-09/>2020-10-09 회고</a></li><li class=file><a href=https://minuk.dev/wiki/others/ title=./wiki/others/>others</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-09-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-09-18/>2020-09-18 회고</a></li><li class=file><a href=https://minuk.dev/wiki/seccomp/ title=./wiki/seccomp/>seccomp</a></li><li class=file><a href=https://minuk.dev/wiki/debug-linux/ title=./wiki/debug-linux/>디버깅을 통해 배우는 리눅스 커널의 구조와 원리</a></li><li class=file><a href=https://minuk.dev/wiki/fuse/ title=./wiki/fuse/>Filesystem in Userspace</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-08-30/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-08-30/>회고/2020-08-30</a></li><li class=file><a href=https://minuk.dev/wiki/raid/ title=./wiki/raid/>RAID(Redundant Array of Independent Disks)</a></li><li class=file><a href=https://minuk.dev/wiki/storage/ title=./wiki/storage/>Storage</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-08-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-08-17/>2020-08-17 회고</a></li><li class=file><a href=https://minuk.dev/wiki/teamnote/ title=./wiki/teamnote/>teamnote</a></li><li class=file><a href=https://minuk.dev/wiki/git/ title=./wiki/git/>git</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-07-31/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-07-31/>2020년 7월 31일자 회고</a></li><li class=file><a href=https://minuk.dev/wiki/3%EA%B3%B5%EB%85%B8%ED%8A%B8/ title=./wiki/3%EA%B3%B5%EB%85%B8%ED%8A%B8/>3공 노트</a></li><li class=file><a href=https://minuk.dev/wiki/nas/ title=./wiki/nas/>NAS</a></li><li class=file><a href=https://minuk.dev/wiki/lfs/ title=./wiki/lfs/>LFS Paper</a></li><li class=file><a href=https://minuk.dev/wiki/ftl/ title=./wiki/ftl/>Flash Translation Layer</a></li><li class=file><a href=https://minuk.dev/wiki/ppn/ title=./wiki/ppn/>PPN(Physical Page Number)</a></li><li class=file><a href=https://minuk.dev/wiki/lpn/ title=./wiki/lpn/>LPN(Logical Page Number)</a></li><li class=file><a href=https://minuk.dev/wiki/load-balance/ title=./wiki/load-balance/>Load Balance</a></li><li class=file><a href=https://minuk.dev/wiki/cache/ title=./wiki/cache/>Cache</a></li><li class=file><a href=https://minuk.dev/wiki/uart/ title=./wiki/uart/>UART (Universal asynchronous receiver/transmitter)</a></li><li class=file><a href=https://minuk.dev/wiki/vhdci/ title=./wiki/vhdci/>VHDCI (Very-high-dencity cable interconnect)</a></li><li class=file><a href=https://minuk.dev/wiki/boxplot/ title=./wiki/boxplot/>boxplot</a></li><li class=file><a href=https://minuk.dev/wiki/quartile/ title=./wiki/quartile/>quartile (사분위수)</a></li><li class=file><a href=https://minuk.dev/wiki/statistics/ title=./wiki/statistics/>statistics</a></li><li class=file><a href=https://minuk.dev/wiki/fsm/ title=./wiki/fsm/>FSM (Finite State machine)</a></li><li class=file><a href=https://minuk.dev/wiki/open-nvm/ title=./wiki/open-nvm/>open-nvm</a></li><li class=file><a href=https://minuk.dev/wiki/mram/ title=./wiki/mram/>MRAM (Magnetic Random Access Memory)</a></li><li class=file><a href=https://minuk.dev/wiki/file/ title=./wiki/file/>vfs - file</a></li><li class=file><a href=https://minuk.dev/wiki/kiocb/ title=./wiki/kiocb/>kiocb</a></li><li class=file><a href=https://minuk.dev/wiki/vfs/ title=./wiki/vfs/>VFS-Virtual File System</a></li><li class=file><a href=https://minuk.dev/wiki/linux/ title=./wiki/linux/>linux</a></li><li class=file><a href=https://minuk.dev/wiki/f2fs-paper/ title=./wiki/f2fs-paper/>F2FS- A New File System for Flash Storage</a></li><li class=file><a href=https://minuk.dev/wiki/english/proverb/ title=./wiki/english/proverb/>english/proverb</a></li><li class=file><a href=https://minuk.dev/wiki/english/ title=./wiki/english/>english</a></li><li class=file><a href=https://minuk.dev/wiki/tool/ title=./wiki/tool/>tool</a></li><li class=file><a href=https://minuk.dev/wiki/verilog/ title=./wiki/verilog/>verilog (베릴로그)</a></li><li class=file><a href=https://minuk.dev/wiki/iommu/ title=./wiki/iommu/>IOMMU (Input Output Memory Management Unit)</a></li><li class=file><a href=https://minuk.dev/wiki/delayed_work/ title=./wiki/delayed_work/>delayed work</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-06-21/>회고/2020-06-21</a></li><li class=file><a href=https://minuk.dev/wiki/jwt/ title=./wiki/jwt/>json web token(jwt)</a></li><li class=file><a href=https://minuk.dev/wiki/tmuxinator/ title=./wiki/tmuxinator/>tmuxinator</a></li><li class=file><a href=https://minuk.dev/wiki/vim-staritfy/ title=./wiki/vim-staritfy/>vim-startify</a></li><li class=file><a href=https://minuk.dev/wiki/my-page/ title=./wiki/my-page/>my-page (나만의 홈페이지 만들기)</a></li><li class=file><a href=https://minuk.dev/wiki/blk_mq/ title=./wiki/blk_mq/>blk_mq</a></li><li class=file><a href=https://minuk.dev/wiki/prp/ title=./wiki/prp/>PRP (Physical Region Page)</a></li><li class=file><a href=https://minuk.dev/wiki/numa/ title=./wiki/numa/>NUMA</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-06-17/>회고/2020-06-17</a></li><li class=file><a href=https://minuk.dev/wiki/block-layer/ title=./wiki/block-layer/>block layer</a></li><li class=file><a href=https://minuk.dev/wiki/workqueue/ title=./wiki/workqueue/>workqueue</a></li><li class=file><a href=https://minuk.dev/wiki/nvme/ title=./wiki/nvme/>nvme</a></li><li class=file><a href=https://minuk.dev/wiki/gem5/ title=./wiki/gem5/>gem5</a></li><li class=file><a href=https://minuk.dev/wiki/simplessd/ title=./wiki/simplessd/>simple-ssd</a></li><li class=file><a href=https://minuk.dev/wiki/mmap/ title=./wiki/mmap/>mmap</a></li><li class=file><a href=https://minuk.dev/wiki/b+tree/ title=./wiki/b+tree/>B+ Tree</a></li><li class=file><a href=https://minuk.dev/wiki/database/ title=./wiki/database/>Database</a></li><li class=file><a href=https://minuk.dev/wiki/memory-cache-clean/ title=./wiki/memory-cache-clean/>memory cache 비우기 (linux command)</a></li><li class=file><a href=https://minuk.dev/wiki/free/ title=./wiki/free/>free (linux command)</a></li><li class=file><a href=https://minuk.dev/wiki/clflush/ title=./wiki/clflush/>clflush (cache line flush)</a></li><li class=file><a href=https://minuk.dev/wiki/c++/ title=./wiki/c++/>C++ Language</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/ title=./wiki/%EC%82%AC%EC%A7%80%EB%B0%A9/>사지방</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/ title=./wiki/%ED%9A%8C%EA%B3%A0/3%EC%9B%94/>2020년 3월 회고</a></li><li class=file><a href=https://minuk.dev/wiki/mysql/ title=./wiki/mysql/>mysql (storage engine)</a></li><li class=file><a href=https://minuk.dev/wiki/block-group/ title=./wiki/block-group/>block group</a></li><li class=file><a href=https://minuk.dev/wiki/journal/ title=./wiki/journal/>journal(journaling)</a></li><li class=file><a href=https://minuk.dev/wiki/group-descriptor-table/ title=./wiki/group-descriptor-table/>group descriptor table</a></li><li class=file><a href=https://minuk.dev/wiki/inode/ title=./wiki/inode/>inode</a></li><li class=file><a href=https://minuk.dev/wiki/superblock/ title=./wiki/superblock/>Superblock</a></li><li class=file><a href=https://minuk.dev/wiki/ext4/ title=./wiki/ext4/>The new ext4 filesystem: current status and future plans</a></li><li class=file><a href=https://minuk.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/ title=./wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/>계룡 개발 모임</a></li><li class=file><a href=https://minuk.dev/wiki/ssd/ title=./wiki/ssd/>SSD</a></li><li class=file><a href=https://minuk.dev/wiki/gutentags/ title=./wiki/gutentags/>gutentags</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-18--%EB%A9%94%EB%A9%98%ED%86%A0/ title=./wiki/modern-c++-design-pattern/chapter-18--%EB%A9%94%EB%A9%98%ED%86%A0/>Modern C++ Design Pattern/Chatper 18. 메멘토</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-17--%EB%A7%A4%EA%B0%9C%EC%9E%90/ title=./wiki/modern-c++-design-pattern/chapter-17--%EB%A7%A4%EA%B0%9C%EC%9E%90/>Modern C++ Design Pattern/Chatper 17. 매개자</a></li><li class=file><a href=https://minuk.dev/wiki/boj/ title=./wiki/boj/>boj</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-16--%EB%B0%98%EB%B3%B5%EC%9E%90/ title=./wiki/modern-c++-design-pattern/chapter-16--%EB%B0%98%EB%B3%B5%EC%9E%90/>Modern C++ Design Pattern/Chatper 16. 반복자</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-04-20/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-04-20/>회고/2020.04.20</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-15--%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-15--%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/>Modern C++ Design Pattern/Chatper 15. 인터프리터</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-14--%EC%BB%A4%EB%A7%A8%EB%93%9C/ title=./wiki/modern-c++-design-pattern/chapter-14--%EC%BB%A4%EB%A7%A8%EB%93%9C/>Modern C++ Design Pattern/Chatper 14. 커맨드</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-13--%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/ title=./wiki/modern-c++-design-pattern/chapter-13--%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/>Modern C++ Design Pattern/Chatper 13. 책임사슬(Chain of Responsibility)</a></li><li class=file><a href=https://minuk.dev/wiki/coc/ title=./wiki/coc/>coc (vim plugin coc)</a></li><li class=file><a href=https://minuk.dev/wiki/regex/ title=./wiki/regex/>Regular Expression (regex)</a></li><li class=file><a href=https://minuk.dev/wiki/glob/ title=./wiki/glob/>glob</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-12--%ED%94%84%EB%A1%9D%EC%8B%9C/ title=./wiki/modern-c++-design-pattern/chapter-12--%ED%94%84%EB%A1%9D%EC%8B%9C/>Modern C++ Design Pattern/Chapter 12. 프록시</a></li><li class=file><a href=https://minuk.dev/wiki/hugo/ title=./wiki/hugo/>hugo</a></li><li class=file><a href=https://minuk.dev/wiki/tee/ title=./wiki/tee/>tee (Linux Command)</a></li><li class=file><a href=https://minuk.dev/wiki/rm/ title=./wiki/rm/>rm (Linux Command)</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-11--%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/ title=./wiki/modern-c++-design-pattern/chapter-11--%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/>Modern C++ Design Pattern/Chapter 11. 플라이웨이트</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-10--%ED%8D%BC%EC%82%AC%EB%93%9C/ title=./wiki/modern-c++-design-pattern/chapter-10--%ED%8D%BC%EC%82%AC%EB%93%9C/>Modern C++ Design Pattern/Chapter 10. 퍼사드</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-7--%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-7--%EC%8B%A4%ED%96%89-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chatper 7. 컴파일 시간 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-8--%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/ title=./wiki/effective-debugging/chapter-8--%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%EB%94%94%EB%B2%84%EA%B9%85/>Effective Debugging/Chatper 8. 멀티스레드 코드 디버깅</a></li><li class=file><a href=https://minuk.dev/wiki/todo/ title=./wiki/todo/>TODO Lists</a></li><li class=file><a href=https://minuk.dev/wiki/vim/ title=./wiki/vim/>vim</a></li><li class=file><a href=https://minuk.dev/wiki/vimwiki/ title=./wiki/vimwiki/>vimwiki</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-04-08/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-04-08/>회고/2020-04-08</a></li><li class=file><a href=https://minuk.dev/wiki/cloudatcost/ title=./wiki/cloudatcost/>cloudatcost</a></li><li class=file><a href=https://minuk.dev/wiki/web/ title=./wiki/web/>web</a></li><li class=file><a href=https://minuk.dev/wiki/nginx/ title=./wiki/nginx/>nginx</a></li><li class=file><a href=https://minuk.dev/wiki/understanding-linux-kernel/ title=./wiki/understanding-linux-kernel/>Understanding Linux Kernel</a></li><li class=file><a href=https://minuk.dev/wiki/mathematical-statistics/ title=./wiki/mathematical-statistics/>Mathematical Statistics</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/ title=./wiki/effective-debugging/>Effective Debugging</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-1--%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/ title=./wiki/effective-debugging/chapter-1--%EA%B3%A0%EC%B0%A8%EC%9B%90-%EC%A0%84%EB%9E%B5/>Effective Debugging/Chapter 1. 고차원 전략</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-2--%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-2--%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8-%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 2. 범용적인 디버깅 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-3--%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-3--%EB%B2%94%EC%9A%A9-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 3. 범용 도구를 활용한 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chapter-5--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chapter-5--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chapter 5. 프로그래밍 기법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chatper-4--%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/ title=./wiki/effective-debugging/chatper-4--%EB%94%94%EB%B2%84%EA%B1%B0-%ED%99%9C%EC%9A%A9%EB%B2%95/>Effective Debugging/Chatper 4. 디버거 활용법</a></li><li class=file><a href=https://minuk.dev/wiki/effective-debugging/chatper-6--%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/ title=./wiki/effective-debugging/chatper-6--%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EA%B0%84-%EA%B8%B0%EB%B2%95/>Effective Debugging/Chatper 6. 컴파일 시간 기법</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/ title=./wiki/modern-c++-design-pattern/>Modern C++ Design Pattern</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-1--%EA%B0%9C%EC%9A%94/ title=./wiki/modern-c++-design-pattern/chapter-1--%EA%B0%9C%EC%9A%94/>Modern C++ Design Pattern/Chatper 1. 개요</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-2--%EB%B9%8C%EB%8D%94/ title=./wiki/modern-c++-design-pattern/chapter-2--%EB%B9%8C%EB%8D%94/>Modern C++ Design Pattern/Chatper 2. 빌더</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-4--%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/ title=./wiki/modern-c++-design-pattern/chapter-4--%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/>Modern C++ Design Pattern/Chatper 4. 프로토타입</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-5--%EC%8B%B1%EA%B8%80%ED%84%B4/ title=./wiki/modern-c++-design-pattern/chapter-5--%EC%8B%B1%EA%B8%80%ED%84%B4/>Modern C++ Design Pattern/Chatper 5. 싱글턴</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-6--%EC%96%B4%EB%8C%91%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-6--%EC%96%B4%EB%8C%91%ED%84%B0/>Modern C++ Design Pattern/Chatper 6. 어댑터</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-7--%EB%B8%8C%EB%A6%BF%EC%A7%80/ title=./wiki/modern-c++-design-pattern/chapter-7--%EB%B8%8C%EB%A6%BF%EC%A7%80/>Modern C++ Design Pattern/Chatper 7. 브릿지</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-8--%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/ title=./wiki/modern-c++-design-pattern/chapter-8--%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/>Modern C++ Design Pattern/Chatper 8. 컴포지트</a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-9--%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/ title=./wiki/modern-c++-design-pattern/chapter-9--%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/>Modern C++ Design Pattern/Chatper 9. 데코레이터</a></li><li class=file><a href=https://minuk.dev/wiki/book-reviews/ title=./wiki/book-reviews/>Book Review</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/algorithm/ title=./wiki/lectures/algorithm/>lectures/algorithm</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/computer-architecture/ title=./wiki/lectures/computer-architecture/>lectures/computer architecture</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/image-processing/ title=./wiki/lectures/image-processing/>lectures/image processing</a></li><li class=file><a href=https://minuk.dev/wiki/lectures/ title=./wiki/lectures/>학교 수업</a></li><li class=file><a href=https://minuk.dev/wiki/tool-configuration/ title=./wiki/tool-configuration/>Tool configuration</a></li><li class=file><a href=https://minuk.dev/wiki/ssh-server/ title=./wiki/ssh-server/>SSH Server Configuration</a></li><li class=file><a href=https://minuk.dev/wiki/firewall/ title=./wiki/firewall/>Firewall (방화벽) Configuration</a></li><li class=file><a href=https://minuk.dev/wiki/ftp/ title=./wiki/ftp/>ftp server command</a></li><li class=file><a href=https://minuk.dev/wiki/user/ title=./wiki/user/>linux user command</a></li><li class=file><a href=https://minuk.dev/wiki/brightness/ title=./wiki/brightness/>Brightness (화면 밝기 조절) command</a></li><li class=file><a href=https://minuk.dev/wiki/wifi-command-line/ title=./wiki/wifi-command-line/>Wifi commands</a></li><li class=file><a href=https://minuk.dev/wiki/wifi/ title=./wiki/wifi/>Wifi commands</a></li><li class=file><a href=https://minuk.dev/wiki/linux-command/ title=./wiki/linux-command/>Linux Command 모음</a></li><li class=file><a href=https://minuk.dev/wiki/docker/ title=./wiki/docker/>docker</a></li><li class=file><a href=https://minuk.dev/wiki/sql/ title=./wiki/sql/>SQL</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/function/ title=./wiki/typescript/function/>Typescript/Function</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/class/ title=./wiki/typescript/class/>Typescript/Class</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/interface/ title=./wiki/typescript/interface/>Typescript/Interface</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/variable-declaration/ title=./wiki/typescript/variable-declaration/>Typescript/Variable Declaration</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/types/ title=./wiki/typescript/types/>Typescript/Types</a></li><li class=file><a href=https://minuk.dev/wiki/typescript/ title=./wiki/typescript/>Typescript</a></li><li class=file><a href=https://minuk.dev/wiki/graphql-typescript/ title=./wiki/graphql-typescript/>graphql typescript (deprecated)</a></li><li class=file><a href=https://minuk.dev/wiki/winston/ title=./wiki/winston/>winston</a></li><li class=file><a href=https://minuk.dev/wiki/jest/ title=./wiki/jest/>Jest</a></li><li class=file><a href=https://minuk.dev/wiki/sequelize/ title=./wiki/sequelize/>Sequelize</a></li><li class=file><a href=https://minuk.dev/wiki/fetch/ title=./wiki/fetch/>Fetch 문법 간단 정리</a></li><li class=file><a href=https://minuk.dev/wiki/promise/ title=./wiki/promise/>Promise 정리</a></li><li class=file><a href=https://minuk.dev/wiki/javascript/ title=./wiki/javascript/>JavaScript</a></li><li class=file><a href=https://minuk.dev/wiki/nexus/ title=./wiki/nexus/>Nexus</a></li><li class=file><a href=https://minuk.dev/wiki/ssdsolid-state-drive/ title=./wiki/ssdsolid-state-drive/>SSD(Solid-State Drive)</a></li><li class=file><a href=https://minuk.dev/wiki/pintos/ title=./wiki/pintos/>Pintos</a></li><li class=file><a href=https://minuk.dev/wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/ title=./wiki/%EB%B2%84%EC%8A%A4-%EC%8B%9C%EA%B0%84-%EB%A9%94%EB%AA%A8/>Bus 시간 메모</a></li><li class=file><a href=https://minuk.dev/wiki/5-articles-per-week/ title=./wiki/5-articles-per-week/>5 articles per week</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/ title=./wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/>썩어버린 Query Language</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/ title=./wiki/%ED%9A%8C%EA%B3%A0/>회고 모음</a></li><li class=file><a href=https://minuk.dev/wiki/memory_leak/ title=./wiki/memory_leak/>Javascript Memory Leak</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/ title=./wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/>송편 생성기 (추석 대회)</a></li><li class=file><a href=https://minuk.dev/wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/ title=./wiki/endurable_transient_inconsistency_in_byte_addressable_persistent_b+-tree/>Endurable Transient Inconsistency in Byte Addressable Persistent B+-Tree</a></li><li class=file><a href=https://minuk.dev/wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/ title=./wiki/ssd-%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C/>SSD 공부 자료 모음</a></li><li class=file><a href=https://minuk.dev/wiki/%EA%B0%9C%EB%B0%9C_todo/ title=./wiki/%EA%B0%9C%EB%B0%9C_todo/>개발 TODO</a></li><li class=file><a href=https://minuk.dev/wiki/f2fs/ title=./wiki/f2fs/>F2FS</a></li><li class=file><a href=https://minuk.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/ title=./wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/>설대회</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-01-01/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-01-01/>회고/2020-01-01</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-01-17/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-01-17/>회고/2020-01-17</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-11-24/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-11-24/>회고/2019.11.24</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-10-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-10-19/>회고/2019.10.19</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-09-19/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-09-19/>회고/2019.09.19</a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2019-09-18/ title=./wiki/%ED%9A%8C%EA%B3%A0/2019-09-18/>회고/2019.09.18</a></li><li class=file><a href=https://minuk.dev/wiki/2024-12-23/ title=./wiki/2024-12-23/></a></li><li class=file><a href=https://minuk.dev/wiki/2025-01-05/ title=./wiki/2025-01-05/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/2025-01-10/ title=./wiki/daily/2025-01-10/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.41.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.41.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.49.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.49.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/daily/drawing-2025-01-05-06.04.59.excalidraw/ title=./wiki/daily/drawing-2025-01-05-06.04.59.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-05-05.12.23.excalidraw/ title=./wiki/drawings/drawing-2025-01-05-05.12.23.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-05-05.54.32.excalidraw/ title=./wiki/drawings/drawing-2025-01-05-05.54.32.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/drawings/drawing-2025-01-13-00.26.22.excalidraw/ title=./wiki/drawings/drawing-2025-01-13-00.26.22.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/excalidraw/test-draw/ title=./wiki/excalidraw/test-draw/></a></li><li class=file><a href=https://minuk.dev/wiki/ipad/ title=./wiki/ipad/></a></li><li class=file><a href=https://minuk.dev/wiki/jekyll-%EA%B8%B0%EB%B0%98-wiki-%EC%97%90%EC%84%9C-hugo-%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EA%B8%B0/ title=./wiki/jekyll-%EA%B8%B0%EB%B0%98-wiki-%EC%97%90%EC%84%9C-hugo-%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EA%B8%B0/></a></li><li class=file><a href=https://minuk.dev/wiki/lectures/compiler/ title=./wiki/lectures/compiler/></a></li><li class=file><a href=https://minuk.dev/wiki/lectures/signal_and_system/ title=./wiki/lectures/signal_and_system/></a></li><li class=file><a href=https://minuk.dev/wiki/macos-initialization/ title=./wiki/macos-initialization/></a></li><li class=file><a href=https://minuk.dev/wiki/modern-c++-design-pattern/chapter-3--%ED%8C%A9%ED%86%A0%EB%A6%AC/ title=./wiki/modern-c++-design-pattern/chapter-3--%ED%8C%A9%ED%86%A0%EB%A6%AC/></a></li><li class=file><a href=https://minuk.dev/wiki/test.excalidraw/ title=./wiki/test.excalidraw/></a></li><li class=file><a href=https://minuk.dev/wiki/test/ title=./wiki/test/></a></li><li class=file><a href=https://minuk.dev/wiki/ucpc_2018_%EC%98%88%EC%84%A0/ title=./wiki/ucpc_2018_%EC%98%88%EC%84%A0/></a></li><li class=file><a href=https://minuk.dev/wiki/%EB%8D%B0%EC%A4%91%EC%96%B4%EC%84%A4/ title=./wiki/%EB%8D%B0%EC%A4%91%EC%96%B4%EC%84%A4/></a></li><li class=file><a href=https://minuk.dev/wiki/%EC%9D%98%EA%B2%AC-%EB%A9%94%EB%AA%A8/ title=./wiki/%EC%9D%98%EA%B2%AC-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%EC%A3%BC%EC%9E%A5-%EB%A9%94%EB%AA%A8/ title=./wiki/%EC%A3%BC%EC%9E%A5-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%A9%94%EB%AA%A8/ title=./wiki/%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%A9%94%EB%AA%A8/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9/ title=./wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9/></a></li><li class=file><a href=https://minuk.dev/wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/ title=./wiki/%ED%9A%8C%EA%B3%A0/2020-05-30/></a></li><li class=file><a href=https://minuk.dev/wiki/tags/ title=./wiki/tags/>tag page</a></li></ul></li><li class=file><a href=https://minuk.dev/about/ title=./about/>about</a></li></ul></aside><aside class=exapandable></aside><article class=main><button class=sidebar-toggle-btn type=menu aria-expanded=false aria-haspopup=true>
<i class="bi bi-list"></i></button><div class=title><h1 class=title-header>simple-ssd</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/simplessd.md><h5>created : Wed, 10 Jun 2020 19:39:41 +0900</h5><h5>modified : Wed, 26 Aug 2020 20:54:02 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
Front Page
[[ssd]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i>
<a href=/tags/ssd class=tag-btn>ssd</a></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#새롭게-알게된-것>새롭게 알게된 것</a></li><li><a href=#다운로드>다운로드</a></li><li><a href=#문서-읽기>문서 읽기</a></li><li><a href=#그림으로-그려보기>그림으로 그려보기</a><ul><li><a href=#host-interface-layer>Host Interface Layer</a></li><li><a href=#ssd-interface>SSD Interface</a></li></ul></li><li><a href=#internal-cache-layer>Internal Cache Layer</a><ul><li><a href=#abstract-class>Abstract Class</a></li><li><a href=#set-associative-cache>Set-Associative Cache</a></li><li><a href=#호출구조>호출구조</a></li><li><a href=#cache-로직-공부>Cache 로직 공부</a></li></ul></li></ul></nav></aside><div class=content><h2 id=새롭게-알게된-것>새롭게 알게된 것</h2><ul><li>[[gem5]]</li></ul><h2 id=다운로드>다운로드</h2><ul><li><a href=https://docs.simplessd.org/en/v2.0.12/instructions/start.html>simplessd 공홈</a></li><li>하라는 대로 하면 된다. (FullSystem은 example 을 실행해도 그대로 안되서, 그냥 standalone 을 먼저 봐보기로 했다.)</li></ul><hr><h2 id=문서-읽기>문서 읽기</h2><ul><li>그냥 홈페이지에 있는 문서를 읽어보자. 중요하니까 정리해놨겠지</li></ul><h2 id=그림으로-그려보기>그림으로 그려보기</h2><ul><li><img src=/wiki/images/simplessd.png alt="simplessd drawio"></li></ul><hr><h3 id=host-interface-layer>Host Interface Layer</h3><ul><li>HIL 이라고도 불리는 Host Interface Layer에 대한 설명이다.</li><li>HIL 은 host side에 있는 host controller, host controller 에게 추상화된 API를 제공해주는 SSD Interface</li></ul><h4 id=host-controller>Host Controller</h4><ul><li>NVMe, SATA and UFS를 구현해 놓았으며, Open-Channel SSD 는 NVMe 를 상속받음.</li></ul><h5 id=host-interface>Host Interface</h5><ul><li><code>hil/nvme/interface.hh</code> 에 <code>SimpleSSD::DMAInterface</code>를 상속하여 선언된 <code>SimpleSSD::HIL::NVMe::Interface</code> 를 보자.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DMAInterface</span> {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  DMAInterface() {}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>DMAInterface() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dmaRead</span>(<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>, DMAFunction <span style=color:#f92672>&amp;</span>,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dmaWrite</span>(<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>, DMAFunction <span style=color:#f92672>&amp;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};</span></span></code></pre></div></div><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Interface</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> SimpleSSD<span style=color:#f92672>::</span>DMAInterface {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  Controller <span style=color:#f92672>*</span>pController;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> updateInterrupt(<span style=color:#66d9ef>uint16_t</span>, <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getVendorID</span>(<span style=color:#66d9ef>uint16_t</span> <span style=color:#f92672>&amp;</span>, <span style=color:#66d9ef>uint16_t</span> <span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};</span></span></code></pre></div></div><ul><li><code>DMAInterface</code> 에서는 Direct Memory Access 를 위해서 <code>dmaRead</code>, <code>dmaWrite</code> 를 제공한다.</li><li><code>updateInterrupt</code> 는 host의 특정 interrupt vector 에 interrupt를 보낸다.</li><li><code>getVendorId</code> 는 NVMe의 <code>Identify Controller</code>가 vendor Id와 subsystem vendor ID를 필요로 하기 때문에 존재하는 method 이다.</li></ul><h5 id=controller-and-firmware>Controller and Firmware</h5><ul><li>NVMe controller/firmware 는 아래 3가지 컴포넌트 (Controller, Subsystem and Namespace)로 구성된다.<ul><li>Controller는 모든 queue 연산(SQ 에서 request 를 읽고, CQ에 request를 쓰고, 인터럽트를 발생시키는)을 담당한다.</li><li>Subsystem은 모든 NVMe의 admin commands를 다루며, Namespace를 제어하고, SSD Layer에 I/O를 실행한다.</li><li>Namespace는 모든 NVMe의 I/O commands 를 다룬다.</li></ul></li></ul><h6 id=controller>Controller</h6><ul><li><p>모든 queue 연산을 담당하는 Controller는 <code>hil/nvme/controller.hh</code>에 <code>SimpleSSD::HIL::NVMe::Controller</code> 로 정의되어 있다.</p></li><li><p><code>EventEngine</code>은 주기적으로 <code>Controller::work</code>를 유발시키며, 이때 주기는 <code>WorkPeriod</code> 설정값을 참조한다.</p></li><li><p><code>Controller::work</code> 는 설정된 중재 함수(<code>Controller::collectSQueue</code>)를 사용하여 모든 submission queue를 모은다.</p></li><li><p>새로운 <code>Request</code>는 내부의 FIFO Queue(<code>Controller::lSQFIFO</code>) 에 넣어지며, 새로운 Request 가 있다면, <code>Controller:handleRequest</code>를 호출해야 한다. 이때 이 함수는 <code>AbstractSubsystem::submitReqeust</code>를 유발한다.</p></li><li><p><code>AbstractSubsystem</code> 이 request를 처리하고 난 뒤, <code>Controller::submit</code> 함수가 불려지게 되며, 내부적으로 존재하는 FIFO Queue(<code>Controller::lCQFIFO</code>)에 완료된 걸 넣는다.</p></li><li><p><code>Controller::submit</code> 함수는 <code>Controller::completion</code> 함수를 부르는 event를 관리한다.</p></li><li><p><code>Controller::completion</code> 함수는 CQ entry를 채우고, <code>Controller::updateInterrupt</code> 를 사용해서 interrupt를 보낸다.</p></li><li><p><code>Controller::updateInterrupt</code>는 단순히 <code>Interface::updateInterrupt</code>를 호출한다.</p></li></ul><h6 id=subsystem>Subsystem</h6><ul><li><p>admin commmands를 다루는 NVMe Subsystem은 <code>hil/nvme/subsystem.hh</code>에 <code>SimpleSSD::HIL::NVMe::Subsystem</code> 으로 선언되어 있다.</p></li><li><p>Open-channel SSD Subsystem은 <code>hil/nvme/ocssd.hh</code>에 <code>SimpleSSD::HIL::NVMe::OpenChannelSSD</code>로 선언되어 있다.</p></li><li><p>두 subsystem 모두 <code>hil/nvme/abstract_subsystem.hh</code>의 <code>SimpleSSD::HIL::NVMe::AbstractSubsystem</code> 을 상속한다.</p></li><li><p>기본적으로 아래쪽 설명들은 NVMe subsystem 을 기반으로 하고 있는데, Open-Channel SSD 랑 사소한 차이만 있기 때문이다.</p></li><li><p>NVMe Subsystem은 2부분으로 나뉘는데, command handling, I/O request handling.</p></li><li><p>Subsystem이 여러 namespaces를 가질수 있으므로, Subsystem은 반드시 I/O requests 를 Namespaces 로부터 HIL의 SSD Interface로 넘겨줘야 한다.</p></li><li><p>각 NVMe 명령들은</p><ul><li>I/O 명령이라면, <code>Subsystem::submitCommand</code> 함수를 통해서 특정한 Namespace로 가지게 되며.</li><li>관리용(admin) 명령이라면, <code>submitCommand</code> 함수는 OPCODE를 확인한 이후 적절한 함수를 호출하게 된다.</li></ul></li><li><p>모든 명령들은 완료됨을 알리기 위해서 <code>Controller::submit</code> 를 유발한다.</p></li><li><p>특정한 I/O 함수들(<code>Subsystem::read, write, flush and trim</code>)이 불리게 된다면, I/O unit으로 번역된뒤, SSD Intreface의 함수들로 간다. (<code>HIL::HIL::read</code>, <code>HIL::HIL::write</code>, <code>HIL::HIL::flush</code> and <code>HIL::HIL::trim</code>);</p></li><li><p>SSD를 선형적으로 쪼개기 위해서, Subsystem은 multiple Namespaces를 유지한다.</p><ul><li>예를 들어 1TB SSD 가 4K 논리적 block을 사용한다고 하자. 이때 512GB, 256GB, 256GB 용량으로 3개의 Namespaces로 쪼갤수 있다.</li><li>Subsystem은 offset과 length를 찾아서 namespaces를 할당할 것이고, Subsystem은 할당되지 않은 공간을 처음 맞는 Namespaces에 할당한다.(first-fit). 만약 공간이 없다면 할당이 실패한다.</li></ul></li><li><p>각 Namespace 마다 offset과 length를 가지고 있으며, 이 값은 SSD interface를 위해 I/O unit으로 번역될때 쓰인다.</p></li></ul><h6 id=namespace>Namespace</h6><ul><li>I/O 명령을 다루는 NVMe Namespace는 <code>hil/nvme/namespace.hh</code>에 <code>SimpleSSD::HIL::NVMe::Namespace</code>로 선언되어 있으며. NVMe Subsystem과 비슷한 구조를 다룬다.(둘다 command를 다룬다.)</li><li>I/O 명령이 오면, Namespace 는 Subsystem의 해당 함수들을 호출한다.(<code>read</code>, <code>write</code>, <code>flush</code> and <code>trim</code>).</li></ul><h4 id=serial-at-attachment>Serial AT Attachment</h4><ul><li>Serial AT Attachment - SATA 는 SSD와 HDD를 위한 전통적 interface이다.</li><li>SimpleSSD 에서는 Serial ATA Advanced host Controller Interface (AHCI) 1.3.1 에 기반한 STATA HBA를 구현하였고, Serial ATA Revision 3.0 에 기반을 둔 STAT PHY와 프로토콜을 구현하였다.</li></ul><h5 id=host-interface-1>Host interface</h5><ul><li><p><code>hil/sata/interface.hh</code>에 선언된 <code>SimpleSSD::HIL::SATA::Interface</code> 추상 클래스는 simulator에게 common API를 제공한다.</p></li><li><p>SimpleSSD-FUllSystem 에서 <code>src/dev/storage/sata_interrface.hh</code>에 선언된 <code>SATAInterface</code> 에서 어떻게 상속하는지 확인할 수 있다.</p></li><li><p><code>SimpleSSD::HIL::SATA::Interface</code> 은 오직 <code>virtual void updateInterrupt(bool) = 0</code>를 interrupt posting 을 위해서 포함하고 있다.</p></li></ul><h5 id=host-bus-adapter>Host Bus Adapter</h5><ul><li><p>SATA는 Host Bus Adapter(HBA) 라고 불리는 host sid controller 를 필요로 한다.</p></li><li><p>HBA 디자인은 다양하지만, 우리는 누구나 접근할수 있는 AHCI spcification을 사용했다.</p></li><li><p>우리는 단 하나의 SimpleSSD 인스턴스만 HBA에 연결되기 때문에 단 하나의 port 만 구현했다.</p></li><li><p><code>Interface</code>는 AHCI registser(Genetic Host Controller registers and Port registers)를 <code>HBA::writeAHCIRegister</code> 함수를 통해서 쓴다.</p></li><li><p><code>PxCl</code> register에 bits를 쓰는 건 그에 대항하는 NCQ에 새로운 요청이 있다는걸 의미한다.</p></li><li><p><code>HBA</code>는 내부 FIFO(<code>HBA::lRequestQueue</code>)에 request를 넣기 위해서 <code>HBA::processCommand</code> 를 호출한다.</p></li><li><p>NVMe와 동일하게 <em>Event Engine</em>은 주기적으로 <code>HBA::work</code> 함수를 호출하고, 이 함수는 <code>HBA::handleRequest</code> 함수를 호출하고와 <code>Device::submitCommand</code> 함수가 불리게 된다.</p></li><li><p>command handling 이후 <code>Device</code>는 <code>HBA::submitFIS</code> 함수를 FIS 응답을 host에게 돌려주기 위해서 부른다. <code>HBA::submitFIS</code> 함수는 <code>HBA::lResponseQueue</code>에 응답을 넣고, <code>HBA::handleResponse</code> 함수를 호출하는 event를 예약한다. <code>handleResponse</code> 함수는 내부의 FIFO에서부터 첫번째 response를 읽고, NCQ에 써서 <code>Interface::updateInterrupt</code> 함수를 사용해 Interrupt를 보낸다.</p></li></ul><h5 id=device>Device</h5><ul><li><code>hil/sata/device.hh</code> 에 선언된 <code>SimpleSSD::HIL::SATA::Device</code>는 HBA와 연결하는 Device이다.</li><li>Device는 아래 나열된 ATA 명령어(ATA/ATAPI Command Set -2 (ACS-2) 와 (AT Attachment 8 - ATA/ATAPI Command Set (ATA8-ACS))를 다룰수 있다.<ul><li><code>FLUSH CACHE</code></li><li><code>FLUSH CACHE EXT</code></li><li><code>IDENTIFY DEVICE</code></li><li><code>READ DMA</code></li><li><code>READ DMA EXT</code></li><li><code>READ FPDMA QUEUED</code></li><li><code>READ SECTOR</code></li><li><code>READ SECTOR EXT</code></li><li><code>READ VERIFY SECTOR</code></li><li><code>READ VERIFY SECTOR EXT</code></li><li><code>SET FEATURE</code></li><li><code>WRITE DMA</code></li><li><code>WRTIE DMA EXT</code></li><li><code>WRITE FPDMA QUEUED</code></li><li><code>WRTIE SECTOR</code></li><li><code>WRTIE SECTOR EXT</code></li></ul></li><li>Device 의 구현이 NVMe Subsystem에 비해 간단해 보일수 있는데, 이는 Namespace를 관리할 필요가 없기 때문이다.</li><li>모든 명령어들은 <code>Device::submitCommand</code> 함수를 통과하며 적절하게 다루어진다.</li><li>완료 이후, 각 명령어들은 명령의 결과를 <code>HBA</code>에게 보고하기(report) 위해서 <code>HBA::submitFIS</code>를 호출한다.</li><li>I/O 와 관련된 <code>READ*</code>, <code>WRITE*</code> and <code>FLUSH*</code> 는 SSD Interface의 함수 (<code>HIL::HIL::read, write and flush</code>) 를 호출한다.</li></ul><h4 id=universal-flash-storage>Universal Flash Storage</h4><ul><li>Universal Flash Storage - UFS : 모바일용 저장소를 위해 디자인된 interface. 대부분의 스마트폰들이 이 UFS interface를 사용하고 있다.</li><li>SimpleSSD 에서는 <code>Universal Flash Storage (UFS) Host Controller Interface (JESD223)</code>을 기반으로 UFS Host Controller를 구현하였으며, UFS PHY는 <code>Specification for M-PHY Version 4.0</code> 을, UFS protocol은 <code>Universal Flash Storage (UFS) Version 2.1 (JESD220C)</code>를 기반으로 한다.</li></ul><h5 id=host-interface-2>Host Interface</h5><ul><li><code>SimpleSSD::HIL::UFS::Interface</code> 는 simulator에게 common API를 제공하기 위해 추상 클래스로 <code>hil/ufs/interface.hh</code> 에 정의되어 있다. 어떻게 구체화 하는지는 SimpleSSD_FullSystem의 <code>UFSInterface</code> 는 <code>scr/dev/storage/ufs_interface.hh</code> 에 나와 있다.</li><li><code>SimpleSSD::HIL::UFS::Interface</code> 는 단지 <code>generateInterrrupt()</code> 와 <code>clearInterrupt()</code> 를 포함한다.</li></ul><h5 id=host-controller-inteface>Host Controller inteface</h5><ul><li><p>SATA처럼 UFS도 UFS Host Controller Interface - UFSHCI 를 제공한다. 이 인터페이스는 <code>Universal Flash Storage (UFS) Host Controller Interface (JESD223)</code>를 따라간다.</p></li><li><p>UFSHCI 는 <code>hil/ufs/host.hh</code> 에 <code>SimpleSSD::HIL::UFS::Host</code>로 구현되어 있다.</p></li><li><p><code>Interface</code> 는 UFSHCI register에 <code>Host::writeRegister</code> 함수를 사용해서 쓴다.</p></li><li><p>UFS는 3가지 종류의 명령이 있는데</p><ul><li>UFS Trasnport Protocol Transfer (UTP Transfer)</li><li>UFS Transport Protocol Task Management (UTP Task)</li><li>UFS InterConnect Command (UIC Command)</li></ul></li><li><p>각 명령어들은 request를 알리는데 서로 다른 doorbell을 사용하며</p><ul><li><code>REG_UTRLDBR</code> 는 UTP Transfer</li><li><code>REG_UTMRLDBR</code> 는 UTP Task</li><li><code>REG_UICCMDR</code> 는 UIC Command</li></ul></li><li><p>를 확인할때 사용할수 있다.</p></li><li><p>리눅스 커널과 UFS 2.1에서 UTP Task는 구현되지 않았기 때문에 SimpleSSD 에서도 구현하지 않았다.</p></li><li><p>UIC Commands 는 오직 UFS hardware를 초기화 할때만 사용하며(M-PHY link 부팅 등), 그러므로 우린 오직 2가지 기초적 명령어들만 구현했다.</p></li><li><p>NVMe와 SATA처럼 <strong>Event Engine</strong> 은 주기적으로 <code>Host::work</code> 함수를 호출하며. <code>Host::handleRequest</code> 함수는 <code>work</code>에 의해서 호출되고 request가 유효한지를 검증한다. <code>Host::processUTPCommand</code> 는 request를 파싱하고, request에 적합한 handler를 부른다.</p></li><li><p>UFS Transfer는 3가지 유형의 명령어들로 정의된다.</p><ul><li>Command (SCSI protocol)</li><li>Native UFS Command</li><li>Device Management Command</li></ul></li><li><p>Native UFS Command는 UFS 2.1 에서 정의되지 않았기 때문에 우린 Command 와 Device Management Command 만을 구현했다.</p></li><li><p><code>Device::processCommand</code> 함수는 Command 를 다루고 <code>Device::processQueryCommand</code> 함수는 Device Management Command 를 다룬다.</p></li><li><p><code>handleRequest</code> 함수에서 완료 루틴(Completion routine) 이 선언되어 있으며 이는 <code>doRequest</code> 와 <code>doWrite</code> 라는 lambda 함수들을 확인하면 된다. <code>doWrite</code> 함수는 completion routine(<code>Host::completion</code>)을 예약하며, <code>completion</code> 함수는 <code>Interface::updateInterrupt</code> 함수를 사용해서 Interrupt를 보낸다.</p></li></ul><h5 id=device-1>Device</h5><ul><li><p>UFSHCI 와 연결해주는 Device 는 <code>hil/ufs/device.hh</code>에 <code>SimpleSSD::HIL::UFS::Device</code> 를 정의한다.</p></li><li><p>UFS 는 SCSI commands set(<code>SCSI Block Commands - 3 (SBC-3)</code> 와 <code>SCSI Primary Commands - 4(SPC-4)</code>) 을 I/O 하기 위해서 사용gksek.</p></li><li><p>Device 는 아래 나오는 SCSI 명령어들로 다루어진다.</p><ul><li><code>INQUERY</code></li><li><code>MODE SELECT 10</code></li><li><code>MODE SENSE 10</code></li><li><code>READ 6</code></li><li><code>READ 10</code></li><li><code>READ CAPACITY 10</code></li><li><code>READ CAPACITY 16</code></li><li><code>START STOP UNIT</code></li><li><code>TEST UNIT READY</code></li><li><code>REPORT LUNS</code></li><li><code>VERIFY 10</code></li><li><code>WRITE 6</code></li><li><code>WRITE 10</code></li><li><code>SYNCHRONIZE CACHE 10</code></li></ul></li><li><p>Device 의 구현은 SATA와 비슷하지만 2가지 명령어 handling 함수를 가진다. (<code>processCommand</code> 와 <code>processQueryCommand</code>)</p></li><li><p>완료 이후 각 SCI command 함수는 callback handler 를 호출하며, 이때 <code>processCommand</code> 함수의 인자로서 콜백은 제공한다.</p></li><li><p><code>processQueryCommand</code> 는 즉시 결과를 리턴한다. I/O 관련 명령 <code>READ*</code>, <code>WRITE*</code> 와 <code>SYNCHRONIZE CACHE</code> 는 SSD Interface 함수들 (<code>HIL::HIL::read, write and flush</code>) 를 호출한다.</p></li></ul><h4 id=nvme-소스코드와의-비교>nvme 소스코드와의 비교</h4><ul><li>[[nvme]] 페이지에 나름 정리한걸 올려놨다.</li><li>driver 부분을 주로 비교하고 나머진 아직 openssd 를 읽으면서 해야할듯.</li></ul><h4 id=프로그램-시작점>프로그램 시작점</h4><ul><li>simplessd에서 <code>sim/main.cc</code> 파일의 220번째 줄을 보면 <code>RequestGenerator</code> 가 있다. 여기서 <code>submitIO()</code> 가 bio를 호출 (실제로는 시뮬레이션이지만, 편의상)하고, <code>iocallback()</code>이 주기적으로 <code>rescheduleSubmit()</code> 를 호출하면서 IO를 발생시킨다.</li><li>여기서는 <code>bil/interface.hh</code>에 <code>DriverInterface</code> 를 만들어 두어서 <code>BIO</code> layer를 구현해둔듯 하다. scheduler는 단순히 <code>DriverInterface</code> 의 <code>submitIO</code>를 호출하는게 전부임.</li></ul><h4 id=bio-발생---드라이버>BIO 발생 -> 드라이버</h4><h5 id=request로부터-opcode-분리>request로부터 opcode 분리</h5><ul><li>linux 의 <code>drivers/nvme/host/core.c</code> 의 <code>nvme_queue_rq()</code>에서 호출하는 <code>nvme_setup_cmd()</code> 와 SimpleSSD의 <code>sil/nvme/nvme.cc</code> 의 <code>Driver::submitIO()</code> 가 서로 같은 일을 하고 있음.</li><li>명령어의 종류에 따라 (<code>READ</code>, <code>WRITE</code>, <code>TRIM(DISCARD)</code>, <code>FLUSH</code>) 기본적인 setup과정을 호출해준다.</li></ul><h6 id=simplessd-구현>SimpleSSD 구현</h6><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>submitIO(BIL<span style=color:#f92672>::</span>BIO <span style=color:#f92672>&amp;</span>bio) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> cmd[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>  PRP <span style=color:#f92672>*</span>prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> ResponseHandler callback <span style=color:#f92672>=</span> [<span style=color:#66d9ef>this</span>](<span style=color:#66d9ef>uint16_t</span> status, <span style=color:#66d9ef>uint32_t</span>,
</span></span><span style=display:flex><span>                                           <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
</span></span><span style=display:flex><span>    _io(status, context);
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  memset(cmd, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> slba <span style=color:#f92672>=</span> bio.offset <span style=color:#f92672>/</span> LBAsize;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> nlb <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)DIVCEIL(bio.length, LBAsize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cmd[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> namespaceID;  <span style=color:#75715e>// NSID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_READ) {
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_READ;  <span style=color:#75715e>// CID, FUSE, OPC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)slba;
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> slba <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>12</span>] <span style=color:#f92672>=</span> nlb <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// LR, FUA, PRINFO, NLB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PRP(bio.length);
</span></span><span style=display:flex><span>    prp<span style=color:#f92672>-&gt;</span>getPointer(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>), <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>));  <span style=color:#75715e>// DPTR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_WRITE) {
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_WRITE;  <span style=color:#75715e>// CID, FUSE, OPC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)slba;
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> slba <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>12</span>] <span style=color:#f92672>=</span> nlb <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// LR, FUA, PRINFO, DTYPE, NLB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PRP(bio.length);
</span></span><span style=display:flex><span>    prp<span style=color:#f92672>-&gt;</span>getPointer(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>), <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>));  <span style=color:#75715e>// DPTR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_FLUSH) {
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_FLUSH;  <span style=color:#75715e>// CID, FUSE, OPC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_TRIM) {
</span></span><span style=display:flex><span>    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_DATASET_MANAGEMEMT;  <span style=color:#75715e>// CID, FUSE, OPC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;                                               <span style=color:#75715e>// NR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x04</span>;                                            <span style=color:#75715e>// AD
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PRP(<span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>    prp<span style=color:#f92672>-&gt;</span>getPointer(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>), <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>));  <span style=color:#75715e>// DPTR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fill range definition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> data[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    memset(data, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>    memcpy(data <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&amp;</span>nlb, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    memcpy(data <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>, <span style=color:#f92672>&amp;</span>slba, <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    prp<span style=color:#f92672>-&gt;</span>writeData(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>16</span>, data);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  submitCommand(<span style=color:#ae81ff>1</span>, (<span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>)cmd, callback,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> IOWrapper(bio.id, prp, bio.callback));
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h6 id=nvmedriver-구현>nvme(driver) 구현</h6><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>blk_status_t</span> <span style=color:#a6e22e>nvme_setup_cmd</span>(<span style=color:#66d9ef>struct</span> nvme_ns <span style=color:#f92672>*</span>ns, <span style=color:#66d9ef>struct</span> request <span style=color:#f92672>*</span>req,
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>struct</span> nvme_command <span style=color:#f92672>*</span>cmd)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>blk_status_t</span> ret <span style=color:#f92672>=</span> BLK_STS_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nvme_clear_nvme_request</span>(req);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memset</span>(cmd, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>cmd));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>req_op</span>(req)) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_DRV_IN:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_DRV_OUT:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>memcpy</span>(cmd, <span style=color:#a6e22e>nvme_req</span>(req)<span style=color:#f92672>-&gt;</span>cmd, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>cmd));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_FLUSH:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>nvme_setup_flush</span>(ns, cmd);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_WRITE_ZEROES:
</span></span><span style=display:flex><span>		ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>nvme_setup_write_zeroes</span>(ns, req, cmd);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_DISCARD:
</span></span><span style=display:flex><span>		ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>nvme_setup_discard</span>(ns, req, cmd);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_READ:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> REQ_OP_WRITE:
</span></span><span style=display:flex><span>		ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>nvme_setup_rw</span>(ns, req, cmd);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> BLK_STS_IOERR;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	cmd<span style=color:#f92672>-&gt;</span>common.command_id <span style=color:#f92672>=</span> req<span style=color:#f92672>-&gt;</span>tag;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>trace_nvme_setup_cmd</span>(req, cmd);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h5 id=submit-command>submit command</h5><ul><li>nvme에서는 <code>struct blk_mq_hw_ctx *hctx</code> 를 parameter로 넣어주므로써 자연스럽게 nvme queue를 admin queue와 submission queue를 처리하는데, SimpleSSD 의 경우에는 <code>uint16_t iv</code> 라는 값을 전달하므로써 이를 처리한다.</li><li>궁금점은 nvme에서는 spin_lock 을 걸어서 복사하는 과정에서 또다른 bio가 오는 것을 생각하고 있는 듯한 구현인데, SimpleSSD 의 경우에는 따로 lock을 거는 게 없다. 단일 쓰레드에서만 도는 걸 생각하는건가? 여기는 잘 모르겠다.</li></ul><h6 id=simplessd-구현-1>SimpleSSD 구현</h6><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>submitCommand(<span style=color:#66d9ef>uint16_t</span> iv, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>cmd, ResponseHandler <span style=color:#f92672>&amp;</span>func,
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint16_t</span> cid <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint16_t</span> opcode <span style=color:#f92672>=</span> cmd[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint16_t</span> tail <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> tick <span style=color:#f92672>=</span> engine.getCurrentTick();
</span></span><span style=display:flex><span>  Queue <span style=color:#f92672>*</span>queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Push to queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (iv <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    increaseCommandID(adminCommandID);
</span></span><span style=display:flex><span>    cid <span style=color:#f92672>=</span> adminCommandID;
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> adminSQ;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (iv <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> ioSQ) {
</span></span><span style=display:flex><span>    increaseCommandID(ioCommandID);
</span></span><span style=display:flex><span>    cid <span style=color:#f92672>=</span> ioCommandID;
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> ioSQ;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    SimpleSSD<span style=color:#f92672>::</span>panic(<span style=color:#e6db74>&#34;I/O Submission Queue is not initialized&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  memcpy(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>&amp;</span>cid, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  queue<span style=color:#f92672>-&gt;</span>setData(cmd, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>  tail <span style=color:#f92672>=</span> queue<span style=color:#f92672>-&gt;</span>getTail();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Push to pending cmd list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  pendingCommandList.push_back(CommandEntry(iv, opcode, cid, context, func));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Ring doorbell
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  pController<span style=color:#f92672>-&gt;</span>ringSQTailDoorbell(iv, tail, tick);
</span></span><span style=display:flex><span>  queue<span style=color:#f92672>-&gt;</span>incrHead();
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h5 id=nvme구현>nvme구현</h5><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="/**%0a%20*%20nvme_submit_cmd%28%29%20-%20Copy%20a%20command%20into%20a%20queue%20and%20ring%20the%20doorbell%0a%20*%20@nvmeq:%20The%20queue%20to%20use%0a%20*%20@cmd:%20The%20command%20to%20send%0a%20*%20@write_sq:%20whether%20to%20write%20to%20the%20SQ%20doorbell%0a%20*/%0astatic%20void%20nvme_submit_cmd%28struct%20nvme_queue%20*nvmeq,%20struct%20nvme_command%20*cmd,%0a%09%09%09%20%20%20%20bool%20write_sq%29%0a%7b%0a%09spin_lock%28&amp;nvmeq-%3esq_lock%29;%0a%09memcpy%28nvmeq-%3esq_cmds%20+%20%28nvmeq-%3esq_tail%20%3c%3c%20nvmeq-%3esqes%29,%0a%09%20%20%20%20%20%20%20cmd,%20sizeof%28*cmd%29%29;%0a%09if%20%28++nvmeq-%3esq_tail%20==%20nvmeq-%3eq_depth%29%0a%09%09nvmeq-%3esq_tail%20=%200;%0a%09if%20%28write_sq%29%0a%09%09nvme_write_sq_db%28nvmeq%29;%0a%09spin_unlock%28&amp;nvmeq-%3esq_lock%29;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * nvme_submit_cmd() - Copy a command into a queue and ring the doorbell
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @nvmeq: The queue to use
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @cmd: The command to send
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @write_sq: whether to write to the SQ doorbell
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nvme_submit_cmd</span>(<span style=color:#66d9ef>struct</span> nvme_queue <span style=color:#f92672>*</span>nvmeq, <span style=color:#66d9ef>struct</span> nvme_command <span style=color:#f92672>*</span>cmd,
</span></span><span style=display:flex><span>			    <span style=color:#66d9ef>bool</span> write_sq)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>nvmeq<span style=color:#f92672>-&gt;</span>sq_lock);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memcpy</span>(nvmeq<span style=color:#f92672>-&gt;</span>sq_cmds <span style=color:#f92672>+</span> (nvmeq<span style=color:#f92672>-&gt;</span>sq_tail <span style=color:#f92672>&lt;&lt;</span> nvmeq<span style=color:#f92672>-&gt;</span>sqes),
</span></span><span style=display:flex><span>	       cmd, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>cmd));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>nvmeq<span style=color:#f92672>-&gt;</span>sq_tail <span style=color:#f92672>==</span> nvmeq<span style=color:#f92672>-&gt;</span>q_depth)
</span></span><span style=display:flex><span>		nvmeq<span style=color:#f92672>-&gt;</span>sq_tail <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (write_sq)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>nvme_write_sq_db</span>(nvmeq);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>nvmeq<span style=color:#f92672>-&gt;</span>sq_lock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h4 id=work>Work</h4><h5 id=simplessd>SimpleSSD</h5><ul><li>simplessd에선 <code>Driver::submitCommand()</code> 에서 <code>pendingCommandList</code> 에 <code>CommandEntry</code>를 넣은 뒤, <code>pController->ringSQTailDoorbell</code> 를 해주는데, 이를 따라가보면, 인자로 넣어준 SQ의 tail을 이동시키는게 전부다&mldr;?</li><li>여기서부터 순간 방향성을 잃었는데, SQ 넣고 어떻게 되지? 싶었다. 한번 SQ에 엑세스 하는걸 봐보자</li><li>그러면 <code>Controller::work()</code> 가 나오게 된다. 이 함수는 <code>workEvent</code> 라는 변수에 담겨서 <code>Controller::writeRegister()</code>에서 schedule에 등록된다. 이는 <code>Driver::init()</code> 에서 Step 5. 에서 일어난다.</li><li>따라서 SimpleSSD 는 <code>workInterval</code> (기본값 : 50000, 50ns) 마다 SQ를 검사해서 처리하는 방식이다.</li></ul><h5 id=nvmedriver>nvme(driver)</h5><ul><li><p><code>nvme_write_sq_db()</code> 를 호출하는데, 이는 결국 <code>writel()</code>를 호출해서 SQ tail 주소에 command를 쓰는 구조이다.</p></li><li><p>그렇다면 nvme에서 command는 어떻게 되는가? : TODO: 흠&mldr;. 아직 잘 모르겠는데? <code>nvme_scan_work()</code> 가 있긴한데, 이게 user 가 scan work를 강제로 SSD에 시키는 건지가 모르겠는데, 근데 그런 구조면, 글러먹은게 IO 연산을 하기 위해서 직접 다 해줘야되는건데? 그러면 굳이 scheduler가 linux kernel level에 존재할 필요가 없는데? 그냥 scheduler layer 없이 SSD scan work 를 조절하면 되는데? 일단 추정은 ssd 내부에 존재하는건데, 이건 OpenChannelSSD 를 읽어보고 알아내야할듯.</p></li><li><p>흐음&mldr;. 이건 잘 못찾았다. Controller 내부에 있다고 가정하고 계속 읽어 나가야할듯</p></li></ul><h3 id=ssd-interface>SSD Interface</h3><ul><li>HIL 의 SSD Interface는 단순한데 <code>hil/hil.hh</code> 에 <code>SimpleSSD::HIL::HIL</code> 로 정의되어 있다.</li><li>I/O request를 host controller로 부터 받아 <code>Interal Cache Layer</code> 에 넘겨준다.</li></ul><h2 id=internal-cache-layer>Internal Cache Layer</h2><ul><li>여기서는 I/O buffer model (data cache)인 Internal Cache Layer (이하 ICL) 을 알아본다.</li><li>ICL은 추상 클래스로 되어 있어서 상속 받아서 구현해볼수 있고 기본적으로는 set-associative cache 로 구현된 Generic Cache를 확인한다.</li></ul><h3 id=abstract-class>Abstract Class</h3><ul><li><code>icl/abstract_cache.hh</code>에 <code>AbstractCache</code> 클래스로 선언되어 있으며 5가지 가상함수가 존재한다.(<code>Statobject</code>에서 파생된 3가지 함수들도 추가로 있다.)</li><li>ICL 은 각 가상함수로부터 I/O requests와 고유한 알고리즘에 의해서 bffer /IIO 를 가진다. data eviction이 필요하거나, flush request가 있을때 I/O를 FTL 에 넘긴다.</li><li>SSD의 Data buffer는 느린 NAND I/O 성능을 감추기 위해서 매우 중요하다. buffer algorithm의 작은 변화도 성능을 크게 바꿀수 있다.</li></ul><h3 id=set-associative-cache>Set-Associative Cache</h3><ul><li><code>icl/generic_cache.hh</code> 에 <code>SimpleSSD::ICL::GenericCache</code> 라고 선언된 set-associative cache를 제공하며, 아래 후술될 인자를 조정할수 있다.<ul><li><code>CacheSize</code> : Buffer Capacity.</li><li><code>CacheWaySize</code> : Set associativity of cache. set size will automatically caclculated</li><li><code>EnableReadCache</code>: Enable read data caching.</li><li><code>EnableReadPrefetch</code>: enable read-ahead and prefetch.</li><li><code>ReadPrefetchMode</code>: Specify how many data should be read-ahead/prefetch.</li><li><code>ReadPrefetchCount</code> : Threshold for read-ahead/prefetch(# of sequential I/O).</li><li><code>ReadPrefetchRatio</code> : Threshold for read-ahead/prefetch(data size of sequential I/O).</li><li><code>EnableWriteCache</code> : enable write data caching.</li><li><code>EvictPolicy</code> : Specify which algorithm to use to select victim cache line.</li><li><code>EvictMode</code> : Specify how many data should be evicted when cache is full.</li><li><code>CacheLatency</code> : Set cache metadata accesss latency.</li></ul></li></ul><h3 id=호출구조>호출구조</h3><ul><li><code>hil/nvme/controller.cc</code> 에서 <code>Controller::work()</code>를 확인해보면 <code>DMAContext</code> 를 만들어주고 호출하는 걸 알수 있다.</li><li>여기서 <code>checkQueue()</code> 를 호출하면서 <code>DMAFunction</code> 타입인 <code>func</code>를 호출하게된다. 이때 <code>func</code>은 <code>doQueue</code> 이고 이는 결국 <code>collectSQueue</code>의 인자로 주어졌던 <code>CPUContext</code>가 가지고 있는 함수를 호출한다. 이때 이건 결국 <code>handleRequest</code>를 호출하게 된다. 이는 <code>SubSystem</code> 에 request를 전달하게 된다.</li><li>결론은 결국 request는 처리되서 subsystem에 도달하게 되고, 이게 어떻게 처리되는지는 <code>Subsystem::submitCommand()</code>를 확인하면 알수 있다. 여기서 admin command 들을 처리하고, 아닌 것들은 그대로 <code>Namespace::submitCommand()</code> 로 넘어오게 된다.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Namespace<span style=color:#f92672>::</span>submitCommand(SQEntryWrapper <span style=color:#f92672>&amp;</span>req, RequestFunction <span style=color:#f92672>&amp;</span>func) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Skip */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// NVM commands
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>switch</span> (req.entry.dword0.opcode) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> OPCODE_FLUSH:
</span></span><span style=display:flex><span>          flush(req, func);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> OPCODE_WRITE:
</span></span><span style=display:flex><span>          write(req, func);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> OPCODE_READ:
</span></span><span style=display:flex><span>          read(req, func);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> OPCODE_COMPARE:
</span></span><span style=display:flex><span>          compare(req, func);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> OPCODE_DATASET_MANAGEMEMT:
</span></span><span style=display:flex><span>          datasetManagement(req, func);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>          resp.makeStatus(true, false, TYPE_GENERIC_COMMAND_STATUS,
</span></span><span style=display:flex><span>                          STATUS_INVALID_OPCODE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          response <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (response) {
</span></span><span style=display:flex><span>    func(resp);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>이때 <code>read</code> 함수등 은 다시 <code>Subsystem::read()</code>를 호출하고 이 내부는</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#ZgotmplZ>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Subsystem<span style=color:#f92672>::</span>read(Namespace <span style=color:#f92672>*</span>ns, <span style=color:#66d9ef>uint64_t</span> slba, <span style=color:#66d9ef>uint64_t</span> nlblk,
</span></span><span style=display:flex><span>                     DMAFunction <span style=color:#f92672>&amp;</span>func, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
</span></span><span style=display:flex><span>  Request <span style=color:#f92672>*</span>req <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Request(func, context);
</span></span><span style=display:flex><span>  DMAFunction doRead <span style=color:#f92672>=</span> [<span style=color:#66d9ef>this</span>](<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> req <span style=color:#f92672>=</span> (Request <span style=color:#f92672>*</span>)context;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pHIL<span style=color:#f92672>-&gt;</span>read(<span style=color:#f92672>*</span>req);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> req;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  convertUnit(ns, slba, nlblk, <span style=color:#f92672>*</span>req);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  execute(CPU<span style=color:#f92672>::</span>NVME__SUBSYSTEM, CPU<span style=color:#f92672>::</span>CONVERT_UNIT, doRead, req);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li><code>HIL::read()</code> 를 부르게 된다. 이렇게 불리게 된 <code>HIL::read()</code> 의 내부에서 <code>ICL::read()</code> 를 부르는 구조이다.</li><li>read 부분만 봤는데, 다른 부분도 비슷할거라고 생각한다.</li></ul><h3 id=cache-로직-공부>Cache 로직 공부</h3><ul><li>결국 <code>GenericCache::read()</code>(읽기의 경우) 가 호출되게 되는데 그 과정을 적어보자</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="/*%20return%20%ea%b0%92%ec%9d%b4%20true%20%eb%a9%b4%20hit,%20%ec%95%84%eb%8b%88%eb%a9%b4%20miss%20%ec%9d%b4%eb%8b%a4.%20*/%0abool%20GenericCache::read%28Request%20&amp;req,%20uint64_t%20&amp;tick%29%20%7b%0a%20%20bool%20ret%20=%20false;%0a%0a%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%22READ%20%20%7c%20REQ%20%257u-%25-4u%20%7c%20LCA%20%25%22%20PRIu64%20%22%20%7c%20SIZE%20%25%22%20PRIu64,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20req.reqID,%20req.reqSubID,%20req.range.slpn,%20req.length%29;%0a%0a%20%20if%20%28useReadCaching%29%20%7b%20/*%20%ec%9d%bd%ea%b8%b0%ec%9a%a9%20Cache%ea%b0%80%20%ec%9e%88%eb%8a%94%ec%a7%80%eb%a5%bc%20%ed%99%95%ec%9d%b8%ed%95%9c%eb%8b%a4.%20*/%0a%20%20%20%20/*%20start%20logical%20page%20number%20?%20%ec%9d%98%20%ec%95%bd%ec%9e%90%ec%9d%b8%eb%93%af%20*/%0a%20%20%20%20uint32_t%20setIdx%20=%20calcSetIndex%28req.range.slpn%29;%20/*%20Set-Associative%20Cache%20%eb%a5%bc%20%ec%b0%b8%ec%a1%b0%20*/%0a%20%20%20%20uint32_t%20wayIdx;%0a%20%20%20%20uint64_t%20arrived%20=%20tick;%0a%0a%20%20%20%20/*%20%ec%9d%b4%ea%b1%b4%20%eb%a8%bc%ec%a7%80%20%eb%aa%a8%eb%a5%b4%ea%b2%a0%eb%8b%a4.%20%ec%97%b0%ec%86%8d%ec%a0%81%ec%9d%b8%20request%eb%a5%bc%20%ec%b2%b4%ed%81%ac%ed%95%98%eb%8a%94%ea%b1%b4%ea%b0%80%20?%0a%20%20%20%20%20*%20%ec%b0%be%ec%95%84%eb%b3%b4%eb%8b%88%20prefetch%20%ec%99%80%20%ea%b4%80%eb%a0%a8%eb%90%9c%20%ea%b1%b4%eb%8d%b0,%20%ec%96%b8%ec%a0%9c%eb%82%98%20predict%20%eb%a5%bc%20sequential%20%ec%9d%b4%eb%9d%bc%ea%b3%a0%20%ec%83%9d%ea%b0%81%ed%95%98%ea%b3%a0%20%ed%95%98%eb%8a%94%ea%b1%b4%ea%b0%80?%0a%20%20%20%20%20*%20%eb%ac%bc%eb%a1%a0%20prefetch%20%ed%95%a0%20%ec%98%81%ec%97%ad%ec%9d%84%20%ea%b3%a0%eb%a5%b4%eb%8a%94%eb%8d%b0%20%ec%96%b4%eb%a0%a4%ec%9a%b4%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%84%20%ec%93%b0%eb%a9%b4%20%eb%ac%b8%ec%a0%9c%ea%b0%80%20%eb%a7%8e%ea%b2%a0%ec%a7%80%eb%a7%8c%20Sequential%20%eb%a7%8c%20prefetch%20%ed%95%98%eb%8a%94%ea%b2%8c%0a%20%20%20%20%20*%20%ec%a2%8b%eb%8b%a4%eb%9d%bc%eb%8a%94%20%eb%85%bc%eb%ac%b8%ec%9d%b4%20%ec%9e%88%eb%82%98?%0a%20%20%20%20%20*%20TODO:%20%eb%85%bc%eb%ac%b8%20%eb%a6%ac%eb%94%a9%0a%20%20%20%20*/%0a%20%20%20%20if%20%28useReadPrefetch%29%20%7b%0a%20%20%20%20%20%20checkSequential%28req,%20readDetect%29;%0a%20%20%20%20%7d%0a%0a%20%20%20%20wayIdx%20=%20getValidWay%28req.range.slpn,%20tick%29;%0a%0a%20%20%20%20//%20Do%20we%20have%20valid%20data?%0a%20%20%20%20if%20%28wayIdx%20!=%20waySize%29%20%7b%0a%20%20%20%20%20%20uint64_t%20tickBackup%20=%20tick;%0a%0a%20%20%20%20%20%20//%20Wait%20cache%20to%20be%20valid%0a%20%20%20%20%20%20if%20%28tick%20%3c%20cacheData[setIdx][wayIdx].insertedAt%29%20%7b%0a%20%20%20%20%20%20%20%20tick%20=%20cacheData[setIdx][wayIdx].insertedAt;%0a%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20//%20Update%20last%20accessed%20time%0a%20%20%20%20%20%20cacheData[setIdx][wayIdx].lastAccessed%20=%20tick;%0a%0a%20%20%20%20%20%20//%20DRAM%20access%0a%20%20%20%20%20%20pDRAM-%3eread%28&amp;cacheData[setIdx][wayIdx],%20req.length,%20tick%29;%0a%0a%20%20%20%20%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22READ%20%20%7c%20Cache%20hit%20at%20%28%25u,%20%25u%29%20%7c%20%25%22%20PRIu64%20%22%20-%20%25%22%20PRIu64%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22%20%28%25%22%20PRIu64%20%22%29%22,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20setIdx,%20wayIdx,%20arrived,%20tick,%20tick%20-%20arrived%29;%0a%0a%20%20%20%20%20%20ret%20=%20true;%0a%0a%20%20%20%20%20%20//%20Do%20we%20need%20to%20prefetch%20data?%0a%20%20%20%20%20%20if%20%28useReadPrefetch%20&&%20req.range.slpn%20==%20prefetchTrigger%29%20%7b%0a%20%20%20%20%20%20%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%20%22READ%20%20%7c%20Prefetch%20triggered%22%29;%0a%0a%20%20%20%20%20%20%20%20req.range.slpn%20=%20lastPrefetched;%0a%0a%20%20%20%20%20%20%20%20//%20Backup%20tick%0a%20%20%20%20%20%20%20%20arrived%20=%20tick;%0a%20%20%20%20%20%20%20%20tick%20=%20tickBackup;%0a%0a%20%20%20%20%20%20%20%20goto%20ICL_GENERIC_CACHE_READ;%0a%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%20%20%20%20//%20We%20should%20read%20data%20from%20NVM%0a%20%20%20%20else%20%7b%0a%20%20%20%20ICL_GENERIC_CACHE_READ:%0a%20%20%20%20%20%20FTL::Request%20reqInternal%28lineCountInSuperPage,%20req%29;%0a%20%20%20%20%20%20std::vector%3cstd::pair%3cuint64_t,%20uint64_t%3e%3e%20readList;%0a%20%20%20%20%20%20uint32_t%20row,%20col;%20%20//%20Variable%20for%20I/O%20position%20%28IOFlag%29%0a%20%20%20%20%20%20uint64_t%20dramAt;%0a%20%20%20%20%20%20uint64_t%20beginLCA,%20endLCA;%0a%20%20%20%20%20%20uint64_t%20beginAt,%20finishedAt%20=%20tick;%0a%0a%20%20%20%20%20%20if%20%28readDetect.enabled%29%20%7b%0a%20%20%20%20%20%20%20%20//%20TEMP:%20Disable%20DRAM%20calculation%20for%20prevent%20conflict%0a%20%20%20%20%20%20%20%20pDRAM-%3esetScheduling%28false%29;%0a%0a%20%20%20%20%20%20%20%20if%20%28!ret%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%20%22READ%20%20%7c%20Read%20ahead%20triggered%22%29;%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20beginLCA%20=%20req.range.slpn;%0a%0a%20%20%20%20%20%20%20%20//%20If%20super-page%20is%20disabled,%20just%20read%20all%20pages%20from%20all%20planes%0a%20%20%20%20%20%20%20%20if%20%28prefetchMode%20==%20MODE_ALL%20%7c%7c%20!bSuperPage%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20endLCA%20=%20beginLCA%20+%20lineCountInMaxIO;%0a%20%20%20%20%20%20%20%20%20%20prefetchTrigger%20=%20beginLCA%20+%20lineCountInMaxIO%20/%202;%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20else%20%7b%0a%20%20%20%20%20%20%20%20%20%20endLCA%20=%20beginLCA%20+%20lineCountInSuperPage;%0a%20%20%20%20%20%20%20%20%20%20prefetchTrigger%20=%20beginLCA%20+%20lineCountInSuperPage%20/%202;%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20lastPrefetched%20=%20endLCA;%0a%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20else%20%7b%0a%20%20%20%20%20%20%20%20beginLCA%20=%20req.range.slpn;%0a%20%20%20%20%20%20%20%20endLCA%20=%20beginLCA%20+%201;%0a%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20for%20%28uint64_t%20lca%20=%20beginLCA;%20lca%20%3c%20endLCA;%20lca++%29%20%7b%0a%20%20%20%20%20%20%20%20beginAt%20=%20tick;%0a%0a%20%20%20%20%20%20%20%20//%20Check%20cache%0a%20%20%20%20%20%20%20%20if%20%28getValidWay%28lca,%20beginAt%29%20!=%20waySize%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20continue;%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20//%20Find%20way%20to%20write%20data%20read%20from%20NVM%0a%20%20%20%20%20%20%20%20setIdx%20=%20calcSetIndex%28lca%29;%0a%20%20%20%20%20%20%20%20wayIdx%20=%20getEmptyWay%28setIdx,%20beginAt%29;%0a%0a%20%20%20%20%20%20%20%20if%20%28wayIdx%20==%20waySize%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20wayIdx%20=%20evictFunction%28setIdx,%20beginAt%29;%0a%0a%20%20%20%20%20%20%20%20%20%20if%20%28cacheData[setIdx][wayIdx].dirty%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20//%20We%20need%20to%20evict%20data%20before%20write%0a%20%20%20%20%20%20%20%20%20%20%20%20calcIOPosition%28cacheData[setIdx][wayIdx].tag,%20row,%20col%29;%0a%20%20%20%20%20%20%20%20%20%20%20%20evictData[row][col]%20=%20cacheData[setIdx]%20+%20wayIdx;%0a%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20cacheData[setIdx][wayIdx].insertedAt%20=%20beginAt;%0a%20%20%20%20%20%20%20%20cacheData[setIdx][wayIdx].lastAccessed%20=%20beginAt;%0a%20%20%20%20%20%20%20%20cacheData[setIdx][wayIdx].valid%20=%20true;%0a%20%20%20%20%20%20%20%20cacheData[setIdx][wayIdx].dirty%20=%20false;%0a%0a%20%20%20%20%20%20%20%20readList.push_back%28%7blca,%20%28%28uint64_t%29setIdx%20%3c%3c%2032%29%20%7c%20wayIdx%7d%29;%0a%0a%20%20%20%20%20%20%20%20finishedAt%20=%20MAX%28finishedAt,%20beginAt%29;%0a%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20tick%20=%20finishedAt;%0a%0a%20%20%20%20%20%20evictCache%28tick%29;%0a%0a%20%20%20%20%20%20for%20%28auto%20&amp;iter%20:%20readList%29%20%7b%0a%20%20%20%20%20%20%20%20Line%20*pLine%20=%20&amp;cacheData[iter.second%20%3e%3e%2032][iter.second%20&%200xFFFFFFFF];%0a%0a%20%20%20%20%20%20%20%20//%20Read%20data%0a%20%20%20%20%20%20%20%20reqInternal.lpn%20=%20iter.first%20/%20lineCountInSuperPage;%0a%20%20%20%20%20%20%20%20reqInternal.ioFlag.reset%28%29;%0a%20%20%20%20%20%20%20%20reqInternal.ioFlag.set%28iter.first%20%25%20lineCountInSuperPage%29;%0a%0a%20%20%20%20%20%20%20%20beginAt%20=%20tick;%20%20//%20Ignore%20cache%20metadata%20access%0a%0a%20%20%20%20%20%20%20%20//%20If%20superPageSizeData%20is%20true,%20read%20first%20LPN%20only%0a%20%20%20%20%20%20%20%20pFTL-%3eread%28reqInternal,%20beginAt%29;%0a%0a%20%20%20%20%20%20%20%20//%20DRAM%20delay%0a%20%20%20%20%20%20%20%20dramAt%20=%20pLine-%3einsertedAt;%0a%20%20%20%20%20%20%20%20pDRAM-%3ewrite%28pLine,%20lineSize,%20dramAt%29;%0a%0a%20%20%20%20%20%20%20%20//%20Set%20cache%20data%0a%20%20%20%20%20%20%20%20beginAt%20=%20MAX%28beginAt,%20dramAt%29;%0a%0a%20%20%20%20%20%20%20%20pLine-%3einsertedAt%20=%20beginAt;%0a%20%20%20%20%20%20%20%20pLine-%3elastAccessed%20=%20beginAt;%0a%20%20%20%20%20%20%20%20pLine-%3etag%20=%20iter.first;%0a%0a%20%20%20%20%20%20%20%20if%20%28pLine-%3etag%20==%20req.range.slpn%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20finishedAt%20=%20beginAt;%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22READ%20%20%7c%20Cache%20miss%20at%20%28%25u,%20%25u%29%20%7c%20%25%22%20PRIu64%20%22%20-%20%25%22%20PRIu64%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22%20%28%25%22%20PRIu64%20%22%29%22,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20iter.second%20%3e%3e%2032,%20iter.second%20&%200xFFFFFFFF,%20tick,%20beginAt,%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20beginAt%20-%20tick%29;%0a%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20tick%20=%20finishedAt;%0a%0a%20%20%20%20%20%20if%20%28readDetect.enabled%29%20%7b%0a%20%20%20%20%20%20%20%20if%20%28ret%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20//%20This%20request%20was%20prefetch%0a%20%20%20%20%20%20%20%20%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%20%22READ%20%20%7c%20Prefetch%20done%22%29;%0a%0a%20%20%20%20%20%20%20%20%20%20//%20Restore%20tick%0a%20%20%20%20%20%20%20%20%20%20tick%20=%20arrived;%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20else%20%7b%0a%20%20%20%20%20%20%20%20%20%20debugprint%28LOG_ICL_GENERIC_CACHE,%20%22READ%20%20%7c%20Read%20ahead%20done%22%29;%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20//%20TEMP:%20Restore%0a%20%20%20%20%20%20%20%20pDRAM-%3esetScheduling%28true%29;%0a%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%0a%20%20%20%20tick%20+=%20applyLatency%28CPU::ICL__GENERIC_CACHE,%20CPU::READ%29;%0a%20%20%7d%0a%20%20else%20%7b%0a%20%20%20%20FTL::Request%20reqInternal%28lineCountInSuperPage,%20req%29;%0a%0a%20%20%20%20pDRAM-%3ewrite%28nullptr,%20req.length,%20tick%29;%0a%0a%20%20%20%20pFTL-%3eread%28reqInternal,%20tick%29;%0a%20%20%7d%0a%0a%20%20stat.request[0]++;%0a%0a%20%20if%20%28ret%29%20%7b%0a%20%20%20%20stat.cache[0]++;%0a%20%20%7d%0a%0a%20%20return%20ret;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* return 값이 true 면 hit, 아니면 miss 이다. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> GenericCache<span style=color:#f92672>::</span>read(Request <span style=color:#f92672>&amp;</span>req, <span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>&amp;</span>tick) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  debugprint(LOG_ICL_GENERIC_CACHE,
</span></span><span style=display:flex><span>             <span style=color:#e6db74>&#34;READ  | REQ %7u-%-4u | LCA %&#34;</span> PRIu64 <span style=color:#e6db74>&#34; | SIZE %&#34;</span> PRIu64,
</span></span><span style=display:flex><span>             req.reqID, req.reqSubID, req.range.slpn, req.length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (useReadCaching) { <span style=color:#75715e>/* 읽기용 Cache가 있는지를 확인한다. */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* start logical page number ? 의 약자인듯 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> setIdx <span style=color:#f92672>=</span> calcSetIndex(req.range.slpn); <span style=color:#75715e>/* Set-Associative Cache 를 참조 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> wayIdx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> arrived <span style=color:#f92672>=</span> tick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 이건 먼지 모르겠다. 연속적인 request를 체크하는건가 ?
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 찾아보니 prefetch 와 관련된 건데, 언제나 predict 를 sequential 이라고 생각하고 하는건가?
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 물론 prefetch 할 영역을 고르는데 어려운 알고리즘을 쓰면 문제가 많겠지만 Sequential 만 prefetch 하는게
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 좋다라는 논문이 있나?
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * TODO: 논문 리딩
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (useReadPrefetch) {
</span></span><span style=display:flex><span>      checkSequential(req, readDetect);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wayIdx <span style=color:#f92672>=</span> getValidWay(req.range.slpn, tick);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Do we have valid data?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (wayIdx <span style=color:#f92672>!=</span> waySize) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint64_t</span> tickBackup <span style=color:#f92672>=</span> tick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Wait cache to be valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (tick <span style=color:#f92672>&lt;</span> cacheData[setIdx][wayIdx].insertedAt) {
</span></span><span style=display:flex><span>        tick <span style=color:#f92672>=</span> cacheData[setIdx][wayIdx].insertedAt;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update last accessed time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      cacheData[setIdx][wayIdx].lastAccessed <span style=color:#f92672>=</span> tick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// DRAM access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      pDRAM<span style=color:#f92672>-&gt;</span>read(<span style=color:#f92672>&amp;</span>cacheData[setIdx][wayIdx], req.length, tick);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      debugprint(LOG_ICL_GENERIC_CACHE,
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;READ  | Cache hit at (%u, %u) | %&#34;</span> PRIu64 <span style=color:#e6db74>&#34; - %&#34;</span> PRIu64
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34; (%&#34;</span> PRIu64 <span style=color:#e6db74>&#34;)&#34;</span>,
</span></span><span style=display:flex><span>                 setIdx, wayIdx, arrived, tick, tick <span style=color:#f92672>-</span> arrived);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      ret <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Do we need to prefetch data?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (useReadPrefetch <span style=color:#f92672>&amp;&amp;</span> req.range.slpn <span style=color:#f92672>==</span> prefetchTrigger) {
</span></span><span style=display:flex><span>        debugprint(LOG_ICL_GENERIC_CACHE, <span style=color:#e6db74>&#34;READ  | Prefetch triggered&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        req.range.slpn <span style=color:#f92672>=</span> lastPrefetched;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Backup tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        arrived <span style=color:#f92672>=</span> tick;
</span></span><span style=display:flex><span>        tick <span style=color:#f92672>=</span> tickBackup;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> ICL_GENERIC_CACHE_READ;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We should read data from NVM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    ICL_GENERIC_CACHE_READ:
</span></span><span style=display:flex><span>      FTL<span style=color:#f92672>::</span>Request reqInternal(lineCountInSuperPage, req);
</span></span><span style=display:flex><span>      std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;&gt;</span> readList;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint32_t</span> row, col;  <span style=color:#75715e>// Variable for I/O position (IOFlag)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>uint64_t</span> dramAt;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint64_t</span> beginLCA, endLCA;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint64_t</span> beginAt, finishedAt <span style=color:#f92672>=</span> tick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (readDetect.enabled) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TEMP: Disable DRAM calculation for prevent conflict
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        pDRAM<span style=color:#f92672>-&gt;</span>setScheduling(false);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ret) {
</span></span><span style=display:flex><span>          debugprint(LOG_ICL_GENERIC_CACHE, <span style=color:#e6db74>&#34;READ  | Read ahead triggered&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        beginLCA <span style=color:#f92672>=</span> req.range.slpn;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If super-page is disabled, just read all pages from all planes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (prefetchMode <span style=color:#f92672>==</span> MODE_ALL <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>bSuperPage) {
</span></span><span style=display:flex><span>          endLCA <span style=color:#f92672>=</span> beginLCA <span style=color:#f92672>+</span> lineCountInMaxIO;
</span></span><span style=display:flex><span>          prefetchTrigger <span style=color:#f92672>=</span> beginLCA <span style=color:#f92672>+</span> lineCountInMaxIO <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          endLCA <span style=color:#f92672>=</span> beginLCA <span style=color:#f92672>+</span> lineCountInSuperPage;
</span></span><span style=display:flex><span>          prefetchTrigger <span style=color:#f92672>=</span> beginLCA <span style=color:#f92672>+</span> lineCountInSuperPage <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        lastPrefetched <span style=color:#f92672>=</span> endLCA;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        beginLCA <span style=color:#f92672>=</span> req.range.slpn;
</span></span><span style=display:flex><span>        endLCA <span style=color:#f92672>=</span> beginLCA <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint64_t</span> lca <span style=color:#f92672>=</span> beginLCA; lca <span style=color:#f92672>&lt;</span> endLCA; lca<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        beginAt <span style=color:#f92672>=</span> tick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check cache
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (getValidWay(lca, beginAt) <span style=color:#f92672>!=</span> waySize) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find way to write data read from NVM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        setIdx <span style=color:#f92672>=</span> calcSetIndex(lca);
</span></span><span style=display:flex><span>        wayIdx <span style=color:#f92672>=</span> getEmptyWay(setIdx, beginAt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (wayIdx <span style=color:#f92672>==</span> waySize) {
</span></span><span style=display:flex><span>          wayIdx <span style=color:#f92672>=</span> evictFunction(setIdx, beginAt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (cacheData[setIdx][wayIdx].dirty) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We need to evict data before write
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            calcIOPosition(cacheData[setIdx][wayIdx].tag, row, col);
</span></span><span style=display:flex><span>            evictData[row][col] <span style=color:#f92672>=</span> cacheData[setIdx] <span style=color:#f92672>+</span> wayIdx;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cacheData[setIdx][wayIdx].insertedAt <span style=color:#f92672>=</span> beginAt;
</span></span><span style=display:flex><span>        cacheData[setIdx][wayIdx].lastAccessed <span style=color:#f92672>=</span> beginAt;
</span></span><span style=display:flex><span>        cacheData[setIdx][wayIdx].valid <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        cacheData[setIdx][wayIdx].dirty <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        readList.push_back({lca, ((<span style=color:#66d9ef>uint64_t</span>)setIdx <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>|</span> wayIdx});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        finishedAt <span style=color:#f92672>=</span> MAX(finishedAt, beginAt);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      tick <span style=color:#f92672>=</span> finishedAt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      evictCache(tick);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>iter : readList) {
</span></span><span style=display:flex><span>        Line <span style=color:#f92672>*</span>pLine <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cacheData[iter.second <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>][iter.second <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        reqInternal.lpn <span style=color:#f92672>=</span> iter.first <span style=color:#f92672>/</span> lineCountInSuperPage;
</span></span><span style=display:flex><span>        reqInternal.ioFlag.reset();
</span></span><span style=display:flex><span>        reqInternal.ioFlag.set(iter.first <span style=color:#f92672>%</span> lineCountInSuperPage);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        beginAt <span style=color:#f92672>=</span> tick;  <span style=color:#75715e>// Ignore cache metadata access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If superPageSizeData is true, read first LPN only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        pFTL<span style=color:#f92672>-&gt;</span>read(reqInternal, beginAt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// DRAM delay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        dramAt <span style=color:#f92672>=</span> pLine<span style=color:#f92672>-&gt;</span>insertedAt;
</span></span><span style=display:flex><span>        pDRAM<span style=color:#f92672>-&gt;</span>write(pLine, lineSize, dramAt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Set cache data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        beginAt <span style=color:#f92672>=</span> MAX(beginAt, dramAt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pLine<span style=color:#f92672>-&gt;</span>insertedAt <span style=color:#f92672>=</span> beginAt;
</span></span><span style=display:flex><span>        pLine<span style=color:#f92672>-&gt;</span>lastAccessed <span style=color:#f92672>=</span> beginAt;
</span></span><span style=display:flex><span>        pLine<span style=color:#f92672>-&gt;</span>tag <span style=color:#f92672>=</span> iter.first;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pLine<span style=color:#f92672>-&gt;</span>tag <span style=color:#f92672>==</span> req.range.slpn) {
</span></span><span style=display:flex><span>          finishedAt <span style=color:#f92672>=</span> beginAt;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        debugprint(LOG_ICL_GENERIC_CACHE,
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#34;READ  | Cache miss at (%u, %u) | %&#34;</span> PRIu64 <span style=color:#e6db74>&#34; - %&#34;</span> PRIu64
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#34; (%&#34;</span> PRIu64 <span style=color:#e6db74>&#34;)&#34;</span>,
</span></span><span style=display:flex><span>                   iter.second <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, iter.second <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>, tick, beginAt,
</span></span><span style=display:flex><span>                   beginAt <span style=color:#f92672>-</span> tick);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      tick <span style=color:#f92672>=</span> finishedAt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (readDetect.enabled) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ret) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// This request was prefetch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          debugprint(LOG_ICL_GENERIC_CACHE, <span style=color:#e6db74>&#34;READ  | Prefetch done&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Restore tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          tick <span style=color:#f92672>=</span> arrived;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          debugprint(LOG_ICL_GENERIC_CACHE, <span style=color:#e6db74>&#34;READ  | Read ahead done&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TEMP: Restore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        pDRAM<span style=color:#f92672>-&gt;</span>setScheduling(true);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tick <span style=color:#f92672>+=</span> applyLatency(CPU<span style=color:#f92672>::</span>ICL__GENERIC_CACHE, CPU<span style=color:#f92672>::</span>READ);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    FTL<span style=color:#f92672>::</span>Request reqInternal(lineCountInSuperPage, req);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pDRAM<span style=color:#f92672>-&gt;</span>write(<span style=color:#66d9ef>nullptr</span>, req.length, tick);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pFTL<span style=color:#f92672>-&gt;</span>read(reqInternal, tick);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stat.request[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret) {
</span></span><span style=display:flex><span>    stat.cache[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/sidebar.js></script><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>