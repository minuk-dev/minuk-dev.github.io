<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>simple-ssd</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent: #00a3d2;--border-width:  5px }</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on('click',function(){$('.collapse').collapse('hide');})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-98056974-1');</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>simple-ssd</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:makerdark98@gmail.com><i class="fa fa-envelope-o"></i></a></li><li class=navbar-icon><a href=https://github.com/makerdark98/><i class="fa fa-github"></i></a></li><li><div style=max-width:250px;display:inline-block;max-height:40px><script async src="https://cse.google.com/cse.js?cx=003491619885022567520:wnnypdnx4aj"></script><div class=gcse-search></div></div></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick="(function(elem){elem.querySelector('a').click();})(this);">
<i class="fa fa-arrow-left"></i>[[ssd]]</button></div></div><div style=margin-left:auto><div style=display:flex><div style=margin-left:auto><div class=wiki-history></div></div></div><script src=/js/localhistory.js></script><script>var now="simplessd"
pushHistory(now);</script></div></div><div><h2>simple-ssd</h2><a href=https://github.com/makerdark98/makerdark98.github.io/blame/master/src/content/wiki/simplessd.md><h5>created : Wed, 10 Jun 2020 19:39:41 +0900</h5><h5>modified : Tue, 07 Jul 2020 20:53:34 +0900</h5></a><a href=http://makerdark98.dev/tags/ssd><kbd class=item-tag>ssd</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#새롭게-알게된-것>새롭게 알게된 것</a></li><li><a href=#다운로드>다운로드</a></li><li><a href=#문서-읽기>문서 읽기</a><ul><li><a href=#host-interface-layer>Host Interface Layer</a></li><li><a href=#ssd-interface>SSD Interface</a></li></ul></li><li><a href=#internal-cache-layer>Internal Cache Layer</a><ul><li><a href=#abstract-class>Abstract Class</a></li><li><a href=#set-associative-cache>Set-Associative Cache</a></li><li><a href=#호출구조>호출구조</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=새롭게-알게된-것>새롭게 알게된 것</h2><ul><li>[[gem5]]</li></ul><h2 id=다운로드>다운로드</h2><ul><li><a href=https://docs.simplessd.org/en/v2.0.12/instructions/start.html>simplessd 공홈</a></li><li>하라는 대로 하면 된다. (FullSystem은 example 을 실행해도 그대로 안되서, 그냥 standalone 을 먼저 봐보기로 했다.)</li></ul><hr><h2 id=문서-읽기>문서 읽기</h2><ul><li>그냥 홈페이지에 있는 문서를 읽어보자. 중요하니까 정리해놨겠지</li></ul><hr><h3 id=host-interface-layer>Host Interface Layer</h3><ul><li>HIL 이라고도 불리는 Host Interface Layer에 대한 설명이다.</li><li>HIL 은 host side에 있는 host controller, host controller 에게 추상화된 API를 제공해주는 SSD Interface</li></ul><h4 id=host-controller>Host Controller</h4><ul><li>NVMe, SATA and UFS를 구현해 놓았으며, Open-Channel SSD 는 NVMe 를 상속받음.</li></ul><h5 id=host-interface>Host Interface</h5><ul><li><code>hil/nvme/interface.hh</code> 에 <code>SimpleSSD::DMAInterface</code>를 상속하여 선언된 <code>SimpleSSD::HIL::NVMe::Interface</code> 를 보자.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DMAInterface</span> {
 <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
  DMAInterface() {}
  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>DMAInterface() {}

  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dmaRead</span>(<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>, DMAFunction <span style=color:#f92672>&amp;</span>,
                       <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dmaWrite</span>(<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>, DMAFunction <span style=color:#f92672>&amp;</span>,
                        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Interface</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> SimpleSSD<span style=color:#f92672>::</span>DMAInterface {
 <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
  Controller <span style=color:#f92672>*</span>pController;

 <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> updateInterrupt(<span style=color:#66d9ef>uint16_t</span>, <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getVendorID</span>(<span style=color:#66d9ef>uint16_t</span> <span style=color:#f92672>&amp;</span>, <span style=color:#66d9ef>uint16_t</span> <span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div><ul><li><code>DMAInterface</code> 에서는 Direct Memory Access 를 위해서 <code>dmaRead</code>, <code>dmaWrite</code> 를 제공한다.</li><li><code>updateInterrupt</code> 는 host의 특정 interrupt vector 에 interrupt를 보낸다.</li><li><code>getVendorId</code> 는 NVMe의 <code>Identify Controller</code>가 vendor Id와 subsystem vendor ID를 필요로 하기 때문에 존재하는 method 이다.</li></ul><h5 id=controller-and-firmware>Controller and Firmware</h5><ul><li>NVMe controller/firmware 는 아래 3가지 컴포넌트 (Controller, Subsystem and Namespace)로 구성된다.<ul><li>Controller는 모든 queue 연산(SQ 에서 request 를 읽고, CQ에 request를 쓰고, 인터럽트를 발생시키는)을 담당한다.</li><li>Subsystem은 모든 NVMe의 admin commands를 다루며, Namespace를 제어하고, SSD Layer에 I/O를 실행한다.</li><li>Namespace는 모든 NVMe의 I/O commands 를 다룬다.</li></ul></li></ul><h6 id=controller>Controller</h6><ul><li><p>모든 queue 연산을 담당하는 Controller는 <code>hil/nvme/controller.hh</code>에 <code>SimpleSSD::HIL::NVMe::Controller</code> 로 정의되어 있다.</p></li><li><p><code>EventEngine</code>은 주기적으로 <code>Controller::work</code>를 유발시키며, 이때 주기는 <code>WorkPeriod</code> 설정값을 참조한다.</p></li><li><p><code>Controller::work</code> 는 설정된 중재 함수(<code>Controller::collectSQueue</code>)를 사용하여 모든 submission queue를 모은다.</p></li><li><p>새로운 <code>Request</code>는 내부의 FIFO Queue(<code>Controller::lSQFIFO</code>) 에 넣어지며, 새로운 Request 가 있다면, <code>Controller:handleRequest</code>를 호출해야 한다. 이때 이 함수는 <code>AbstractSubsystem::submitReqeust</code>를 유발한다.</p></li><li><p><code>AbstractSubsystem</code> 이 request를 처리하고 난 뒤, <code>Controller::submit</code> 함수가 불려지게 되며, 내부적으로 존재하는 FIFO Queue(<code>Controller::lCQFIFO</code>)에 완료된 걸 넣는다.</p></li><li><p><code>Controller::submit</code> 함수는 <code>Controller::completion</code> 함수를 부르는 event를 관리한다.</p></li><li><p><code>Controller::completion</code> 함수는 CQ entry를 채우고, <code>Controller::updateInterrupt</code> 를 사용해서 interrupt를 보낸다.</p></li><li><p><code>Controller::updateInterrupt</code>는 단순히 <code>Interface::updateInterrupt</code>를 호출한다.</p></li></ul><h6 id=subsystem>Subsystem</h6><ul><li><p>admin commmands를 다루는 NVMe Subsystem은 <code>hil/nvme/subsystem.hh</code>에 <code>SimpleSSD::HIL::NVMe::Subsystem</code> 으로 선언되어 있다.</p></li><li><p>Open-channel SSD Subsystem은 <code>hil/nvme/ocssd.hh</code>에 <code>SimpleSSD::HIL::NVMe::OpenChannelSSD</code>로 선언되어 있다.</p></li><li><p>두 subsystem 모두 <code>hil/nvme/abstract_subsystem.hh</code>의 <code>SimpleSSD::HIL::NVMe::AbstractSubsystem</code> 을 상속한다.</p></li><li><p>기본적으로 아래쪽 설명들은 NVMe subsystem 을 기반으로 하고 있는데, Open-Channel SSD 랑 사소한 차이만 있기 때문이다.</p></li><li><p>NVMe Subsystem은 2부분으로 나뉘는데, command handling, I/O request handling.</p></li><li><p>Subsystem이 여러 namespaces를 가질수 있으므로, Subsystem은 반드시 I/O requests 를 Namespaces 로부터 HIL의 SSD Interface로 넘겨줘야 한다.</p></li><li><p>각 NVMe 명령들은</p><ul><li>I/O 명령이라면, <code>Subsystem::submitCommand</code> 함수를 통해서 특정한 Namespace로 가지게 되며.</li><li>관리용(admin) 명령이라면, <code>submitCommand</code> 함수는 OPCODE를 확인한 이후 적절한 함수를 호출하게 된다.</li></ul></li><li><p>모든 명령들은 완료됨을 알리기 위해서 <code>Controller::submit</code> 를 유발한다.</p></li><li><p>특정한 I/O 함수들(<code>Subsystem::read, write, flush and trim</code>)이 불리게 된다면, I/O unit으로 번역된뒤, SSD Intreface의 함수들로 간다. (<code>HIL::HIL::read</code>, <code>HIL::HIL::write</code>, <code>HIL::HIL::flush</code> and <code>HIL::HIL::trim</code>);</p></li><li><p>SSD를 선형적으로 쪼개기 위해서, Subsystem은 multiple Namespaces를 유지한다.</p><ul><li>예를 들어 1TB SSD 가 4K 논리적 block을 사용한다고 하자. 이때 512GB, 256GB, 256GB 용량으로 3개의 Namespaces로 쪼갤수 있다.</li><li>Subsystem은 offset과 length를 찾아서 namespaces를 할당할 것이고, Subsystem은 할당되지 않은 공간을 처음 맞는 Namespaces에 할당한다.(first-fit). 만약 공간이 없다면 할당이 실패한다.</li></ul></li><li><p>각 Namespace 마다 offset과 length를 가지고 있으며, 이 값은 SSD interface를 위해 I/O unit으로 번역될때 쓰인다.</p></li></ul><h6 id=namespace>Namespace</h6><ul><li>I/O 명령을 다루는 NVMe Namespace는 <code>hil/nvme/namespace.hh</code>에 <code>SimpleSSD::HIL::NVMe::Namespace</code>로 선언되어 있으며. NVMe Subsystem과 비슷한 구조를 다룬다.(둘다 command를 다룬다.)</li><li>I/O 명령이 오면, Namespace 는 Subsystem의 해당 함수들을 호출한다.(<code>read</code>, <code>write</code>, <code>flush</code> and <code>trim</code>).</li></ul><h4 id=serial-at-attachment>Serial AT Attachment</h4><ul><li>Serial AT Attachment - SATA 는 SSD와 HDD를 위한 전통적 interface이다.</li><li>SimpleSSD 에서는 Serial ATA Advanced host Controller Interface (AHCI) 1.3.1 에 기반한 STATA HBA를 구현하였고, Serial ATA Revision 3.0 에 기반을 둔 STAT PHY와 프로토콜을 구현하였다.</li></ul><h5 id=host-interface-1>Host interface</h5><ul><li><p><code>hil/sata/interface.hh</code>에 선언된 <code>SimpleSSD::HIL::SATA::Interface</code> 추상 클래스는 simulator에게 common API를 제공한다.</p></li><li><p>SimpleSSD-FUllSystem 에서 <code>src/dev/storage/sata_interrface.hh</code>에 선언된 <code>SATAInterface</code> 에서 어떻게 상속하는지 확인할 수 있다.</p></li><li><p><code>SimpleSSD::HIL::SATA::Interface</code> 은 오직 <code>virtual void updateInterrupt(bool) = 0</code>를 interrupt posting 을 위해서 포함하고 있다.</p></li></ul><h5 id=host-bus-adapter>Host Bus Adapter</h5><ul><li><p>SATA는 Host Bus Adapter(HBA) 라고 불리는 host sid controller 를 필요로 한다.</p></li><li><p>HBA 디자인은 다양하지만, 우리는 누구나 접근할수 있는 AHCI spcification을 사용했다.</p></li><li><p>우리는 단 하나의 SimpleSSD 인스턴스만 HBA에 연결되기 때문에 단 하나의 port 만 구현했다.</p></li><li><p><code>Interface</code>는 AHCI registser(Genetic Host Controller registers and Port registers)를 <code>HBA::writeAHCIRegister</code> 함수를 통해서 쓴다.</p></li><li><p><code>PxCl</code> register에 bits를 쓰는 건 그에 대항하는 NCQ에 새로운 요청이 있다는걸 의미한다.</p></li><li><p><code>HBA</code>는 내부 FIFO(<code>HBA::lRequestQueue</code>)에 request를 넣기 위해서 <code>HBA::processCommand</code> 를 호출한다.</p></li><li><p>NVMe와 동일하게 <em>Event Engine</em>은 주기적으로 <code>HBA::work</code> 함수를 호출하고, 이 함수는 <code>HBA::handleRequest</code> 함수를 호출하고와 <code>Device::submitCommand</code> 함수가 불리게 된다.</p></li><li><p>command handling 이후 <code>Device</code>는 <code>HBA::submitFIS</code> 함수를 FIS 응답을 host에게 돌려주기 위해서 부른다. <code>HBA::submitFIS</code> 함수는 <code>HBA::lResponseQueue</code>에 응답을 넣고, <code>HBA::handleResponse</code> 함수를 호출하는 event를 예약한다. <code>handleResponse</code> 함수는 내부의 FIFO에서부터 첫번째 response를 읽고, NCQ에 써서 <code>Interface::updateInterrupt</code> 함수를 사용해 Interrupt를 보낸다.</p></li></ul><h5 id=device>Device</h5><ul><li><code>hil/sata/device.hh</code> 에 선언된 <code>SimpleSSD::HIL::SATA::Device</code>는 HBA와 연결하는 Device이다.</li><li>Device는 아래 나열된 ATA 명령어(ATA/ATAPI Command Set -2 (ACS-2) 와 (AT Attachment 8 - ATA/ATAPI Command Set (ATA8-ACS))를 다룰수 있다.<ul><li><code>FLUSH CACHE</code></li><li><code>FLUSH CACHE EXT</code></li><li><code>IDENTIFY DEVICE</code></li><li><code>READ DMA</code></li><li><code>READ DMA EXT</code></li><li><code>READ FPDMA QUEUED</code></li><li><code>READ SECTOR</code></li><li><code>READ SECTOR EXT</code></li><li><code>READ VERIFY SECTOR</code></li><li><code>READ VERIFY SECTOR EXT</code></li><li><code>SET FEATURE</code></li><li><code>WRITE DMA</code></li><li><code>WRTIE DMA EXT</code></li><li><code>WRITE FPDMA QUEUED</code></li><li><code>WRTIE SECTOR</code></li><li><code>WRTIE SECTOR EXT</code></li></ul></li><li>Device 의 구현이 NVMe Subsystem에 비해 간단해 보일수 있는데, 이는 Namespace를 관리할 필요가 없기 때문이다.</li><li>모든 명령어들은 <code>Device::submitCommand</code> 함수를 통과하며 적절하게 다루어진다.</li><li>완료 이후, 각 명령어들은 명령의 결과를 <code>HBA</code>에게 보고하기(report) 위해서 <code>HBA::submitFIS</code>를 호출한다.</li><li>I/O 와 관련된 <code>READ*</code>, <code>WRITE*</code> and <code>FLUSH*</code> 는 SSD Interface의 함수 (<code>HIL::HIL::read, write and flush</code>) 를 호출한다.</li></ul><h4 id=universal-flash-storage>Universal Flash Storage</h4><ul><li>Universal Flash Storage - UFS : 모바일용 저장소를 위해 디자인된 interface. 대부분의 스마트폰들이 이 UFS interface를 사용하고 있다.</li><li>SimpleSSD 에서는 <code>Universal Flash Storage (UFS) Host Controller Interface (JESD223)</code>을 기반으로 UFS Host Controller를 구현하였으며, UFS PHY는 <code>Specification for M-PHY Version 4.0</code> 을, UFS protocol은 <code>Universal Flash Storage (UFS) Version 2.1 (JESD220C)</code>를 기반으로 한다.</li></ul><h5 id=host-interface-2>Host Interface</h5><ul><li><code>SimpleSSD::HIL::UFS::Interface</code> 는 simulator에게 common API를 제공하기 위해 추상 클래스로 <code>hil/ufs/interface.hh</code> 에 정의되어 있다. 어떻게 구체화 하는지는 SimpleSSD_FullSystem의 <code>UFSInterface</code> 는 <code>scr/dev/storage/ufs_interface.hh</code> 에 나와 있다.</li><li><code>SimpleSSD::HIL::UFS::Interface</code> 는 단지 <code>generateInterrrupt()</code> 와 <code>clearInterrupt()</code> 를 포함한다.</li></ul><h5 id=host-controller-inteface>Host Controller inteface</h5><ul><li><p>SATA처럼 UFS도 UFS Host Controller Interface - UFSHCI 를 제공한다. 이 인터페이스는 <code>Universal Flash Storage (UFS) Host Controller Interface (JESD223)</code>를 따라간다.</p></li><li><p>UFSHCI 는 <code>hil/ufs/host.hh</code> 에 <code>SimpleSSD::HIL::UFS::Host</code>로 구현되어 있다.</p></li><li><p><code>Interface</code> 는 UFSHCI register에 <code>Host::writeRegister</code> 함수를 사용해서 쓴다.</p></li><li><p>UFS는 3가지 종류의 명령이 있는데</p><ul><li>UFS Trasnport Protocol Transfer (UTP Transfer)</li><li>UFS Transport Protocol Task Management (UTP Task)</li><li>UFS InterConnect Command (UIC Command)</li></ul></li><li><p>각 명령어들은 request를 알리는데 서로 다른 doorbell을 사용하며</p><ul><li><code>REG_UTRLDBR</code> 는 UTP Transfer</li><li><code>REG_UTMRLDBR</code> 는 UTP Task</li><li><code>REG_UICCMDR</code> 는 UIC Command</li></ul></li><li><p>를 확인할때 사용할수 있다.</p></li><li><p>리눅스 커널과 UFS 2.1에서 UTP Task는 구현되지 않았기 때문에 SimpleSSD 에서도 구현하지 않았다.</p></li><li><p>UIC Commands 는 오직 UFS hardware를 초기화 할때만 사용하며(M-PHY link 부팅 등), 그러므로 우린 오직 2가지 기초적 명령어들만 구현했다.</p></li><li><p>NVMe와 SATA처럼 <strong>Event Engine</strong> 은 주기적으로 <code>Host::work</code> 함수를 호출하며. <code>Host::handleRequest</code> 함수는 <code>work</code>에 의해서 호출되고 request가 유효한지를 검증한다. <code>Host::processUTPCommand</code> 는 request를 파싱하고, request에 적합한 handler를 부른다.</p></li><li><p>UFS Transfer는 3가지 유형의 명령어들로 정의된다.</p><ul><li>Command (SCSI protocol)</li><li>Native UFS Command</li><li>Device Management Command</li></ul></li><li><p>Native UFS Command는 UFS 2.1 에서 정의되지 않았기 때문에 우린 Command 와 Device Management Command 만을 구현했다.</p></li><li><p><code>Device::processCommand</code> 함수는 Command 를 다루고 <code>Device::processQueryCommand</code> 함수는 Device Management Command 를 다룬다.</p></li><li><p><code>handleRequest</code> 함수에서 완료 루틴(Completion routine) 이 선언되어 있으며 이는 <code>doRequest</code> 와 <code>doWrite</code> 라는 lambda 함수들을 확인하면 된다. <code>doWrite</code> 함수는 completion routine(<code>Host::completion</code>)을 예약하며, <code>completion</code> 함수는 <code>Interface::updateInterrupt</code> 함수를 사용해서 Interrupt를 보낸다.</p></li></ul><h5 id=device-1>Device</h5><ul><li><p>UFSHCI 와 연결해주는 Device 는 <code>hil/ufs/device.hh</code>에 <code>SimpleSSD::HIL::UFS::Device</code> 를 정의한다.</p></li><li><p>UFS 는 SCSI commands set(<code>SCSI Block Commands - 3 (SBC-3)</code> 와 <code>SCSI Primary Commands - 4(SPC-4)</code>) 을 I/O 하기 위해서 사용gksek.</p></li><li><p>Device 는 아래 나오는 SCSI 명령어들로 다루어진다.</p><ul><li><code>INQUERY</code></li><li><code>MODE SELECT 10</code></li><li><code>MODE SENSE 10</code></li><li><code>READ 6</code></li><li><code>READ 10</code></li><li><code>READ CAPACITY 10</code></li><li><code>READ CAPACITY 16</code></li><li><code>START STOP UNIT</code></li><li><code>TEST UNIT READY</code></li><li><code>REPORT LUNS</code></li><li><code>VERIFY 10</code></li><li><code>WRITE 6</code></li><li><code>WRITE 10</code></li><li><code>SYNCHRONIZE CACHE 10</code></li></ul></li><li><p>Device 의 구현은 SATA와 비슷하지만 2가지 명령어 handling 함수를 가진다. (<code>processCommand</code> 와 <code>processQueryCommand</code>)</p></li><li><p>완료 이후 각 SCI command 함수는 callback handler 를 호출하며, 이때 <code>processCommand</code> 함수의 인자로서 콜백은 제공한다.</p></li><li><p><code>processQueryCommand</code> 는 즉시 결과를 리턴한다. I/O 관련 명령 <code>READ*</code>, <code>WRITE*</code> 와 <code>SYNCHRONIZE CACHE</code> 는 SSD Interface 함수들 (<code>HIL::HIL::read, write and flush</code>) 를 호출한다.</p></li></ul><h4 id=nvme-소스코드와의-비교>nvme 소스코드와의 비교</h4><ul><li>[[nvme]] 페이지에 나름 정리한걸 올려놨다.</li><li>driver 부분을 주로 비교하고 나머진 아직 openssd 를 읽으면서 해야할듯.</li></ul><h4 id=프로그램-시작점>프로그램 시작점</h4><ul><li>simplessd에서 <code>sim/main.cc</code> 파일의 220번째 줄을 보면 <code>RequestGenerator</code> 가 있다. 여기서 <code>submitIO()</code> 가 bio를 호출 (실제로는 시뮬레이션이지만, 편의상)하고, <code>iocallback()</code>이 주기적으로 <code>rescheduleSubmit()</code> 를 호출하면서 IO를 발생시킨다.</li><li>여기서는 <code>bil/interface.hh</code>에 <code>DriverInterface</code> 를 만들어 두어서 <code>BIO</code> layer를 구현해둔듯 하다. scheduler는 단순히 <code>DriverInterface</code> 의 <code>submitIO</code>를 호출하는게 전부임.</li></ul><h4 id=bio-발생---드라이버>BIO 발생 -> 드라이버</h4><h5 id=request로부터-opcode-분리>request로부터 opcode 분리</h5><ul><li>linux 의 <code>drivers/nvme/host/core.c</code> 의 <code>nvme_queue_rq()</code>에서 호출하는 <code>nvme_setup_cmd()</code> 와 SimpleSSD의 <code>sil/nvme/nvme.cc</code> 의 <code>Driver::submitIO()</code> 가 서로 같은 일을 하고 있음.</li><li>명령어의 종류에 따라 (<code>READ</code>, <code>WRITE</code>, <code>TRIM(DISCARD)</code>, <code>FLUSH</code>) 기본적인 setup과정을 호출해준다.</li></ul><h6 id=simplessd-구현>SimpleSSD 구현</h6><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>submitIO(BIL<span style=color:#f92672>::</span>BIO <span style=color:#f92672>&amp;</span>bio) {
  <span style=color:#66d9ef>uint32_t</span> cmd[<span style=color:#ae81ff>16</span>];
  PRP <span style=color:#f92672>*</span>prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
  <span style=color:#66d9ef>static</span> ResponseHandler callback <span style=color:#f92672>=</span> [<span style=color:#66d9ef>this</span>](<span style=color:#66d9ef>uint16_t</span> status, <span style=color:#66d9ef>uint32_t</span>,
                                           <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
    _io(status, context);
  };

  memset(cmd, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>64</span>);

  <span style=color:#66d9ef>uint64_t</span> slba <span style=color:#f92672>=</span> bio.offset <span style=color:#f92672>/</span> LBAsize;
  <span style=color:#66d9ef>uint32_t</span> nlb <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)DIVCEIL(bio.length, LBAsize);

  cmd[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> namespaceID;  <span style=color:#75715e>// NSID
</span><span style=color:#75715e></span>
  <span style=color:#66d9ef>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_READ) {
    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_READ;  <span style=color:#75715e>// CID, FUSE, OPC
</span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)slba;
    cmd[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> slba <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>;
    cmd[<span style=color:#ae81ff>12</span>] <span style=color:#f92672>=</span> nlb <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// LR, FUA, PRINFO, NLB
</span><span style=color:#75715e></span>
    prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PRP(bio.length);
    prp<span style=color:#f92672>-&gt;</span>getPointer(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>), <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>));  <span style=color:#75715e>// DPTR
</span><span style=color:#75715e></span>  }
  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_WRITE) {
    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_WRITE;  <span style=color:#75715e>// CID, FUSE, OPC
</span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span>)slba;
    cmd[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> slba <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>;
    cmd[<span style=color:#ae81ff>12</span>] <span style=color:#f92672>=</span> nlb <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// LR, FUA, PRINFO, DTYPE, NLB
</span><span style=color:#75715e></span>
    prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PRP(bio.length);
    prp<span style=color:#f92672>-&gt;</span>getPointer(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>), <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>));  <span style=color:#75715e>// DPTR
</span><span style=color:#75715e></span>  }
  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_FLUSH) {
    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_FLUSH;  <span style=color:#75715e>// CID, FUSE, OPC
</span><span style=color:#75715e></span>  }
  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (bio.type <span style=color:#f92672>==</span> BIL<span style=color:#f92672>::</span>BIO_TRIM) {
    cmd[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> SimpleSSD<span style=color:#f92672>::</span>HIL<span style=color:#f92672>::</span>NVMe<span style=color:#f92672>::</span>OPCODE_DATASET_MANAGEMEMT;  <span style=color:#75715e>// CID, FUSE, OPC
</span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;                                               <span style=color:#75715e>// NR
</span><span style=color:#75715e></span>    cmd[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x04</span>;                                            <span style=color:#75715e>// AD
</span><span style=color:#75715e></span>
    prp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PRP(<span style=color:#ae81ff>16</span>);
    prp<span style=color:#f92672>-&gt;</span>getPointer(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>), <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>)(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>));  <span style=color:#75715e>// DPTR
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// Fill range definition
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> data[<span style=color:#ae81ff>16</span>];

    memset(data, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>16</span>);
    memcpy(data <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&amp;</span>nlb, <span style=color:#ae81ff>4</span>);
    memcpy(data <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>, <span style=color:#f92672>&amp;</span>slba, <span style=color:#ae81ff>8</span>);

    prp<span style=color:#f92672>-&gt;</span>writeData(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>16</span>, data);
  }

  submitCommand(<span style=color:#ae81ff>1</span>, (<span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>)cmd, callback,
                <span style=color:#66d9ef>new</span> IOWrapper(bio.id, prp, bio.callback));
}
</code></pre></div><h6 id=nvmedriver-구현>nvme(driver) 구현</h6><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>blk_status_t <span style=color:#a6e22e>nvme_setup_cmd</span>(<span style=color:#66d9ef>struct</span> nvme_ns <span style=color:#f92672>*</span>ns, <span style=color:#66d9ef>struct</span> request <span style=color:#f92672>*</span>req,
		<span style=color:#66d9ef>struct</span> nvme_command <span style=color:#f92672>*</span>cmd)
{
	blk_status_t ret <span style=color:#f92672>=</span> BLK_STS_OK;

	nvme_clear_nvme_request(req);

	memset(cmd, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>cmd));
	<span style=color:#66d9ef>switch</span> (req_op(req)) {
	<span style=color:#66d9ef>case</span> REQ_OP_DRV_IN:
	<span style=color:#66d9ef>case</span> REQ_OP_DRV_OUT:
		memcpy(cmd, nvme_req(req)<span style=color:#f92672>-&gt;</span>cmd, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>cmd));
		<span style=color:#66d9ef>break</span>;
	<span style=color:#66d9ef>case</span> REQ_OP_FLUSH:
		nvme_setup_flush(ns, cmd);
		<span style=color:#66d9ef>break</span>;
	<span style=color:#66d9ef>case</span> REQ_OP_WRITE_ZEROES:
		ret <span style=color:#f92672>=</span> nvme_setup_write_zeroes(ns, req, cmd);
		<span style=color:#66d9ef>break</span>;
	<span style=color:#66d9ef>case</span> REQ_OP_DISCARD:
		ret <span style=color:#f92672>=</span> nvme_setup_discard(ns, req, cmd);
		<span style=color:#66d9ef>break</span>;
	<span style=color:#66d9ef>case</span> REQ_OP_READ:
	<span style=color:#66d9ef>case</span> REQ_OP_WRITE:
		ret <span style=color:#f92672>=</span> nvme_setup_rw(ns, req, cmd);
		<span style=color:#66d9ef>break</span>;
	<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
		WARN_ON_ONCE(<span style=color:#ae81ff>1</span>);
		<span style=color:#66d9ef>return</span> BLK_STS_IOERR;
	}

	cmd<span style=color:#f92672>-&gt;</span>common.command_id <span style=color:#f92672>=</span> req<span style=color:#f92672>-&gt;</span>tag;
	trace_nvme_setup_cmd(req, cmd);
	<span style=color:#66d9ef>return</span> ret;
}
</code></pre></div><h5 id=submit-command>submit command</h5><ul><li>nvme에서는 <code>struct blk_mq_hw_ctx *hctx</code> 를 parameter로 넣어주므로써 자연스럽게 nvme queue를 admin queue와 submission queue를 처리하는데, SimpleSSD 의 경우에는 <code>uint16_t iv</code> 라는 값을 전달하므로써 이를 처리한다.</li><li>궁금점은 nvme에서는 spin_lock 을 걸어서 복사하는 과정에서 또다른 bio가 오는 것을 생각하고 있는 듯한 구현인데, SimpleSSD 의 경우에는 따로 lock을 거는 게 없다. 단일 쓰레드에서만 도는 걸 생각하는건가? 여기는 잘 모르겠다.</li></ul><h6 id=simplessd-구현-1>SimpleSSD 구현</h6><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Driver<span style=color:#f92672>::</span>submitCommand(<span style=color:#66d9ef>uint16_t</span> iv, <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>cmd, ResponseHandler <span style=color:#f92672>&amp;</span>func,
                           <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
  <span style=color:#66d9ef>uint16_t</span> cid <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>uint16_t</span> opcode <span style=color:#f92672>=</span> cmd[<span style=color:#ae81ff>0</span>];
  <span style=color:#66d9ef>uint16_t</span> tail <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>uint64_t</span> tick <span style=color:#f92672>=</span> engine.getCurrentTick();
  Queue <span style=color:#f92672>*</span>queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;

  <span style=color:#75715e>// Push to queue
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (iv <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    increaseCommandID(adminCommandID);
    cid <span style=color:#f92672>=</span> adminCommandID;
    queue <span style=color:#f92672>=</span> adminSQ;
  }
  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (iv <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> ioSQ) {
    increaseCommandID(ioCommandID);
    cid <span style=color:#f92672>=</span> ioCommandID;
    queue <span style=color:#f92672>=</span> ioSQ;
  }
  <span style=color:#66d9ef>else</span> {
    SimpleSSD<span style=color:#f92672>::</span>panic(<span style=color:#e6db74>&#34;I/O Submission Queue is not initialized&#34;</span>);
  }

  memcpy(cmd <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>&amp;</span>cid, <span style=color:#ae81ff>2</span>);
  queue<span style=color:#f92672>-&gt;</span>setData(cmd, <span style=color:#ae81ff>64</span>);
  tail <span style=color:#f92672>=</span> queue<span style=color:#f92672>-&gt;</span>getTail();

  <span style=color:#75715e>// Push to pending cmd list
</span><span style=color:#75715e></span>  pendingCommandList.push_back(CommandEntry(iv, opcode, cid, context, func));

  <span style=color:#75715e>// Ring doorbell
</span><span style=color:#75715e></span>  pController<span style=color:#f92672>-&gt;</span>ringSQTailDoorbell(iv, tail, tick);
  queue<span style=color:#f92672>-&gt;</span>incrHead();
}
</code></pre></div><h5 id=nvme구현>nvme구현</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/**
</span><span style=color:#75715e> * nvme_submit_cmd() - Copy a command into a queue and ring the doorbell
</span><span style=color:#75715e> * @nvmeq: The queue to use
</span><span style=color:#75715e> * @cmd: The command to send
</span><span style=color:#75715e> * @write_sq: whether to write to the SQ doorbell
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nvme_submit_cmd</span>(<span style=color:#66d9ef>struct</span> nvme_queue <span style=color:#f92672>*</span>nvmeq, <span style=color:#66d9ef>struct</span> nvme_command <span style=color:#f92672>*</span>cmd,
			    <span style=color:#66d9ef>bool</span> write_sq)
{
	spin_lock(<span style=color:#f92672>&amp;</span>nvmeq<span style=color:#f92672>-&gt;</span>sq_lock);
	memcpy(nvmeq<span style=color:#f92672>-&gt;</span>sq_cmds <span style=color:#f92672>+</span> (nvmeq<span style=color:#f92672>-&gt;</span>sq_tail <span style=color:#f92672>&lt;&lt;</span> nvmeq<span style=color:#f92672>-&gt;</span>sqes),
	       cmd, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>cmd));
	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>nvmeq<span style=color:#f92672>-&gt;</span>sq_tail <span style=color:#f92672>==</span> nvmeq<span style=color:#f92672>-&gt;</span>q_depth)
		nvmeq<span style=color:#f92672>-&gt;</span>sq_tail <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
	<span style=color:#66d9ef>if</span> (write_sq)
		nvme_write_sq_db(nvmeq);
	spin_unlock(<span style=color:#f92672>&amp;</span>nvmeq<span style=color:#f92672>-&gt;</span>sq_lock);
}
</code></pre></div><h4 id=work>Work</h4><h5 id=simplessd>SimpleSSD</h5><ul><li>simplessd에선 <code>Driver::submitCommand()</code> 에서 <code>pendingCommandList</code> 에 <code>CommandEntry</code>를 넣은 뒤, <code>pController->ringSQTailDoorbell</code> 를 해주는데, 이를 따라가보면, 인자로 넣어준 SQ의 tail을 이동시키는게 전부다&mldr;?</li><li>여기서부터 순간 방향성을 잃었는데, SQ 넣고 어떻게 되지? 싶었다. 한번 SQ에 엑세스 하는걸 봐보자</li><li>그러면 <code>Controller::work()</code> 가 나오게 된다. 이 함수는 <code>workEvent</code> 라는 변수에 담겨서 <code>Controller::writeRegister()</code>에서 schedule에 등록된다. 이는 <code>Driver::init()</code> 에서 Step 5. 에서 일어난다.</li><li>따라서 SimpleSSD 는 <code>workInterval</code> (기본값 : 50000, 50ns) 마다 SQ를 검사해서 처리하는 방식이다.</li></ul><h5 id=nvmedriver>nvme(driver)</h5><ul><li><p><code>nvme_write_sq_db()</code> 를 호출하는데, 이는 결국 <code>writel()</code>를 호출해서 SQ tail 주소에 command를 쓰는 구조이다.</p></li><li><p>그렇다면 nvme에서 command는 어떻게 되는가? : TODO: 흠&mldr;. 아직 잘 모르겠는데? <code>nvme_scan_work()</code> 가 있긴한데, 이게 user 가 scan work를 강제로 SSD에 시키는 건지가 모르겠는데, 근데 그런 구조면, 글러먹은게 IO 연산을 하기 위해서 직접 다 해줘야되는건데? 그러면 굳이 scheduler가 linux kernel level에 존재할 필요가 없는데? 그냥 scheduler layer 없이 SSD scan work 를 조절하면 되는데? 일단 추정은 ssd 내부에 존재하는건데, 이건 OpenChannelSSD 를 읽어보고 알아내야할듯.</p></li><li><p>흐음&mldr;. 이건 잘 못찾았다. Controller 내부에 있다고 가정하고 계속 읽어 나가야할듯</p></li></ul><h3 id=ssd-interface>SSD Interface</h3><ul><li>HIL 의 SSD Interface는 단순한데 <code>hil/hil.hh</code> 에 <code>SimpleSSD::HIL::HIL</code> 로 정의되어 있다.</li><li>I/O request를 host controller로 부터 받아 <code>Interal Cache Layer</code> 에 넘겨준다.</li></ul><h2 id=internal-cache-layer>Internal Cache Layer</h2><ul><li>여기서는 I/O buffer model (data cache)인 Internal Cache Layer (이하 ICL) 을 알아본다.</li><li>ICL은 추상 클래스로 되어 있어서 상속 받아서 구현해볼수 있고 기본적으로는 set-associative cache 로 구현된 Generic Cache를 확인한다.</li></ul><h3 id=abstract-class>Abstract Class</h3><ul><li><code>icl/abstract_cache.hh</code>에 <code>AbstractCache</code> 클래스로 선언되어 있으며 5가지 가상함수가 존재한다.(<code>Statobject</code>에서 파생된 3가지 함수들도 추가로 있다.)</li><li>ICL 은 각 가상함수로부터 I/O requests와 고유한 알고리즘에 의해서 bffer /IIO 를 가진다. data eviction이 필요하거나, flush request가 있을때 I/O를 FTL 에 넘긴다.</li><li>SSD의 Data buffer는 느린 NAND I/O 성능을 감추기 위해서 매우 중요하다. buffer algorithm의 작은 변화도 성능을 크게 바꿀수 있다.</li></ul><h3 id=set-associative-cache>Set-Associative Cache</h3><ul><li><code>icl/generic_cache.hh</code> 에 <code>SimpleSSD::ICL::GenericCache</code> 라고 선언된 set-associative cache를 제공하며, 아래 후술될 인자를 조정할수 있다.<ul><li><code>CacheSize</code> : Buffer Capacity.</li><li><code>CacheWaySize</code> : Set associativity of cache. set size will automatically caclculated</li><li><code>EnableReadCache</code>: Enable read data caching.</li><li><code>EnableReadPrefetch</code>: enable read-ahead and prefetch.</li><li><code>ReadPrefetchMode</code>: Specify how many data should be read-ahead/prefetch.</li><li><code>ReadPrefetchCount</code> : Threshold for read-ahead/prefetch(# of sequential I/O).</li><li><code>ReadPrefetchRatio</code> : Threshold for read-ahead/prefetch(data size of sequential I/O).</li><li><code>EnableWriteCache</code> : enable write data caching.</li><li><code>EvictPolicy</code> : Specify which algorithm to use to select victim cache line.</li><li><code>EvictMode</code> : Specify how many data should be evicted when cache is full.</li><li><code>CacheLatency</code> : Set cache metadata accesss latency.</li></ul></li></ul><h3 id=호출구조>호출구조</h3><ul><li><code>hil/nvme/controller.cc</code> 에서 <code>Controller::work()</code>를 확인해보면 <code>DMAContext</code> 를 만들어주고 호출하는 걸 알수 있다.</li><li>여기서 <code>checkQueue()</code> 를 호출하면서 <code>DMAFunction</code> 타입인 <code>func</code>를 호출하게된다. 이때 <code>func</code>은 <code>doQueue</code> 이고 이는 결국 <code>collectSQueue</code>의 인자로 주어졌던 <code>CPUContext</code>가 가지고 있는 함수를 호출한다. 이때 이건 결국 <code>handleRequest</code>를 호출하게 된다. 이는 <code>SubSystem</code> 에 request를 전달하게 된다.</li><li>결론은 결국 request는 처리되서 subsystem에 도달하게 되고, 이게 어떻게 처리되는지는 <code>Subsystem::submitCommand()</code>를 확인하면 알수 있다. 여기서 admin command 들을 처리하고, 아닌 것들은 그대로 <code>Namespace::submitCommand()</code> 로 넘어오게 된다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Namespace<span style=color:#f92672>::</span>submitCommand(SQEntryWrapper <span style=color:#f92672>&amp;</span>req, RequestFunction <span style=color:#f92672>&amp;</span>func) {
    <span style=color:#75715e>/* Skip */</span>
    <span style=color:#75715e>// NVM commands
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>switch</span> (req.entry.dword0.opcode) {
        <span style=color:#66d9ef>case</span> OPCODE_FLUSH:
          flush(req, func);
          <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> OPCODE_WRITE:
          write(req, func);
          <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> OPCODE_READ:
          read(req, func);
          <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> OPCODE_COMPARE:
          compare(req, func);
          <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> OPCODE_DATASET_MANAGEMEMT:
          datasetManagement(req, func);
          <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
          resp.makeStatus(true, false, TYPE_GENERIC_COMMAND_STATUS,
                          STATUS_INVALID_OPCODE);

          response <span style=color:#f92672>=</span> true;

          <span style=color:#66d9ef>break</span>;
      }
    }
  }

  <span style=color:#66d9ef>if</span> (response) {
    func(resp);
  }
}
</code></pre></div><ul><li>이때 <code>read</code> 함수등 은 다시 <code>Subsystem::read()</code>를 호출하고 이 내부는</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> Subsystem<span style=color:#f92672>::</span>read(Namespace <span style=color:#f92672>*</span>ns, <span style=color:#66d9ef>uint64_t</span> slba, <span style=color:#66d9ef>uint64_t</span> nlblk,
                     DMAFunction <span style=color:#f92672>&amp;</span>func, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
  Request <span style=color:#f92672>*</span>req <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Request(func, context);
  DMAFunction doRead <span style=color:#f92672>=</span> [<span style=color:#66d9ef>this</span>](<span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context) {
    <span style=color:#66d9ef>auto</span> req <span style=color:#f92672>=</span> (Request <span style=color:#f92672>*</span>)context;

    pHIL<span style=color:#f92672>-&gt;</span>read(<span style=color:#f92672>*</span>req);

    <span style=color:#66d9ef>delete</span> req;
  };

  convertUnit(ns, slba, nlblk, <span style=color:#f92672>*</span>req);

  execute(CPU<span style=color:#f92672>::</span>NVME__SUBSYSTEM, CPU<span style=color:#f92672>::</span>CONVERT_UNIT, doRead, req);
}
</code></pre></div><ul><li><code>HIL::read()</code> 를 부르게 된다. 이렇게 불리게 된 <code>HIL::read()</code> 의 내부에서 <code>ICL::read()</code> 를 부르는 구조이다.</li><li>read 부분만 봤는데, 다른 부분도 비슷할거라고 생각한다.</li></ul></div><script>function convertWikiLink(elem){elem.innerHTML=elem.innerHTML.replace(/\[\[(.+?)\]\]\{(.+?)\}/g,(original,matching,display)=>{if(display==="_index"){display="Front Page";matching="";}
return `<a href="/wiki/${matching.toLowerCase().replace(/ /g,'-').replace(/[()]/g,'')}">${display}</a>`;});elem.innerHTML=elem.innerHTML.replace(/\[\[(.+?)\]\]/g,(original,matching)=>{var display=matching;if(display==="_index"){display="Front Page";matching="";}
return `<a href="/wiki/${matching.toLowerCase().replace(/ /g,'-').replace(/[()]/g,'')}">${display}</a>`;});};(function(){var content=document.querySelector('.content');if(content)convertWikiLink(content);var parent=document.querySelector('.parent-doc');if(parent)convertWikiLink(parent);})();</script><div><script src=https://utteranc.es/client.js repo=makerdark98/makerdark98.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><footer><p class="copyright text-muted">© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/calintat/minimal>Minimal</a>.</p></footer></body></html>