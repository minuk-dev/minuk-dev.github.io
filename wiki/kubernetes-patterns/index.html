<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>쿠버네티스 패턴</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>쿠버네티스 패턴
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[kubernetes]]</button></div></div></div><div><h2>쿠버네티스 패턴</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/kubernetes-patterns.md><h5>created : Tue, 16 Aug 2022 10:56:05 +0900</h5><h5>modified : Fri, 26 Aug 2022 16:08:59 +0900</h5></a><a href=https://minuk.dev/tags/kubernetes><kbd class=item-tag>kubernetes</kbd></a>
<a href=https://minuk.dev/tags/k8s><kbd class=item-tag>k8s</kbd></a>
<a href=https://minuk.dev/tags/book><kbd class=item-tag>book</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><ul><li><a href=#1장-개요>1장 개요</a></li></ul></li><li><a href=#1부-기본-패턴>1부 기본 패턴</a><ul><li><a href=#2장-예측-범위-내의-요구사항>2장 예측 범위 내의 요구사항</a></li><li><a href=#3장-선언적-배포>3장 선언적 배포</a></li><li><a href=#4장-정상상태-점검>4장 정상상태 점검</a></li><li><a href=#5장-수명주기-관리>5장 수명주기 관리</a></li><li><a href=#6장-자동-배치>6장 자동 배치</a></li></ul></li><li><a href=#2부-행동-패턴>2부 행동 패턴</a><ul><li><a href=#7장-배치-잡>7장 배치 잡</a></li><li><a href=#8장-주기적-잡>8장 주기적 잡</a></li><li><a href=#9장-데몬-서비스>9장 데몬 서비스</a></li><li><a href=#10장-싱글톤-서비스>10장 싱글톤 서비스</a></li><li><a href=#11장-스테이트풀-서비스>11장 스테이트풀 서비스</a></li><li><a href=#12장-서비스-디스커버리>12장 서비스 디스커버리</a></li><li><a href=#13장-자기-인식>13장 자기 인식</a></li></ul></li><li><a href=#3부-구조-패턴>3부 구조 패턴</a><ul><li><a href=#14장-초기화-컨테이너>14장 초기화 컨테이너</a></li><li><a href=#15장-사이드카>15장 사이드카</a></li><li><a href=#16장-어댑터>16장 어댑터</a></li><li><a href=#17장-앰배서더ambassador>17장 앰배서더(Ambassador)</a></li></ul></li><li><a href=#4부-설정-패턴>4부 설정 패턴</a><ul><li><a href=#18장-envvar-설정>18장 EnvVar 설정</a></li><li><a href=#19장-설정-자원>19장 설정 자원</a></li><li><a href=#20장-불변-설정>20장 불변 설정</a></li><li><a href=#21장-설정-템플릿>21장 설정 템플릿</a></li></ul></li><li><a href=#5부-고급-패턴>5부 고급 패턴</a><ul><li><a href=#22장-컨트롤러>22장 컨트롤러</a></li><li><a href=#23장-오퍼레이터>23장 오퍼레이터</a></li><li><a href=#24장-탄력적스케일>24장 탄력적스케일</a></li><li><a href=#25장-이미지-빌더>25장 이미지 빌더</a></li></ul></li><li><a href=#다읽은-후기>다읽은 후기</a></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><ul><li>책 내용 정리 및 공식 문서와 비교하며 버전 확인</li></ul><h3 id=1장-개요>1장 개요</h3><h4 id=클라우드-네이티브로-가는길>클라우드 네이티브로 가는길</h4><ul><li>클린코드</li><li>도메인 주도 설계</li><li>마이크로서비스 아키텍처 방식</li><li>컨테이너</li></ul><h4 id=분산-기본-요소>분산 기본 요소</h4><table><thead><tr><th>개념</th><th>로컬 기본 요소</th><th>분산 기본 요소</th></tr></thead><tbody><tr><td>캡슐화 동작</td><td>클래스</td><td>컨테이너 이미지</td></tr><tr><td>인스턴스화 동작</td><td>객체</td><td>컨테이너</td></tr><tr><td>재사용 단위</td><td>Jar 파일</td><td>컨테이너 이미지</td></tr><tr><td>컴포지션</td><td>포함 관계</td><td>사이드카 패턴</td></tr><tr><td>상속</td><td>확장 관계</td><td>FROM 으로 부모 이미지 상속</td></tr><tr><td>배포 단위</td><td>.jar/.war/.ear</td><td>pod</td></tr><tr><td>빌드타임/런타임 격리</td><td>모듈, 패키지, 클래스</td><td>namespace, pod, container</td></tr><tr><td>초기화 필요조건</td><td>Constructor</td><td>초기화 컨테이너</td></tr><tr><td>초기화 직 후 트리거</td><td>Init method</td><td>postStart</td></tr><tr><td>삭제 직전 트리거</td><td>Destroy method</td><td>preStop</td></tr><tr><td>정리 절차</td><td>finalize(), shutdown hook</td><td>Defer 컨테이너</td></tr><tr><td>비동기 & 병렬 칫행</td><td>ThreadPoolExecutor, ForkJoinPool</td><td>Job</td></tr><tr><td>주기적 작업</td><td>Timer, ScheduleExecutorService</td><td>CronJob</td></tr><tr><td>백그라운드 작업</td><td>Deamon Thread</td><td>DeamonSets</td></tr><tr><td>설정관리</td><td>System.getenv(), Properties</td><td>ConfigMap, Secret</td></tr></tbody></table><h4 id=컨테이너>컨테이너</h4><ul><li>컨테이너 이미지는 하나의 문제를 해결하는 기능 단위다.</li><li>컨테이너 이미지는 하나의 팀에 의해 소유되며, 릴리즈 주기가 있다.</li><li>컨테이너 이미지는 자기 완비적이며, 런타임 의존 성을 정의하고 수행한다.</li><li>컨테이너 이미지는 불변적이며, 한번 만들어지면 변경되지 않는다. 즉 이미 설정 값이 정해져 있다.</li><li>컨테이너 이미지는 런타임 의존성과 자원 요구사항이 정의되어 있다.</li><li>컨테이너 이미지는 기능을 노출시키기 위해 잘 정의된 API가 있다.</li><li>컨테이너는 일반적으로 하나의 유닉스 프로세스로 실행된다.</li><li>컨테이너는 일회용이며 언제든지 스케일 업과 스케일 다운을 안전하게 수행할 수 있다.</li></ul><h4 id=파드>파드</h4><ul><li>파드는 스케줄링의 최소 단위이다.</li><li>파드는 파드에 속한 컨테이너들의 동일 장소 배치를 보장한다.</li><li>한 파드는 파드 안의 모든 컨테이너가 공유하는 하나의 IP 주소와 이름, 포트 범위를 갖는다.</li></ul><h4 id=서비스>서비스</h4><ul><li>서비스는 애플리케이션에 접근하기 위한 이름으로 된 진입점이다.</li></ul><h4 id=레이블>레이블</h4><ul><li>레이블은 실행 중인 특정 파드의 인스턴스들을 가리키기 위해 사용된다.</li><li>레이블은 스케줄러에서 많이 사용된다.</li><li>레이블은 파드를 논리적 그룹으로 묶어 가리킬 수 있다.</li><li>미리 앞서서 레이블을 추가하지 않아야한다. 레이블 삭제가 어떤 영향을 일으키는지 알아낼 방법이 없다.</li></ul><h4 id=어노테이션>어노테이션</h4><ul><li>레이블과 유사한 기능을 하지만, 사람보다는 봇을 위한 용도로 사용된다.</li><li>검색 불가능한 메타데이터를 지정하는데 사용한다.</li></ul><h4 id=네임스페이스>네임스페이스</h4><ul><li>네임스페이스는 쿠버네티스 자원으로서 관리된다.</li><li>네임스페이스는 컨테이너, 파드, 서비스, 레플리카세트 등의 자원에 대한 영역을 제공한다.</li><li>네임스페이스 내에서 자원명은 고유해야한다.</li><li>네임스페이스는 격리시키는 것이 아니므로 자원간 접근을 막을수는 없다.</li><li>노드, PersistentVolume 등은 네임스페이스 내에 속하지 않는다.</li><li>서비스는 <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code> 형식의 dns address 를 갖는다.</li><li>ResourceQuota는 네임스페이스 별로 제약조건을 걸 수 있다.</li></ul><h2 id=1부-기본-패턴>1부 기본 패턴</h2><h3 id=2장-예측-범위-내의-요구사항>2장 예측 범위 내의 요구사항</h3><ul><li>애플리케이션의 요구사항에 따라서 필요한 자원량은 달라지며, 이를 예측하는 것은 어려운 일이다.</li><li>쿠버네티스를 사용하면서 런타임 요구사항을 알아야하는 이유:<ul><li>효율적인 하드웨어 사용을 위한 배치</li><li>전체 클러스터 설계 및 관리</li></ul></li></ul><h4 id=런타임-의존성>런타임 의존성</h4><ul><li>PersistentVolume</li><li>hostPort</li><li>configMap, secret</li></ul><h4 id=자원-프로파일>자원 프로파일</h4><ul><li>compressible resource : cpu, network</li><li>incompressible resource : memory</li><li>incompressible resource를 너무 많이 사용할 경우 컨테이너가 죽게 된다.</li><li>requests, limits 에 따른 서비스 구분:<ul><li>Best-Effort:<ul><li>requests, limits 를 갖고 있지 않다.</li><li>incompressible resource가 모자랄때, 가장 먼저 죽는다.</li></ul></li><li>Burstable:<ul><li>requests와 limits 가 다르다. (일반적으로 limits 가 requests 보다 크다.)</li></ul></li><li>Guaranteed:<ul><li>requests와 limts가 같다.</li><li>가장 나중에 죽는다.</li></ul></li></ul></li></ul><h4 id=파드-우선순위>파드 우선순위</h4><ul><li>책의 내용과 살짝 다르다. k8s v1.24 문서를 기준으로 작성되었다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>scheduling.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PrioirtyClass</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>high-priority</span>
</span></span><span style=display:flex><span><span style=color:#f92672>value</span>: <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>globalDefault</span>: <span style=color:#ae81ff>flase</span>
</span></span><span style=display:flex><span><span style=color:#f92672>description</span>: <span style=color:#e6db74>&#34;This is a very high priority Pod class&#34;</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>env</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/random-generator:1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>priorityClassName</span>: <span style=color:#ae81ff>high-prioirty</span>
</span></span></code></pre></div><h4 id=프로젝트-자원>프로젝트 자원</h4><ul><li>추가 참고자료 : <a href=https://hakkyoonjung31.github.io/linux/memory-overcommit/>메모리 상승과 오버커밋</a></li><li>메모리 오버커밋 : 요구된 메모리를 그대로 할당하는 것이 아닌 실제 사용되는 시점에서 필요한 만큼의 메모리를 할당하는 방식에 의해 요구되는 메모리의 총량이 100%를 넘기는 경우</li><li>오버 커밋 상태에서 실제 메모리 사용 총량이 메모리 총량을 넘기게 될 수도 있는데, 이때 OOM-Killer에 의해 프로세스들을 죽여서 용량을 확보하게 된다.</li><li>개인 해석:<ul><li>오버커밋에 의해 요청된 메모리와 사용하는 메모리는 차이가 날 수 있다.</li><li>즉 requests는 250M를 하는데, pod에서 오버커밋을 이용해 500M를 할당하고, 사용은 200M를 하고 있는 상황같은게 발생 할 수 있다는 것이다.</li><li>kubernetes 는 기본적으로 requests 를 기준으로 스케줄링한다.</li></ul></li></ul><h3 id=3장-선언적-배포>3장 선언적 배포</h3><ul><li>선언적 업데이트를 작동시키기 위한 옵션:<ul><li><code>kubectl replace</code>로 새로운 버전의 deployment로 전체 deployment를 교체한다.</li><li>deployment를 <code>kubectl patch</code> 나 <code>kubectl edit</code>으로 새로운 버전을 넣는다.</li><li><code>kubectl set image</code> 을 통해서 deployment에 새로운 이미지를 넣는다.</li></ul></li><li>deployment 의 장점:<ul><li>deployment는 상태가 내부적으로 관리되는 객체이므로 클라이언트와 상호작용 없이, 서버측에서 실행된다.</li><li>deployment 의 선언적 특성은 배포에 필요한 단계보다는 배포된 상태가 어떻게 보여야하는지를 알 수 있다.</li><li>deployment의 정의는 운영 환경에 배포되기 전에 다양한 환경에서 테스트된 실행 가능한 객체이다.</li><li>업데이트 프로세스는 모두 기록되며, 일시 중지 및 계속을 위한 옵션, 이전 버전으로 롤백을 위한 옵션으로 버전이 지정된다.</li></ul></li></ul><h4 id=고정-배포>고정 배포</h4><ul><li>Recreate 전략:<ul><li>우선적으로 현재 버전의 모든 컨테이너를 죽이고, 이전 버전의 컨테이너가 축출될때 모든 신규 컨테이너를 동시에 시작한다.</li></ul></li></ul><h4 id=블루-그린>블루-그린</h4><ul><li>블루(이전 버전), 그린(현재 버전)</li><li>블루와 그린을 모두 띄운뒤 신규 트래픽을 그린으로 보낸뒤, 기존 트래픽을 다 처리하면 블루를 삭제한다.</li><li>블루와 그린이 순간적으로 동시에 뜨게 된다.</li><li>즉, 자원이 2배로 필요하다.</li></ul><h4 id=카나리아>카나리아</h4><ul><li>소수의 인스턴스를 교체하면서 동작한다.</li></ul><h3 id=4장-정상상태-점검>4장 정상상태 점검</h3><ul><li>프로세스 상태는 애플리케이션의 정상상태를 결정하기에는 충분하지 않다.</li></ul><h4 id=liveness-probe>Liveness probe</h4><ul><li><p>HTTP : 200~399 사이 응답코드</p></li><li><p>TCP : 성공적인 TCP connection</p></li><li><p>Exec : 성공적인 종료코드(0)</p></li><li><p>한번쯤은 yaml을 써보는게 도움이 될거 같아서 써본다. 실제로는 문서를 참고해서 작성할것</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pod-with-liveness-check</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/random-generator:1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>DELAY_STARTUP</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;20&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/actuator/health</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>30</span>
</span></span></code></pre></div><h4 id=readiness-probe>Readiness probe</h4><ul><li>liveness와는 다르게 readiness probe 이 실패할 경우, service의 endpoint가 제거되어 새로운 트래픽을 수신할 수 없게 된다.</li></ul><h4 id=others>Others</h4><ul><li>spring actuator, wide-fly swarm, karaf, microprofile spec 등 애플리케이션 프레임워크는 정상상태 점검을 위한 인터페이스를 제공한다.</li><li>로그는 표준스트림 이외에도 <code>/dev/termination-log</code> 에 남기는 것이 좋다.</li><li>OpenTracing이나 Prometheus 같은 트레이싱, 메트릭 수집 라이브러리와 통합하여 어플리케이션 상태를 관찰할 수 있도록 해야한다.</li></ul><h3 id=5장-수명주기-관리>5장 수명주기 관리</h3><ul><li>k8s는 컨테이너를 종료시킬때, SIGTERM을 먼저, 그 다음 <code>.spec.terminationGracePeriodSeconds</code> 의 유예시간 이후 SIGKILL을 발생시킨다.</li><li>postStart, preStop 훅</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metatdata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hooks</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/random-generator:1.0</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>lifecycle</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>postStart</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>exec</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>sh</span>
</span></span><span style=display:flex><span>        - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>sleep 30 &amp;&amp; echo &#34;Wake up!&#34; &gt; /tmp/postStart_done</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>preStop</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/shutdown</span>
</span></span></code></pre></div><ul><li>수명주기 훅과 초기화 컨테이너</li></ul><table><thead><tr><th>측면</th><th>수명주기 훅</th><th>초기화 컨테이너</th></tr></thead><tbody><tr><td>활성화 단계</td><td>컨테이너 수명주기 단계</td><td>파드 수명주기 단계</td></tr><tr><td>시작 단계 동작</td><td>postStart 명령어</td><td>실행될 초기화 컨테이너 목록</td></tr><tr><td>종료 단계 동작</td><td>preStop 명령어</td><td>X</td></tr><tr><td>타이밍(Timing) 보장</td><td>postStart 명령은 컨테이너의 ENTRYPOINT 와 동시에 실행</td><td>애플리케이션 컨테이너가 시작되기 전에 모든 초기화 컨테이너는 성공적으로 종료가 완료되어야 한다.</td></tr><tr><td>사용 사례</td><td>컨테이너별로 트고하된 중요하지 않은 시작/정리 종료를 실행</td><td>컨테이너를 사용해 워크플로우 같은 순차적 작업을 수행. 작업 실행을 위해 컨테이너를 재사용</td></tr></tbody></table><h3 id=6장-자동-배치>6장 자동 배치</h3><ul><li>가용한 노드 자원:<ul><li>Allocatable = Node Capacity - Kube-Reserved - System-Reserved</li><li>Kube-Reserved : 쿠버네티스 데몬에 의해 사용되는 자원</li><li>System-Reserved : sshd, udev 와 같은 시스템 데몬에 사용되는 자원</li><li>OS와 Kubernetes가 사용하는 자원을 따로 예약해두지 않으면 자원 부족 문제가 생길 수 있다.</li></ul></li></ul><h4 id=node-affinity>Node Affinity</h4><ul><li><code>.spec.affinity.nodeAffinity</code> 를 통해서 선호 조건, 필수 조건을 걸 수 있다.</li></ul><h4 id=pod-affinity>Pod Affinity</h4><ul><li>다른 파드와 상대적인 위치</li></ul><h4 id=taint-와-toleration>Taint 와 Toleration</h4><ul><li>taint 종류:<ul><li><code>effect=NoSchedule</code> : 스케줄링을 피하는</li><li><code>effect=PreferNoSchdule</code> : 가급적 스케줄링을 피하는</li><li><code>effect=NoExecute</code> : 이미 실행중인것을 빼도록</li></ul></li></ul><h4 id=descheduler>Descheduler</h4><ul><li>처음 들어본 개념이라 좀 찾아봤는데, 기본적으로 지원하는 건 아니고 추가적으로 deployment 형태로 설치해야하는 것 같다.</li><li><a href=https://github.com/kubernetes-sigs/descheduler>공식사이트</a> 에서는 helm 이나 다른 방법으로 설치하는 것도 안내해주고 있다.</li><li>Scheduler 만으로는 앞으로 Balance 하는것을 만드는 거지, 이미 배포된 것들에 대해서 처리하지 못하기 때문에 사용한다.</li><li>전략 종류:<ul><li>RemoveDuplicates, LowNodeUtilization, RemovePodsViolatingInterPodAntiAffinity, RemovePodsViolatingNodeAffinity</li></ul></li><li>Descheduler가 건들이지 않는 Pod:<ul><li>Replicaset, Deployment, Job, DeamonSet에 의해서 관리되지 않는 파드</li><li>local storage을 갖는 pod</li><li>PodDisruptionBudget 규칙에 위배되는 Pod</li><li>Deschdeduler 파드</li></ul></li></ul><h2 id=2부-행동-패턴>2부 행동 패턴</h2><h3 id=7장-배치-잡>7장 배치 잡</h3><ul><li><p>잡의 특징:</p><ul><li>잡은 일시적인 인메모리 작업이 아니라, 클러스터 재시작에도 살아남는 지속된 작업이다.</li><li>잡은 완료되고 나면, 삭제되지 않고 추적 목적으로 유지된다. 잡의 일부분으로 생성된 파드도 삭제되지 않으며 검사가 가능하다.</li><li>잡은 여러번 실행되어야 할 수 있다. (<code>.spec.completions</code> 항목 참조)</li><li>잡이 여러번 실행되어야하는 경우 동시에 실행할 수도 있다. (<code>.spec.parallelism</code> 항목 참조)</li><li>Pod 가 실행 중인 동안 노드에 장애가 되거나 어떠한 이유로 Pod가 extract 되었을 때, Scheduler 는 Pod를 재배치 후 실행한다.</li></ul></li><li><p>잡의 종류:</p><ul><li>단일 파드 잡(Single Pod Job):<ul><li><code>.spec.comletions</code> 와 <code>.spec.parallelism</code> 값을 생략 또는 모두 1로 세팅</li></ul></li><li>고정 완료 횟수 잡(Fixed completion count Job):<ul><li><code>.spec.completions</code> 은 1보다 크게, <code>.spec.parallelism</code> 은 1로 세팅</li></ul></li><li>작업 큐 잡(Work queue Job):<ul><li><code>.spec.completions</code> 은 생략, <code>.spec.parllelism</code> 은 1보다 크게 세팅</li></ul></li></ul></li><li><p>복잡한 작업은 batch application framework(e.g. Spring Batch, JBeret) 으로 실행</p></li></ul><h3 id=8장-주기적-잡>8장 주기적 잡</h3><ul><li>책에 있는 내용은 v1beta1 이지만, 현재(v1.24) 에서는 v1 이다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>CronJob</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>schedule</span>: <span style=color:#e6db74>&#34;*/3 * * * *&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>jobTemplate</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/random-generator:1.0</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>            - <span style=color:#e6db74>&#34;java&#34;</span>
</span></span><span style=display:flex><span>            - <span style=color:#e6db74>&#34;-cp&#34;</span>
</span></span><span style=display:flex><span>            - <span style=color:#e6db74>&#34;/&#34;</span>
</span></span><span style=display:flex><span>            - <span style=color:#e6db74>&#34;RandomRunner&#34;</span>
</span></span><span style=display:flex><span>            - <span style=color:#e6db74>&#34;/numbers.txt&#34;</span>
</span></span><span style=display:flex><span>            - <span style=color:#e6db74>&#34;10000&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>OnFailure</span>
</span></span></code></pre></div><ul><li><p>주의사항:</p><ul><li>CronJob은 특정 상황에서 여러 잡을 생성할 수 있다. 따라서 Job은 멱등성(idempotent)을 지니도록 구성해야한다.</li><li>v1 CronJob API 는 타임존 설정을 공식적으로 지원하지 않는다. 이는 내부 라이브러리가 어떻게 구현되었는 가에 따라서 다르게 동작할 수 있다. 즉, 프로덕션 레벨에서는 사용이 권장되지 않는다.</li><li>CronJob 은 kube-controller-manager 의 시간대를 기준으로 한다.</li></ul></li><li><p>개인 생각:</p><ul><li>시간대별로 필요한거면, 복잡한 Job에 해당한다고 생각한다. Spring Batch를 사용하는게 옳지 않나 싶다.</li></ul></li></ul><h3 id=9장-데몬-서비스>9장 데몬 서비스</h3><ul><li><p>DeamonSet 의 특징:</p><ul><li>nodeSelector를 통해 제한하지 않는한, 모든 노드에 하나의 Pod가 배치된다.</li><li>DeamonSet 에 의해 생성된 Pod은 생성된 시점에 nodeName을 가진다. 따라서 Scheduler에 의해 배치 되지 않는다. 이는 Scheduler와 상관 없이 실행되며, Scheduler에 의해 Pod들이 배치 되기 전에 실행할 수 있다는 것을 의미한다.</li><li>대부분의 컨트롤러는 DeamonSet에 의해 생성된 Pod를 더 높은 우선순위로 별개 취급한다.</li></ul></li><li><p>DeamonSet 에 의해 생성되는 대표적인 오브젝트들:</p><ul><li>Service</li><li>DNS</li><li>NodeIP with hostPort</li><li>Push</li></ul></li><li><p>Static Pod 와 비교:</p><ul><li>Static Pod 는 Kubelet에 의해서만 관리되며, controller는 없고 health check 를 실행하지 않는다. 이 모든 것이 kubelet에 의해서만 관리된다.</li></ul></li></ul><h3 id=10장-싱글톤-서비스>10장 싱글톤 서비스</h3><h4 id=애플리케이션-외부-잠금>애플리케이션 외부 잠금</h4><ul><li>어플리케이션 외부에서 별도의 관리 프로세스를 통해서 싱글톤을 구현하는 방법</li><li>replica set으로 구현할 경우 replicas 숫자를 1로 유지한다는 보장이 없으므로 별도의 주의가 필요하다.</li><li>일시적으로 node가 비정상 상태일 경우, 새롭게 Pod 가 생성되는데, 이때 비정상이였던 node가 살아나면 싱글톤 보장이 깨진다.</li><li>StatefulSet 을 사용해 구현할 경우, 강력하게 싱글톤 제약을 걸 수 있지만 복잡성 또한 증가한다.</li><li>이렇게 StatefulSet 을 사용해 Singleton 서비스를 구성하면, Headless Service 를 사용해 묶어야한다.:<ul><li>책의 이 부분이 이해하기 어려운데, <a href=https://bcho.tistory.com/1310>참고자료 - 조대협의 블로그</a> 를 읽어보면 이해가 쉽다.</li><li>간략하게 요약하면, statfuleset 으로 만들어진 pod 같은 경우, 굳이 service를 통해서 접근할 필요가 없다. 하지만 service 가 없다면, pod 는 domain name을 가질수 없어 접근이 어렵다. 따라서 headless service 를 통해 pod를 묶기만 하고 접근은 pod로 한다.</li></ul></li></ul><h4 id=애플리케이션-내부-잠금>애플리케이션 내부 잠금</h4><ul><li>distributed lock 을 활용하여 pod 가 여러개 뜨더라도 하나의 pod 만 active 상태로 만든다.</li><li>distributed lock 을 위하여 zookeeper, redis, etcd 등 이러한 내용이 구현되어 있는 프로그램 또는 프레임 워크가 필요하다.</li><li>k8s 에서는 master node 의 etcd 를 kubernetes api 를 통해서 노출하고 사용하는 편이 좋은 선택이다.:<ul><li>또한 이렇게 하는 것이 아닌 configmap 이 동시에 하나의 pod만 수정 가능하다는 것을 이용하여 분산락을 대체해서 사용하는 방법도 있다.</li></ul></li></ul><h4 id=poddisruptionbudget>PodDisruptionBudget</h4><ul><li>일정 비율의 파드가 임의의 한 시점에 노드에서 자발적으로 축출되지 않게 보장한다.</li><li>관련해서 책에서는 v1beta1 이지만 kubernetes v1.24 기준, v1 버전을 지원한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>policy/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PodDistruptionBudget</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator-pdb</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>minAvailable</span>: <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><ul><li><code>.spec.minAvailable</code>, <code>spec.maxUnavilable</code> 중에 하나만 사용가능하다.</li></ul><h3 id=11장-스테이트풀-서비스>11장 스테이트풀 서비스</h3><ul><li><p>[[Twelve-Factor-App]]</p></li><li><p>Stateful 한 자원 : Storage, Networking, Identifier</p></li><li><p>기본 예제에 꽤나 직관적으로 특징을 알아볼수 있어서 기재</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StatefulSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>rg</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceName</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/random-generator:1.0</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>http</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>logs</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/logs</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumeClaimTemplates</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>logs</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>accessModes</span>: [ <span style=color:#e6db74>&#34;ReadWriteOnce&#34;</span> ]
</span></span><span style=display:flex><span>      <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Mi</span>
</span></span></code></pre></div><ul><li>Scale 이 증가할 때는 pvc 가 자동생성, Scale이 감소할 때는 pvc 가 삭제되지 않는다. (데이터 보존을 위해)<ul><li>만약 PV 재사용을 원한다면 직접 pvc 삭제</li></ul></li></ul><h4 id=네트워크>네트워크</h4><ul><li>Headless Service 로 관리:<ul><li>DNS 생성을 위해서</li><li>단순히 묶기위한 객체</li></ul></li></ul><h4 id=순서성>순서성</h4><ul><li>Pod 생성 순서가 Scale에 의해서 생긴 순서를 보장한다.</li><li>내려갈때도 그 순서가 보장된다.</li></ul><h4 id=개인적인-궁금점>개인적인 궁금점</h4><ul><li>StatefulSet 에서 Durability는 어떻게 보장되지? Node가 죽으면 어떻게 동작하는지 잘 모르겠다.:<ul><li><a href=https://medium.com/tailwinds-navigator/kubernetes-tip-how-statefulsets-behave-differently-than-deployments-when-node-fails-d29e36bca7d5>Kubernetes Tip: How Statefulsets Behave Differently Than Deployments When Node Fails?</a></li><li>위 글에서 꽤나 상세한 설명을 하고 있다. 하지만 그렇게 와닿지는 않아서 나중에 시간될때 kind로 cluster 간략하게 구성해서 테스트 해봐야할것 같다.</li></ul></li></ul><h4 id=기타-기능>기타 기능</h4><ul><li>분할 업데이트</li><li>병렬 배포</li><li>at-most-one 보장</li></ul><h3 id=12장-서비스-디스커버리>12장 서비스 디스커버리</h3><ul><li>proxy 레이어를 둬서 application이 간접적으로 service registry 를 참조하는 구조</li></ul><h4 id=내부-디스커버리>내부 디스커버리</h4><ul><li>Service 객체를 사용하는 방법:<ul><li>환경 변수를 통한 방법:<ul><li>환경변수를 참조하도록 어플리케이션 개발, 환경변수 주입</li></ul></li><li>DNS 참조를 통한 디스커버리</li><li>다중 포트</li><li>세션 어피니티</li><li>레디니스 점검</li><li>가상 IP:</li><li>ClusterIP 선택:<ul><li><code>.spec.clusterIP</code>를 사용</li></ul></li></ul></li></ul><h4 id=수동-서비스-디스커버리>수동 서비스 디스커버리</h4><ul><li>Endpoint를 직접 만든다.</li><li>ExternalName을 사용하는 Service</li></ul><h4 id=클러스터-외부의-서비스-디스커버리>클러스터 외부의 서비스 디스커버리</h4><ul><li>외부에 서비스를 노출하는 방법:<ul><li>nodePort 등으로 외부에 서비스를 노출, 이를 외부 서비스 디스커버리로 참조</li><li>LoadBalancer를 사용</li><li>Headless service 이용</li></ul></li></ul><h4 id=어플리케이션-계층-서비스-디스커버리>어플리케이션 계층 서비스 디스커버리</h4><ul><li>ingress를 활용하여 만든다.</li></ul><h4 id=개인생각>개인생각</h4><ul><li>이 책을 쓰는 시점에는 Istio가 서비스디스커버리의 메타가 아니라서 이런 여러 방법을 소개함에도 소개가 되지 않은 것 같다.</li><li>물론 어떤 관점에서 본다면 ingress의 일종이라고 여길수 있겠지만, istio 는 envoy를 활용하여 더 많은 메커니즘이 있다.</li><li>서비스 디스커버리에 대해서는 istio를 추가로 공부하자.</li></ul><h3 id=13장-자기-인식>13장 자기 인식</h3><ul><li><a href=https://kubernetes.io/ko/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>Downward API 공식문서</a></li><li>Downward API 는 자신에 대한 정보를 환경변수, 볼륨의 형태로 제공할 수 있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubernetes-downwardapi-volume-example</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>zone</span>: <span style=color:#ae81ff>us-est-coast</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cluster</span>: <span style=color:#ae81ff>test-cluster1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>rack</span>: <span style=color:#ae81ff>rack-22</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>two</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>builder</span>: <span style=color:#ae81ff>john-doe</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>client-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8s.gcr.io/busybox</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;sh&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>]
</span></span><span style=display:flex><span>      <span style=color:#f92672>args</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>while true; do</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>if [[ -e /etc/podinfo/labels ]]; then</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>echo -en &#39;\n\n&#39;; cat /etc/podinfo/labels; fi;</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>if [[ -e /etc/podinfo/annotations ]]; then</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>echo -en &#39;\n\n&#39;; cat /etc/podinfo/annotations; fi;</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>sleep 5;</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>done;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>podinfo</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/etc/podinfo</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>podinfo</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>downwardAPI</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>items</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>path</span>: <span style=color:#e6db74>&#34;labels&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>metadata.labels</span>
</span></span><span style=display:flex><span>          - <span style=color:#f92672>path</span>: <span style=color:#e6db74>&#34;annotations&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>metadata.annotations</span>
</span></span></code></pre></div><h2 id=3부-구조-패턴>3부 구조 패턴</h2><h3 id=14장-초기화-컨테이너>14장 초기화 컨테이너</h3><ul><li>초기화 컨테이너가 실패하면, 전체 파드는 다시 시작되고, 모든 초기화 컨테이너도 다시 실행된다</li><li>초기화 컨테이너 이외의 초기화 기법:<ul><li>admission controller</li><li>admission webhook</li><li>initializer</li><li>PodPreset</li></ul></li></ul><h3 id=15장-사이드카>15장 사이드카</h3><ul><li>일반적으로 서비스의 네트워킹, 모니터링, 트레이싱에 쓰인다.</li><li>관점지향 프로그래밍과 유사</li></ul><h3 id=16장-어댑터>16장 어댑터</h3><ul><li>application 이 쓰는 log의 형태가 모니터링할때 원하는 형태와 다를때 사용할 수 있다.</li><li>일종의 사이드카</li></ul><h3 id=17장-앰배서더ambassador>17장 앰배서더(Ambassador)</h3><ul><li>application 에서 외부에 접근할때, 외부 복잡성을 숨기고 간단하게 접근하도록 할수 있다.</li><li>cache, circuit-breaker 등에 활용 될 수 있다.</li><li>일종의 사이드카</li></ul><h2 id=4부-설정-패턴>4부 설정 패턴</h2><h3 id=18장-envvar-설정>18장 EnvVar 설정</h3><ul><li>한눈에 여러개 설정을 볼수 있어서 yaml을 기재</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/random-generator:1.0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>LOG_FILE</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>value</span>: <span style=color:#ae81ff>/tmp/random.log</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>PATTERN</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>configMapKeyRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator-config</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>key</span>: <span style=color:#ae81ff>pattern</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>SEED</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>secretKeyRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator-secret</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>key</span>: <span style=color:#ae81ff>seed</span>
</span></span></code></pre></div><ul><li>시작하고나서는 변수를 변경할수 없어, 변경을 원할경우 재시작을 해야한다.:<ul><li>port, db connection configuration 등에 적합</li></ul></li></ul><h3 id=19장-설정-자원>19장 설정 자원</h3><ul><li>volume 으로 mount 하면 변경이 반영된다.</li><li>Secret 의 특징:<ul><li>자신에게 접근하는 파드가 실행 중인 노드에만 배포된다.</li><li>노드에서 시크릿은 tmpfs의 메모리에 저장되며, 실제 스토리지에는 기록되지 않고 파드가 제거될 때 함께 제거된다.</li><li>etcd에 암호화된 형태로 저장된다.</li></ul></li><li>configmap 과 secret 에는 자원 제약이 있으므로 무분별하게 사용해서는 안된다.</li></ul><h3 id=20장-불변-설정>20장 불변 설정</h3><ul><li>불변 설정 패턴에 데이터 컨테이너를 사용하는 것은 다소 복잡하지만 아래 장점이 있다.:<ul><li>환경별 설정은 컨테이너 안에 있으므로, 여타 컨테이너 이미지처럼 버전을 지정할 수 있다.</li><li>이런 방식으로 생성된 설정은 컨테이너 레지스트리를 통해 배포될 수 있고, 클러스터에 접근하지 않아도 설정을 확인할 수 있다.</li><li>컨테이너 이미지 안에 이쓴 설정을 직접 변경할 수는 없다. 설정을 변경하려면 버전을 업데이트한 새로운 컨테이너 이미지가 필요하다.</li><li>설정 데이터 이미지는 설정 데이터가 너무 복잡해 환경 변수나 컨피그맵에 넣을 수 없을 때 유용하다. 임의의 대규모 설정 데이터를 수용할 수 있기 때문이다.</li></ul></li><li>단점:<ul><li>레지시트리를 통해 추가 컨테이너 이미지를 빌드하고 배포해야 하므로, 복잡성이 더 높다.</li><li>민감한 설정 데이터를 처리하는 보안 문제에는 아무런 대책이 없다.</li><li>쿠버네티스의 경우 별도의 초기화 컨테이너 처리가 필요하므로, 환경에 따라 다른 디플로이먼트 객체를 관리해야 한다.</li></ul></li></ul><h3 id=21장-설정-템플릿>21장 설정 템플릿</h3><ul><li>어플리케이션이 시작되기 전에 설정 파일을 세팅하는 방법:<ul><li>템플릿 처리기를 ENTRYPOINT의 일부로 Dockerfile에 추가해서, 탬플릿 처리를 컨테이너 이미지에 포함시킬 수 있다.</li><li>쿠버네티스의 경우 템플릿 처리기가 실행되고 파드의 어플리케이션 컨테이너에 대한 설정을 만드는 초기화 컨테이너를 사용할수 있다.</li></ul></li><li>모든 내용을 다 볼 필요는 없고, 아래 yaml 만 읽어도 대충은 어떻게 설정할지 보여서 yaml만 기재</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>extensions/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>example</span>: <span style=color:#ae81ff>cm-template</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>widfly-cm-template</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>example</span>: <span style=color:#ae81ff>cm-template</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>initContainers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8spatterns/example-config-cm-template-init</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>init</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#e6db74>&#34;/params&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>wildfly-parameters</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#e6db74>&#34;/out&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>widfly-config</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>jboss/wildfly:10.1.0.Final</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>server</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>        - <span style=color:#e6db74>&#34;/opt/jboss/wildfly/bin/standalone.sh&#34;</span>
</span></span><span style=display:flex><span>        - <span style=color:#e6db74>&#34;-Djboss.server.config.dir=/config&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>http</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#e6db74>&#34;/config&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>wildfly-config</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>wildfly-parameters</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>configMap</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>name</span>: <span style=color:#ae81ff>wildfly-parameters</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>wildfly-config</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>emptyDir</span>: {}
</span></span></code></pre></div><h2 id=5부-고급-패턴>5부 고급 패턴</h2><h3 id=22장-컨트롤러>22장 컨트롤러</h3><ul><li><p>reconciliation 과정:</p><ul><li>observe : 관측하고 있는 자원이 변경될 때 쿠버네티스가 배포하는 이벤트를 watch 하여 actual state를 찾는다.</li><li>analyze : 실제 상태와 요청한 상태의 차이를 알아낸다.</li><li>act : 실제 상태가 요청한 상태로 구동되도록 작업을 수행한다.</li></ul></li><li><p>reconciliation components:</p><ul><li>controller : 표준 쿠버네티스 자원을 모니터링하고 작동하는 간단한 reconciliation process.</li><li>operator: CRD와 연동.</li></ul></li><li><p>컨트롤러는 Singletone Service 로 동작하여 동시성 문제를 방지한다.</p></li><li><p>controller 데이터를 저장할수 있는 위치:</p><ul><li>label:<ul><li>자원 메타데이터의 일부인 label은 모든 컨트롤러에서 watch할 수 있으며, backend database 에서 indexing 되어 효율적인 쿼리검색이 가능하다.</li><li>selector 를 사용하기 위해서는 반드시 label을 사용해야한다.</li><li>label은 허용된 구문과 문자 집합이 따로 있다.</li></ul></li><li>annotation:<ul><li>label을 대체할 자원</li><li>색인되지 않는다.</li></ul></li><li>configmap:<ul><li>configmap 보다는 CRD가 더 권장되지만, CRD는 클러스터 권한이 더 높게 요구된다.</li></ul></li></ul></li><li><p>책에는 추가적인 다른 내용도 있긴하지만, deprecated 된 내용도 있어서 이정도만 알면 될것 같다.</p></li></ul><h3 id=23장-오퍼레이터>23장 오퍼레이터</h3><ul><li><p>CRD 에는 특별한 두가지 자원이 존재한다.:</p><ul><li>scale: 이 속성을 사용하면 CRD 에서 replica 수를 관리하는 방법을 지정할 수 있다. HorizontalPodAutoscaler를 사용한다면 필수로 지정되어야한다.</li><li>status: 외부에서 상태를 업데이트 할 수 있다.</li></ul></li><li><p>컨트롤러와 오퍼레이터 분류:</p><ul><li>설치 CRD:<ul><li>쿠버네티스 플랫폼에서 애플리케이션을 설치하고 운영하는 데 사용된다. 일반적인 예로 프로메테우스 자체를 설치하고 관리하는 프로메테우스 CRD가 있다.</li></ul></li><li>어플리케이션 CRD:<ul><li>어플리케이션별 도메인 컨셉을 나타낼때 사용한다.</li></ul></li></ul></li><li><p>오퍼레이터 개발과 배포에 도움되는 프로젝트들:</p><ul><li>CoreOS Operator Framework</li><li>Kubebuilder</li><li>Metacontroller</li></ul></li></ul><h3 id=24장-탄력적스케일>24장 탄력적스케일</h3><ul><li>HPA 관련</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl autoscale deployment &lt;deployment name&gt; --cpu-percent<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span> --min<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> --max<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>autoscaling/v2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>HorizontalPodAutoscaler</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>minReplicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>maxReplicas</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>scaleTargetRef</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>metrics</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>resource</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>cpu</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>target</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>averageUtilization</span>: <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>type</span>: <span style=color:#ae81ff>Utilization</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>type</span>: <span style=color:#ae81ff>Resource</span>
</span></span></code></pre></div><ul><li><p>metric types:</p><ul><li>standard metrics:<ul><li><code>.spec.metrics.resource[:].type</code> 으로 선언되며 CPU, Memory 등 자원 사용량 메트릭을 나타낸다.</li></ul></li><li>user defined metrics:<ul><li><code>.spec.metrics.resource[:].type</code> 으로 선언되며 클러스터별로 각기 다른 클러스터링 모니터링 설정이 필요하다.</li><li>prometheus, datadog, azure 등등 에서 널리 사용되고 있다.</li></ul></li><li>외부 메트릭:<ul><li>메시지 큐와 같이 외부 서비스에 존재하는 지표를 사용하고 싶을때 사용</li></ul></li></ul></li><li><p>HPA 가 해주는 것들:</p><ul><li>메트릭 선택</li><li>쓰래싱(thrashing) 방지</li><li>지연된 반응</li></ul></li></ul><h4 id=수직-pod-autoscaling>수직 Pod Autoscaling</h4><ul><li>Veritcal Pod Autoscaler (VPA)</li><li>좀 찾아보니까 기본으로 제공되는 건 아닌것 같다. <a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#readme>공식 사이트</a>:<ul><li>이것저것 민감한 이슈들이 많아서 아직까지 beta 상태이다. 글을 쓰는 이 시점에도 19시간 전에 커밋된게 있는 걸로 보아 아직까지 개발중인 것 같다.</li></ul></li><li>책이랑 좀 다르니 공식 사이트를 따르자.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>autoscaling.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>VerticalPodAutoscaler</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app-vpa</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>targetRef</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>apiVersion</span>: <span style=color:#e6db74>&#34;apps/v1&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kind</span>:       <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>:       <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>updatePolicy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>updateMode</span>: <span style=color:#e6db74>&#34;Auto&#34;</span>
</span></span></code></pre></div><h3 id=25장-이미지-빌더>25장 이미지 빌더</h3><ul><li>읽어보니까, 예전에 봤던 면접이 이걸 하라고 했던 것 같다.</li><li>대충 yaml 만 적어둔다. 자세한건 공식 문서를 참고하자.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>BuildConfig</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>runtime</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>source</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>images</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>from</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ImageStreamTag</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator-build:latest</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>sourcePath</span>: <span style=color:#ae81ff>/deployments/.</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>destinationDir</span>: <span style=color:#e6db74>&#34;.&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dockerfile</span>: |-<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      FROM openjdk:8-alpine
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      COPY *.jar /
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      CMD java -jar /*.jar</span>      
</span></span><span style=display:flex><span>  <span style=color:#f92672>strategy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>Docker</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>output</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>to</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ImageStreamTag</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-generator:latest</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>triggers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>imageChange</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>automatic</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>from</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ImageStreamTag</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-gnerator-build:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ImageChange</span>
</span></span></code></pre></div><ul><li>KNative 도 이를 지원한다고 한다. KNative는 조금더 공부해봐야지 알 것 같다.:<ul><li>옮긴이의 말로는 중단되고, Tekton Pipelines 으로 대체되었다고 한다. 이것도 한번 찾아봐야지 알것 같다.</li></ul></li></ul><p>&ndash;</p><h2 id=다읽은-후기>다읽은 후기</h2><ul><li>책을 정리하면서 읽고, 최대한 모르는 건 찾아보면서 읽었으나 아직 잘 모르겠는게 많다.</li><li>실습을 해보면서 익히는게 좋을 것 같다. 책이 좀 되서, 잘 안되는 예제를 몇개 만나고 나니 예제를 안하고 책 읽고, 공식문서 보고 넘어가는 식으로 공부하니 손에 익지 않았다.</li><li>손으로 직접 해보고 싶은건 Builder, Autoscaler, Service Discovery 이다. 이렇게 3개는 다른 공부를 하면서도 접해본적이 없어서 책을 읽으면서도 꼭 나중에 손으로 해봐야겠다고 생각했다.</li><li>전체적으로 훑기에 좋았던 것 같다. CKA 자격증 동영상만 볼때는 잘 몰랐던 내용들이 나와서 계속 찾아보면서 읽었고 전체적인 이해도에 도움을 주었다.:<ul><li>특히 StatefulSet 을 읽었을때, 아 이런식으로 돌리는구나 싶었다.</li></ul></li><li>단점은 책이 좀 나온지 돼서, version issue나 deprecated 된 프로젝트가 있었다는 것 정도이다.</li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>