<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>linux-debug/workqueue</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>linux-debug/workqueue
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[debug-linux]]</button></div></div></div><div><h2>linux-debug/workqueue</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/linux-debug/workqueue.md><h5>created : Tue, 10 Nov 2020 23:56:55 +0900</h5><h5>modified : Wed, 09 Dec 2020 13:31:24 +0900</h5></a><a href=https://minuk.dev/tags/linux-debug><kbd class=item-tag>linux-debug</kbd></a>
<a href=https://minuk.dev/tags/workqueue><kbd class=item-tag>workqueue</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><ul><li><a href=#워크큐>워크큐</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h3 id=워크큐>워크큐</h3><ul><li>주요 키워드 : 워크, 워커스레드, 워커 풀, 풀워크큐</li><li>워크 : 워크큐를 실행하는 단위<ul><li><p>실행 처리 흐름</p><ol><li>워크 큐잉(schedule_work), insert_work)</li><li>워크 스레드 깨움(wake_up_worker)</li><li>워크 스레드 실행(process_one_work)</li></ol></li><li><p>커널 후반부를 처리하는 단위, 워 크핸들러 실행 도중 휴면 상태에 진입할 숫 있다.</p></li><li><p>워크는 워커 스레드가 실행한다.</p></li></ul></li><li>워크 스레드<ul><li>워커 스레드의 이름은 &ldquo;kworker/&rdquo; 로 시작하며, 워크큐의 종류에 다라 &ldquo;kworker/&rdquo; 다음에 번호를 부여한다.</li><li>워커 스레드 핸들러 함수는 worker_thread() 함수다.</li></ul></li><li>워커 풀<ul><li>큐잉한 워크 리스트를 관리</li><li>워커 스레드를 생성하면서 관리</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> worker_pool {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>spinlock_t</span> lock;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cpu;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head worklist;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> nr_workers;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head workers;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>풀워크큐<ul><li>워커 풀을 통해 워크와 워커 스레드를 관리한다.</li></ul></li></ul><h4 id=워크큐의-특징>워크큐의 특징</h4><ul><li>워커 스레드가 워커를 실행할 때는 언제든 휴면이 가능한다. 따라서 스케쥴링을 지원하는 모든 커널 함수를 쓸 수 있다.</li><li>실행 시각에 민감한 후반부를 처리하는 용도로 워크큐의 워크를 사용하는 것은 적합하지 않다. 시스템 부하에 따라 워크 핸들러의 실행 시각 시간이 달라질 수 있다.</li><li>드라이브 레벨에 서워크는 쓰기 쉽다. 워크는 work_struct 구조체 변수만 설정, 워크를 실행할 코드에 queue_work() 혹은 schedule_work() 함수만 추가하면 된다.</li><li>워크큐를 쓰면 드라이버를 조금 더 유연하게 설계 가능하다. 또한 딜레이 워크(struct delayed_work)를 제공하며, 이를 사용해 jiffies(1/HZ) 단위로 워크를 특정 시각 이후로 지연시킨 후 실행 가능</li></ul><h4 id=워크큐와-다른-인터럽트-후반부-기법과의-비교>워크큐와 다른 인터럽트 후반부 기법과의 비교</h4><ul><li>vs IRQ 스레드 방식<ul><li>스레드의 우선순위 : IRQ 스레드는 우선순위를 높여서 처리 가능</li></ul></li><li>vs Soft IRQ 방식과의 비교<ul><li>Soft IRQ는 인터럽트 발생 빈도가 높고 후반부를 빨리 처리해야하는 상황에서 사용</li><li>워크큐는 Soft IRQ에 비해 처리 속도가 느리다.</li></ul></li></ul><h4 id=워크큐-설계>워크큐 설계</h4><ul><li>인터럽트 핸들러로 빨리 처리해야 할 코드를 수행한 후 워크를 워크큐에 큐잉한다.</li><li>인터럽트 후반부로 처리해야 할 코드를 워크 핸들러에서 처리한다.</li></ul><h4 id=워크큐의-종류>워크큐의 종류</h4><h5 id=alloc_workqueue>alloc_workqueue()</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define alloc_workqueue(fmt, flags, max_active, args...) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __alloc_workqueue_key((fmt), (flags), (max_active), \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    NULL, NULL, ##args)
</span></span></span></code></pre></div><ul><li><p>fmt : 워크큐의 이름을 지정하며, workqueue_struct 구조체의 name 필드에 저장된다.</p></li><li><p>flags : 워크큐의 속성 정보 저장, workqueue_struct 구조체의 flags 필드에 저장.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>  WQ_UNBOUND <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  WQ_FREEZABLE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  WQ_MEM_RECLAIM <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  WQ_HIGHPRI <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>  WQ_CPU_INTENSIVE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  WQ_SYSFS <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>  WQ_POWER_EFFICIENT <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>max_active : workqueue_struct 구조체의 saved_max_active에 저장</p></li><li><p>workqueue_init_early 함수에서 호출됨.</p></li></ul><h5 id=7가지-워크큐>7가지 워크큐</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>workqueue_init_early</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> std_nice[NR_STD_WORKER_POOLS] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, HIGHPRI_NICE_LEVEL };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i, cpu;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  system_wq <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;events&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  system_highpri_wq <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;events_highpri&#34;</span>, WQ_HIGHPRI, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  system_long_wq <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;events_long&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  system_unbound_wq <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;evnets_unbound&#34;</span>, WQ_UNBOUND,
</span></span><span style=display:flex><span>                        WQ_UNBOUND_MAX_ACTIVE);
</span></span><span style=display:flex><span>  system_freezable_wq <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;events_power_efficient&#34;</span>,
</span></span><span style=display:flex><span>                        WQ_FREEZABLE, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  system_power_efficient_wq <span style=color:#f92672>=</span> <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;events_power_efficient&#34;</span>,
</span></span><span style=display:flex><span>                        WQ_POWER_EFFICIENT, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  system_freezable_power_efficient_wq <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>alloc_workqueue</span>(<span style=color:#e6db74>&#34;events_freezable_power_efficient&#34;</span>,
</span></span><span style=display:flex><span>                        WQ_FREEZABLE <span style=color:#f92672>|</span> WQ_POWER_EFFICIENT,
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span>system_wq <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>system_highpri_wq <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>system_long_wq <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>system_unbound_wq <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>system_freezable_sq <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>system_power_efficient_wq <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>system_freezable_power_efficient_wq);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>7가지 워크큐 생성</li><li>워크큐가 제대로 생성됐는지 점검</li><li>system_wq : 시스템 워크큐</li><li>system_highpri_wq : 시스템 워크큐에서 쓰는 워커 스레드 보다 우선순위가 높은 워커 스레드를 처리하는 큐</li><li>system_long_wq : 오래걸리는 작업 때 사용</li><li>system_unbound_wq : percpu 타입의 워커를 쓰지 않고 wq->numa_pwq_tbl[node]에 지정된 워커 풀을 쓴다. 시스템 워크큐보다 빨리 실행된다.</li><li>system_freezable_wq : freezable 유저 프로세스나 커널 쓰레드를 처리할때 사용. (freeze_wokques_begin() 함수에서 실행)<ul><li>프로세스를 얼릴때는 __frefrigerator 함수를 호출</li></ul></li><li>system_power_efficient_wq, system_freezable_power_efficient_wq : 절전 목적으로 사용하는 워크큐</li></ul><h5 id=워크>워크</h5><ul><li>워크큐를 실행하는 기본 단위</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> work_struct {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>atomic_long_t</span> data;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head entry;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>work_func_t</span> func;
</span></span><span style=display:flex><span>  <span style=color:#75715e>#ifdef CONFIG_LOCKDEP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> lockdep_map lockdep_map;
</span></span><span style=display:flex><span>  <span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><ul><li><p>data : 워크 실행상태를 나타낸다.</p><ul><li>워크 초기화 : 0xFFFFFFE0</li><li>워크를 워크큐에 큐잉 : WORK_STRUCT_PENDING_BIT(0x1)</li></ul></li><li><p>entry : 연결 리스트, worker_pool 구조체 중 연결 리스트 worklist에 등록된다.</p></li><li><p>func : 워크 핸들러 함수의 주소를 저장</p></li><li><p>초기화 방법 : INIT_WORK, DECLARE_WORK</p><ul><li><p>INIT_WORK : 커널이 INIT_WORK 함수를 실행할 때 워크를 초기화</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>INIT_WORK</span>(<span style=color:#f92672>&amp;</span>work, callback);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define INIT_WORK(_work, _func)                              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>      __INIT_WORK((_work), (_func), 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define __INIT_WORK(_work, _func, _onstack)                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  do {                                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        __init_work((_work), _onstack);                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        (_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT(); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        INIT_LIST_HEAD(&amp;(_work)-&gt;entry);                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        (_work)-&gt;func = (_func);                          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  } while(0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define WORK_DATA_INIT() ATOMIC_LONG_INIT(WORKSTRUCT_NO_POOL)
</span></span></span></code></pre></div><ul><li>6번째 줄의 __init_work 함수는 CONFIG_DEBUG_OBJECTS 커널 컨피그가 활성화돼 있어야 실행, 대부분 비활성</li></ul></li><li><p>DECLARE_WORK : 커널이 컴파일될 때 워크 세부 정보가 포함된 전역 변수 생성</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#a6e22e>DECLARE_WORK</span>(work, callback);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define DECLARE_WORK(n, f)                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>      struct work_struct n = __WORK_INITIALIZER(n, f)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define __WORK_INITIALIZER(n, f) {                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  .data = WORK_DATA_STATIC_INIT(),                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  .entry = { &amp;(n).entry, &amp;(n).entry },                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  .func = (f),                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __WORK_INIT_LOCKDEP_MAP(#n, &amp;(n))                           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define WORK_DATA_STATIC_INIT()                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>      ATOMIC_LONG_INIT((unsigned long)(WORK_STRUCT_NO_POOL | WORK_STRUCT_STATIC))
</span></span></span></code></pre></div></li></ul></li></ul><h5 id=워크-큐잉>워크 큐잉</h5><ul><li><p>schedule_work(), queue_work_on(), __queue_work(), insert_work(), wake_up_worker()</p></li><li><p>interface</p><ul><li><p>schedule_work()</p><ul><li>시스템 워크큐에 큐잉</li><li>호출 구조 : schedule_work() -> queue_work() -> queue_work_on() -> __queue_work()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>schedule_work</span>(<span style=color:#f92672>&amp;</span>work);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>schedule_work</span>(<span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>queue_work</span>(system_wq, work);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>system_wq __read_mostly;
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(system_wq);
</span></span></code></pre></div><ul><li>queue_work()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queue_work</span>(<span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>queue_work_on</span>(WORK_CPU_UNBOUND, wq, work);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>queue_work_on()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queue_work_on</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_save</span>(flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>test_and_set_bit</span>(WORK_STRUCT_PENDING_BIT, <span style=color:#a6e22e>work_data_bits</span>(work))) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__queue_work</span>(cpu, wq, work);
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_restore</span>(flags);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>__queue_work()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__queue_work</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work);
</span></span></code></pre></div><ul><li>queue_work_on 이 호출할 때, 인자<ul><li>cpu : WORK_CPU_UNBOUND</li><li>wq : system_wq</li><li>work : work_struct 구조체의 주소</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__queue_work</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>pwq;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>last_pool;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>worklist;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> work_flags;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> req_cpu <span style=color:#f92672>=</span> cpu;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>retry:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (req_cpu <span style=color:#f92672>==</span> WORK_CPU_UNBOUND)
</span></span><span style=display:flex><span>    cpu <span style=color:#f92672>=</span> <span style=color:#a6e22e>wq_select_unbound_cpu</span>(<span style=color:#a6e22e>raw_smp_processor_id</span>());
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* pwq which will be used unless @work is executing elsewhere */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(wq<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WQ_UNBOUND))
</span></span><span style=display:flex><span>    pwd <span style=color:#f92672>=</span> <span style=color:#a6e22e>per_cpu_ptr</span>(wq<span style=color:#f92672>-&gt;</span>cpu_pwqs, cpu);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    pwd <span style=color:#f92672>=</span> <span style=color:#a6e22e>unbound_pwq_by_node</span>(wq, <span style=color:#a6e22e>cpu_to_node</span>(cpu));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  last_pool <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_work_pool</span>(work);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (last_pool <span style=color:#f92672>&amp;&amp;</span> last_pool <span style=color:#f92672>!=</span> pwq<span style=color:#f92672>-&gt;</span>pool) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>last_pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    worker <span style=color:#f92672>=</span> <span style=color:#a6e22e>find_worker_executing_work</span>(last_pool, work);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (worker <span style=color:#f92672>&amp;&amp;</span> worker<span style=color:#f92672>-&gt;</span>current_pwq<span style=color:#f92672>-&gt;</span>wq <span style=color:#f92672>==</span> wq) {
</span></span><span style=display:flex><span>      pwd <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>current_pwq;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* meh... not running there, queue her */</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>last_pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>pwd<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>pwq<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* pwq determined, queue */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_workqueue_queue_work</span>(req_cpu, pwq, work);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(pwq<span style=color:#f92672>-&gt;</span>nr_active <span style=color:#f92672>&lt;</span> pwq<span style=color:#f92672>-&gt;</span>max_active)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>trace_workqueue_activate_work</span>(work);
</span></span><span style=display:flex><span>    pwq<span style=color:#f92672>-&gt;</span>nr_active<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    worklist <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pwq<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>worklist;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>list_empty</span>(worklist))
</span></span><span style=display:flex><span>      pwq<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>watchdog_ts <span style=color:#f92672>=</span> jiffies;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    work_flags <span style=color:#f92672>|=</span> WORK_STRUCT_DELAYED;
</span></span><span style=display:flex><span>    worklist <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>pwq<span style=color:#f92672>-&gt;</span>delayed_works;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>insert_work</span>(pwq, work, worklist, work_flags);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>풀워크큐 가져오기</li><li>워커 구조체 가져오기</li><li>ftrace 로그 출력</li><li>워커 풀에 워크의 연결리스트를 등록하고 워커 스레드 깨우기</li></ul></li><li><p>get_work_pool()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span><span style=color:#a6e22e>get_work_pool</span>(<span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> data <span style=color:#f92672>=</span> <span style=color:#a6e22e>atomic_long_read</span>(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>data);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> pool_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>assert_rcu_or_pool_mutex</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (data <span style=color:#f92672>&amp;</span> WORK_STRUCT_PWQ)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ((<span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>      (data <span style=color:#f92672>&amp;</span> WORK_STRUCT_WQ_DATA_MASK))<span style=color:#f92672>-&gt;</span>pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  pool_id <span style=color:#f92672>=</span> data <span style=color:#f92672>&gt;&gt;</span> WORK_OFFQ_POOL_SHIFT;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pool_id <span style=color:#f92672>==</span> WORK_OFFQ_POOL_NONE)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>idr_find</span>(<span style=color:#f92672>&amp;</span>worker_pool_idr, pool_id);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>insert_work()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert_work</span>(<span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>pwq, <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work,
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> extra_flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> pwq<span style=color:#f92672>-&gt;</span>pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_work_pwq</span>(work, pwq, extra_flags);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list_add_tail</span>(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>entry, head);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>get_pwq</span>(pwq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>smp_mb</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>__need_more_worker</span>(pool))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wake_up_worker</span>(pool);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>wake_up_worker()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wake_up_worker</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> <span style=color:#a6e22e>first_idle_worker</span>(pool);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(worker))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wake_up_process</span>(worker<span style=color:#f92672>-&gt;</span>task);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>find_worker_executing_work()</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span><span style=color:#a6e22e>find_worker_executing_work</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool,
</span></span><span style=display:flex><span>                                                <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>hash_for_each_possible</span>(pool<span style=color:#f92672>-&gt;</span>busy_hash, worker, hentry,
</span></span><span style=display:flex><span>                      (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)work)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (worker<span style=color:#f92672>-&gt;</span>current_work <span style=color:#f92672>==</span> work <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>          worker<span style=color:#f92672>-&gt;</span>current_func <span style=color:#f92672>==</span> work<span style=color:#f92672>-&gt;</span>func)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> worker;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h5 id=워크의-실행-주체>워크의 실행 주체</h5><ul><li><p>워커 스레드, 워크를 워크큐에 큐잉하면 워커 스레드를 깨운다.</p></li><li><p>worker_thread()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>worker_thread</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>__worker)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> __worker;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>list_first_entry</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worklist,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> work_struct, entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>-&gt;</span>watchdog_ts <span style=color:#f92672>=</span> jiffies;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(<span style=color:#f92672>!</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>work_data_bits</span>(work) <span style=color:#f92672>&amp;</span> WORK_STRUCT_LINKED))) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* optimization path, not strictly necessary */</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>process_one_work</span>(worker, work);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled)))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>process_scheduled_works</span>(worker);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>move_linked_works</span>(work, <span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled, NULL);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>process_scheduled_works</span>(worker);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>keep_working</span>(pool));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>keep_working() : 이미 큐잉된 워크가 있으면 true를 반환하는 역할</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>keep_working</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worklist) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>atomic_read</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>nr_running) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>워커 풀에 워크가 큐잉됐는지 체크한다.</p></li><li><p>워커 풀에 큐잉된 워크의 연결 리스트를 가져와 워크 구조체를 알아낸다.</p></li><li><p>process_one_work() 함수를 호출해 워크를 실행한다.</p></li></ul></li><li><p>process_one_work()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process_one_work</span>(<span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker. <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work)
</span></span><span style=display:flex><span><span style=color:#a6e22e>__releases</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock)
</span></span><span style=display:flex><span><span style=color:#a6e22e>__acquires</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> pool_workqueue <span style=color:#f92672>*</span>pwq <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_work_pwq</span>(work);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>pool;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> cpu_intensive <span style=color:#f92672>=</span> pwq<span style=color:#f92672>-&gt;</span>wq<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WQ_CPU_INTENSIVE;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> work_color;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>collision;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  collision <span style=color:#f92672>=</span> <span style=color:#a6e22e>find_worker_executing_work</span>(pool, work);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(collision)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>move_linked_works</span>(work, <span style=color:#f92672>&amp;</span>collision<span style=color:#f92672>-&gt;</span>scheduled, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* claim and dequeue */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>debug_work_deactivate</span>(work);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>hash_add</span>(pool<span style=color:#f92672>-&gt;</span>busy_hash, <span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>hentry, (unsgined <span style=color:#66d9ef>long</span>)work);
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>current_work <span style=color:#f92672>=</span> work;
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>current_func <span style=color:#f92672>=</span> work<span style=color:#f92672>-&gt;</span>func;
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>current_pwq <span style=color:#f92672>=</span> pwq;
</span></span><span style=display:flex><span>  work_color <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_work_color</span>(work);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list_del_init</span>(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>entry);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_work_pool_and_clear_pending</span>(work, pool<span style=color:#f92672>-&gt;</span>id);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_workqueue_execute_start</span>(work);
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>current_func</span>(work);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_workqueue_execute_end</span>(work);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#a6e22e>in_atomic</span>() <span style=color:#f92672>||</span> <span style=color:#a6e22e>lockdep_depth</span>(current) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pr_err</span>(<span style=color:#e6db74>&#34;BUG: workqueue leaked lock or atomic: %s/0x%08x/%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;last function: %pf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>      current<span style=color:#f92672>-&gt;</span>comm, <span style=color:#a6e22e>prempt_count</span>(), <span style=color:#a6e22e>task_pid_nr</span>(current),
</span></span><span style=display:flex><span>      worker<span style=color:#f92672>-&gt;</span>current_func);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>debug_show_held_locks</span>(current);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>dump_stack</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>워크 전처리 : 하나의 워크를 여러 워커에서 실행하지 않도록 관리</li><li>워크 핸들러 실행</li></ul></li></ul><hr><h5 id=워커-스레드>워커 스레드</h5><ul><li><p>워커 스레드의 흐름</p><ol><li>워커 스레드 생성 : create_worker() 함수를 호출하면 워커 스레드를 생성.</li><li>휴면 상태 : 휴면 상태에서 다른 드라이버가 자신을 깨워주기를 기다림.</li><li>실행 : 워크를 워크큐에 큐잉한 후 워커 스레드가 깨어나면 스레드 핸들러인 worker_thread() 함수가 실행</li><li>소멸 : 워커 스레드가 필요 없으면 소멸.</li></ol></li><li><p>worker 구조체</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> worker {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head      entry;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hlist_node     hentry;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> work_struct      <span style=color:#f92672>*</span>current;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>work_func_t</span>             current_func;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> pool_workqueue   <span style=color:#f92672>*</span>current_pwq;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span>                    desc_valid;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head        scheduled;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct      <span style=color:#f92672>*</span>task;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool      <span style=color:#f92672>*</span>pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head        node;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>           last_active;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>            flags;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>                     id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span>                    desc[WORKER_DESC_LEN];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>rescue_wq;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>current_work : work_struct 구조체로, 현재 실행하려는 워크를 저장하는 필드</li><li>current_func : 실행하려는 워크 핸들러의 주소를 저장하는 필드</li></ul></li><li><p>워커는 워커 스레드를 표현하는 자료구조이며, worker 구조체</p></li></ul><h5 id=워커-스레드의-생성-시기>워커 스레드의 생성 시기</h5><ul><li><p>기본적으로 부팅과정에서 워크큐 자료구조를 초기화할 때 워커 스레드를 생성.</p></li><li><p>만약 워크큐에 많이 큐잉될 상황이 예측될 때, create_worker() 함수를 호출해 워커 스레드를 생성 가능</p></li><li><p>부팅 과정에서 워커 스레드 생성되는 로직</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>workqueue_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cpu, bkt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>wq_numa_init</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>wq_pool_mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* create the initial workers */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>for_each_online_cpu</span>(cpu) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>for_each_cpu_worker_pool</span>(pool, cpu) {
</span></span><span style=display:flex><span>      pool<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>POOL_DISASSOCIATED;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>create_worker</span>(pool));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>create_worker()</p><ul><li>워커 풀의 아이디 읽어오기</li><li>워커 스레드의 이름을 지정해 워커 스레드 생성 요청</li><li>워커 풀에 워커 스레드를 등록</li><li>워커 정보를 갱신하고 생성된 워커 스레드를 깨우기</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> owrker <span style=color:#f92672>*</span><span style=color:#a6e22e>create_worker</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> id <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> id_buf[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  id <span style=color:#f92672>=</span> <span style=color:#a6e22e>ida_simple_get</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worker_da, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, GFP_KERNEL);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (id <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> fail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>worker)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> fail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>pool <span style=color:#f92672>=</span> pool;
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pool<span style=color:#f92672>-&gt;</span>cpu <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>snprintf</span>(id_buf, <span style=color:#66d9ef>sizeof</span>(id_buf), <span style=color:#e6db74>&#34;%d:%d%s&#34;</span>, pool<span style=color:#f92672>-&gt;</span>cpu, id,
</span></span><span style=display:flex><span>      pool<span style=color:#f92672>-&gt;</span>attrs<span style=color:#f92672>-&gt;</span>nice <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;H&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>snprintf</span>(id_buf, <span style=color:#66d9ef>sizeof</span>(id_buf), <span style=color:#e6db74>&#34;u%d:%d&#34;</span>, pool<span style=color:#f92672>-&gt;</span>id, id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>task <span style=color:#f92672>=</span> <span style=color:#a6e22e>kthread_create_on_node</span>(worker_thread, worker, pool<span style=color:#f92672>-&gt;</span>node,
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#34;kworker/%s&#34;</span>, id_buf);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>IS_ERR</span>(worker<span style=color:#f92672>-&gt;</span>task))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> fail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_user_nice</span>(worker<span style=color:#f92672>-&gt;</span>task, pool<span style=color:#f92672>-&gt;</span>attrs<span style=color:#f92672>-&gt;</span>nice);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kthread_bind_mask</span>(worker<span style=color:#f92672>-&gt;</span>task, pool<span style=color:#f92672>-&gt;</span>attrs<span style=color:#f92672>-&gt;</span>cpumask);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* successful, attach the worker to the pool */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>worker_attach_to_pool</span>(worker, pool);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* start the newly created worker */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_lock_irq</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>pool<span style=color:#f92672>-&gt;</span>nr_workers<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>worker_enter_idle</span>(worker);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>wake_up_process</span>(worker<span style=color:#f92672>-&gt;</span>task);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_unlock_irq</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> worker;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fail:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (id <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ida_simple_remove</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worker_ida, id);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kfree</span>(worker);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>worker_attach_to_pool()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>worker_attach_to_pool</span>(<span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>attach_mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_cpus_allowed_ptr</span>(worker<span style=color:#f92672>-&gt;</span>task, pool<span style=color:#f92672>-&gt;</span>attrs<span style=color:#f92672>-&gt;</span>cpumask);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pool<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> POOL_DISASSOCIATED)
</span></span><span style=display:flex><span>    worker<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>|=</span> WORKER_UNBOUND;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list_add_tail</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>node, <span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>workers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>attach_mutex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>worker_enter_idle()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>worker_enter_idle</span>(<span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>WARN_ON_ONCE</span>(worker<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WORKER_IDLE) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>entry) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                (worker<span style=color:#f92672>-&gt;</span>hentry.next <span style=color:#f92672>||</span> worker<span style=color:#f92672>-&gt;</span>hentry.pprev)))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>|=</span> WORKER_IDLE;
</span></span><span style=display:flex><span>  pool<span style=color:#f92672>-&gt;</span>nr_idle<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>last_active <span style=color:#f92672>=</span> jiffies;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list_add</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>entry, <span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>idle_list);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>too_many_workers</span>(pool) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>timer_pending</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>idle_time))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mod_timer</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>idle_timer, jiffies <span style=color:#f92672>+</span> IDLE_WORKER_TIMEOUT);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#f92672>!</span>(pool<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>*</span> POOL_DISASSOCIATED) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                 pool<span style=color:#f92672>-&gt;</span>nr_workers <span style=color:#f92672>==</span> pool<span style=color:#f92672>-&gt;</span>nr_idle <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                 <span style=color:#a6e22e>atomic_read</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>nr_running));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>정리</p><ul><li>kthread_create_on_node() : &ldquo;kworker/&rdquo; 이름으로 워커 스레드를 만듦.</li><li>worker_attach_to_pool() : 워커 풀에 워커를 등록.</li><li>worker_enter_idle() : 워커 상태를 WORKER_IDLE로 바꿈.</li><li>wake_up_process() : 워커 스레드를 깨움.</li></ul></li></ul></li><li><p>woker_thread()</p><ul><li><p>create_worker()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span><span style=color:#a6e22e>create_worker</span>(<span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  worker<span style=color:#f92672>-&gt;</span>task <span style=color:#f92672>=</span> <span style=color:#a6e22e>kthread_create_on_node</span>(worker_thread, worker, pool<span style=color:#f92672>-&gt;</span>node,
</span></span><span style=display:flex><span>                                       <span style=color:#e6db74>&#34;kworker/%s&#34;</span>, id_buf);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>전체 동작 과정</p><ul><li>1단계 깨어남 : 워크를 워크큐에 큐잉하면 wake_up_worker() 함수를 호출.</li><li>2단계 전처리 : need_more_worker() 함수를 호출해 워커 스레드를 실행할 조건인지 점검.</li><li>3단계 워크 실행 : process_one_work() 함수 호출해 워크 실행</li><li>4단계 슬립 : 워커 상태를 아이들로 설정하고 슬립 상태로 진입.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>worker_thread</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>__worker)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker <span style=color:#f92672>*</span>worker <span style=color:#f92672>=</span> __worker;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> worker_pool <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> worker<span style=color:#f92672>-&gt;</span>pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_pf_worker</span>(true); <span style=color:#75715e>// worker-&gt;task-&gt;flags |= PF_WQ_WORKER;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>woke_up:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_lock_irq</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* am I supposed to die? */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(worker<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WORKER_DIE)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spin_unlock_irq</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>list_mepty</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>entry));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>set_pf_worker</span>(false); <span style=color:#75715e>// worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>set_task_comm</span>(worker<span style=color:#f92672>-&gt;</span>task, <span style=color:#e6db74>&#34;kworker/dying&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ida_simple_remove</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worker_ida, worker<span style=color:#f92672>-&gt;</span>id);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_detach_from_pool</span>(worker, pool);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kfree</span>(worker);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>worker_leave_idle</span>(worker);
</span></span><span style=display:flex><span>recheck:
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* no more worker necessary? */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>need_more_worker</span>(pool))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> sleep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* do we need to manage? */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>may_start_working</span>(pool)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>manage_workers</span>(worker))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> recheck;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>list_emtpry</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>worker_clr_flags</span>(worker, WORKER_PREP <span style=color:#f92672>|</span> WORKER_REBOUND);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>list_first_entry</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>worklist,
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>struct</span> work_struct, entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>-&gt;</span>watchdog_ts <span style=color:#f92672>=</span> jiffies;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(<span style=color:#f92672>!</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>work_data_bits</span>(work) <span style=color:#f92672>&amp;</span> WORK_STRUCT_LINKED))) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* optimization path, not strictly necessary */</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>process_one_work</span>(worker, work);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled)))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>process_scheduled_works</span>(worker);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>move_linked_works</span>(work, <span style=color:#f92672>&amp;</span>worker<span style=color:#f92672>-&gt;</span>scheduled, NULL);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>process_scheduled_works</span>(worker);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>keep_working</span>(pool));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>worker_set_flags</span>(worker, WORKER_PREP);
</span></span><span style=display:flex><span>sleep:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>worker_enter_idle</span>(worker);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__set_current_state</span>(TASK_IDLE);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_unlock_irq</span>(<span style=color:#f92672>&amp;</span>pool<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>schedule</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>goto</span> woke_up;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>set_pf_worker()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_pf_worker</span>(<span style=color:#66d9ef>bool</span> val)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#f92672>&amp;</span>wq_pool_attach_mutex);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (val)
</span></span><span style=display:flex><span>    current<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>|=</span> PF_WQ_WORKER;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    current<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>PF_WQ_WORKER;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#f92672>&amp;</span>wq_pool_attach_mutex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><h4 id=딜레이워크>딜레이워크</h4><ul><li>딜레이 워크 : 워크를 일정시간 후에 지연시켜 실행하는 기법.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> delayed_work {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> work_struct work;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timer_list timer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cpu;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>work : 어떤 일을 할지</li><li>timer : 워크를 지정된 시간만큰 지연할 수 있는 시간 정보를 저장</li><li>wq : 딜레이 워크를 관리하는 워크큐 주소</li><li>cpu : 딜레이 워크를 실행한 cpu 번호</li></ul><h5 id=딜레이-워크의-전체-흐름>딜레이 워크의 전체 흐름</h5><ul><li>딜레이 워크 초기화 : INIT_DELAYED_WORK()</li><li>딜레이 워크 타이머 등록 : schedule_delayed_work(), queue_delayed_work(), queue_delayed_work_on(), __queue_delayed_work()</li><li>딜레이 워크 큐잉 : delayed_work_timer_fn(), __queue_wokr()</li><li>딜레이 워크 실행 : process_one_work()</li></ul><h5 id=init_delayed_work>INIT_DELAYED_WORK()</h5><ul><li>사용법</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> delayed_work d_work;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sample</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>INIT_DELAYED_WORK</span>(<span style=color:#f92672>&amp;</span>d_work, callback_fn);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>INIT_DELAYED_WORK()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define INIT_DELAYED_WORK(_work, _func)       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __INIT_DELAYED_WORK(_work, _func, 0)
</span></span></span></code></pre></div><ul><li>__INIT_DELAYED_WORK()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define __INIT_DELAYED_WORK(_work, _func, _tflags)  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  do {                                              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    INIT_WORK(&amp;(_work)-&gt;work, (_func));             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    __init_timer(&amp;(_work)-&gt;timer,                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>      delayed_work_timer_fn,                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>      (_tflags) | TIMER_IRQSAFE);                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  } while(0);
</span></span></span></code></pre></div><ul><li>__init_timer()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define __init_timer(_timer, _fn, _flags)                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  do {                                                          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    static struct lock_class_key __key;                         \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    init_timer_key((_timer), (_fn), (_flags), #_timer, &amp;__key); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  } while (0)
</span></span></span></code></pre></div><ul><li>init_timer_key()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_timer_key</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(truct timer_list <span style=color:#f92672>*</span>), <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>struct</span> lock_class_key <span style=color:#f92672>*</span>key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>debug_init</span>(timer);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>do_init_timer</span>(timer, func, flags, name, key);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=schedule_delayed_work>schedule_delayed_work()</h5><ul><li>사용법</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>schedule_delayed_work</span>(<span style=color:#f92672>&amp;</span>d_work, timeout);
</span></span></code></pre></div><ul><li>schedule_delayed_work()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>schedule_delayed_work</span>(<span style=color:#66d9ef>struct</span> delayed_work <span style=color:#f92672>*</span>dwork,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> delay)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>queue_dleayed_work</span>(system_wq, dwork, delay);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>queue_delayed_work()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queue_delayed_work</span>(<span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>struct</span> delayed_work <span style=color:#f92672>*</span>dwork,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> delayed)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>queue_delayed_work_on</span>(WORK_CPU_UNBOUND, wq, dwork, delay);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>queue_delayed_work_on()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queue_delayed_work_on</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>struct</span> delayed_work <span style=color:#f92672>*</span>dwork, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> delay)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> work<span style=color:#f92672>-</span><span style=color:#66d9ef>struct</span> <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>dwork<span style=color:#f92672>-&gt;</span>work;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* read the comment in __queue_work() */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_save</span>(flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>test_and_set_bit</span>(WORK_STRUCT_PENDING_BIT, <span style=color:#a6e22e>work_data_bits</span>(work))) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__queue_delayed_work</span>(cpu, wq, dwork, delay);
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_restore</span>(flags);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>__queue_delayed_work()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__queue_delayed_work</span>(<span style=color:#66d9ef>int</span> cpu, <span style=color:#66d9ef>struct</span> workqueue_struct <span style=color:#f92672>*</span>wq,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>struct</span> dealyed_work <span style=color:#f92672>*</span>dwork, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> delay)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>dwork<span style=color:#f92672>-&gt;</span>timer;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> work_struct <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>dwork<span style=color:#f92672>-&gt;</span>work;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#f92672>!</span>wq);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>WARN_ON_ONCE</span>(timer<span style=color:#f92672>-&gt;</span>function <span style=color:#f92672>!=</span> delayed_work_timer_fn <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>              timer<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>!=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)dwork);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#a6e22e>timer_pending</span>(timer));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>WARN_ON_ONCE</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>work<span style=color:#f92672>-&gt;</span>entry));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>delay) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__queue_work</span>(cpu, wq, <span style=color:#f92672>&amp;</span>dwork<span style=color:#f92672>-&gt;</span>work);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  dwork<span style=color:#f92672>-&gt;</span>wq <span style=color:#f92672>=</span> wq;
</span></span><span style=display:flex><span>  dwork<span style=color:#f92672>-&gt;</span>cpu <span style=color:#f92672>=</span> cpu;
</span></span><span style=display:flex><span>  timer<span style=color:#f92672>-&gt;</span>expires <span style=color:#f92672>=</span> jiffies <span style=color:#f92672>+</span> delay;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(cpu <span style=color:#f92672>!=</span> WORK_CPU_UNBOUND))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add_timer_on</span>(timer, cpu);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add_tiemr</span>(timer);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=delayed_work_timer_fn>delayed_work_timer_fn()</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delayed_work_timer_fn</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> __data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> delayed_work <span style=color:#f92672>*</span>dwork <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> dleayed_work <span style=color:#f92672>*</span>)__data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* should have been called from irqsafe timer with irq already off */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__queue_work</span>(dwork<span style=color:#f92672>-&gt;</span>cpu, dwork<span style=color:#f92672>-&gt;</span>wq, <span style=color:#f92672>&amp;</span>dwork<span style=color:#f92672>-&gt;</span>work);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>