<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>linux-debug/scheduling</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>linux-debug/scheduling
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[linux-debug]]</button></div></div></div><div><h2>linux-debug/scheduling</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/linux-debug/scheduling.md><h5>created : Wed, 09 Dec 2020 13:30:45 +0900</h5><h5>modified : Wed, 23 Jun 2021 15:35:51 +0900</h5></a><a href=https://minuk.dev/tags/linux><kbd class=item-tag>linux</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#주요-키워드>주요 키워드</a><ul><li><a href=#선점-스케쥴링과-비선점-스케쥴링-비교>선점 스케쥴링과 비선점 스케쥴링 비교</a></li></ul></li><li><a href=#스케줄링-정책>스케줄링 정책</a><ul><li><a href=#스케줄러-클래스>스케줄러 클래스</a></li><li><a href=#런큐>런큐</a></li><li><a href=#우선순위nice>우선순위(nice)</a></li></ul></li><li><a href=#프로세스-상태-관리>프로세스 상태 관리</a><ul><li><a href=#프로세스-상태>프로세스 상태</a></li><li><a href=#프로세스-상태-변화>프로세스 상태 변화</a></li><li><a href=#프로세스-상태-변화-함수-목록>프로세스 상태 변화 함수 목록</a></li><li><a href=#task_running실행-대기으로-바뀔-때-호출되는-함수>TASK_RUNNING(실행 대기)으로 바뀔 때 호출되는 함수</a></li><li><a href=#task_runningcpu-실행로-바뀔-때-호출하는-함수>TASK_RUNNING(CPU 실행)로 바뀔 때 호출하는 함수</a></li><li><a href=#task_interruptible-상태로-바뀔-때-호출하는-함수>TASK_INTERRUPTIBLE 상태로 바뀔 때 호출하는 함수</a></li><li><a href=#task_uninterruptible-상태로-바뀔-때-호출하는-함수>TASK_UNINTERRUPTIBLE 상태로 바뀔 때 호출하는 함수</a></li></ul></li><li><a href=#스케줄러-클래스-1>스케줄러 클래스</a><ul><li><a href=#sched_class-구조체>sched_class 구조체</a></li><li><a href=#5가지-스케줄러-클래스>5가지 스케줄러 클래스</a></li><li><a href=#프로세스를-스케줄러에-등록>프로세스를 스케줄러에 등록</a></li><li><a href=#세부-함수-호출>세부 함수 호출</a></li></ul></li><li><a href=#런큐-1>런큐</a><ul><li><a href=#runqueues-변수>runqueues 변수</a></li></ul></li><li><a href=#cfs-스케줄러>CFS 스케줄러</a><ul><li><a href=#cfs-스케줄러-알고리즘>CFS 스케줄러 알고리즘</a></li><li><a href=#cfs-관련-세부-함수>CFS 관련 세부 함수</a></li></ul></li><li><a href=#선점-스케줄링>선점 스케줄링</a><ul><li><a href=#선점-스케줄링-진입점>선점 스케줄링 진입점</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=주요-키워드>주요 키워드</h2><ul><li>scheduling : 실행 대기 중인 프로세스 중에서 우선순위가 가장 높은 프로세스를 선택해 CPU에서 실행시킴<ul><li>Preemptive Scheduling : 강제로 CPU에서 실행 중인 프로세스를 비우고 새로운 프로세스 실행</li><li>Non-Preemptive Scheduling : 프로세스가 자발적으로 스케줄링 요청</li></ul></li><li>context-switching : cpu에서 실행 중인 프로세스의 레지스터 세트를 비우고 새로운 프로세스 레지스터 세트를 채우는 동작, 아키텍쳐마다 구현 방식이 다름</li><li>scheduling policy : 스케쥴링 시 어떤 방식과 규칙으로 다음에 실행할 프로세스를 선택할지 결정</li><li>scheduler class : 5가지 커널 스케쥴러 세부동작을 모듈화한 자료구조 이자 인터페이스, 프로세스는 스케쥴러 클레스를 우선순위에 따라 선택할 수 있음</li><li>run queue : 실행 대기 중인 프로세스를 관리하는 자료구조, percpu 타입 변수</li><li>proirity : 유저 공간에서 설정한 nice와 커널 우선순위가 존재</li></ul><h3 id=선점-스케쥴링과-비선점-스케쥴링-비교>선점 스케쥴링과 비선점 스케쥴링 비교</h3><ul><li>Preemptive Scheduling<ul><li>실행 중인 프로세스를 강제로 CPU에서 실행 중지</li><li>새로운 프로세스가 CPU에서 실행</li><li>선점 스케쥴링 시작점<ul><li>인터럽트 핸들러를 처리하고 난 후 인터럽트가 발생하기 전에 코드로 되돌아가기 직전</li><li>시스템 콜의 핸들러 함수를 처리하고 난 후 유저 공간으로 복귀하기 직전</li></ul></li></ul></li><li>비선점 스케쥴링<ul><li>프로세스가 자발적으로 스케줄링 요청</li><li>비선점 스케줄링 시작점<ul><li>입출력(I/O) 동작을 시작할 때</li><li>뮤텍스를 획득하지 못하고 휴먼 상태에 진입할 때</li></ul></li></ul></li></ul><h2 id=스케줄링-정책>스케줄링 정책</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define SCHED_NORMAL    0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SCHED_FIFO      1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SCHED_RR        2
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SCHED_BATCH     3
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SCHED_IDLE      5
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SCHED_DEADLINE  6
</span></span></span></code></pre></div><h3 id=스케줄러-클래스>스케줄러 클래스</h3><ul><li><p>stop 스케줄러</p><ul><li><a href=http://jake.dothome.co.kr/stop-sched/>참고- 문C 블로그</a></li><li>어떠한 스케줄러보다 우선 순위가 더 높아 preemption 되지 않으며, 다른 cpu로 migration도 허용되지 않다. 모든 요청에 대해 대부분 거절하거나 아무런 일도 하지 않는다.</li></ul></li><li><p>deadline 스케줄러</p><ul><li><a href=http://jake.dothome.co.kr/dl-scheduler/>참고- 문C 블로그</a></li><li>2013년 3월 Kernel v3.14에서 소개</li><li>EDF + CBS 알고리즘 기반<ul><li>EDF(Earliest Deadline First)<ul><li>작업이 N 개일때 복잡도는 O(n^2) 로 알려져 있으며, 수학적으로 최적이라는 것이 증명되어 있지만, 현실적으로 프로세스의 마감시간을 예측하는 것이 어렵다.</li><li>예시 : P1이 수행시간이 1, 주기가 8, P2가 수행시간이 2, 주기가 5, P3가 수행시간이 4, 주기가 10이고, 1단위 시간이 10ms 일때 CPU 사용량은 1/8 + 2/5 + 4/10 = 0.925이기에 스케줄링이 가능하다고 판단하며 스케줄링한다.</li></ul></li><li>CBS(Constatn Bandwidth Server)<ul><li>자료가 안나오길래 아래 적어둔 논문 기반으로 정보를 적는다.</li><li>논문 : Intergrating multimedia applications in hard real-time systems</li><li>1998년도에 소개된 예약기반(reservation-based) 스케줄링 알고리즘</li><li>$$\text{ a budget } c_s \text{ and by a ordered pair } (Q_s, T_s), \text{ where } Q_s \text{ is the maximum budget and } T_s \text{ is the period of the server }$$</li><li>$$\text{ server bandwidth } U_s = Q_s / T_s$$</li><li>$$\text{ At each instant, a fixed deadline } d_{s, k}$$</li><li>$$\text{ Initially, } d_{s, 0} = 0$$</li><li>각 작업들은 동적인 마감시간(deadline)을 가지고 있고 이는 초기에는 현제 서버의 마감시간과 동일하게 된다.</li><li>작업들이 실행되면 그와 같은 양이 예산에서 빠지며, 예산이 0이 됬을 때 서버의 최대 예산인 Q_s를 다시 채우고, 새로운 서버 마감시간이 생기게된다. 이 때 새로운 마감시간은 T_s만큼 더한것이다. \(d_{s, k + 1} = d_{s, k} + T_s \)</li><li>흐으으음&mldr; 이 이상 자세히 적을 필요는 없을 듯, 그냥 대충 예산 개념이 존재해서 스케줄링 한다? 정도까지만 정리함. 사실상 정리하면 그냥 논문 번역이 될듯</li></ul></li></ul></li><li>처음에는 UP 시스템용으로 구현되었다가 SMP 시스템에서도 채용함. 각 cpu의 earliest deadline을 관리하고 다른 CPU로 전달하여 효과적으로 스케줄링한다.</li><li>상당히 최신에 추가된 내용이며, 2017년에도 새 버전의 deadline 스케줄러가 소개됬다고 한다.</li><li>Stop 스케줄러 바로 다음의 우선순위를 가짐</li></ul></li><li><p>RT 스케줄러</p><ul><li>stop - deadline 다음 순서의 우선순위를 가지고 있다.</li><li>rt 런큐는 CPU 수만큼 생성된다.</li></ul></li><li><p>CFS 스케줄러</p><ul><li><a href=https://goodgid.github.io/Scheduler-CFS/>참고</a></li><li>rb 데이터 구조를 사용하며 O(logN) 성능을 가지는 스케줄러</li><li>특징<ul><li>공평한 CPU 시간</li><li>가상 런타임</li><li>대기자 공평성</li><li>RB-트리</li></ul></li></ul></li><li><p>Idle 스케줄러</p><ul><li><a href=http://jake.dothome.co.kr/idle-sched/>참고- 문C 블로그</a></li><li>어떠한 스케줄러보다 우선순위가 낮다.</li><li>core 마다 1개씩 지정되어 있어 다른 cpu로의 migration이 필요 없다.</li></ul></li></ul><h3 id=런큐>런큐</h3><ul><li>실행 대기상태 프로세스와 CPU에서 실행 중인 프로세스를 관리하는 자료구조</li></ul><h3 id=우선순위nice>우선순위(nice)</h3><ul><li>-20 ~ 19의 값을 가지며 커널공간에서 100 ~ 139 범위 값으로 변환되어 관리된다.(0 ~ 99 는 RT)</li><li>RT(Real-Time) 프로세스의 우선순위 범위<ul><li>0 ~ 99 사이의 우선순위를 가짐</li><li>SCHED_FIFO 이며, 우선순위가 더 높은 RT 프로세스가 없으면 계속 CPU를 점유해 사용한다.</li></ul></li></ul><h2 id=프로세스-상태-관리>프로세스 상태 관리</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define TASK_RUNNING          0x0000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TASK_INTERRUPTIBLE    0x0001
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TASK_UNINTERRUPTIBLE  0x0002
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define __TASK_STOPPED        0x0004
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define __TASK_TRACED         0x0008
</span></span></span></code></pre></div><h3 id=프로세스-상태>프로세스 상태</h3><ul><li>TASK_RUNNING : 실행대기<ul><li>프로세스가 런큐에 삽입된 후 실행을 기다리는 상태</li><li>스케줄러는 TASK_RUNNING(실행 대기)상태에 있는 프로세스 중에서 CPU에서 실행할 프로세스를 선택</li></ul></li><li>TASK_RUNNING : CPU 실행<ul><li>프로세스가 CPU에서 실행 중인 상태</li><li>CPU 레지스터 세트에는 현재 실행 중인 프로세스의 상태 정보로 채워짐</li></ul></li><li>TASK_INTERRUPTIBLE<ul><li>프로세스가 휴면 상태에 진입한 상태</li><li>프로세스를 깨우면 다시 TASK_RUNNING(실행 대기) 상태로 변경됨</li></ul></li><li>TASK_UNINTERRUPTIBLE<ul><li>프로세스가 특정 조건으로 깨워나고 싶을 때 설정하는 상태</li><li>보통 스스로 깨어날 조건을 설정한 다음에 TASK_UNINTERRUPTIBLE 상태로 변경</li><li>뮤텍스를 얻지 못하거나 입출력(I/O) 동작 중에 TASK_UNINTERRUPTIBLE 상태로 변경</li></ul></li></ul><h4 id=task_interruptible과-task_uninterruptible-상태의-차이점>TASK_INTERRUPTIBLE과 TASK_UNINTERRUPTIBLE 상태의 차이점</h4><ul><li>I/O 나 mutex 같이 깨어나봤자 의미가 없을때, 자신을 깨울수 있는 방법과 시기(I/O가 종료되거나, mutex를 획득할수 있어질때)를 설정하고 TASK_UNINTERRUPTIBLE 로 둔다.</li><li>TASK_UNINTERRUPTIBLE 상태의 프로세스가 비정상으로 많은 경우<ul><li>다수의 프로세스들이 뮤텍스를 획득하지 못해 자신을 TASK_UNINTERRUPTIBLE 상태로 바꾸고 휴면 상태에 진입</li><li>I/O 동작 중에 외부 장치와 인터페이싱에 문제가 있음</li></ul></li><li>TASK_RUNNING 상태의 프로세스가 비정상으로 많은 경우<ul><li>특정 프로세스가 CPU를 계속 점유하고 실행중</li><li>인터럽트가 비정상적으로 많이 발생해서 프로세스 선점 스케줄링이 제대로 수행되지 못함.</li></ul></li></ul><h3 id=프로세스-상태-변화>프로세스 상태 변화</h3><pre tabindex=0><code class=language-uml data-lang=uml>@startuml
[*] --&gt; TASK_RUNNING_실행대기
TASK_RUNNING_실행대기 --&gt; TASK_RUNNING_CPU실행 : 1
TASK_RUNNING_CPU실행 --&gt; TASK_INTERRUPTIBLE : 2
TASK_RUNNING_CPU실행 --&gt; TASK_UNINTERRUPTIBLE : 3
TASK_INTERRUPTIBLE --&gt; TASK_RUNNING_실행대기 : 4
TASK_RUNNING_CPU실행 --&gt; TASK_DEAD : 5
TASK_UNINTERRUPTIBLE --&gt; TASK_RUNNING_실행대기
TASK_DEAD --&gt; [*]
@enduml
</code></pre><ul><li><ol><li>실행대기(TASK_RUNNING) -> CPU 실행중(TASK_RUNNING)</li></ol><ul><li>context switching 이라 부르며, CPU register sets을 저장하고, 다음 실행될 THREAD의 CPU register sets을 불러온다.</li></ul></li><li><ol start=2><li>CPU 실행(TASK_RUNNING) -> 휴면(TASK_INTERRUPTIBLE)</li></ol></li><li><ol start=3><li>CPU 실행(TASK_RUNNING) -> 휴면(TASK_UNINTERRUPTIBLE)</li></ol><ul><li>특정 조건에서만 깨어날수 있게 됨</li><li>자신이 깨어날 조건 설정 -> TASK_UNINTERRUPTIBLE 상태로 변경 -> <code>schedule()</code> 함수를 호출해 휴면상태에 진입</li><li>I/O를 실행할때, 뮤텍스를 획득하지 못했을 때</li></ul></li><li><ol start=4><li>휴면(TASK_INTERRUPTIBLE) -> 실행 대기(TASK_RUNNING)</li></ol><ul><li><code>wake_up_process()</code> 함수를 호출해서 프로세스를 깨울때의 상황</li></ul></li><li><ol start=5><li>휴면(TASK_UNINTERRUPTIBLE) -> 실행 대기(TASK_RUNNING)</li></ol><ul><li>I/O 실행 완료 또는 뮤텍스를 해제한 프로세스가 뮤텍스를 기다리고 있는 프로세스를 깨울때</li></ul></li></ul><h3 id=프로세스-상태-변화-함수-목록>프로세스 상태 변화 함수 목록</h3><ul><li>TASK_RUNNING(실행 대기)<ul><li>wake_up_interruptible()</li><li>wake_up_new_task()</li><li>wake_up_process()</li><li>yeild()</li><li>do_nanosleep()</li></ul></li><li>TASK_RUNNING(CPU 실행)<ul><li>schedule()</li></ul></li><li>TASK_INTERRUPTIBLE<ul><li>wait_event_interruptible()</li><li>do_sigtimedwiat()</li><li>sys_pause()</li><li>do_nano_sleep()</li></ul></li><li>TASK_UNINTERRUPTIBLE<ul><li>io_wait_event()</li><li>mutex_lock()</li><li>usleep_range()</li><li>msleep()</li><li>wait_for_completion()</li></ul></li></ul><h3 id=task_running실행-대기으로-바뀔-때-호출되는-함수>TASK_RUNNING(실행 대기)으로 바뀔 때 호출되는 함수</h3><ul><li><p>프로세스를 깨울때</p></li><li><p>프로세스를 처음 생성하고 실행 요청을 할 때</p></li><li><p>프로세스 관련 정보를 업데이트 할때</p></li><li><p>wake_up_new_task()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wake_up_new_task</span>(<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rq_flags rf;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raw_spin_lock_irqsave</span>(<span style=color:#f92672>&amp;</span>p<span style=color:#f92672>-&gt;</span>pi_lock, rf.flags);
</span></span><span style=display:flex><span>  p<span style=color:#f92672>-&gt;</span>state <span style=color:#f92672>=</span> TASK_RUNNING;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>_do_fork 에서 호출됨</li></ul></li><li><p>wake_up_process()</p><ul><li>wake_up_process() -> try_to_wake_up() -> ttwu_do_activate() -> ttwu_do_wakeup()</li><li>ttwu : try to wake up 의 약어</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ttwu_do_wakeup</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> wake_flags,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rq_flags <span style=color:#f92672>*</span>rf)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>check_preempt_curr</span>(rq, p, wake_flags);<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>  p<span style=color:#f92672>-&gt;</span>state <span style=color:#f92672>=</span> TASK_RUNNING;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_sched_wakeup</span>(p);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>yield()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __sched <span style=color:#a6e22e>yield</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_current_state</span>(TASK_RUNNING);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>do_sched_yield</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>do_nanosleep()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __sched <span style=color:#a6e22e>do_nanosleep</span>(<span style=color:#66d9ef>struct</span> hrttimer_sleepr <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>enum</span> hrtimer_mode mode)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> restart_block <span style=color:#f92672>*</span>restart;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__set_current_state</span>(TASK_RUNNING);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=task_runningcpu-실행로-바뀔-때-호출하는-함수>TASK_RUNNING(CPU 실행)로 바뀔 때 호출하는 함수</h3><ul><li>schedule()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __sched notrace <span style=color:#a6e22e>__schedule</span>(<span style=color:#66d9ef>bool</span> preempt)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cput;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cpu <span style=color:#f92672>=</span> <span style=color:#a6e22e>smp_processor_id</span>();
</span></span><span style=display:flex><span>  rq <span style=color:#f92672>=</span> <span style=color:#a6e22e>cpu_rq</span>(cpu);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(prev <span style=color:#f92672>!=</span> next)) {
</span></span><span style=display:flex><span>    rq<span style=color:#f92672>-&gt;</span>nr_switches <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    rq<span style=color:#f92672>-&gt;</span>curr <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Also unlocks the rq: */</span>
</span></span><span style=display:flex><span>    rq <span style=color:#f92672>=</span> <span style=color:#a6e22e>context_switch</span>(rq, prev, next, <span style=color:#f92672>&amp;</span>rf);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=task_interruptible-상태로-바뀔-때-호출하는-함수>TASK_INTERRUPTIBLE 상태로 바뀔 때 호출하는 함수</h3><ul><li>wait_event_interruptible()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define wait_event_interruptible(wq_head, condition)            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>({                                                              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  int __ret = 0;                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  might_sleep();                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  if (!(condition))                                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    __retval = __wait_event_interruptible(wq_head, condition);  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __ret;                                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>})
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define __wait_event_interruptible(wq_head, condition)          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  ___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    schedule())
</span></span></span></code></pre></div><ul><li>___wait_event()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>({                                                                     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __label__ __out;                                                     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  struct wait_queue_entry __wq_entry;                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  long __ret = ret; </span><span style=color:#75715e>/* explicit shadow */</span><span style=color:#75715e>                              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                                                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  for (;;) {                                                           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    long __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    </span><span style=color:#75715e>/* skip */</span><span style=color:#75715e>                                                         \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  }                                                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  finish_wait(&amp;wq_head, &amp;__wq_entry);                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>__out: __ret;                                                          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>})
</span></span></span></code></pre></div><ul><li>prepare_to_wait_event()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>prepare_to_wait_event</span>(<span style=color:#66d9ef>struct</span> wait_queue_head <span style=color:#f92672>*</span>wq_head, <span style=color:#66d9ef>struct</span> wait_queue_entry <span style=color:#f92672>*</span>wq_entry.
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> saste)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_lock_irqsave</span>(<span style=color:#f92672>&amp;</span>wq_head<span style=color:#f92672>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#a6e22e>signal_pending_state</span>(state, current))) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>wq_entry<span style=color:#f92672>-&gt;</span>entry)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (wq_entry<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> WQ_FLAGS_EXCLUSIVE)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>__add_wait_queue_entry_tail</span>(wq_head, wq_entry);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>__add_wait_queue</span>(wq_head, wq_entry);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>set_current_state</span>(state);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>do_sigtimedwait()</li><li>sys_pause()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>SYSCALL_DEFINE0</span>(pause)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>signal_pending</span>(current)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__set_current_state</span>(TASK_INTERRUPTIBLE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>schedule</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ERESTARTNOHAND;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>펜딩된 시그널(자신에게 전달된 시그널)이 없는지 점검</li><li>자신을 TASK_INTERRUPTIBLE(휴면 상태)로 변경</li><li>schedule() 함수를 호출해 휴면상태로 진입</li></ul></li><li>do_nanosleep()</li></ul><h3 id=task_uninterruptible-상태로-바뀔-때-호출하는-함수>TASK_UNINTERRUPTIBLE 상태로 바뀔 때 호출하는 함수</h3><ul><li><p>io_wait_event()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define io_wait_event(wq_head, condition)        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>do {                                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  might_sleep();                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  if (condition)                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    break;                                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  __io_wait_event(wq_head, condition);           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>} while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define __io_wait_event(wq_head, condition)                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>(void)__wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0, \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  io_schedule())
</span></span></span></code></pre></div></li><li><p>mutex_lock()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __sched
</span></span><span style=display:flex><span><span style=color:#a6e22e>__mutex_lock</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock, <span style=color:#66d9ef>long</span> state, unsgined <span style=color:#66d9ef>int</span> subclass,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> lockdep_map <span style=color:#f92672>*</span>nest_lock, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ip)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>__mutex_lock_common</span>(lock, state, subclass, nest_lock, ip, NULL, false);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>int</span> __sched
</span></span><span style=display:flex><span><span style=color:#a6e22e>__mutex_lock_common</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock, <span style=color:#66d9ef>long</span> state, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> subclass,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> lockdep_map <span style=color:#f92672>*</span>nest_lock, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ip,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> ww_acquire_ctx <span style=color:#f92672>*</span>ww_ctx, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> use_ww_ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_current_state</span>(state);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>schedule_preempt_disabled</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>usleep_range()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __sched <span style=color:#a6e22e>usleep_range</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> min, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> max)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ktime_t</span> exp <span style=color:#f92672>=</span> <span style=color:#a6e22e>ktime_add_us</span>(<span style=color:#a6e22e>ktime_get</span>(), min);
</span></span><span style=display:flex><span>  u64 delta <span style=color:#f92672>=</span> (u64)(max <span style=color:#f92672>-</span> min) <span style=color:#f92672>*</span> NSEC_PER_USEC;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__set_current_state</span>(TASK_UNINTERRUPTIBLE);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Do not return before teh requested sleep time has elapsed */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>schedule_hrtimeout_range</span>(<span style=color:#f92672>&amp;</span> exp, delta, HRTIMER_MODE_ABS))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>msleep()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>msleep</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> msec)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> timeout <span style=color:#f92672>=</span> <span style=color:#a6e22e>msecs_to_jiffies</span>(msecs) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (timeout)
</span></span><span style=display:flex><span>    timeout <span style=color:#f92672>=</span> <span style=color:#a6e22e>schedule_timeout_uninterruptible</span>(timeout);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>long</span> __sched <span style=color:#a6e22e>schedule_timeout_uninterruptible</span>(<span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>long</span> timeout)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__set_current_state</span>(TASK_UNINTERRUPTIBLE);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>schedule_timeout</span>(timeout);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>wait_for_completion()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __sched <span style=color:#a6e22e>wait_for_completion</span>(<span style=color:#66d9ef>struct</span> completion <span style=color:#f92672>*</span>x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>wait_for_common</span>(x, MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=스케줄러-클래스-1>스케줄러 클래스</h2><ul><li>프로세스가 스케줄러 클래스르 ㄹ통해 유연하게 스케줄러를 바꾸게 지원하기 위해서</li></ul><h3 id=sched_class-구조체>sched_class 구조체</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sched_class {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>enqueue_task) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> flags);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>dequeue_task) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> flags);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>yield_task) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> (<span style=color:#f92672>*</span>yeild_to_task) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>bool</span> preempt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>check_preempt_curr) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span> (<span style=color:#f92672>*</span>pick_next_task) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq,
</span></span><span style=display:flex><span>                                       <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>prev,
</span></span><span style=display:flex><span>                                       <span style=color:#66d9ef>struct</span> rq_flags <span style=color:#f92672>*</span>rf);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>put_prev_task) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>select_task_rq) (<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> task_cpu, <span style=color:#66d9ef>int</span> sd_flag, <span style=color:#66d9ef>int</span> flags);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>migrate_task_rq) (<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>task_woken) (<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>this_rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>task);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>set_cpus_allowed)(<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> cpumask <span style=color:#f92672>*</span>newmask);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>enqueue_task : 프로세스가 실행 가능한 상태로 진입</li><li>dequeue_task : 프로세스가 더 이상 실행 가능한 상태가 아닐 때</li><li>yeild_task : 프로세스가 스스로 yield() 시스템 콜을 실행했을 때</li><li>check_preempt_curr : 현재 실행 중인 프로세스를 선점할 수 있는지 검사</li><li>pick_next_task : 실행할 다음 프로세스를 선택</li><li>put_prev_task : 실행 중인 프로세스를 다시 내부 자료구조(런큐)에 삽입</li><li>load_balance : 코어 스케줄러가 태스크 부하를 분산하고자 할 때<ul><li><a href=http://jake.dothome.co.kr/load-balance-1/>참고-문C블로그</a></li><li>Passive Balancing : Fork Balancing, Exec Balancing, Wake Balancing, Idle Balancing</li><li>Periodic Balancing</li></ul></li><li>set_current_task : 프로세스의 스케줄러 클래스나 태스크 그룹을 바꿀 때</li><li>task_tick : 타이머 틱 함수를 호출</li></ul><h3 id=5가지-스케줄러-클래스>5가지 스케줄러 클래스</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class stop_sched_class;
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class dl_sched_class;
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class rt_sched_class;
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class fair_sched_class;
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class idle_sched_class;
</span></span></code></pre></div><ul><li>리눅스 시스템에서 전체 프로세스 가운데 RT 클래스 프로세스와 CFS 클래스 프로세스의 비율 : 99% 는 CFS, 1%정도가 나머지 그마저도 대부분 RT</li></ul><h4 id=스케줄러-클래스의-우선-순위>스케줄러 클래스의 우선 순위</h4><ul><li>stop -> dl -> rt -> fair -> idle</li><li>struct 내부 변수 next를 사용해서 다음 우선 순위의 스케줄러를 가르킨다.</li></ul><h3 id=프로세스를-스케줄러에-등록>프로세스를 스케줄러에 등록</h3><ul><li><ol><li>스케줄러 클래스 설정</li></ol><ul><li>sched_fork()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sched_fork</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> clone_flags, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>dl_prio</span>(p<span style=color:#f92672>-&gt;</span>prio))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EAGAIN;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>rt_prio</span>(p<span style=color:#f92672>-&gt;</span>prio))
</span></span><span style=display:flex><span>    p<span style=color:#f92672>-&gt;</span>sched_class <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>rt_sched_class;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    p<span style=color:#f92672>-&gt;</span>sched_class <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>fair_sched_class;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><ol start=2><li>스케줄러 클래스 변경</li></ol><ul><li>__setscheduler()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__setscheduler</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p,
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_attr <span style=color:#f92672>*</span>attr, <span style=color:#66d9ef>bool</span> keep_boost)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__setscheduler_params</span>(p, attr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p<span style=color:#f92672>-&gt;</span>prio <span style=color:#f92672>=</span> <span style=color:#a6e22e>normal_prio</span>(p);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (keep_boost)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>-&gt;</span>prio <span style=color:#f92672>=</span> <span style=color:#a6e22e>rt_effective_prio</span>(p, p<span style=color:#f92672>-&gt;</span>prio);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>dl_prio</span>(p<span style=color:#f92672>-&gt;</span>prio))
</span></span><span style=display:flex><span>    p<span style=color:#f92672>-&gt;</span>sched_class <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>dl_sched_class;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>rt_prio</span>(p<span style=color:#f92672>-&gt;</span>prio))
</span></span><span style=display:flex><span>    p<span style=color:#f92672>-&gt;</span>sched_class <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>rt_sched_class;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    p<span style=color:#f92672>-&gt;</span>sched_class <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>fair_sched_class;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><h3 id=세부-함수-호출>세부 함수 호출</h3><ul><li>enqueue_task()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>enqueue_task</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(flags <span style=color:#f92672>&amp;</span> ENQUEUE_NOCLOCK))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>update_rq_clock</span>(rq);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(flags <span style=color:#f92672>&amp;</span> ENQUEUE_RESTOR))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sched_info_queued</span>(rq, p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p<span style=color:#f92672>-&gt;</span>sched_class<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>enqueue_task</span>(rq, p, flags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>dequeue_task()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dequeue_task</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p, <span style=color:#66d9ef>int</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>flags <span style=color:#f92672>&amp;</span> DEQUEUE_NOCLOCK)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>update_rq_clock</span>(rq);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(flags <span style=color:#f92672>&amp;</span> DEQUEUE_SAVE))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sched_info_dequeued</span>(rq, p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p<span style=color:#f92672>-&gt;</span>shced_class<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>dequeue_task</span>(rq, p, flags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=런큐-1>런큐</h2><ul><li>percpu 타입의 전역변수</li><li>RT, CFS, Deadline 서브 런큐를 관리</li><li>실행 요청을 한 프로세스가 런큐에 삽입됨</li><li>CPU를 점유하면서 실행 중인 current 프로세스를 관리</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> rq {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>raw_spinlock_t</span> lock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> nr_running;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> load_wait load;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> nr_load_updates;
</span></span><span style=display:flex><span>  u64 nr_switches;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> cfs_rq cfs;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rt_rq rt;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> dl_rq dl;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> nr_uninterruptible;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>curr, <span style=color:#f92672>*</span>dle, <span style=color:#f92672>*</span>stop;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>lock : 런큐 자료구조를 변경할 때 경쟁 조건을 피하기 위한 락</li><li>nr_running : 런큐에 삽입된 모든 프로세스 개수</li><li>nr_switches : 컨텍스트 스위칭을 수행한 개수</li><li>cfs, rt : cfs, rt 런큐</li><li>nr_uninterruptible : 런큐에 있는 태스크 중 TASK_UNINTERRUPTIBLE 상태의 프로세스 개수</li><li>curr : 해당 런큐에서 CPU를 점유하면서 실행 중인 프로세스의 태스크 디스크립터</li><li>idle : idle 프로세스의 태스크 디스크립터</li><li>cfs_task : cfs 런큐에 삽입된 모든 일반 프로세스의 연결 리스트</li></ul><h3 id=runqueues-변수>runqueues 변수</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>DECLARE_PER_CPU_SHARED_ALIGNED</span>(<span style=color:#66d9ef>struct</span> rq, runqueues);
</span></span><span style=display:flex><span><span style=color:#75715e>#define cpu_rq(cpu) (&amp;per_cpu(runqueues, (cpu)))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define this_rq() this_cpu_ptr(&amp;runqueues)
</span></span></span></code></pre></div><h2 id=cfs-스케줄러>CFS 스케줄러</h2><ul><li>CFS(Completely Fair Scheduler)</li><li>2.6.23 버전 이후로 적용된 리눅스 기본 스케줄러</li><li>특징<ul><li>타임 슬라이스 : 스케줄러가 프로세스에게 부여한 실행 시간</li><li>우선순위<ul><li>우선순위가 높은 프로세스에 대해 가장 먼저 CPU 에서 실행 시키고, 더 많은 타임 슬라이스를 할당해준다.</li></ul></li><li>가상 실행 시간(vruntime)<ul><li>프로세스가 그동안 실행 시간을 정규화한 시간 정보</li></ul></li></ul></li></ul><h3 id=cfs-스케줄러-알고리즘>CFS 스케줄러 알고리즘</h3><ul><li><p>load weight : 프로세스의 우선순위에 주는 가중치</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_load_weight</span>(<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> prio <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>static_prio <span style=color:#f92672>-</span> MAX_RT_PRIO;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> load_weight <span style=color:#f92672>*</span>load <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>p<span style=color:#f92672>-&gt;</span>se.load;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (update_load <span style=color:#f92672>&amp;&amp;</span> p<span style=color:#f92672>-&gt;</span>sched_class <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>fiar_sched_class) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reweight_task</span>(p, prio);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    load<span style=color:#f92672>-&gt;</span>weight <span style=color:#f92672>=</span> <span style=color:#a6e22e>scale_load</span>(sched_prio_to_weight[prio]);
</span></span><span style=display:flex><span>    load<span style=color:#f92672>-&gt;</span>inv_weight <span style=color:#f92672>=</span> sched_prio_to_wmult[prio];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>타임 슬라이스</p><ul><li>$$(time slice) = \frac{(load weight of process)}{(sum of load weight in CFS runqueue)} \time (scheduling latency)$$</li></ul></li><li><p>vruntime : 프로세스가 그동안 실행한 시간을 정규화한 시간 정보</p></li><li><p>CFS 스케줄러는 런큐에 등록된 프로세스 중 vruntime이 가장 작은 프로세스를 다음에 실행할 프로세스로 선택</p></li><li><p>update_curr()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_curr</span>(<span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  u64 delta_exec;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  curr<span style=color:#f92672>-&gt;</span>vruntime <span style=color:#f92672>+=</span> <span style=color:#a6e22e>calc_delta_fair</span>(delta_exec, curr);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> u64 <span style=color:#a6e22e>calc_delta_fair</span>(u64 delta, <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>se)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(se<span style=color:#f92672>-&gt;</span>load.weight <span style=color:#f92672>!=</span> NICE_0_LOAD))
</span></span><span style=display:flex><span>    delta <span style=color:#f92672>=</span> <span style=color:#a6e22e>__cal_delta</span>(delta, NICE_0_Load, <span style=color:#f92672>&amp;</span>se<span style=color:#f92672>-&gt;</span>load);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> delta;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>$$vruntime += delta_exc * \frac{1024}{load weight}$$</li></ul></li><li><p>위의 공식대로라면, 휴면상태였던 프로세스 또는 새롭게 생성된 프로세스는 CPU를 더 많이 할당받게 된다. 따라서 주기적으로 vruntime의 최소값을 설정해준다.</p></li><li><p>update_min_vruntime()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_min_vruntime</span>(<span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> cfs_rq<span style=color:#f92672>-&gt;</span>curr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rb_node <span style=color:#f92672>*</span>leftmost <span style=color:#f92672>=</span> <span style=color:#a6e22e>rb_first_cached</span>(<span style=color:#f92672>&amp;</span>cfs_rq<span style=color:#f92672>-&gt;</span>tasks_timeline);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u64 vruntime <span style=color:#f92672>=</span> cfs_rq<span style=color:#f92672>-&gt;</span>min_vruntime;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* ensure we never gain time by being placed backwards. */</span>
</span></span><span style=display:flex><span>  cfs_rq<span style=color:#f92672>-&gt;</span>min_vruntime <span style=color:#f92672>=</span> <span style=color:#a6e22e>max_vruntime</span>(cfs_rq<span style=color:#f92672>-&gt;</span>min_vruntime, vruntime);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=cfs-관련-세부-함수>CFS 관련 세부 함수</h3><h4 id=타임-슬라이스-관리>타임 슬라이스 관리</h4><ul><li>프로세스가 타임 슬라이스를 소진했는지 점검, 프로세스의 타임 슬라이스를 업데이트, 타임 슬라이스를 모두 소진한 프로세스를 선점될 조건임을 마킹</li><li>scheduler_tick()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>scheduler_tick</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cpu <span style=color:#f92672>=</span> <span style=color:#a6e22e>smp_processor_id</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq <span style=color:#f92672>=</span> <span style=color:#a6e22e>cpu_rq</span>(cpu);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> rq<span style=color:#f92672>-&gt;</span>curr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rq_flags rf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sched_clock_tick</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rq_lock</span>(rq, <span style=color:#f92672>&amp;</span>rf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>update_rq_clock</span>(rq);
</span></span><span style=display:flex><span>  curr<span style=color:#f92672>-&gt;</span>sched_class<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>task_tick</span>(rq, curr, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>task_tick_fair()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>task_tick_fair</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>curr, <span style=color:#66d9ef>int</span> queued)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> shced_entity <span style=color:#f92672>*</span>se <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>curr<span style=color:#f92672>-&gt;</span>se;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>for_each_sched_entity</span>(se) {
</span></span><span style=display:flex><span>    cfs_rq <span style=color:#f92672>=</span> <span style=color:#a6e22e>cfs_rq_of</span>(se);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>entity_tick</span>(cfs_rq, se, queued);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>eneity_tick()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>entity_tick</span>(<span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq, <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>curr, <span style=color:#66d9ef>int</span> queued)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>update_curr</span>(cfs_rq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>update_load_avg</span>(curr, UPDATE_TG);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>update_cfs_shares</span>(curr);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (cfs_rq<span style=color:#f92672>-&gt;</span>nr_running <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>check_preempt_tick</span>(cfs_rq, curr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li>check_preempt_tick()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>check_preempt_tick</span>(<span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq, <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>curr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ideal_runtime, delta_exec;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>se;
</span></span><span style=display:flex><span>  s64 delta;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ideal_runtime <span style=color:#f92672>=</span> <span style=color:#a6e22e>sched_slice</span>(cfs_rq, curr);
</span></span><span style=display:flex><span>  delta_exec <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>sum_exec_runtime <span style=color:#f92672>-</span> curr<span style=color:#f92672>-&gt;</span>prev_sum_exec_runtime;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (delta_exec <span style=color:#f92672>&gt;</span> ideal_runtime) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resched_curr</span>(<span style=color:#a6e22e>rq_of</span>(cfs_rq));
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (delta_exec <span style=color:#f92672>&lt;</span> sysctl_sched_min_granularity)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  se <span style=color:#f92672>=</span> <span style=color:#a6e22e>__pick_first_entity</span>(cfs_rq);
</span></span><span style=display:flex><span>  delta <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>vruntime <span style=color:#f92672>-</span> se<span style=color:#f92672>-&gt;</span>vruntime;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (delta <span style=color:#f92672>&lt;</span> e)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (delta <span style=color:#f92672>&gt;</span> ideal_runtime)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resched_curr</span>(<span style=color:#a6e22e>rq_off</span>(cfs_rq));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><ol><li>프로세스가 소진한 타임 슬라이스 읽기</li></ol></li><li><ol start=2><li>프로세스 선점 요청 : 프로세스가 타임 슬라이스를 모두 소진했으면 선점 요청을 한다.</li></ol></li><li>프로세스가 선점 요청을 하면, 인터럽트를 핸들링한 후 또는 시스템 콜을 핸들링한 후 유저 공간으로 복귀하기 전에 프로세스가 선점된다.</li></ul></li></ul><h4 id=vruntime-관리와-관련된-세부-함수>vruntime 관리와 관련된 세부 함수</h4><ul><li>프로세스를 vruntime 기준으로 CFS 런큐의 레드 블랙 트리에 등록</li><li>CFS가 다음 프로세스를 레드 블랙 트리에서 선택(pick)하는 과정</li><li>enqueue_entity()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>enqueue_entity</span>(<span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq, <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>se, <span style=color:#66d9ef>int</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> renorm <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>(flags <span style=color:#f92672>&amp;</span> ENQUEUE_WAKEUP) <span style=color:#f92672>||</span> (flags <span style=color:#f92672>&amp;</span> ENQUEUE_MIGRATED);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> curr <span style=color:#f92672>=</span> cfs_rq<span style=color:#f92672>-&gt;</span>curr <span style=color:#f92672>==</span> se;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>update_curr</span>(cfs_rq);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>account_tntity_enqueue</span>(cfs_rq, se);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>curr)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__enqueue_entity</span>(cfs_rq, se);
</span></span><span style=display:flex><span>  se<span style=color:#f92672>-&gt;</span>on_rq <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>__enqueue_entity()<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__enqueue_entity</span>(<span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq, <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>se)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rb_node <span style=color:#f92672>**</span>link <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cfs_rq<span style=color:#f92672>-&gt;</span>tasks_timeline.rb_root.rb_node;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> rb_node <span style=color:#f92672>*</span>parent <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> shced_entity <span style=color:#f92672>*</span>entry;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> leftmost <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#f92672>*</span>link) {
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>link;
</span></span><span style=display:flex><span>    entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>rb_entry</span>(parent, <span style=color:#66d9ef>struct</span> sched_entity, run_node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>entity_before</span>(se, entry)) {
</span></span><span style=display:flex><span>      link <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>parent<span style=color:#f92672>-&gt;</span>rb_left;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      link <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>parent<span style=color:#f92672>-&gt;</span>rb_right;
</span></span><span style=display:flex><span>      leftmost <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rb_link_node</span>(<span style=color:#f92672>&amp;</span>se<span style=color:#f92672>-&gt;</span>run_node, parent, link);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rb_insert_color_cached</span>(<span style=color:#f92672>&amp;</span>se<span style=color:#f92672>-&gt;</span>run_node,
</span></span><span style=display:flex><span>                    <span style=color:#f92672>&amp;</span>cfs_rq<span style=color:#f92672>-&gt;</span>tasks_timeline, leftmost);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=선점-스케줄링>선점 스케줄링</h2><ul><li>선점 스케줄링 : CPU에서 실행 중인 프로세스를 비우고 새로운 프로세스를 CPU에서 실행시킴</li></ul><h3 id=선점-스케줄링-진입점>선점 스케줄링 진입점</h3><ul><li>인터럽트 핸들링 후 : 인터럽트 핸들러를 실행한 후 실행을 멈춘 프로세스로 복귀하기 전</li><li>시스템 콜 핸들링 후 : 시스템 콜 함수를 처리한 후 유저 공간으로 복귀하기 직전</li></ul><h4 id=선점-스케줄링의-진입점커널-모드-중-인터럽트-발생>선점 스케줄링의 진입점:커널 모드 중 인터럽트 발생</h4><ul><li>arm 기준<ul><li><p>인터럽트가 발생하면 실행되는 __irq_svc 레이블에서 선점 스케줄링을 시작한다.:</p><ol><li>인터럽트 발생 후 인터럽트 핸들러 처리</li><li>프로세스 선점 스케줄링 조건 점검</li><li>프로세스 선점 스케줄링 실행</li></ol></li><li><p><code>__irq_svc</code>:</p><pre tabindex=0><code>__irq_svc:
  svc_entry
  irq_handler

#ifdef CONFIG_PREEMPTION
  ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
  ldr	r0, [tsk, #TI_FLAGS]		@ get flags
  teq	r8, #0				@ if preempt count != 0
  movne	r0, #0				@ force flags to 0
  tst	r0, #_TIF_NEED_RESCHED
  blne	svc_preempt
#endif

svc_exit r5, irq = 1			@ return from exception
UNWIND(.fnend		)
ENDPROC(__irq_svc)
</code></pre></li><li><p>책은 라즈베리 파이를 기준으로 하는데, 책에서는 CONFIG_PREEMPT가 비활서오하 되어 있어서, 커널 코드가 실행되는 도중 인터럽트가 발생했을 때 선점 스케줄링을 시도하지 않는다.</p></li><li><p>하지만 대부분의 상용 리눅스 시스템에서는 CONFIG_PREEMPT가 활성화 되어 있다고 한다.</p></li><li><p>어셈블리를 해석해보면 r8 이 0이고 r0 & TIF_NEED_RESCHED 이 0이 아니라면 <code>svc_preempt()</code>를 호출하는 구조이다.</p></li><li><p><code>svc_preempt</code>:</p><pre tabindex=0><code>#ifdef CONFIG_PREEMPTION
svc_preempt:
  mov	r8, lr
1:	bl	preempt_schedule_irq		@ irq en/disable is done inside
  ldr	r0, [tsk, #TI_FLAGS]		@ get new tasks TI_FLAGS
  tst	r0, #_TIF_NEED_RESCHED
  reteq	r8				@ go again
  b	1b
#endif
</code></pre></li><li><p>그냥 preempt_schedule_irq 호출 하고 return하는 코드들이다.</p></li><li><p>여기까지가 architecture별로 다른 부분이고 preempt_schedule_irq() 부터는 다시 공통 c 코드로 돌아간다.</p></li></ul></li><li>x86 기준:<ul><li>잡담 : 문서를 읽기 싫어서 사고 과정이 다음과 같았습니다. preempt_schedule_irq()는 공통 코드니까 이걸 호출하는 부분을 x86에서 찾으면 되겠다.</li><li>근데 common 을 사용하는 거 같기는 한데 정확히는 못찾았다. ㅠㅠ 일단 한시간 동안 이걸 찾는데 실패했으니 오늘은 여기까지</li></ul></li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>