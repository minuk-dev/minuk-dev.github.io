<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>linux-debug/timer</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>linux-debug/timer
</a><button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[debug-linux]]</button></div></div></div><div><h2>linux-debug/timer</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/linux-debug/timer.md><h5>created : Tue, 10 Nov 2020 23:57:38 +0900</h5><h5>modified : Wed, 09 Dec 2020 13:31:16 +0900</h5></a><a href=https://minuk.dev/tags/linux-debug><kbd class=item-tag>linux-debug</kbd></a>
<a href=https://minuk.dev/tags/timer><kbd class=item-tag>timer</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><ul><li><a href=#커널-타이머-관리>커널 타이머 관리</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h3 id=커널-타이머-관리>커널 타이머 관리</h3><ul><li>주요 개념<ul><li>HZ와 jiffies</li><li>Soft IRQ 서비스</li><li>커널 타이버를 이루는 자료구조</li><li>동적 타이머</li></ul></li><li>HZ : 1초에 jiffies가 업데이트되는 횟수</li><li>Soft IRQ의 타이머 서비스<ol><li>타이머 인터럽트가 발생하면 TIMER_SOFTIRQ라는 Soft IRQ 서비스를 요청합니다.</li><li>Soft IRQ 서비스 루틴에서 TIMER_SOFTIRQ 서비스의 아이디 핸들러인 run_timer_softirq() 함수를 호출한다.</li><li>run_timer_softirq() 함수에서는 time_bases라는 전역변수에 등록된 동적 타이머를 처리합니다.</li></ol></li><li>이외의 시간을 처리하는 기법<ul><li>SoC(Sytem on chip)에서 제공하는 틱 디바이스, timekeeping, 고해상도 타이머(High Resolution Timer)</li></ul></li></ul><h4 id=jiffies>jiffies</h4><ul><li><p>HZ가 너무 크면 시스템에 오버헤드, 너무 작으면 동적 타이머의 오차가 커짐.</p></li><li><p><code>out/.config</code> 에서 <code>CONFIG_HZ=100</code> 같은 구문에서 확인 가능하다.</p></li><li><p>jiffies로 시간 흐름을 제어하는 코드 분석</p><ul><li>mod_timer()</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> timer_list dynamic_timer
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> timeout <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>timeout <span style=color:#f92672>=</span> jiffies;
</span></span><span style=display:flex><span>timeout <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> HZ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mod_timer</span>(<span style=color:#f92672>&amp;</span>dynamic_timer, timeout);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mod_timer</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> expires);
</span></span></code></pre></div></li><li><p>jffieis 와 jiffies_64 변수</p><ul><li>System.map 파일<pre tabindex=0><code>80c03d00 D jiffies
80c03d00 D jiffies_64
</code></pre></li></ul></li><li><p>do_timer</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_timer</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ticks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  jiffies_64 <span style=color:#f92672>+=</span> ticks;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>calc_global_load</span>(ticks);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tick_do_update_jiffies64</span>(<span style=color:#66d9ef>ktime_t</span> now)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (delta <span style=color:#f92672>&gt;=</span> tick_period) {
</span></span><span style=display:flex><span>    delta <span style=color:#f92672>=</span> <span style=color:#a6e22e>ktime_sub</span>(delta, tick_period);
</span></span><span style=display:flex><span>    last_jiffies_update <span style=color:#f92672>=</span> <span style=color:#a6e22e>ktime_add</span>(last_jiffies_update,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>do_timer</span>(<span style=color:#f92672>++</span>ticks);
</span></span><span style=display:flex><span><span style=color:#75715e>/* skip */</span>
</span></span></code></pre></div></li><li><p>msecs_to_jiffies()</p><ul><li><p>밀리초를 입력으로 받아 jiffies 단위 시각 정보를 반환</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>msecs_to_jiffies</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> m);
</span></span></code></pre></div></li><li><p>사용 예제</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>msecs_to_jiffies</span>(ms);
</span></span></code></pre></div></li><li><p>구현부</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>msecs_to_jiffies</span>(cosnt <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> m)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>__builtin_constant_p</span>(m)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((<span style=color:#66d9ef>int</span>)m <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> MAX_JIFFY_OFFSET;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>_msecs_to_jiffies</span>(m);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>__msecs_to_jiffies</span>(m);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define MAX_JIFFY_OFFSET ((LONG_MAX &gt;&gt; 1)-1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define LONG_MAX ((long)(~0UL&gt;&gt;1))
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>_msecs_to_jiffies</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> m)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (m <span style=color:#f92672>+</span> (MSEC_PER_SEC <span style=color:#f92672>/</span> HZ) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> (MSEC_PER_SEC <span style=color:#f92672>/</span> HZ);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>time_after(), time_before()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define time_after(a,b)    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (typecheck(unsigned long, a) &amp;&amp; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  typecheck(unsigned long, b) &amp;&amp; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  ((long)((b) - (a)) &lt; 0))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define time_before(a,b) time_after(b,a)
</span></span></span></code></pre></div></li></ul><h4 id=동적-타이머-초기화>동적 타이머 초기화</h4><ul><li><p>기본 흐름</p><ol><li>동적 타이머 초기화 : 동적 타이머 초기화는 보통 드라이 버레벨에서 수행한다. 동적 타이머를 나타내는 timer_list 구조체의 필드 중에서 flags와 function만 바뀐다.</li><li>동적 타이머 등록 : 동적 타이머도 마찬가지로 드라이버 레벨에서 등록된다. 각 드라이버의 시나리오에 따라 동적 타이머의 만료 시간을 1/HZ 단위로 지정한 다음 add_timer() 함수를 호출한다.</li><li>동적 타이머 실행 : 동적 타이머가 지정한 만료 시각이 되면 Soft IRQ 타이머 서비스가 동적 타이머를 실행한다.</li></ol></li><li><p>동적 타이머 자료구조</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> timer_list {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> hlist_node    entry;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>        expries;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span>                 (<span style=color:#f92672>*</span>function)(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>  u32                  flags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_LOCKDEP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> lockdep_map   lockdep_map;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><ul><li>entry : 해시 연결리스트, timer_bases 전역변수 에동적 타이머를 등록할 때 쓰인다.</li><li>expires : 동적 타이머 만료시각을 나타낸다. 이 시각에 커널 타이머가 동적 타이머의 핸들러 함수를 호출한다. 이때 단위는 1/HZ</li><li>function : 동적 타이머 핸들러 함수의 주소를 저장하는 필드. call_tiemr_fn() 함수에 서이 필드에 접근해 동적 타이머 핸들러를 호출한다.</li><li>flags : 동적 타이머의 설정 필드이며 다음 값 중 하나로 설정된다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define TIMER_CPUMASK      0x0003FFFF
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_MIGRATING    0x00040000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_BASEMASK     (TIMER_CPUMASK | TIMER_MIGRATING)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_DEFERRABLE   0x00080000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_PINNED       0x00100000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_IRQSAFE      0x00200000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_ARRAYSHIFT   22
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMER_ARRAYMASK    0xFFC00000
</span></span></span></code></pre></div></li></ul></li><li><p>동적 타이머 초기화 함수</p><ul><li><p>timer_setup()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>timer_setup</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>func, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags);
</span></span></code></pre></div><ul><li>timer : 동적 타이머를 나타내는 정보</li><li>func : 동적 타이머 핸들러 함수</li><li>flags : 동적 타이머 플레그</li><li>커널 4.14 버전까지 동적 타이머를 초기화하려면 setup_timer() 함수나 init_timer() 함수를 써야됬다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define timer_setup(timer, callback, flags)       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    __init_timer((timer), (callback), (flags))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define __init_timer(_timer, _fn, _flags) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  init_timer_key((_timer), (_fn), (_flags), NULL, NULL)
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_timer_key</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer,
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>), <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags,
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>struct</span> lock_class_key <span style=color:#f92672>*</span>key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>debug_init</span>(timer);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>do_init_timer</span>(timer, func, flags, name, key);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>debug_init</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>debug_timer_init</span>(timer);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_timer_init</span>(timer);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_init_timer</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>struct</span> lock_class_key <span style=color:#f92672>*</span>key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  timer<span style=color:#f92672>-&gt;</span>entry.pprev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  timer<span style=color:#f92672>-&gt;</span>function <span style=color:#f92672>=</span> func;
</span></span><span style=display:flex><span>  timer<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>=</span> flags <span style=color:#f92672>|</span> <span style=color:#a6e22e>raw_smp_processor_id</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>lockdep_init_map</span>(<span style=color:#f92672>&amp;</span>timer<span style=color:#f92672>-&gt;</span>lockdep_map, name, key, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><h4 id=동적타이머-등록>동적타이머 등록</h4><ul><li><p>동적 타이머 등록 함수</p><ul><li><p>add_timer : 동적타이머를 등록하기 위한 인터페이스</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_timer</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#a6e22e>timer_pending</span>(timer));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mod_timer</span>(timer, timer<span style=color:#f92672>-&gt;</span>expires);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>mod_timer</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mod_timer</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> expires)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>__mod_timer</span>(timer, expires, false);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>__mod_timer : 실제로 동적타이머를 등록하는 함수</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>__mod_timer</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> expires, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> options)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base, <span style=color:#f92672>*</span>new_base;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> UINT_MAX;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> clk <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, flags;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>BUG_ON</span>(<span style=color:#f92672>!</span>timer<span style=color:#f92672>-&gt;</span>function);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>timer_pending</span>(timer)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> diff <span style=color:#f92672>=</span> timer<span style=color:#f92672>-&gt;</span>expires <span style=color:#f92672>-</span> expires;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>diff)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (options <span style=color:#f92672>&amp;</span> MOD_TIMER_REDUCE <span style=color:#f92672>&amp;&amp;</span> diff <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    base <span style=color:#f92672>=</span> <span style=color:#a6e22e>lock_timer_base</span>(timer, <span style=color:#f92672>&amp;</span>flgas);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>forward_timer_base</span>(base);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>timer_pending</span>(timer) <span style=color:#f92672>&amp;&amp;</span> (options <span style=color:#f92672>&amp;</span> MOD_TIMER_REDUCE) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>time_before_eq</span>(timer<span style=color:#f92672>-&gt;</span>expires, expires)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> out_unlock;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    clk <span style=color:#f92672>=</span> base<span style=color:#f92672>-&gt;</span>clk;
</span></span><span style=display:flex><span>    idx <span style=color:#f92672>=</span> <span style=color:#a6e22e>calc_wheel_index</span>(expires, clk);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    base <span style=color:#f92672>=</span> <span style=color:#a6e22e>lock_timer_base</span>(timer, <span style=color:#f92672>&amp;</span>flags);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>forward_timer_base</span>(base);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>detach_if_pending</span>(timer, base, false);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>debug_active</span>(timer, expires);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  timer<span style=color:#f92672>-&gt;</span>expires <span style=color:#f92672>=</span> expires;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (idx <span style=color:#f92672>!=</span> UINT_MAX <span style=color:#f92672>&amp;&amp;</span> clk <span style=color:#f92672>==</span> base<span style=color:#f92672>-&gt;</span>clk) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>enqueue_timer</span>(base, timer, idx);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>trigger_dyntick_cpu</span>(base, timer);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>internal_add_timer</span>(base, timer);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>out_unlock:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raw_spin_unlock_irqrestore</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>반복해서 동적 타이머를 등록하면 1을 반환하며 실행을 종료</li><li>동적 타이머는 timer_base 타이머 해시 벡터에 등록함</li></ul></li></ul></li><li><p>timer_pending() : 동적 타이머가 등록됬는지 확인하는 함수</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>timer_pending</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span> timer)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> timer<span style=color:#f92672>-&gt;</span>entry.pprev <span style=color:#f92672>!=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>이미 동적 타이머를 등록했을 때 1을 반환</li><li>timer->entry.pprev 포인터는 percpu 타입의 timer_base 변수의 벡터 해시 테이블의 주소를 가리킨다.</li></ul></li><li><p>lock_timer_base()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span><span style=color:#a6e22e>lock_timer_base</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer,
</span></span><span style=display:flex><span>                                      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>flags)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__acquires</span>(timer<span style=color:#f92672>-&gt;</span>base<span style=color:#f92672>-&gt;</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(tf <span style=color:#f92672>&amp;</span> TIMER_MIGRATING)) {
</span></span><span style=display:flex><span>      base <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_timer_base</span>(tf);
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* skip */</span>
</span></span></code></pre></div></li><li><p>get_timer_base() : 타이머가 기준으로 하는 timer_bases 전역변수를 읽는다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span><span style=color:#a6e22e>get_timer_base</span>(u32 tflags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>get_timer_cpu_base</span>(tflags, tflags <span style=color:#f92672>&amp;</span> TIMER_CPUMASK);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>get_timer_cpu_base()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span><span style=color:#a6e22e>get_timer_cpu_base</span>(u32 flags, u32 cpu)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#a6e22e>per_cpu_ptr</span>(<span style=color:#f92672>&amp;</span>timer_bases[BASE_STD], cpu);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> base;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>forward_timer_base() : timer_base의 clk 필드를 현재 시각으로 바꾼다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>forward_timer_base</span>(<span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_NO_HZ_COMMON
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> jnow;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  jnow <span style=color:#f92672>=</span> <span style=color:#a6e22e>READ_ONCE</span>(jiffies);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>time_after</span>(base<span style=color:#f92672>-&gt;</span>next_expiry, jnow))
</span></span><span style=display:flex><span>    back<span style=color:#f92672>-&gt;</span>clk <span style=color:#f92672>=</span> jnow;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    base<span style=color:#f92672>-&gt;</span>clk <span style=color:#f92672>=</span> base<span style=color:#f92672>-&gt;</span>next_expiry;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li><li><p>enqueue_timer()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>enqueue_timer</span>(<span style=color:#66d9ef>struct</span> timer_bae <span style=color:#f92672>*</span>base, <span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> idx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>hlist_add_head</span>(<span style=color:#f92672>&amp;</span>timer<span style=color:#f92672>-&gt;</span>entry, base<span style=color:#f92672>-&gt;</span>vectors <span style=color:#f92672>+</span> idx);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__set_bit</span>(idx, base<span style=color:#f92672>-&gt;</span>pending_map);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timer_set_idx</span>(timer, idx);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>base : percpu 타입의 timer_bases 전역변수에서 현재 구동중인 CPU에 해당하는 오프셋을 적용한 주소</li><li>timer : 등록하려는 동적 타이머의 속성 정보</li></ul></li></ul><h4 id=동적타이머-실행>동적타이머 실행</h4><ol><li>TIMER_SOFTIRQ 아이디로 Soft IRQ 서비스 요청</li><li>Soft IRQ 컨텍스트 시작</li><li>Soft IRQ 서비스 요청 점검</li><li>등록된 동적 타이머 실행</li></ol><ul><li><p>update_process_times()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_process_times</span>(<span style=color:#66d9ef>int</span> user_tick)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>account_process_tick</span>(p, user_tick);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>run_local_timers</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>run_local_timers()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_local_timers</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#a6e22e>this_cpu_ptr</span>(<span style=color:#f92672>&amp;</span>timer_bases[BASE_STD]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>hrtimer_run_queues</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>time_before</span>(jiffies, base<span style=color:#f92672>-&gt;</span>clk)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>IS_ENABLED</span>(CONFIG_NO_HZ_COMMON))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* CPU is awake, so check the deferrable base. */</span>
</span></span><span style=display:flex><span>    base<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>timer_before</span>(jiffies, base<span style=color:#f92672>-&gt;</span>clk))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raise_softirq</span>(TIMER_SOFTIRQ);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>지연 타이머는 deferrable 전용 타이머 베이스를 사용한다.</li><li>타이머 인터럽트가 발생 -> 만료될 동적 타이머가 있는지 점검 -> 있다면 TIMER_SOFTIRQ라는 서비스로 Soft IRQ 서비스 요청</li></ul></li><li><p>__do_softirq()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asmlinkage __visible <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__softirq_entry</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> jiffies <span style=color:#f92672>+</span> MAX_SOFTIRQ_TIME;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> old_flags <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>flags;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> softirq_action <span style=color:#f92672>*</span>h;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>restart:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_softirq_pending</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  h <span style=color:#f92672>=</span> softirq_vec;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ((softirq_bit <span style=color:#f92672>=</span> <span style=color:#a6e22e>ffs</span>(pending))) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> vec_nr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> prev_count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    h <span style=color:#f92672>+=</span> softirq_bit <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vec_nr <span style=color:#f92672>=</span> h <span style=color:#f92672>-</span> softirq_vec;
</span></span><span style=display:flex><span>    prev_count <span style=color:#f92672>=</span> <span style=color:#a6e22e>preempt_count</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kstat_incr_softirqs_this_cpu</span>(vec_nr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>trace_softirq_entry</span>(vec_nr);
</span></span><span style=display:flex><span>    h<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>action</span>(h);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>run_timer_softirq()</p><ul><li>TIMER_SOFTIRQ 의 handler 는 run_timer_softirq 임</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __latent_entropy <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_timer_softirq</span>(<span style=color:#66d9ef>struct</span> softirq_action <span style=color:#f92672>*</span>h)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#a6e22e>this_cpu_ptr</span>(<span style=color:#f92672>&amp;</span>timer_bases[BASE_STD]);
</span></span><span style=display:flex><span>  base<span style=color:#f92672>-&gt;</span>must_forward_clk <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  __run_timers9base);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>IS_ENABLED</span>(CONFIG_NO_HZ_COMMON))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__run_timers</span>(<span style=color:#a6e22e>this_cpu_ptr</span>(<span style=color:#f92672>&amp;</span>timer_bases[BASE_DEF]));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>__run_timers()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__run_timers</span>(<span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> hlist_head heads[LVLDEPTH];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> levels;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>timer_after_eq</span>(jiffies, base<span style=color:#f92672>-&gt;</span>clk))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raw_spin_lock_irq</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>time_after_eq</span>(jiffies, base<span style=color:#f92672>-&gt;</span>clk)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    levels <span style=color:#f92672>=</span> <span style=color:#a6e22e>collect_expired_timers</span>(base, heads);
</span></span><span style=display:flex><span>    base<span style=color:#f92672>-&gt;</span>clk<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (levels<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>expire_timers</span>(base, heads <span style=color:#f92672>+</span> levels);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  base<span style=color:#f92672>-&gt;</span>running_timer <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raw_spin_unlock_irq</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>__collect_expired_timers()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>collect_expired_timers</span>(<span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>struct</span> hlist_head <span style=color:#f92672>*</span>heads)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>__collect_expired_timers</span>(base, heads);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>__colect_expired_timers</span>(<span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>struct</span> hlist_head <span style=color:#f92672>*</span>heads)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> clk <span style=color:#f92672>=</span> base<span style=color:#f92672>-&gt;</span>clk;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> hlist_head <span style=color:#f92672>*</span>vec;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i, levels <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> idx;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> LVL_DEPTH; i <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    idx <span style=color:#f92672>=</span> (clk <span style=color:#f92672>&amp;</span> LVL_MASK) <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> LVL_SIZE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>__test_and_clear_bit</span>(idx, base<span style=color:#f92672>-&gt;</span>pending_map)) {
</span></span><span style=display:flex><span>      vec <span style=color:#f92672>=</span> base<span style=color:#f92672>-&gt;</span>vectors <span style=color:#f92672>+</span> idx;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>hlist_move_list</span>(vec, heads<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>      levels<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> levels;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>expire_timers()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expire_timers</span>(<span style=color:#66d9ef>struct</span> timer_base <span style=color:#f92672>*</span>base, <span style=color:#66d9ef>struct</span> hlist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>hlist_empty</span>(head)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>fn)(<span style=color:#66d9ef>struct</span> tiemr_list <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    timer <span style=color:#f92672>=</span> <span style=color:#a6e22e>hlist_entry</span>(head<span style=color:#f92672>-&gt;</span>first, <span style=color:#66d9ef>struct</span> timer_list, entry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    base<span style=color:#f92672>-&gt;</span>running_timer <span style=color:#f92672>=</span> timer;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>detach_timer</span>(timer, true);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn <span style=color:#f92672>=</span> timer<span style=color:#f92672>-&gt;</span>function;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (timer<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> TIMER_IRQSAFE) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>raw_spin_unlock</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>call_timer_fn</span>(timer, fn);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>raw_spin_lock</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>raw_spin_unlock_irq</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>call_timer_fn</span>(timer, fn);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>raw_spin_lock_irq</span>(<span style=color:#f92672>&amp;</span>base<span style=color:#f92672>-&gt;</span>lock);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>list에서 timer를 꺼낸후, running_timer 로 만들어 놓고, list 에서 detach 시킨다.</li><li>그 뒤 fn 에다가 timer callback 을 넣어주고, TIMER_IRQSAFE(TIMER 가 irq disabled 이고 irq handler 가 실행 중인걸 기다려야되는지)인지 확인하고, 그에 따라 lock 걸고 timer를 실행한다.</li></ul></li><li><p>call_timer_fn()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>call_timer_fn</span>(<span style=color:#66d9ef>struct</span> timer_list <span style=color:#f92672>*</span>timer, <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>fn)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>),
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#a6e22e>preempt_count</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_timer_expire_entry</span>(timer);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fn</span>(data);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>trace_timer_expire_exit</span>(timer);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h5 id=커널-타이머-정리>커널 타이머 정리</h5><ol><li>동적 타이머 등록 : mod_timer</li><li>TIMER_SOFTIRQ 서비스 요청</li><li>Soft IRQ 서비스 실행</li><li>동적 타이머 만료 후 타이머 핸들러 실행</li></ol><hr><ul><li>HZ : 진동수, 1초에 jiffies 가 업데이트 되는 횟수</li><li>TIMER_SOFTIRQ 로 Soft IRQ 서비스를 요청</li><li>msecs_to_jiffies 를 통해서 밀리초 입력을 jiffies 로 시각 정보를 반환</li><li>내부 시간 비교는 time_after() 와 time_before() 를 사용</li><li>동적타이머 등록 함수 : add_timer(), mod_timer()</li><li>Soft IRQ 컨텍스트에서 처리되므로 실행 시간이 빨라야한다.</li><li>ftrace 에서 동적 타이머 추적 가능 이벤트<ul><li>timer_init, timer_start, timer_expire_entry, timer_expire_exit, timer_cancel</li></ul></li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>