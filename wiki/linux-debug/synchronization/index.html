<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://unpkg.com/simpledotcss/simple.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>linux-debug/synchronization |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>linux-debug/synchronization</div></header><main><article class=main><div class=title><h1 class=title-header>linux-debug/synchronization</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/linux-debug/synchronization.md><h5>created : Wed, 11 Nov 2020 00:07:13 +0900</h5><h5>modified : Wed, 09 Dec 2020 13:31:12 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
[[debug-linux]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i>
<a href=/tags/linux-debug class=tag-btn>linux-debug</a>
<a href=/tags/synchronization class=tag-btn>synchronization</a></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><ul><li><a href=#커널-동기화>커널 동기화</a></li></ul></li><li><a href=#정리>정리</a></li></ul></nav></aside><div class=content><h3 id=커널-동기화>커널 동기화</h3><ul><li>주요 개념 : critical section, race condition</li><li>SMP : symmetric multiprocessing</li></ul><h4 id=커널-동기화-기법>커널 동기화 기법</h4><ul><li>스핀락과 뮤텍스</li></ul><h5 id=스핀락>스핀락</h5><ul><li><p>구현부가 상대적으로 간단하다</p></li><li><p>아키텍쳐에 의존적인 코드로 구현</p></li><li><p>휴면상태로 가지 않고 계속 기다림 (Busy-Wait)</p></li><li><p>spin_lock_irq(), spin_lock_irq_save()</p></li><li><p>spin_lock data structure</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=typedef%20struct%20spinlock%20%7b%0a%20%20union%20%7b%0a%20%20%20%20struct%20raw_spinlock%20rlock;%0a%20%20%7d;%0a%7d%20spinlock_t;>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> spinlock {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> raw_spinlock rlock;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>spinlock_t</span>;</span></span></code></pre></div></div><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=typedef%20struct%20raw_spinlock%20%7b%0a%20%20arch_spinlock_t%20raw_lock;%0a#ifdef%20CONFIG_DEBUG_SPINLOCK%0a%20%20unsigned%20int%20magic,%20owner_cpu;%0a%20%20void%20*owner;%0a#endif%0a#ifdef%20CONFIG_DEBUG_LOCK_ALLOC%0a%20%20struct%20lockdep_map%20dep_map;%0a#endif%0a%7d%20raw_spinlock_t;>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> raw_spinlock {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>arch_spinlock_t</span> raw_lock;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_DEBUG_SPINLOCK
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> magic, owner_cpu;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>owner;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_DEBUG_LOCK_ALLOC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> lockdep_map dep_map;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>raw_spinlock_t</span>;</span></span></code></pre></div></div><ul><li>아키텍쳐마다 다른데, x86은 asm-generic의 qspinlock 을 사용한다.</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=typedef%20struct%20qspinlock%20%7b%0a%20%20union%20%7b%0a%20%20%20%20atomic_t%20val;%0a%0a%20%20/*%0a*%20By%20using%20the%20whole%202nd%20least%20significant%20byte%20for%20the%0a*%20pending%20bit,%20we%20can%20allow%20better%20optimization%20of%20the%20lock%0a*%20acquisition%20for%20the%20pending%20bit%20holder.%0a*/%0a#ifdef%20__LITTLE_ENDIAN%0a%20%20%20%20struct%20%7b%0a%20%20%20%20%20%20u8%09locked;%0a%20%20%20%20%20%20u8%09pending;%0a%20%20%20%20%7d;%0a%20%20%20%20struct%20%7b%0a%20%20%20%20%20%20u16%09locked_pending;%0a%20%20%20%20%20%20u16%09tail;%0a%20%20%20%20%7d;%0a#else%0a%20%20%20%20struct%20%7b%0a%20%20%20%20%20%20u16%09tail;%0a%20%20%20%20%20%20u16%09locked_pending;%0a%20%20%20%20%7d;%0a%20%20%20%20struct%20%7b%0a%20%20%20%20%20%20u8%09reserved[2];%0a%20%20%20%20%20%20u8%09pending;%0a%20%20%20%20%20%20u8%09locked;%0a%20%20%20%20%7d;%0a#endif%0a%20%20%7d;%0a%7d%20arch_spinlock_t;>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> qspinlock {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>atomic_t</span> val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>* By using the whole 2nd least significant byte for the
</span></span></span><span style=display:flex><span><span style=color:#75715e>* pending bit, we can allow better optimization of the lock
</span></span></span><span style=display:flex><span><span style=color:#75715e>* acquisition for the pending bit holder.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __LITTLE_ENDIAN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      u8	locked;
</span></span><span style=display:flex><span>      u8	pending;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      u16	locked_pending;
</span></span><span style=display:flex><span>      u16	tail;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      u16	tail;
</span></span><span style=display:flex><span>      u16	locked_pending;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>      u8	reserved[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>      u8	pending;
</span></span><span style=display:flex><span>      u8	locked;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  };
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>arch_spinlock_t</span>;</span></span></code></pre></div></div></li><li><p>스핀락 사용 예제</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20__always_inline%20void%20spin_lock%28spinlock_t%20*lock%29;>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spin_lock</span>(<span style=color:#66d9ef>spinlock_t</span> <span style=color:#f92672>*</span>lock);</span></span></code></pre></div></div></li><li><p>스핀락 획득 과정</p><ol><li>스핀락을 이미 획득했는지 판단 : lock instance의 next와 owner 필드를 확인한다.</li><li>스핀락을 획득한 후 바뀌는 자료구조 : next 값을 1증가 시킨다.</li><li>획득한 스핀락을 해제한 후 바뀌는 자료구조 : owner를 1만큼 증가시킨다.</li></ol></li><li><p>스핀락 구현부</p><ul><li><p>spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20__alwyas_inline%20void%20spin_lock%28spinlock_t%20*lock%29%0a%7b%0a%20%20raw_spin_lock%28&amp;lock-%3erlock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __alwyas_inline <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spin_lock</span>(<span style=color:#66d9ef>spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raw_spin_lock</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>rlock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>raw_spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#define%20raw_spin_lock%28lock%29%20_raw_spin_lock%28lock%29>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define raw_spin_lock(lock) _raw_spin_lock(lock)</span></span></span></code></pre></div></div></li><li><p>_raw_spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=void%20__lock_func%20_raw_spin_lock%28raw_spinlock_t%20*lock%29%0a%7b%0a%20%20__raw_spin_lock%28lock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __lock_func <span style=color:#a6e22e>_raw_spin_lock</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__raw_spin_lock</span>(lock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>__raw_spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20void%20__raw_spin_lock%28raw_spinlock_t%20*lock%29%0a%7b%0a%20%20preempt_disable%28%29;%0a%20%20spin_acquire%28&amp;lock-%3edep_map,%200,%200,%20_RET_IP_%29;%0a%20%20LOCK_CONTENDED%28lock%3c%20do_raw_spin_trylock,%20do_raw_spin_lock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__raw_spin_lock</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preempt_disable</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_acquire</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>dep_map, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, _RET_IP_);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>LOCK_CONTENDED</span>(lock<span style=color:#f92672>&lt;</span> do_raw_spin_trylock, do_raw_spin_lock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>스핀락을 획득 한 후 preempt_disable() 함수를 호출할 필요가 없다. 내부적으로 호출해준다.</li></ul></li><li><p>do_raw_spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20void%20do_raw_spin_lock%28raw_spinlock_t%20*lock%29%20__acquires%28lock%29%0a%7b%0a%20%20__acquire%28lock%29;%0a%20%20arch_spin_lock%28&amp;lock-%3eraw_lock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_raw_spin_lock</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock) <span style=color:#a6e22e>__acquires</span>(lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__acquire</span>(lock);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>arch_spin_lock</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>raw_lock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>arch_spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="#define%20arch_spin_lock%28l%29%09%09queued_spin_lock%28l%29%0a/**%0a%20*%20queued_spin_lock%20-%20acquire%20a%20queued%20spinlock%0a%20*%20@lock:%20Pointer%20to%20queued%20spinlock%20structure%0a%20*/%0astatic%20__always_inline%20void%20queued_spin_lock%28struct%20qspinlock%20*lock%29%0a%7b%0a%20%20u32%20val;%0a%0a%20%20val%20=%20atomic_cmpxchg_acquire%28&amp;lock-%3eval,%200,%20_Q_LOCKED_VAL%29;%0a%20%20if%20%28likely%28val%20==%200%29%29%0a%20%20%20%20return;%0a%20%20queued_spin_lock_slowpath%28lock,%20val%29;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define arch_spin_lock(l)		queued_spin_lock(l)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * queued_spin_lock - acquire a queued spinlock
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @lock: Pointer to queued spinlock structure
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>queued_spin_lock</span>(<span style=color:#66d9ef>struct</span> qspinlock <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  u32 val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  val <span style=color:#f92672>=</span> <span style=color:#a6e22e>atomic_cmpxchg_acquire</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>val, <span style=color:#ae81ff>0</span>, _Q_LOCKED_VAL);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(val <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>queued_spin_lock_slowpath</span>(lock, val);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="struct%20pv_lock_ops%20pv_lock_ops%20=%20%7b%0a#ifdef%20CONFIG_SMP%0a%20%20.queued_spin_lock_slowpath%20=%20native_queued_spin_lock_slowpath,%0a%20%20.queued_spin_unlock%20=%20PV_CALLEE_SAVE%28__native_queued_spin_unlock%29,%0a%20%20.wait%20=%20paravirt_nop,%0a%20%20.kick%20=%20paravirt_nop,%0a%20%20.vcpu_is_preempted%20=%20PV_CALLEE_SAVE%28__native_vcpu_is_preempted%29,%0a#endif%20/*%20SMP%20*/%0a%7d;">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> pv_lock_ops pv_lock_ops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_SMP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  .queued_spin_lock_slowpath <span style=color:#f92672>=</span> native_queued_spin_lock_slowpath,
</span></span><span style=display:flex><span>  .queued_spin_unlock <span style=color:#f92672>=</span> <span style=color:#a6e22e>PV_CALLEE_SAVE</span>(__native_queued_spin_unlock),
</span></span><span style=display:flex><span>  .wait <span style=color:#f92672>=</span> paravirt_nop,
</span></span><span style=display:flex><span>  .kick <span style=color:#f92672>=</span> paravirt_nop,
</span></span><span style=display:flex><span>  .vcpu_is_preempted <span style=color:#f92672>=</span> <span style=color:#a6e22e>PV_CALLEE_SAVE</span>(__native_vcpu_is_preempted),
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>/* SMP */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};</span></span></code></pre></div></div></li><li><p>이후부터는 링크를 참고했다. <a href=https://lwn.net/Articles/561775/>LWN.net</a></p><ul><li>간단하게 하면 0-1 비트는 4개의 entries로 per-cpu array 안에 들어있는 queue node의 index, 2-16은 cpu number + 1 로 (최대 cpu 개수는 16383)</li><li>ticket spinlock 보다 빠르며, [[NUMA]] 를 사용하는 여러개의 코어가 존재하는 곳에서 더욱더 적합하다.</li><li>추가적인 링크는 <a href="https://m.blog.naver.com/PostView.nhn?blogId=jjoommnn&amp;logNo=130141126016&amp;proxyReferer=https:%2F%2Fwww.google.com%2F">큐 스핀락</a> 여기를 참고하자.</li></ul></li></ul></li><li><p>[[assembly]]</p></li><li><p>흐으으음&mldr; 책은 대부분 arm 아키텍쳐와 관련된 내용이 많네 스킵</p></li></ul><h5 id=스핀락-플러그인-함수>스핀락 플러그인 함수</h5><ul><li><p>spin_lock_irq()</p></li><li><p>spin_unlock_irq()</p><ul><li>임계 영역에서 스핀락을 걸 때 인터럽트가 발생하지 않으면 좋겠다.
스핀락을 획득해 다른 모듈이 접근하지 못하는건 좋지만, 임계 영역에서 인터럽트 발생이 문제다.</li></ul></li><li><p>임계 영역의 코드 구간에서 인터럽트를 비활성화</p></li><li><p>spin_lock_irq()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20__always_inline%20void%20spin_lock_irq%28spinlock_t%20*lock%29%0a%7b%0a%20%20raw_spin_lock_irq%28&amp;lock-%3erlock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spin_lock_irq</span>(<span style=color:#66d9ef>spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>raw_spin_lock_irq</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>rlock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>raw_spin_lock_irq()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20void%20__raw_spin_lock_irq%28raw_spinlock_t%20*lock%29%0a%7b%0a%20%20local_irq_disable%28%29;%0a%20%20preempt_disable%28%29;%0a%20%20spin_acquire%28&amp;lock-%3edep_map,%200,%200,%20_RET_IP_%29;%0a%20%20LOCK_CONTENDED%28lock,%20do_raw_spin_trylock,%20do_raw_spin_lock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__raw_spin_lock_irq</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_disable</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preempt_disable</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_acquire</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>dep_map, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, _RET_IP_);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>LOCK_CONTENDED</span>(lock, do_raw_spin_trylock, do_raw_spin_lock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>__raw_spin_lock()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20void%20__raw_spin_lock%28raw_spinlock_t%20*lock%29%0a%7b%0a%20%20preempt_disable%28%29;%0a%20%20spin_acquire%28&amp;lock-%3edep_map,%200,%200,%20_RET_IP_%29;%0a%20%20LOCK_CONTENDED%28lock,%20do_raw_spin_trylock,%20do_raw_spin_lock%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__raw_spin_lock</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preempt_disable</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_acquire</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>dep_map, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, _RET_IP_);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>LOCK_CONTENDED</span>(lock, do_raw_spin_trylock, do_raw_spin_lock);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>local_irq_disable()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#define%20local_irq_disable%28%29%20%5c%0a%20%20do%20%7b%20raw_local_irq_disable%28%29;%20trace_hardirqs_off%28%29;%20%7d%20while%20%280%29>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define local_irq_disable() \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  do { raw_local_irq_disable(); trace_hardirqs_off(); } while (0)</span></span></span></code></pre></div></div></li><li><p>raw_local_irq_disable()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#define%20raw_local_irq_disable%28%29%20arch_local_irq_disable%28%29>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define raw_local_irq_disable() arch_local_irq_disable()</span></span></span></code></pre></div></div></li><li><p>arch_local_irq_disable()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20notrace%20void%20arch_local_irq_disable%28void%29%0a%7b%0a%20%20PVOP_VCALLEE0%28pv_irq_ops.irq_disable%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> notrace <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>arch_local_irq_disable</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>PVOP_VCALLEE0</span>(pv_irq_ops.irq_disable);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>irq_disable is driver specific.<div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="struct%20irq_chip%20i8259A_chip%20=%20%7b%0a%20%20.name%09%09=%20%22XT-PIC%22,%0a%20%20.irq_mask%09=%20disable_8259A_irq,%0a%20%20.irq_disable%09=%20disable_8259A_irq,%0a%20%20.irq_unmask%09=%20enable_8259A_irq,%0a%20%20.irq_mask_ack%09=%20mask_and_ack_8259A,%0a%7d;">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> irq_chip i8259A_chip <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .name		<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XT-PIC&#34;</span>,
</span></span><span style=display:flex><span>  .irq_mask	<span style=color:#f92672>=</span> disable_8259A_irq,
</span></span><span style=display:flex><span>  .irq_disable	<span style=color:#f92672>=</span> disable_8259A_irq,
</span></span><span style=display:flex><span>  .irq_unmask	<span style=color:#f92672>=</span> enable_8259A_irq,
</span></span><span style=display:flex><span>  .irq_mask_ack	<span style=color:#f92672>=</span> mask_and_ack_8259A,
</span></span><span style=display:flex><span>};</span></span></code></pre></div></div></li></ul></li><li><p>spin_unlock_irq()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20void%20__raw_spin_unlock_irq%28raw_spinlock_t%20*lock%29%0a%7b%0a%20%20spin_release%28&amp;lock-%3edep_map,%201,%20_RET_IP_%29;%0a%20%20do_raw_spin_unlock%28lock%29;%0a%20%20local_irq_enable%28%29;%0a%20%20preempt_enable%28%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__raw_spin_unlock_irq</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_release</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>dep_map, <span style=color:#ae81ff>1</span>, _RET_IP_);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>do_raw_spin_unlock</span>(lock);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_enable</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preempt_enable</span>();
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>local_irq_enable()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#define%20local_irq_enable%28%29%20%5c%0a%20%20do%20%7b%20trace_hardirqs_on%28%29;%20raw_local_irq_enable%28%29;%20%7d%20while%20%280%29%0a%0a#define%20raw_local_irq_enable%28%29%20arch_local_irq_enable%28%29>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define local_irq_enable() \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  do { trace_hardirqs_on(); raw_local_irq_enable(); } while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define raw_local_irq_enable() arch_local_irq_enable()</span></span></span></code></pre></div></div></li><li><p>spin_lock_irqsave()/spin_unlock_irqrestore()</p><ul><li>acquire spinlock, disable interrupt line, return interrupt state.</li></ul></li><li><p>spin_lock_irq_save()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=#define%20spin_lock_irqsave%28lock,%20flags%29%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5c%0a%20%20do%20%7b%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5c%0a%20%20%20%20raw_spin_lock_irqsave%28spinlock_check%28lock%29,%20flags%29;%20%5c%0a%20%20%7d%20while%20%280%29>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define spin_lock_irqsave(lock, flags)                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  do {                                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    raw_spin_lock_irqsave(spinlock_check(lock), flags); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>  } while (0)</span></span></span></code></pre></div></div></li><li><p>__raw_spin_lock_irqsave()</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20inline%20unsigned%20long%20__raw_spin_lock_irqsave%28raw_spinlock_t%20*lock%29%0a%7b%0a%20%20unsigned%20long%20lfags;%0a%0a%20%20local_irq_save%28flags%29;%0a%20%20preempt_disable%28%29;%0a%20%20spin_acquire%28&amp;lock-%3edep_map,%200,%200,%20_RET_IP_%29;%0a%0a#ifdef%20CONFIG_LOCKDEP%0a%20%20LOCK_CONTENDED%28lock,%20do_raw_spin_trylock,%20do_raw_spin_lock%29;%0a#else%0a%20%20do_raw_spin_lock_falgs%28lock,%20&amp;flags%29;%0a#endif%0a%20%20return%20flags;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>__raw_spin_lock_irqsave</span>(<span style=color:#66d9ef>raw_spinlock_t</span> <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> lfags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_irq_save</span>(flags);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preempt_disable</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_acquire</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>dep_map, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, _RET_IP_);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_LOCKDEP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>LOCK_CONTENDED</span>(lock, do_raw_spin_trylock, do_raw_spin_lock);
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>do_raw_spin_lock_falgs</span>(lock, <span style=color:#f92672>&amp;</span>flags);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> flags;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li></ul><h5 id=mutex>Mutex?</h5><ul><li><p>mutex data structure</p><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=struct%20mutex%20%7b%0a%20%20atomic_long_t%20%20%20%20%20%20owner;%0a%20%20spinlock_t%20%20%20%20%20%20%20%20%20wait_lock;%0a#ifdef%20CONFIG_MUTEX_SPIN_ON_ONWER%0a%20%20struct%20optimistic_spin_queue%20osq;%20/*%20Spinner%20MCS%20lock%20*/%0a#endif%0a%20%20struct%20list_head%20%20%20wait_list;%0a#ifdef%20CONFIG_DEBUG_MUTEXES%0a%20%20void%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*magic;%0a#endif%0a#ifdef%20CONFIG_DEBUG_LOCK_ALLOC%0a%20%20struct%20lockdep_map%20dep_map;%0a#endif%0a%7d;>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> mutex {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>atomic_long_t</span>      owner;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>spinlock_t</span>         wait_lock;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_MUTEX_SPIN_ON_ONWER
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> optimistic_spin_queue osq; <span style=color:#75715e>/* Spinner MCS lock */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> list_head   wait_list;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_DEBUG_MUTEXES
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span>               <span style=color:#f92672>*</span>magic;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_DEBUG_LOCK_ALLOC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> lockdep_map dep_map;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};</span></span></code></pre></div></div><ul><li>owner : 뮤텍스를 획득한 프로세스의 태스크 디스크립터 주소, 이 필드를 보고 잠겼는지 확인</li><li>wait_list : 뮤텍스를 기다리는 프로세스의 정보</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=struct%20mutex_waiter%20%7b%0a%20%20struct%20list_head%20%20%20%20%20%20list;%0a%20%20struct%20task_struct%20%20%20%20*task;%0a%20%20struct%20ww_acquire_ctx%20*ww_ctx;%0a#ifdef%20CONFIG_DEBUG_MUTEXES%0a%20%20void%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*magic;%0a#endif%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> mutex_waiter {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> list_head      list;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct    <span style=color:#f92672>*</span>task;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> ww_acquire_ctx <span style=color:#f92672>*</span>ww_ctx;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_DEBUG_MUTEXES
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span>                  <span style=color:#f92672>*</span>magic;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><ul><li>list : 뮤텍스를 기다리는 잠든 프로세스 리스트</li><li>task : 뮤텍스를 기다리는 프로세스의 테스크 디스크립터 주소(???)</li><li>ww_ctx : wait/wound deadlock proof mutex 로 deadlock을 회피하여 뮤텍스 락을 처리하는 알고리즘에 사용</li></ul></li><li><p>fastpath : 뮤텍스를 다른 프로세스가 이미 획득하지 않은 상태때 동작 방식</p><ul><li><p>mutex 구조체의 owner 필드 점검</p></li><li><p>owner 가 0x0이니 뮤텍스를 다른 프로세스가 획득하지 않은 상태로 판단</p></li><li><p>뮤텍스 자료구조인 mutex 구조체의 onwer 필드에 획득한 프로세스의 테스크 디스크립터 저장</p></li><li><p>mutex_lock()</p></li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=void%20__sched%20mutex_lock%28struct%20mutex%20*lock%29%0a%7b%0a%20%20might_sleep%28%29;%0a%0a%20%20if%20%28!__mutex_trylock_fast%28lock%29%29%0a%20%20%20%20__mutex_lock_slowpath%28lock%29;%0a%7d%0aEXPORT_SYMBOL%28mutex_lock%29;>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __sched <span style=color:#a6e22e>mutex_lock</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>might_sleep</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>__mutex_trylock_fast</span>(lock))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__mutex_lock_slowpath</span>(lock);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(mutex_lock);</span></span></code></pre></div></div><ul><li>__mutex_trylock_fast()</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="static%20__always_inline%20bool%20__mutex_trylock_fast%28struct%20mutex%20*lock%29%0a%7b%0a%20%20unsigned%20long%20curr%20=%20%28unsigned%20long%29current;%0a%0a%20%20if%20%28!atomic_long_cmpxchg_acquire%28&amp;lock-%3eowner,%200UL,%20curr%29%29%0a%20%20%20%20return%20true;%0a%0a%20%20return%20false;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>__mutex_trylock_fast</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> curr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)current;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>atomic_long_cmpxchg_acquire</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>owner, <span style=color:#ae81ff>0UL</span>, curr))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>__mutx_unlock_fast()</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="static%20__always_inline%20bool_mutex_unlock_fast%28struct%20mutex%20*lock%29%0a%7b%0a%20%20unsigned%20long%20curr%20=%20%28unsigned%20long%29current;%0a%0a%20%20if%20%28atomic_long_cmpxchg_release%28&amp;lock-%3eowner,%20curr,%200UL%29%20==%20curr%29%0a%20%20%20%20return%20true;%0a%0a%20%20return%20false;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#a6e22e>bool_mutex_unlock_fast</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> curr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)current;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>atomic_long_cmpxchg_release</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>owner, curr, <span style=color:#ae81ff>0UL</span>) <span style=color:#f92672>==</span> curr)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li><li><p>slowpath : 뮤텍스를 이미 획득해 휴면 상태에 진입한 후 깨어남</p><ul><li>__mutex_lock_slowpath()</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20noinline%20void%20__sched%0a__mutex_lock_slowpath%28struct%20mutex%20*lock%29%0a%7b%0a%20%20__mutex_lock%28lock,%20TASK_UNINTERRUPTIBLE,%200,%20NULL,%20_RET_IP_%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> noinline <span style=color:#66d9ef>void</span> __sched
</span></span><span style=display:flex><span><span style=color:#a6e22e>__mutex_lock_slowpath</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__mutex_lock</span>(lock, TASK_UNINTERRUPTIBLE, <span style=color:#ae81ff>0</span>, NULL, _RET_IP_);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>__mutex_lock()</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=static%20int%20__sched%0a__mutex_lock%28struct%20mutex%20*lock,%20long%20state,%20unsgiend%20int%20subclass,%0a%20%20struct%20lockdep_map%20*nest_lock,%20unsigned%20long%20ip%29%0a%7b%0a%20%20return%20__mutex_lock_common%28lock,%20state,%20subclass,%20nest_lock,%20ip,%20NULL,%20false%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __sched
</span></span><span style=display:flex><span><span style=color:#a6e22e>__mutex_lock</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock, <span style=color:#66d9ef>long</span> state, unsgiend <span style=color:#66d9ef>int</span> subclass,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> lockdep_map <span style=color:#f92672>*</span>nest_lock, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ip)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>__mutex_lock_common</span>(lock, state, subclass, nest_lock, ip, NULL, false);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>__mutex_lock_common()</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="%0astatic%20__always_inline%20int%20__sched%0a__mutex_lock_common%28struct%20mutex%20*lock,%20long%20state,%20unsgiend%20int%20subclass,%0a%20%20struct%20lockdep_map%20*nest_lock,%20unsigned%20long%20ip,%0a%20%20struct%20ww_acquire_ctx%20*ww_ctx,%20const%20bool%20use_ww_ctx%29%0a%7b%0a%20%20struct%20mutex_waiter%20waiter;%0a%20%20bool%20first%20=%20false;%0a%20%20struct%20ww_mutex%20*ww;%0a%20%20int%20ret;%0a%20%20/*%20skip%20*/%0a%20%20waiter.task%20=%20current;%0a%0a%20%20set_current_state%28state%29;%0a%20%20for%20%28;;%29%20%7b%0a%20%20%20%20/*%20skip%20*/%0a%20%20%20%20spin_unlock%28&amp;lock-%3ewait_lock%29;%0a%20%20%20%20schedule_preempt_disabled%28%29;%0a%20%20%20%20/*%20skip%20*/%0a%20%20%20%20set_current_state%28state%29;%0a%20%20%7d%0a%20%20spin_lock%28&amp;lock-%3ewait_lock%29;%0aacquired:%0a%20%20__set_current_state%28TASK_RUNNING%29;%0a%20%20/*%20skip%20*/%0a%20%20mutex_remove_waiter%28lock,%20&amp;waiter,%20current%29;%0a%20%20if%20%28likely%28list_empty%28&amp;lock-%3ewait_list%29%29%29%0a%20%20%20%20__mutex_clear_flag%28lock,%20MUTEX_FLAGS%29;%0a%0a%20%20debug_mutex_free_waiter%28&amp;waiter%29;%0a%20%20/*%20skip%20*/%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>int</span> __sched
</span></span><span style=display:flex><span><span style=color:#a6e22e>__mutex_lock_common</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock, <span style=color:#66d9ef>long</span> state, unsgiend <span style=color:#66d9ef>int</span> subclass,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> lockdep_map <span style=color:#f92672>*</span>nest_lock, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ip,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> ww_acquire_ctx <span style=color:#f92672>*</span>ww_ctx, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> use_ww_ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> mutex_waiter waiter;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> first <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> ww_mutex <span style=color:#f92672>*</span>ww;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  waiter.task <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set_current_state</span>(state);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spin_unlock</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>wait_lock);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>schedule_preempt_disabled</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>set_current_state</span>(state);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spin_lock</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>wait_lock);
</span></span><span style=display:flex><span>acquired:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__set_current_state</span>(TASK_RUNNING);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex_remove_waiter</span>(lock, <span style=color:#f92672>&amp;</span>waiter, current);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(<span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>wait_list)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__mutex_clear_flag</span>(lock, MUTEX_FLAGS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>debug_mutex_free_waiter</span>(<span style=color:#f92672>&amp;</span>waiter);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>mutex_unlock()</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data=void%20__sched%20mutex_unlock%28struct%20mutex%20*lock%29%0a%7b%0a#ifndef%20CONFIG_DEBUG_LOCK_ALLOC%0a%20%20if%20%28__mutex_unlock_fast%28lock%29%29%0a%20%20%20%20return;%0a#endif%0a%20%20__mutex_unlock_slowpath%28lock,%20_RET_IP_%29;%0a%7d>
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> __sched <span style=color:#a6e22e>mutex_unlock</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef CONFIG_DEBUG_LOCK_ALLOC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>__mutex_unlock_fast</span>(lock))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>__mutex_unlock_slowpath</span>(lock, _RET_IP_);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><ul><li>__mutex_unlock_slowpath(struct mutex *lock, unsigned long ip)</li></ul><div class=codeblock><div class=copy-button-box><button class=copy-button state=copy data="struct%20noinline%20void%20__sched%20__mutex_unlock_slowpath%28struct%20mutex%20*lock,%20unsgiend%20long%20ip%29%0a%7b%0a%20%20struct%20task_struct%20*next%20=%20NULL;%0a%20%20DEFINE_WAKE_Q%28wake_q%29;%0a%20%20unsigned%20long%20owner;%0a%20%20/*%20skip%20*/%0a%20%20if%20%28!list_empty%28&amp;lock-%3ewait_list%29%29%20%7b%0a%20%20%20%20/*%20get%20the%20first%20entry%20from%20the%20wait-list%20*/%0a%20%20%20%20struct%20mutex_waiter%20*waiter%20=%0a%20%20%20%20%20%20list_first_entry%28&amp;lock-%3ewait_list,%0a%20%20%20%20%20%20%20%20struct%20mutex_waiter,%20list%29;%0a%20%20%20%20next%20=%20waiter-%3etask;%0a%0a%20%20%20%20debug_mutex_wake_waiter%28lock,%20waiter%29;%0a%20%20%20%20wake_q_add%28&amp;wake_q,%20next%29;%0a%20%20%7d%0a%20%20/*%20skip%20*/%0a%20%20wake_up_q%28&amp;wake_q%29;%0a%7d">
<i class="bi bi-copy"></i></button></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> noinline <span style=color:#66d9ef>void</span> __sched <span style=color:#a6e22e>__mutex_unlock_slowpath</span>(<span style=color:#66d9ef>struct</span> mutex <span style=color:#f92672>*</span>lock, unsgiend <span style=color:#66d9ef>long</span> ip)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>DEFINE_WAKE_Q</span>(wake_q);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> owner;
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>list_empty</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>wait_list)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* get the first entry from the wait-list */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> mutex_waiter <span style=color:#f92672>*</span>waiter <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>list_first_entry</span>(<span style=color:#f92672>&amp;</span>lock<span style=color:#f92672>-&gt;</span>wait_list,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> mutex_waiter, list);
</span></span><span style=display:flex><span>    next <span style=color:#f92672>=</span> waiter<span style=color:#f92672>-&gt;</span>task;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>debug_mutex_wake_waiter</span>(lock, waiter);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wake_q_add</span>(<span style=color:#f92672>&amp;</span>wake_q, next);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* skip */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>wake_up_q</span>(<span style=color:#f92672>&amp;</span>wake_q);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></li></ul><hr><h2 id=정리>정리</h2><ul><li>커널 동기화란 1개의 프로세스만 특정 코드 구간을 실행할 때 접근하거나 정해진 순서로 코드 구간을 실행하도록 설계하는 기업</li><li>임계 영역은 2개 이상의 프로세스가 동시에 실행하면 동시 접근 문제를 일으킬 수 있는 코드 블록</li><li>레이스 컨디션은 임계 영역에 두 개의 프로세스가 동시에 접근하는 상황</li><li>레이스 컨디션이 발생하는 요인은 선점 스케줄링, 인터럽트 발생, SMP 시스템에서 2개 이상의 프로세스가 같은 코드를 싱행하는 상황 등</li><li>레이스 컨디션 방지를 위해 선점 스케줄링이나 인터럽트 발생을 비활성화하거나 임계 영역에 락을 걸어야한다.</li><li>리눅스 커널에서 가장 많이 쓰이는 커널 동기화 기법은 스핀락과 뮤텍스</li><li>스핀락 획득을 시도할 때 __raw_tickets 구조체의 next 필드와 owner를 체크. next 와 owner가 동일하다면 스핀락을 획득한 적이 없으니 바로 획득 가능, next 필드가 owner 필드보다 크면 스핀락을 획득하기 전까지 계속 기다린다.</li><li>뮤텍스 획득을 시도할 때 mutex 구조체의 owner 필드를 체크한다. owner 필드가 0이면 프로세스는 바로 뮤텍스를 획득. 뮤텍스 획득에 성공했다면 mutex 구조체의 owner에 테스크 디스크립터 주소를 저장한다.</li><li>뮤텍스를 해제하는 프로세스는 뮤텍스 대기열을 체크하고 뮤텍스를 기다리며 잠든 프로세스를 깨운다. 이후 깨어난 프로세스는 뮤텍스를 획득한다.</li></ul></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>