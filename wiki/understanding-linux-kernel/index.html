<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://unpkg.com/simpledotcss/simple.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>Understanding Linux Kernel |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>Understanding Linux Kernel</div></header><main><article class=main><div class=title><h1 class=title-header>Understanding Linux Kernel</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/Understanding%20Linux%20Kernel.md><h5>created : Tue, 07 Apr 2020 20:48:28 +0900</h5><h5>modified : Sat, 26 Mar 2022 03:29:57 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
[[Book Review]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i>
<a href=/tags/linux class=tag-btn>linux</a></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#basic-operating-system-concepts>Basic Operating System Concepts</a></li><li><a href=#multiuser-systems>Multiuser Systems</a></li><li><a href=#users-and-groups>Users and Groups</a></li><li><a href=#processes>Processes</a></li><li><a href=#kernel-architecture>Kernel Architecture</a></li><li><a href=#an-overview-of-the-unix-filesystem>An Overview of the Unix Filesystem</a><ul><li><a href=#files>Files</a></li><li><a href=#hard-and-soft-links>Hard and Soft Links</a></li><li><a href=#file-types>File Types</a></li><li><a href=#file-descriptor-and-inode>File Descriptor and Inode</a></li><li><a href=#access-rights-and-file-mode>Access Rights and File Mode</a></li><li><a href=#file-handling-system-calls>File-Handling System Calls</a></li></ul></li><li><a href=#an-overview-of-unix-kernels>An Overview of Unix Kernels</a><ul><li><a href=#the-processkernel-model>The Process/Kernel Model</a></li><li><a href=#process-implementation>Process Implementation</a></li></ul></li></ul></nav></aside><div class=content><h1 id=1-introduction>1. Introduction</h1><ul><li>Linux pros<ul><li>Monolithic kernel</li><li>Compiled and statically linked traditional Unix kernels</li><li>Kernel threading</li><li>Multithreaded application support - lightweight processes(LWP)</li><li>Preemptive kernel</li><li>Multiprocessor support - symmetric multiprocessing(SMP)</li><li>Filesystem</li><li>STREAMS</li></ul></li></ul><h2 id=basic-operating-system-concepts>Basic Operating System Concepts</h2><ul><li>Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform.</li><li>Provide an execution environment to the applications that run on the computer system (the so-called user programs)</li></ul><h2 id=multiuser-systems>Multiuser Systems</h2><ul><li>An authentication mechanism for verifying the user&rsquo;s identity</li><li>A protection mechanism against buggy user programs that could block other applications running in the system</li><li>A protection mechanism against malicious user programs that could interfere with or spy on the activity of others users</li><li>An accounting mechanism that limits the amount of resource units assigned to each user</li></ul><h2 id=users-and-groups>Users and Groups</h2><ul><li>User ID(UID), Group ID(GID)</li><li>superuser</li></ul><h2 id=processes>Processes</h2><ul><li>Process : An instance of a program in execution or execution context</li><li>Multi Processing operating system with preemptable processes.</li><li>process/kernel model - Whenever a process makes a system call, the hardware changes the privilege mode from User ode to Kernel Mode.</li></ul><h2 id=kernel-architecture>Kernel Architecture</h2><ul><li>Kernels are <code>monolithic</code>: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process.</li><li>cf.) <code>microkernel</code> operating systems demand a very small set of functions from the kernel, generally including a few synchronization primitives, a simple scheduler, and an interprocess communication mechanism.</li><li>The main advantages of using modules include:<ul><li>A modularized approach</li><li>Platform independence</li><li>Frugal main memory usage</li><li>No performance penalty</li></ul></li></ul><h2 id=an-overview-of-the-unix-filesystem>An Overview of the Unix Filesystem</h2><h3 id=files>Files</h3><ul><li>All the nodes of the tree, except the leaves, denote directory names.</li></ul><h3 id=hard-and-soft-links>Hard and Soft Links</h3><ul><li>Hard links have two limitations:<ul><li>It is not possible to create hard links for directories. Doing so might transform the directory tree into a graph with cycles, thus making it impossible to locate a file according to its name.</li><li>Links can be created only among files included in the same filesystem. This is a serious limitation, because modern Unix systems may include several filesystems located on different disk and/or partitions, and users may be unaware of the physical divisions between them.</li></ul></li></ul><h3 id=file-types>File Types</h3><ul><li>Unix files may have one of the following types:<ul><li>Regular file</li><li>Directory</li><li>SYmbolic link</li><li>Block-oriented device file</li><li>Character-oriented device file</li><li>Pipe and named pipe (also called FIFO)</li><li>Socket</li></ul></li></ul><h3 id=file-descriptor-and-inode>File Descriptor and Inode</h3><ul><li>All information needed by the filesystem to handle a file is included in a data structure called an <code>inode</code>.</li><li>Unix system must always provide at least the following attributes, which are specified in the POSIX standard:<ul><li>File type</li><li>Number of hard links associated with the file</li><li>File length in bytes</li><li>Device ID(i.e., an identifier of the device containing the file)</li><li>Inode number that identifies the file within the filesystem</li><li>UID of the file owner</li><li>User group ID of the file</li><li>Several timestamps that specify the inode status change time, the last access time, and the last modify time</li><li>Access rights and file mode</li></ul></li></ul><h3 id=access-rights-and-file-mode>Access Rights and File Mode</h3><ul><li>User types<ul><li>The user who is the owner of the file</li><li>The users who belong to the same group as the file, not including the owner</li><li>All remaining users (others)</li></ul></li><li>Access rights : read, write and executed<ul><li>Additional flags : suid, sgid, sticky</li></ul></li></ul><h3 id=file-handling-system-calls>File-Handling System Calls</h3><ul><li><p>Opening a file</p><pre><code>  fd = open(path, flag, mode)
</code></pre><ul><li><code>path</code> : Denotes the pathname (relative or absolute) of the file to be opened.</li><li><code>flag</code> : Specifies how the file must be opened (e.g., read, write, read/write, append). It also can specify whether a non-existing file should be created.</li><li><code>mode</code> : Specifies the access rights of a newly created file.</li></ul></li><li><p>Accessing an opened file</p><pre><code>  newoffset = lseek(fd, offset, whence);
</code></pre><ul><li><p><code>fd</code> : Indicates the file descriptor of the opened file</p></li><li><p><code>offset</code> : Specifies a signed integer value that will be used for computing the new position of the file pointer</p></li><li><p><code>whence</code> : Specifies whether the new position should be computed by adding the offset value to the number 0 (offset from the beginning of the file), the current file pointer, or the position of the last byte (offset from the end of the file)</p><p>nread = read(fd, buf, count);</p></li><li><p><code>fd</code> : Indicates the file descriptor of the opened file</p></li><li><p><code>buf</code> : Specifies the address of the buffer in the process&rsquo;s address space to which the data will be transferred.</p></li><li><p><code>count</code> : Denotes the number of bytes to read</p></li></ul></li><li><p>Closing a file</p><pre><code>  res = close(fd);
</code></pre></li><li><p>Renaming and deleting a file</p><pre><code>  res = rename(oldpath, newpath);
  res = unlink(pathname);
</code></pre></li></ul><h2 id=an-overview-of-unix-kernels>An Overview of Unix Kernels</h2><h3 id=the-processkernel-model>The Process/Kernel Model</h3><ul><li>Kernel threads Characteristics<ul><li>They run in Kernel Mode in the kernel address space</li><li>They do not interact with users, and thus do not require terminal devices</li><li>They are usually created during system startup and remain alive until the system is shut down</li></ul></li><li>Kernel routines can be activated in several ways<ul><li>A process invokes a system call.</li><li>The CPU executing the process signals an exception, which is an unusual condition such as an invalid instruction. Thee kernel handles the exception on behalf of the process that caused it.</li><li>A peripheral device issues and interrupt signal to the CPU to notify it of an event such as a request for attention, a status change, or the completion of an I/O operation. Each interrupt signal is dealt by a kernel program called an interrupt handler. Because peripheral devices operate asynchronously with respect to the CPU, interrupts occur at unpredictable times.</li><li>A kernel thread is executed. Because it runs in Kernel Mode, the corresponding program must be considered part of the kernel.</li></ul></li></ul><h3 id=process-implementation>Process Implementation</h3><ul><li>Process descriptor include:<ul><li>The program counter(PC) and stack pointer (SP) registers</li><li>The general purpose registers</li><li>The floating point registers</li><li>The processor control registers (Processor Status Word) containing information about the CPU state</li><li>The memory management registers used to keep track of the RAM accessed by the process.</li></ul></li></ul></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>