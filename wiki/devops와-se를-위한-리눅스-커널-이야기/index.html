<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://unpkg.com/simpledotcss/simple.css><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.140.0"><meta name=description content="minuk.dev wiki"><meta name=keywords content="hugo,site,new"><meta name=author content="Min-Uk.Lee"><title>DevOps와 SE를 위한 리눅스 커널 이야기 |
minuk dev wiki
</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><header class=header><div class=header_left><a href=/><img class=logo src=/images/Rb.png alt=logo>
MinUk.Dev</a></div><div class=header_middle>DevOps와 SE를 위한 리눅스 커널 이야기</div></header><main><article class=main><div class=title><h1 class=title-header>DevOps와 SE를 위한 리눅스 커널 이야기</h1></div><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/devops%ec%99%80-se%eb%a5%bc-%ec%9c%84%ed%95%9c-%eb%a6%ac%eb%88%85%ec%8a%a4-%ec%bb%a4%eb%84%90-%ec%9d%b4%ec%95%bc%ea%b8%b0.md><h5>created : Mon, 22 Aug 2022 13:49:39 +0900</h5><h5>modified : Fri, 02 Sep 2022 20:40:26 +0900</h5></a><div class=article-meta><div class="breadcumb content"><i class="bi bi-folder"></i>
[[[devops]]]</div></div><div class=list-terms><ul><i class="bi bi-tags" title=Tags></i>
<a href=/tags/book class=tag-btn>book</a>
<a href=/tags/devops class=tag-btn>devops</a>
<a href=/tags/se class=tag-btn>se</a>
<a href=/tags/linux class=tag-btn>linux</a></ul></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#간략-설명>간략 설명</a></li><li><a href=#1-시스템-구성-정보-확인하기>1. 시스템 구성 정보 확인하기</a></li><li><a href=#2-top을-통해-살펴보는-프로세스-정보들>2. top을 통해 살펴보는 프로세스 정보들</a></li><li><a href=#3-load-average와-시스템-부하>3. Load Average와 시스템 부하</a></li><li><a href=#4-free-명령이-숨기고-있는-것들>4. free 명령이 숨기고 있는 것들</a></li><li><a href=#5-swap-메모리-증설의-포인트>5. swap, 메모리 증설의 포인트</a></li><li><a href=#6-numa-메모리-관리의-새로운-세계>6. NUMA, 메모리 관리의 새로운 세계</a><ul><li><a href=#개인-의견>개인 의견</a></li><li><a href=#요약>요약</a></li></ul></li><li><a href=#7-time_wait-소켓이-서비스에-미치는-영향>7. TIME_WAIT 소켓이 서비스에 미치는 영향</a><ul><li><a href=#개인-의견-1>개인 의견</a></li><li><a href=#요약-1>요약</a></li></ul></li><li><a href=#8-tcp-keepalive-를-이용한-세션-유지>8. TCP Keepalive 를 이용한 세션 유지</a></li><li><a href=#9-tcp-재전송과-타임아웃>9. TCP 재전송과 타임아웃</a></li><li><a href=#10-dirty-page가-io에-끼치는-영향>10. dirty page가 I/O에 끼치는 영향</a></li><li><a href=#11-io-작업이-지나가는-관문-io-스케줄러>11. I/O 작업이 지나가는 관문, I/O 스케줄러</a></li><li><a href=#12-어플리케이션-성능-측정과-튜닝>12. 어플리케이션 성능 측정과 튜닝</a></li><li><a href=#개인-정리>개인 정리</a></li></ul></nav></aside><div class=content><h2 id=간략-설명>간략 설명</h2><ul><li>이 책은 실습과 개념, Tip 이 동시에 존재하는 책이다.</li><li>개념, 실습에 대한 내용은 책을 반드시 참고하자. 실험이 알차다.</li><li>여기선 Tip 에 해당하는 각 챕터의 요약부분만을 정리해둔다.</li></ul><h2 id=1-시스템-구성-정보-확인하기>1. 시스템 구성 정보 확인하기</h2><ul><li>demidecode 명령을 통해서 CPU, 메모리, BIOS 등의 정보를 확인할 수 있다.</li><li>CPU 정보는 <code>/proc/cpuinfo</code> 파일을 통해서도 확인할 수 있다.</li><li>free 명령을 통해서 시스템에 설치된 메모리의 전체 크기를 알 수 있다.</li><li>시스템에 마운트된 블록 디바이스의 정보는 df 명령을 통해 확인할 수 있다.</li><li>네트워크 카드 정보는 ethtool 명령을 통해서 확인할 수 있다.</li><li>ethtool 명령 중 -g 옵션으로 네트워크 카드에 설정된 Ring Buffer의 최대 크기와 현재 크기를 확인할 수 있다.</li><li>ethtool 명령 중 -k 옵션으로 네트워크 카드의 부수적인 기능들을 확인할 수 있다.</li><li>ethtool 명령 중 -i 옵션으로 네트워크 카드가 사용 중인 커널 드라이버의 정보를 확인할 수 있다.</li></ul><h2 id=2-top을-통해-살펴보는-프로세스-정보들>2. top을 통해 살펴보는 프로세스 정보들</h2><ul><li>top 명령으로 현재 시스템의 CPU, Memory, swap의 사용량 및 각 프로세스들의 상태와 메모리 점유 상태를 확인할 수 있다.</li><li>top 명령의 결과 중 VIRT는 프로세스에게 할당된 가상 메모리 전체의 크기를 가리킨다. RES는 그 중에서도 실제로 메모리에 올려서 사용하고 있는 물리 메모리의 크기, 그리고 SHR은 다른 프로세스와 공유하고 있는 메모리의 크기를 의미한다.</li><li>커널은 프로세스가 메모리를 요청할 때 그에 맞는 크기를 할당해주지만 해당 영역을 물리 메모리에 바로 할당하지는 않는다. Memory Commit 참고- <code>vm.overcommit_memory</code> 는 커널의 Memory Commit 동작 방식을 변경할 수 있게 해주는 커널 파라미터이다.</li><li>top으로 볼 수 있는 프로세스의 상태 중 D는 I/O 대기중인 프로세스, R은 실제 실행 중인 프로세스, S는 sleep 상태의 프로세스를 의미한다. T는 tracing 중인 프로세스, Z는 좀비 상태의 프로세스를 의미한다.</li><li>프로세스에는 우선순위가 있어 우선순위값이 더 작을 수록 빨리 실행된다. 우선순위는 nice 명령을 통해서 조절될 수 있다.</li></ul><hr><ul><li>개인 생각: nice를 조절해본 경험이 없는데, 조절할일이 많나?</li></ul><h2 id=3-load-average와-시스템-부하>3. Load Average와 시스템 부하</h2><ul><li>Load Average는 실행 중 혹은 실행 대기 중이거나 I/O 작업 등을 위해 대기 큐에 있는 프로세스들의 수를 기반으로 만들어진 값이다.</li><li>Load Average 자체의 절대적인 높음과 낮음은 없다.</li><li>커널에도 버그가 있을 수 있으므로 Load Average 값을 절대적으로 신뢰해서는 안된다.</li><li>vmstat 툴도 시스템 부하를 측정하는데 사용할 수 있다.</li><li><code>/proc/sched_debug</code>는 nr_running과 runnable tasks 항목에서 각 CPU에 할당된 프로세스 수와 프로세스의 PID 등 정보를 확인할수 있다.</li></ul><h2 id=4-free-명령이-숨기고-있는-것들>4. free 명령이 숨기고 있는 것들</h2><ul><li>free 명령으로 볼 수 있는 buffers 는 파일 시스템의 메타 데이터 등을 저장하고 있는 블록 디바이스의 블록을 위한 캐시이다.</li><li>free 명령으로 볼 수 있는 cached는 I/O 작업의 효율성을 위해 한번 읽은 파일의 내용을 저장하는 데 사용하는 캐시이다.</li><li>buffers와 cached는 미사용중인 메모리 영역을 시스템의 효율성을 위해서 커널이 사용하고 있는 것이며, 프로세스가 요청하면 이 영역을 해제하여 프로세스에게 전달해 줄수 있다.</li><li><code>/proc/meminfo</code> 에서 보이는 anon 영역은 프로세스에서 사용하는 영역, file 영역은 I/O 를 위한 캐시이다.</li><li>slab 영역은 커널이 사용하는 캐싱 영역을 의미, dentry cache, inode cache 등 다양한 캐싱 용도로 사용된다.</li></ul><h2 id=5-swap-메모리-증설의-포인트>5. swap, 메모리 증설의 포인트</h2><ul><li>버디시스템</li><li>swap 을 사용할 경우 성능하락이 생길수 있다.</li><li>swap 영역을 사용할 때에는 어떤 프로세스에서 swap 영역을 사용하는지 정확하게 알 필요가 있으며 smem 이라는 툴을 이용해 빠르게 확인할 수 있다.</li><li><code>vm.swappiness</code> 파라미터를 통해서 메모리 재할당시, swap을 사용하게 할지 페이지 캐시를 해제하게 할지 비율을 조절할 수 있다.</li><li><code>vm.vfs_cache_pressure</code> 파라메터를 통해 메모리 재할당시, 페이지 캐시를 더 많이 해제할지 vfs 관련 cache를 더 많이 해제할지 비율을 조절할 수 있다.</li></ul><h2 id=6-numa-메모리-관리의-새로운-세계>6. NUMA, 메모리 관리의 새로운 세계</h2><h3 id=개인-의견>개인 의견</h3><ul><li>NUMA는 예전에 논문 볼때 봤던건데, 최근 본 kubecon에서도 관련 자료가 있고, 이 책에도 있어 좀 놀랐다. 이게 이렇게나 기본 상식인지 몰랐다.</li><li>내용 자체는 좋으나 난이도가 있다고 생각해서, 모두 적지는 않는다.</li></ul><h3 id=요약>요약</h3><ul><li>NUMA : Non-Uniform Memory Access, 하드웨어 설계에 따른 cpu에 따라 특정 메모리에 접근하는 속도가 각기 다르다.</li><li>numastat, numactl 명령어를 사용해서 NUMA 의 상태, 제어를 할 수 있다.</li><li><code>/proc/&lt;pid>/numa_maps</code> 에 process 별 numa 정보가 확인 가능하다.</li><li>numad 는 데몬으로 상주하면서 프로세스의 numa 상태를 최적화한다. 하지만 항상 최적화가 좋은건 아니다.</li><li><code>vm.zone_reclaim_mode</code> 는 zone 에서 최대한 재할당해서 메모리를 확보하려고 노력할지, 최대한 다른 zone 을 통해서 메모리를 확보할지를 결정하는 변수이다.</li><li>numa 정책:<ul><li>bind : 특정 노드에서 메모리를 할당받도록 강제한다.</li><li>preferred : 선호하는 노드를 정하되, 부족하면 다른 곳에서 받는다.</li><li>interleave : 최대한 여러 노드에서 균등하게 받도록 한다.</li></ul></li><li>NUMA 아키텍쳐와 관련된 workload는 요구되는 memory size와 process의 thread 방식에 가장 큰 영향을 받는다.</li></ul><h2 id=7-time_wait-소켓이-서비스에-미치는-영향>7. TIME_WAIT 소켓이 서비스에 미치는 영향</h2><h3 id=개인-의견-1>개인 의견</h3><ul><li>워낙에 유명한 문제이기도 하고, 운영을 배울때 거의 단골로 나오는 내용이라 정리한다는 느낌으로만 봤다.</li></ul><h3 id=요약-1>요약</h3><ul><li>TIME_WAIT 소켓은 먼저 연결을 끊는 쪽에서 발생한다.</li><li>클라이언트 입장에서의 TIME_WAIT 소켓은 tw_reuse 파라미터를 통해 재사용할 수 있기 때문에 로컬 포트 고갈 문제는 발생하지 않는다.</li><li>불필요한 TCP 3 way handshake가 일어날 수 있기 때문에 가급적, Connection Pool 방식을 적용해 TIME_WAIT 소켓을 줄이도록 한다.</li><li>서버 입장에서는 TIME_WAIT 소켓은 tw_recycle 파라미터를 통해 빠르게 회수 할 수 있지만, 권장되지는 않는다. 근본적인 문제(connection 이 지나치게 낭비된다거나 등)를 찾아서 해결해야한다.</li><li>서버 입장에서 keepalive 기능을 켬으로써 불필요한 TCP 3way handshake 를 줄일 수도 있고 TIME_WAIT 소켓도 줄일수 있다. 서비스의 응답 속도 향상이 가능하지만, keepalive 가 가져올수 있는 문제점이 있기에 사용 시 테스트를 반드시 해봐야한다. 자세한건 keepalive 관련 챕터 및 LB 관련 내용 참고</li><li>TIME_WAIT 소켓은 정상적인 TCP 연결 해제를 위해 반드시 필요하다.</li></ul><h2 id=8-tcp-keepalive-를-이용한-세션-유지>8. TCP Keepalive 를 이용한 세션 유지</h2><ul><li>TCP Keepalive 는 커널레벨에서 종단 간의 세션을 유지시켜주는 기능을 한다.</li><li>net.ipv4.tcp_keepalive_time 는 두 종단 간의 연결이 유지되어 있는지를 keepalive 패킷을 보내는 주기를 설정한다.</li><li>net.ipv4.tcp_keepalive_probes 는 keepalive 패킷에 대한 응답을 받지 못했을 때 추가로 보내는 패킷의 개수를 지정한다.</li><li>net.ipv4.tcp_keepalive_intvl은 keepalive 패킷에 대한 응답을 받지 못해서 재전송 패킷을 보낼 때 필요한 주기를 설정한다.</li><li>tcp keepalive 설정으로 좀비 커넥션을 관리한다.</li><li>HTTP keepalive가 설정되어 있다면 tcp keepalive 설정 값과 다르다고 해도 의도한 대로 동작한다. 혼동하지 말자</li><li>LB 환경에서는 TCP Keepalive 가 설정되어 있지 않다면 LB Idle time 값을 참조해 설정해야 한다.</li></ul><h2 id=9-tcp-재전송과-타임아웃>9. TCP 재전송과 타임아웃</h2><ul><li>RTO(Retransmission Timeout)</li><li>TCP 재전송은 RTO를 기준으로 발생한다.</li><li>RTO 는 RTT를 기반으로 동적으로 생성된다.</li><li>관련 파라메터:<ul><li>net.ipv4.tcp_syn_retries</li><li>net.ipv4.tcp_synack_retries</li><li>net.ipv4.tcp_orphan_retries</li><li>net.ipv4.tcp_retries1, net.ipv4.tcp_retries2</li></ul></li><li>최소한 한번의 재전송은 견딜 수 있도록 connection timeout 은 3s, read tiemout 은 300ms 이상으로 설정하는 것이 좋다.</li></ul><h2 id=10-dirty-page가-io에-끼치는-영향>10. dirty page가 I/O에 끼치는 영향</h2><ul><li>관련 파라메터:<ul><li>vm.dirty_ratio</li><li>vm.dirty_background_ratio</li><li>vm.dirty_background_bytes</li><li>vm.dirty_writeback_centisecs</li></ul></li><li>diry page를 너무 빨리 동기화시키면 flush 커널 스레드가 너무 자주 깨어나게 되며, dirty page를 너무 늦게 동기화시키면 동기화해야할 dirty page가 너무 많아서 vm.dirty_ratio 에 도달할 가능성이 커지게 된다. 워크로드와 시스템 구성에 맞게 적절히 설정해주어야한다.</li></ul><h2 id=11-io-작업이-지나가는-관문-io-스케줄러>11. I/O 작업이 지나가는 관문, I/O 스케줄러</h2><ul><li><code>/sys/block/&lt;block device>/queue/scheduler</code> 에서 현재 사용하는 스케줄러, 사용 가능한 스케줄러 정보를 보고, 수정할 수 있다.</li><li>cfq, deadline, noop I/O scheduler</li><li>iotop 을 사용해서 I/O 프로세스를 확인 할 수 있다.</li><li>perf-tools 중에 iosnoop 은 I/O 요청들의 섹터 주소를 볼 수 있기에 순차 접근이 많은지 임의 접근이 많은지에 대한 I//O 워크로드 패턴을 살펴볼 수 있다.</li></ul><h2 id=12-어플리케이션-성능-측정과-튜닝>12. 어플리케이션 성능 측정과 튜닝</h2><ul><li>워커 수를 최소한 CPU 코어 수와 같은 수로 설정해서 CPU 리소스를 최대로 사용할수 있도록 구성한다.</li><li>TIME_WAIT 소켓이 생긴다면 연결을 유지한 상태로 사용해 성능을 향상시킬수 있다.</li><li>다른 서비스들과 연동할 때 keepalive 옵션과 커넥션 풀 방식을 사용해 성능을 증가 시킬수 있다.</li><li>시스템 리소스가 부족함이 없을때 응답 속도가 느려질 경우 워커 설정 및 소프트웨어적 설정에 문제가 있는지 확인해야한다.</li></ul><h2 id=개인-정리>개인 정리</h2><ul><li>개인적으로 알고 있었던 설정들도 있고, 모르고 있던 설정들도 있는데 전반적으로 한곳에 이런걸 모아둬서 정리하는 보람이 있었다.</li><li>사실 지식으로만 알고 있던 부분들을 실습을 섞어서 수치로 볼수 있게 구성되어 있어 책 자체 퀄리티가 좋다고 생각한다.</li><li>몇몇 커널 파라메터는 너무 어렵다. 수치를 보면서도 바로바로 해석이 안된다.</li></ul></div><hr><div class=list-files><ul class=section-tree></ul></div></article><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer></body><script src=/js/dir_toggle.js></script><script src=/js/codeblock_copy.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css><script type=module>
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";
mermaid.initialize({
  startOnLoad: true,
  theme: "dark",
});
</script></html>