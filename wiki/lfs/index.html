<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>LFS Paper</title><style>html body{font-family:raleway,sans-serif;background-color:#fff}:root{--accent:#00a3d2;--border-width:5px}</style><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/copy-btn.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=/js/copy-btn.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98056974-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-98056974-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta name=google-site-verification content="g_3tJyj-KkW-_wKx7Ij5GimHV1nKPZXetCz8ydbBAfA"></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>LFS Paper</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/wiki/>Wiki</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></nav><main><div class=navigator style=display:flex><div style=display:flex><div class=parent-doc style=flex:none><button class="btn btn-link" onclick='(function(e){e.querySelector("a").click()})(this)'>
<i class="fa fa-arrow-left"></i>
[[ssd]]</button></div></div></div><div><h2>LFS Paper</h2><a href=https://github.com/minuk-dev/minuk-dev.github.io/blame/master/content/wiki/LFS.md><h5>created : Thu, 16 Jul 2020 20:35:14 +0900</h5><h5>modified : Sun, 23 Aug 2020 20:20:12 +0900</h5></a><a href=https://minuk.dev/tags/filesystem><kbd class=item-tag>filesystem</kbd></a>
<a href=https://minuk.dev/tags/lfs><kbd class=item-tag>lfs</kbd></a></div><aside class=navbar id=nav-toc style=text-align:left><nav id=TableOfContents><ul><li><a href=#the-design-and-implementation-of-a-log-structured-file-system>The Design and Implementation of a Log-Structured File system</a><ul><li><a href=#읽은-계기>읽은 계기</a></li><li><a href=#잡담>잡담</a></li><li><a href=#abstract>Abstract</a></li><li><a href=#1-intorduction>1. Intorduction</a></li><li><a href=#2-design-for-file-systems-of-the-1990s>2. Design for file systems of the 1990&rsquo;s</a></li><li><a href=#3-log-structured-file-systems>3. Log-structured file systems</a></li><li><a href=#4-crash-recovery>4. Crash recovery</a></li><li><a href=#5-experience-with-the-sprite-lfs>5. Experience with the Sprite LFS</a></li><li><a href=#6-related-work>6. Related work</a></li><li><a href=#7-conclusion>7. Conclusion</a></li></ul></li></ul></nav></aside><div align=start class=content data-spy=scroll data-offset=20 data-target=#nav-toc style=position:relative><h2 id=the-design-and-implementation-of-a-log-structured-file-system>The Design and Implementation of a Log-Structured File system</h2><h3 id=읽은-계기>읽은 계기</h3><ul><li><del>주변에서 읽어보라 해서</del></li><li>F2FS 에서 관련 논문으로 조회되서</li><li>우연히 김박사넷에 관심 분야에 뭐뭐 있나 찾아보다가 보여서</li></ul><h3 id=잡담>잡담</h3><ul><li>겸사겸사 영어 공부할겸 영어로 paraphase 하면서 작문하는 연습을 하기로 했다.</li><li>영어로 먼적 작문 하고 한글로 다시 번역하는 식으로 진행</li></ul><hr><h3 id=abstract>Abstract</h3><ul><li>This paper introduces <code>log-structured file system</code>. (이 논문에서는 <code>log-structured file system</code> 을 소개한다.)</li><li>This FS has a log-like structure and it contains all modifications sequentially. (이 파일 시스템에서는 log 같은 구조체가 있으며, 이건 모든 변경사항을 순차적으로 가지고 있다.)</li><li>This method boosts file writing and crash recovery. (이러한 방법은 파일 쓰기와 장애 복구를 향상 시킨다.)</li><li>The Log is a structure on disk to index information . (로그는 정보를 색인하기 위한 디스크 상의 자료구조이다.)</li><li>We introduce new concepts, which disk spaces are divided by a specific size, to maintain large free areas on disk for fast writing. (빠른 쓰기를 위해 디스크에 큰 여유공간을 확보하는 게 문제가 되었고, 이를 디스크를 특정한 크기로 나눔으로써 해결하는 새로운 방법을 제시했다.)</li><li>There is a prototype log-structured file system called Sprite LFS. It can use 70% of the disk bandwidth for writing. (Sprite LFS 라는 프로토 타입을 제시하였고, 이 는쓰기할때 디스크의 70%의 성능을 사용하게 해준다.)</li></ul><hr><h3 id=1-intorduction>1. Intorduction</h3><h4 id=background>Background</h4><ul><li>CPU speeds have increased but disk doesn&rsquo;t. => Application performances are limited. (CPU의 성능은 향상되는데 디스크는 그렇지 않고 이로 인해서 제약이 생긴다.)</li></ul><h4 id=idea>Idea</h4><ul><li>Many read requests loaded from main memory. => Write requests are a bottleneck on disk performances. (많은 읽기 요청이 메인 메모리에서 가져와지기 때문에 병목은 쓰기 요청에 있다는 것을 알수 있다.)</li><li>Many of writing times account for seeking time. => We use a sequential structure called log to remove it. (쓰기 시간은 대부분이 쓸 위치를 찾는 시간이고, 이를 순차적 쓰기 구조를 통해서 해결한다.)</li><li>Because of the nature of the log, crash recovery can be also faster. (Log 의 특성에 따라 자연스럽게 장애 복구 또한 빨라졌다.)</li></ul><h4 id=related-works>Related works</h4><ul><li>Many other papers suggest this notion. But, it is only for temporary storage. (다른 논문들도 이런 개념을 제시하였으나 일시적 저장에 그쳤다.)</li></ul><h4 id=well-known-issues>Well-known issues</h4><ul><li>Log structured File system has a problem to free up disk space for new data. We solve it by introduce segments and segment cleaner. (알려진 문제로, Log structured File system은 새로운 데이터를 위해 디스크 공간을 확보하는 게 있으며, 이는 segments와 segment cleaner를 통해서 해결한다.)</li></ul><hr><h3 id=2-design-for-file-systems-of-the-1990s>2. Design for file systems of the 1990&rsquo;s</h3><h4 id=21-technology>2.1. Technology</h4><ul><li>File system design has three significant components(Processors, Disks, and Main Memory).</li><li>Disk performance depends on two components (Transfer bandwidth and access time).</li><li>Disk is not better than before compared with CPU.</li><li>Main Memory improvement is so remarkable that modern file systems cache recently-used file data in it. Therefore, a system can absorb a greater fraction of the read requests and more write requests can be buffered before write to disk.</li></ul><h4 id=22-workloads>2.2. Workloads</h4><ul><li>Random accesses are dominated by small files. In contrast, Sequential are dominated by large file.</li></ul><h4 id=23-problems-with-existing-file-systems>2.3. Problems with existing file systems</h4><ul><li>Current file systems have two problems.</li><li>First, spread information around the disk caused too many small accesses.</li><li>Second, applications must wait for the write to complete.</li></ul><hr><h3 id=3-log-structured-file-systems>3. Log-structured file systems</h3><ul><li>Basic idea : Buffering a sequence of file system changes in the file cache and then writing all the changes to disk sequentially in a single disk write operations.</li><li>This single write operation contains file data blocks, attributes, index, blocks, directories, and almost all the other information.</li><li>This idea has two important issues.</li><li>First, How to retrieve inforamtion from the log.</li><li>Second, How to manage the free space on disk for writing new data.</li></ul><h4 id=31-file-location-and-reading>3.1. File location and reading</h4><ul><li>Basic structures are based from inode, and contains the first ten blocks of the file. When the file is bigger than ten blocks, it contains one or more indirect blocks.</li><li>Unlike other file systems, inode map, which maintains the current locations of each inode, are placed at unfixed location. It is divided into log blocks.</li><li>A fixed checkpoint region on each disk identifie the locations of all the inode map blocks.</li></ul><h4 id=32-free-space-management-segments>3.2. Free space management: segments</h4><ul><li>It is main issue for log-structured filesystem to manage free space.</li><li>From this point on, Threading and copying live data are presented.</li><li>Sprite LFS use a combination of threading and copying. -> The disk is divided into large fixed-size extent called segments.</li><li>All live data are copied before the segment was rewritten.</li></ul><h4 id=33-segment-cleaning-mechanism>3.3. Segment cleaning mechanism</h4><ul><li>The process of copying live data out of a segment is called segment cleaning.</li><li>It consists of three-step.<ul><li>Read a number of segments into memory</li><li>Identify the live data</li><li>Write the live data back to a smaller number of clean segments.</li></ul></li><li>In order to write out again, Identifying blocks must be possible.</li><li>=> For this purpose, We define segment summary block, which are indexing which segment is live.</li><li>Segment Summary Blocks impose little overhead during writing, and they are useful during crash recovery.</li><li>Sprite LFS counts the number (unique identifier - uid) to recognize which block is live. If the uid of a block does not match the uid currently stored in the inode map when the sgement is cleaned.</li></ul><h4 id=34-segment-cleaning-policies>3.4. Segment cleaning policies</h4><ul><li>Four policy issues must be addressed<ul><li>When should the segment cleaner execute?</li><li>How many segments should it clean at a time?</li><li>Which segments should be cleaned?</li><li>How should the live blocks be grouped when they are written out?</li></ul></li><li>In this paper, we do not focus on the first and second keypoints. It just run when the number of segments which must be cleaned is over threadshold value.</li><li>We think the third and fourth policy decisions are more important than former things.<ul><li>To decision this, we use a term called write cost</li><li>$$\text{write cost} = \frac{\text{total bytes read and writeen}}{\text{new data written}} = \frac{\text{read segs} + \text{write live} + \text{write new}}{\text{new data written}} = \frac{N + N \times u + N \times (1-u)}{N \times (1-u)} = \frac{2}{1-u}$$</li><li>It means the average amount of time when the disk is busy per byte of new data written, including all the cleaning overheads.</li><li>It is ideal that this value equals 1.0.</li><li>The above formula has one conservative assumption, a segment must be read in its entirety to recover the live blocks. However in practice, it may be faster to read just the live blocks.</li></ul></li><li>According to reference, Unix FFS on small-file workloads uses only at most 5-10% of the disk bandwidth for a write cost of 10-20.</li><li>From this, we conclude the cleaner can choose the least utilized segments to clean.</li><li>There is a trade off between performance and space utilization. But this is not only in log-structured file systems.</li><li>The key for high performance at low cost is to force the disk into a bimodal segment distribution where some segments are nearly full and others are nearly empty.</li></ul><h4 id=35-simulation-results>3.5. Simulation results</h4><ul><li>We build a simulator to analyze different cleaning policies under controlled conditions.</li><li>modeling a fixed number of 4-kbytes files</li><li>It has two random access patterns: Uniform and Hot-and-cold.<ul><li>Uniform : Each file has equal likelihood of being selected in each step.</li><li>Hot-and-cold : One group contains 10% of the files; 90% of the time. The other are 90% of the files;10% of the time.</li></ul></li><li><img src=/wiki/images/lfs-figure4.png alt=figure4.png></li><li>Figure 4 shows the surprising result that locality and better grouping result in worse performance than a system with no locality.</li><li><img src=/wiki/images/lfs-figure5.png alt=figure5.png></li><li>Figure 5 shows the reason for above the situation. Every segment&rsquo;s utilization eventually drops to the cleaning threshold, including the cold segments and the utilization of cold segments drops very slowly. It caused to linger.</li><li>??? 머지 이해 못하겠는데??</li><li>일단 지금 이해한건, cold data 도 live data 인데, 90% 정도로 큰 비율을 차지하기 때문에 segments 의 대부분이 live data 가 많은 채로 유지되고, 이게 결국 write cost를 커진 채로 남아 있는 block 들이 계속 쌓이게 되고, 이런 segments 들이 많아지다가 이걸 치워야 할때 문제가 발생한다는 건가?</li></ul><h4 id=36-segment-usage-table>3.6. Segment usage table</h4><ul><li>It use <code>segment usage table</code> to support benefit.</li><li>Segment usage table maintains how many bytes of live data and most recent modified time per segment in order to clean.</li><li>The blocks of the segment usage table are written to the log, and the addresses of the blocks are stored in the checkpoint regions.</li></ul><hr><h3 id=4-crash-recovery>4. Crash recovery</h3><ul><li>When a system crash occurs, such as sudden shutdown, and reboot the system.</li><li>In many other file system, Crash recovery has very high costs.</li><li>However, Sprite LFS can improve this performance to use <code>checkpoints</code> and <code>roll-forward</code></li></ul><h4 id=41-checkpoints>4.1. Checkpoints</h4><ul><li>To create a checkpoint, We have to take two steps.</li><li>First, it writes out all modified information to the log, including file data blocks, indirect blocks, inodes, and blocks of the inode map and segment usage table.</li><li>Second, it writes a checkpoint region to a special fixed position on disk.</li><li>The checkpoint region contains the addresses of all the blocks in the inode map and segment usage table, plus the current time and a pointer to the last segment written.</li><li>During reboot, Sprite LFS reads the checkpoint region and uses that information to initialize its main memory data strucutres.</li><li>To prevent crash, there are actually two checkpoint regions for recovery.</li><li>The checkpoint time determines which checkpoint to use for the recovery process.</li><li>The interval between checkpoints affects the overhead of writing and system tolerance against crash. This paper use 30 seconds.</li></ul><h4 id=42-roll-forward>4.2. Roll-forward</h4><ul><li>Crash recovery process is just to discard any data in the log after the lastest checkpoint. It named <code>roll-forward</code>.</li><li>During roll-forward Sprite LFS uses the information in segment summary blocks to recovery recently-written file data.</li><li>The roll-forward code also adjusts the utilizations in the segment usage table read from the checkpoint.</li><li>The final issue in roll-forawrd is how to restore consistency between directory entries and inodes.</li><li>To solve it, Sprite LFS outputs a special record in the log for each directory change(operation code, the location of the directory entry, the contents of the directory entry and the new reference count for the inode named in the entry.). - called the <code>directory operation log</code>.</li><li>During roll-forward, the diretory operation log is used to ensure consistency between directory entries and inodes.</li><li>The interaction between the directory operation log and checkpoints introduced additional synchronization issues.</li></ul><hr><h3 id=5-experience-with-the-sprite-lfs>5. Experience with the Sprite LFS</h3><h4 id=51-micro-benchmarks>5.1. Micro-benchmarks</h4><ul><li><img src=/wiki/images/lfs-figure8.png alt=figure8.png></li><li><img src=/wiki/images/lfs-figure9.png alt=figure9.png></li><li>밴치마크를 지금 평가하기에는 조금 어려운듯. 논문 출판년도가 년도이고, 이때 당시에는 SSD 보다는 HDD 였을테니, 그냥 그랬구나하면서 끝내고, 논문에서 분석한 이유? 정도만 요약하면 될듯. 추가적으로 LFS의 뒤를 잇는 F2FS 를 다시 읽어보는게 더 좋을듯.</li><li>The data is too old to analyze. We just see <code>Sprite LFS</code> is better especially on writes.</li></ul><h4 id=52-cleaning-overheads>5.2. Cleaning overheads</h4><ul><li><img src=/wiki/images/lfs-table2.png alt=table2.png></li><li>밴치마크들은 이야기하는 것 보다 그냥 보는게 낳은듯 더 이상 정리 안함.</li><li>There are two reasons that the experience benchmarks is better than the simulations and predictions.</li><li>First, in practice, there are a substantial number of longer files and they tend to be written and deleted as a whole, however in simulations, just a sing block long. It affects locality each segments.</li><li>Second, data temperatures is different. In practice, it has much gap between hot data and cold data.</li></ul><h4 id=53-crash-recovery>5.3. Crash recovery</h4><ul><li>Skip</li></ul><h4 id=54-other-overheads-in-sprite-lfs>5.4. Other overheads in Sprite LFS</h4><ul><li>Because of the short checkpoint interval, metadata is unnecessary often accessed.</li></ul><h3 id=6-related-work>6. Related work</h3><ul><li>Skip</li></ul><h3 id=7-conclusion>7. Conclusion</h3><ul><li>The basic principle behind a lfs is &ldquo;collect large amounts of new data in a file cache in main memory&rdquo;.</li></ul></div><script src=/js/wikilink.js></script><div><script src=https://utteranc.es/client.js repo=minuk-dev/minuk-dev.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></main><footer class=footer><div class=footer-left></div><div class=footer-right><ul class=social><li><a href=/about>About</a></li><li><a href=https://github.com/minuk-dev>Github</a></li></ul></div></footer>