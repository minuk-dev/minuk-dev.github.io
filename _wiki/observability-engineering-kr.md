---
layout  : wiki
title   : Observability Engineering
summary : 뎅브옵스 엔지니어를 위한 실전 관찰 가능성 엔지니어링
date    : 2024-08-18 23:12:23 +0900
lastmod : 2024-08-18 23:12:23 +0900
draft   : false
parent  : Book reviews
resource: 533a8e0d-a063-47ce-8177-d38b17431249
---

- 원래 영어로 읽었었다.
- [[Observability Engineering]]
- 아무래도 번역된걸 읽으면 다른 느낌일수도 있어서 다시 읽는다.

# Part 1. 관찰 가능성으로 가는 길
## Chatper 1. 관찰 가능성이란?
### 1.1. 관찰 가능성의 수학적 정의
- 관찰가능성: 외부출력으로부터 시스템 내부의 상태를 얼마나 잘 추론할 수 있는 것인지를 축정하는 것

### 1.2. 소프트웨어 시스템에 대한 관찰 가능성 적용
- 소프트웨어 어플리케이션이 관찰 가능성을 갖도록 하기 위해 알아햐하는 것:
  - 어플리케이션 내부 동작을 이해해야 한다.
  - 전혀 보지 못했거나, 예상하지 못했던 시스템 상태 등 어플리케이션이 가질 수 있는 시스템 상태를 알고 있어야한다.
  - 코드에 대한 이해 없이 외부 도구를 이용해 관찰하고 쿼리하는 것만으로도 내부 동작 및 시스템 상태를 이해랄 수 있어야 한다.
  - 별도의 코드를 추가하지 않더라도 내부 상태를 이해할수 있어야한다. (코드를 추가해야 내부 상태를 이해할 수 있다면 어플리케이션에 대한 선행지식이 필요하다는 것을 의미한다.)

### 1.3. 소프트웨어를 위한 관찰 가능성에 대한 잘못된 특성화
- 소프트웨어 시스템이 관찰 가능성을 갖도록 하기 위해 특정한 도구를 채택할 필요는 없다. 하지만, 관찰 가능성을 향상시키기 위해 데이터를 효율적으로 수집하여 문제점을 효과적으로 디버그하는 방법을 발전시켜야한다.

### 1.4. 왜 지금 관찰가능성인가?
- 기존의 접근방식은 사후 대응적이다.
- 모니터링만으로는 소프트웨어 개발자들의 시스템을 완전히 살펴볼 수 없다.
- 모니터링에서는 개발자들은 성능 임계치를 설정한다. 이는 시간이 지나면서, 임계치에 다가간 수치들을 제거하거나(e.g. 응답시간에 대한 임계치가 100ms 일때, 수치가 90ms 쯤 되면 이를 낮추려고 노력한다.), 임계치를 조정하거나(e.g. 100 ms 였던것을 300ms, 600ms 점점 올린다. 포인트는 이러한 조정이 근거가 떨어지고 감에 의한것들) 쓸데없는 신호들(e.g. 진짜로 특정 API 요청에 대한 응답시간이 유저에게 치명적인가에 대한 고민이 없을수 있다.)에 대해 호들값을 떤다.

#### 1.4.1. 이것이 정말 최선의 방법인가?
- 모니터링 관행은 시스템에 대한 많은 암묵적 가정으로 수행되었다.
- 시스템은 점점 추상적이고 복잡해지면서 내재된 한계에 부딧히게 되었다.

#### 1.4.2  메트릭과 모니터링이 충분하지 않은 경우
- 많은 복잡한 부가 요소들은 메트릭을 기반으로 만들어졌다.:
  - 시계열 데이터베이스와 통계분석,
  - 그래프 라이브러리와 매혹적인 대시보드
  - 온콜 로테이션 체계, 운영팀, 에스컬레이션 정책
- 시스템의 복잡도가 높아짐에 따라, 저수준 명령어로 다시 돌아가게 되었다.
- 현대적 시스템의 실제 상황:
  - 어플리케이션은 많은 서비스로 구성된다.
  - Polypglot persitence 방식(필요에 따라 적절한 데이터베이스와 스토리지를 선택하는 방식)
  - Infra 는 역동적이며 탄력적이다.
  - 광범위하며 느슨하게 연결된 서비스들이 있고, 대부분 통제 범위 밖
  - 엔지니어는 아주 작은 이슈라도 빠르게 수정하고 프로덕션에 배포하여 사용자에게 영향을 주지않으려고 함.
  - 자동계측으로는 복잡한 시스템 내에서 발생하는 일을 완전히 이해하기에 충분하지 않다.
  - 소프트웨어 엔지니어들은 프로덕션 환경에서 운영중인 자신의 코드를 가지고 있으며, 배포시 발생할 수 있는 성능 변화를 미리 계측하고 싶어한다.
  - 신뢰성은 오류 계산, 서비스 품질, 사용자 경험을 복합적으로 고려하며 사용자에게 부정적인 영향을 줄이도록 하고, 이러한 탄력성을 구축하는 동시에 일정하면서도 지속적으로 성능 저하를 허용하는 것에 초점이 맞춰져 있다.:
    - 이게 좀 어렵게 써져있는데,
    - 에러 budget 을 정하고, 이러한 수준까지는 성능 저하를 허용하여서 개발자가 탄력적으로 개발할수 있게하고, 어느 수준이 될 경우에는 이러한 에러를 줄이기 위해서 노력해야한다는 것을 의미하고
    - 신뢰성 측정은 이러한 것에 도움을 줘야한다는 뜻으로 해석된다.
    - 더 자세한건 SRE 책을 참조하자.
  - 수많은 요소들(디멘젼)이 상관관계를 가지며 분석해야한다.
  
### 1.5. 메트릭을 이요한 디버깅과 관찰 가능성을 이요한 디버깅
- 직관적인 접근방법은 이전에 겪었던 문제의 변형이거나 연장선 상에 있는 것 같이 예측 가능할 때만 유효한다.
- 현대적인 분산 시스템 아키텍처는 그 누구도 예측할 수 없고 이전에 경험해보지 못했던 새로운 방식으로 실패하는 것으로 악명이 높다.
- 모니터링이 알려진 불확실성에 대한 것이라면, 관찰가능성은 알려지지 않은 불확실성에 대한 것이다.

#### 1.5.1. 카디널리티의 역할
- 메트릭 기반의 도구들은 주어진 합리적인 스케일에서 낮은 카디널리티를 갖는 디멘션만 다룰수 있다.
- 메트릭은 아래 2가지 특성을 가지게 된다.:
  - 조사하는 동안 잠재적인 문제의 근원을 파악하기 위해 반드시 확인되어야만 하는 추가 질문을 결정한다. 즉, 메트릭을 설정하고 문제 재발을 기다려야한다.
  - 둘쨰, 추가 질문을 대답하기 위해서는 또다른 메트릭들이 필요하므로, 모든 새로운 방식에 따라 비용이 선형적으로 증가한다.

#### 1.5.2. 디멘셔널리티의 역할
- 카디널리티: 데이터 값의 고유성
- 디메셔널리티: 데이터의 키 개수에 관한 것

### 1.6. 관찰 가능성을 이용한 디버깅
- 관찰 가능성 도구들은 높은 카디널리티와 높은 디멘셔널리티에 대해 쿼리할 수 있도록 설계되어 있다.
- 관찰 가능한 시스템의 핵심은 시스템을 개방형 방식으로 계속해서 탐색할 수 있는가 이다.
- 모니터링은 사후 대응적으로 접근한다.
- 엔지니어들은 예측할 수 없는 실패 상황에 대해 강한 반감을 가진다.
- 하드웨어, 인프라 문제는 개발자가 만든 코드나 사용자로 인해 발생한 문제에 비해 상대적으로 간단하다.
- 이러한 점이 모노리식 환경이나 아주 간단한 아키텍쳐를 다루는 사람들조차 모니터링보다 관찰 가능성을 선호하게 되는지를 말한다.

### 1.7. 현대적인 시스템을 위한 관찰 가능성
- 관찰가능하다: 상태를 이해하기 위해 새로운 코드를 배포하는 일 없이도 시스템의 상태를 이해할 수 있을때
- 예측 불가한 장애 모드는 종종 발생하지만 거의 반복되지 않는다는 특징이 있다.:
  - Available, Reliable, Capable 한 모니터링 대시보드를 만들기가 어렵다.

## Chapter 2. 관찰 가능성과 모니터링의 디버깅은 어떻게 다를까?
### 2.1. 모니터링 데이터를 활용한 디버깅
- 메트릭에서는 시스템은 이분법적이다. 알림을 보내냐, 보내지 않느냐.
- 데시보드가 처음 만들어질때는 걱정할 시스템 메트릭이 얼마 없지만, 시간이 지나면서 점점 추가되고, 현대적인 서비스는 하나의 화면에 표기할수 없을 정도로 많은 메트릭을 수집한다.
- 필요한 조건을 정의하여, 디버깅하거나 대시보드를 만들기 위해서 선견지명이 필요하다. 이는 사용자에게 부담이 된다.
- 근본적으로, 메트릭을 이용해 새로운 시스템애 관한 통찰력을 갖는 것은 태생적으로 사후 대응적인 접근이 될 수밖에 없다.
- 이러한 제약사항을 바탕으로 트러블슈팅 하는 것에 너무 익숙해져있다.

### 2.1.1. 대시보드를 이용한 문제 해결
### 2.1.2. 직관을 통한 문제 해결의 한계
- 충분하지 않은 상관관계
- 드릴다운 되지 않음
- 도구의 춘추 전국 시대

### 2.1.3. 사후 대응적일 수 밖에 없는 기존 모니터링
- 프로덕션 환경에서 문제가 발생했을 때, 실제 눈에 보이는 시스템 정보의 조각들로부터 어디를 조사해야 할지를 결정하고 있는가? 아니면 문제점을 찾기 위해 직감을 따르고 잇는가? 혹은 지난번에 문제를 찾아냈던 곳을 들여다보고 있는가?
- 시스템에 대한 전문성과 이전에 발생했던 문제들에 의존하고 잇는가? 문제 분석을 위해 트러블슈팅 도구를 이용할 때 탐색적으로 증거를 찾고 있는가? 아니면 가설을 증명하기 위해 노력하고 있는가?
- 종종 직감에 따라 해결책을 정하고, 그 해결책이 맞는 답인지 확인하기 위해 적용해 보는 경우가 얼마나 많은가? 확인된 가정이 문제의 원인이 아니고 증상 혹은 결과라서 실제 문제는 해결하지 못하는 경우가 있는가?
- 트러블슈팅 도구가 여러분의 의문점에 대해 정확한 답변을 주고 올바른 해결책으로 이끌어 주는가? 아니면 실제로 필요한 답을 얻기 위해 도구가 제시한 해결책을 시스템에 대한 전문성을 바탕으로 원하는 답을 얻기 위해 한 번 더 해석하는가?
- 관찰된 내용 간의 관계를 연결 짓고, 서로 다른 데이터 소스들 사이에 문맥을 전달하기 위해 자신의 의존한 트러블슈팅 도구에서 다른 도구로 전환하는 횟수가 얼마나 되는가?
- 무엇보다도 팀 내의 최고 디버거는 가장 오래한 근무한 사람인가? 이는 시스템에 대한 지식 대부분은 도구와 같이 대중적인 방법에 의한 것이 아니라 개인적인 실무 경험을 바탕으로 얻은 것이라는 것을 알려주는 결정적인 증거이지 않는가?

### 2.2. 관찰 가능성을 통한 더 나은 디버깅
- 관찰 가능성 도구를 사용하는 팀 내의 최고 디버거는 가장 호기심이 많은 엔지니어이다.
- 디버깅하를 하는 과정에서 메트릭을 보다가 로그러 넘어갈때 문맥을 넘어가야하고, 트레이스를 볼때 또 한번 그래야한다. 이러한 과정에서 사람은 실수를 하게 되고 다수의 데이터소스와 출처를 다루는 것에 어려움을 겪을 수 있다.
- 관찰 가능성 도구는 이러한 문맥을 추출해 하나의 도구에서 제공한다.

## Chapter 3. 관찰 가능성 없이 확장하며 배운 교훈
## Chapter 4. 관찰 가능성은 어떻게 데브옵스, SRE, 클라우드 네이티브를 연결하는가
### 4.1. 클라우드 네이티브, 데브옵스, SRE 에 대한 간단한 소개
- https://cloud.google.com/blog/products/devops-sre/the-2019-accelerate-state-of-devops-elite-performance-productivity-and-scaling
- 클라우드 네이티브: 탄력적이고 관리가능하며, 관찰 가능한 느슨한 연결된 시스템을 가능하게 해준다. 견고한 자동화 기능과 함께 사용하면, 엔지니어는 최소한의 노력만으로도 영향이 큰 변경을 자주 그리고 예측 가능하게 수행할 수 있게 된다.

### 4.2. 관찰 가능성: 디버깅의 과거와 오늘
- 클라우드 네이티브에서 언급된 기술:
  - 컨테이너, 서비스 메시, 마이크로서비스, 불변 인프라
- 분산 트레이싱을 이용해 개별 요청의 처리 단계를 나누고 시가고하할 수 있기 때문에 특정 요청의 실행에 영향을 미치는 복잡한 종속 관계만 이해하면 된다.
- 관찰 가능성은, 시스템의 복잡도와 관계 없이 일관되고 합리적인 방식으로 디버깅할 수 있도록 공유문맥을 제공한다.

### 4.3. 관찰 가능성을 통한 데브옵스와 SRE 프랙티스의 강화
- SLO, error budgets 를 통해서 서비스를 관리하는데 중점을 둔다.
- 원인 중심의 모니터링에서 증상 중심의 모니터링으로 변화한다는 것은 알려진 장애 모드를 나열하는 기존의 접근 방법 대신 실제 사례에서 경험한 실패를 설명할수 있는 능력이 필요하다는 것을 의미한다.
- SRE 는 관찰 가능성, 피쳐 플래깅, 지속적인 검증, 사고 분석과 같은 엔지니어링 기술을 제공한다.

- 카오스 엔지니어링과 지속적인 검증
- 피쳐 플래깅
- 점진적인 출시 패턴
- 사고 분석과 비난하지 않는 회고

# Part 2. 관찰 가능성 기초
## Chatper 5. 정형화된 이벤트: 관찰 가능성의 기본 구성 요소
- 예전 방식에서는 메트릭을 만들고, 어떠한 새로운 질문에 대한 답을 찾기 위해 새롭게 미리 사용자 정의 메트릭을 정의해야만 한다.
- 관찰 가능성에서는 상위 수준의 집계된 성능 데이터부터, 개별 요청에서 사용된 원천 데이터까지 시스템을 반복적으로 탐색할 수 있어야한다.
- 정형화된 이벤트를 통해 어떠한 정보든 담을 수 있도록 해야한다.

### 5.1. 정형화된 이벤트를 이용한 디버깅
- 어떠한 요청을 처리하기 위해, 고유 ID, 변수 값, 헤더, 요청에 포함된 모든 매개 변수, 실행 시간, 호출된 원격 서비스, 원격 서비스 수행에 소요된 시간 혹은 나중에 디버깅할 때 도움이 될 수 있는 문맥에 관한 다른 정보들
- 종류: 런타임 정보, 요청 정보
- 이벤트에 추가할 수 있는 세부 정보의 양에는 사실상 제한이 없어야 한다.

### 5.2. 메트릭을 기본 구성 요소로 사용하기 어려운 이유
- 메트릭 기반에서는 단서를 제공할수는 있지만, 세부정보를 담기 어렵다.
- 이벤트 기반에서는 더 작은 단위로 분류되고, 다양한 관점을 보여줄 수 있다.
- 사전에 정의된 기간에 대하여 미리 정의한 관계를 수치화한 메트릭은 시스템의 단일 속성에 한정된 좁은 시야의 뷰만을 제공한다. 제약사항이 너무 많다.

### 5.3. 기존 로그를 기본 구성 요소로 사용하기 어려운 이유
#### 5.3.1. 비정형 로그
- 기존의 로그는 사람이 읽을 수 있도록 만들어졌기 때문에 정형화되어 있지 않았다.
- 현대적인 시스템에서는 로그가 중앙의 집계기로 전달되어 대규모로 구축된 스토리지 백엔드 시스템에 저장된다.
- 로그파서는 정형화되지 않은 수백만 라인의 로그를 검색할 수 있고, 이러한 로그 파서는 로그데이터를 정보의 조각으로 나누고 그룹화를 해야한다.
- 이 과정에서 정형화되지 않은 데이터들이 혼재되어 있다면 파싱이 복잡해진다.

#### 5.3.2. 정형화된 로그
- 각 메시지에 요청 ID 와 같은 공통 필드를 포함시켜두면 좋다.
- Observability 의 목표가 시스템의 내부 상태를 이해하기 위해 이벤트 데이터로부터 여러가지 방법을 이용해 정보를 얻어내는것이니 기계가 읽을 수 있는 형식의 데이터여야 한다.


### 5.4. 디버깅 시 유용한 이벤트
- 알려져 있거나 예상 가능한 필드뿐만 아니라 임의의 필드 값도 저장할 수 있도록 이벤트의 범위가 넓어야 한다.

### 요약
- 관찰 가능성의 기본 구성요소는 임의로 확대 가능한 정형화된 이벤트이다.
- 정형화된 이벤트는 충분한 공간(Cardinality 측면)을 가져야한다.
- 메트릭은 하나의 시스템 속성에 대한 하나의 좁은 관점만 제공하고, 미리 정의되어야하기 때문에 기본 구성 요소로 역할을 수행하기 힘들다.
- 비정형 로그는 컴퓨터가 활용하기 어렵다. 정형화된 이벤트를 사용하자.

## Chapter 6. 이벤트를 추적으로 연결하기
- 분산 추적: 서로 연관된 일련의 이벤트 집합이다.

### 6.1. 분산 추적이란 무엇이고 왜 중요한가?
- 분산 추적은 어플리케이션을 구성하는 다양한 서비스가 처리하는 단일 요청 혹은 추적의 진행상황을 따라가는 방법이다.
- 구글의 2010 Dapper 에 관환 논문을 발표한 이후 분산추적의 인기가 높아지기 시작했다.:
  - twitter: zipkin
  - uber: jeager
  - honeycomb: lightstep
- 분산 추적은 분산 시스템의 다양한 서비스와 컴포넌트 간의 관계를 명확하게 보여주기 때문에 이용해 볼만한 가치가 있다.

### 6.2. 추적을 구성하는 컴포넌트
- 워터폴 차트:
  - trace span, root span, parent-child
- 필수 구성요소:
  - trace id
  - span id
  - parent id
  - timestamp
  - duration time
- 있으면 효과적인 tag:
  - service name
  - span name

### 6.3. 어렵게 추적 계측하기
- 손으로 하나하나 하기
- 이때 W3C와 B3 에서 규정한 표준을 따라야한다.

### 6.4. 추적 스팬에 사용자 정의 필드 추가하기
### 6.5. 이벤트를 추적으로 연결하기
- OpenTelemetry 쓰세요

## Chapter 7. OpenTelemetry를 이용한 계측
### 7.1. 계측이란?
### 7.2. 오픈 계측 표준
- OpenTelemetry

### 7.3. 코드를 이용한 계측
- OpenTelemetry 개념:
  - API: 개발자가 계측의 세부적인 구현을 신경쓰지 않더라도, 코드를 계측 할 수 있도록 해주는 OTel 라이브러리의 규격이다.
  - SDK: OTel 을 구현하는 컴포넌트로 상태를 추적하고 전송할 데이터를 정리한다.
  - Tracer: 프로세스 내의 Active span 을 추적하는 SDK 의 컴포넌트, span에 attribute, event 를 추가하고 추적 완료 시 span을 종료시킨다.
  - Meter: 프로세스에 대해 보고 가능한 metric 을 주적하는 sdk 컴포넌트이다. 현재 메트릭에 값을 추가하거나 주기적으로 값을 추출한다.
  - Context Propagation: Request 에 포함된 W3C 의 TraceContext 또는 B3M과 같은 문맥을 역질렬화하는 SDK의 필수적인 기능이다. 프로세스 내에서 현재 요청의 문맥이 무엇인지 추적하고, 추적 정보를 새로운 서비스로 전달하기 위해 직렬화한다.
  - Exporter: 메모리에 적재된 Otel 객체를 지정된 저장소로 전달 가능하도록 적절한 형식으로 변환하는 SDK 플러그인이다.
  - Collector: 원격 측적 데이터를 수신 및 처리하여 하나 이상의 지정된 목적지로 전달한다. 일반적으로 프록시 혹은 사이드카로 실행되는 독립적인 바이너리 프로세스 형태이다.

#### 7.3.1. 자동 계측 시작하기
- Go 에서는 명시적인 형식 안정성과 컴파일 타임 설정 사용이 필수이기 때문에 자동 계측을 위한 설정도 명시적이여야한다.
- Java, .Net 은 런타임에 별도로 동작하는 OpenTelemetry Agent 를 연결해 자동 계측을 수행할 수 있다.

#### 7.3.2. 사용자 정의 계측 추가하기
- 추적 스팬의 시작과 끝
  - Otel 에서는 context 라는 용어를 사용할때는 용어의 의미가 혼용되지 않도록 주의해야한다.:
    - 문맥은 서비스의 이벤트와 관련된 사정이나 상황을 일컫는 논리적 용어인 동시에 추적 스팬의 문맥처럼 특정한 형식을 갖는 문맥을 뜻하기도 한다.
- 이벤트에 다양한 필드 추가하기
- 프로세스 범주의 메트릭 기록

#### 7.3.3. 백엔드 시스템으로 계측 데이터 전송하기

## Chapter 8. 관찰 가능성 확보를 위한 이벤트 분석
- 가설 주도 디버깅
- 관찰 가능성 기반의 디버깅은 프로덕션 환경의 코드를 확인하는데 있어 가장 호기심이 많거나 부지런한 사람이 답을 찾을 수 있다는 특징을 갖는다.

### 8.1. 알려진 조건 기반의 디버깅
- root cause 를 찾고 runbook 을 작성하도록 독려하고, 대시보드 제작을 하게 한다.
- 하지만, 현대 시스템은 동일한 방식으로 두번 실패하는 경우는 드물다. 그리고 만약 그렇다면, 런북이 아닌 자동 복구 가능을 구성하는 것이 더 좋은 수단이다.
- 런북은 다음 스프린트에서 문제가 수정되기 전까지, 다른 엔지니어가 문제를 완화시킬 수 있게 해줄뿐이다.:
  - 발생할 수 있는 모든 시스템 에러와 해결책이 담긴 문서는 금방 outdated 되거나 잘못된 내용을 담게 된다.

### 8.2. 디버깅의 제1원칙
- 제1원칙: 시스템에 대한 어떠한 가정도 하지 않고, 가설을 만들고 검증하고 무효화해야한다.
- 직감으로 문제 원인을 찾아내는 것은 시스템의 복잡도가 올라가고 가용한 해답의 수가 급증하고 있기 때문에 점차 비실용적인 일이 되어가고 있다.
- 관찰가능성의 진짜 힘은 이슈를 디버깅하기 전에 많은 것을 미리 파악하지 못했어도 괜찮다는 것이다.

#### 8.2.1. 핵심 분석 루프 사용하기
#### 8.2.2. 핵심 분석 루프의 무차별 대입 자동화
- 관찰 가능성 도구는 숫자 처리에 관한 작업 대부분을 자동화할 수 있어야 하지만, 수동으로 핵심 분석 루프를 수행하는 것조차 관찰 가능성의 기본적인 구성 요소 도움 없이는 획득하기 어렵다.

### 8.3. AIOps 의 약속에 대한 오해
- 
