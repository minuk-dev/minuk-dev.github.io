<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>teamnote on MD98 page</title><link>http://makerdark98.dev/tags/teamnote/</link><description>Recent content in teamnote on MD98 page</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sat, 08 Aug 2020 00:10:21 +0900</lastBuildDate><atom:link href="http://makerdark98.dev/tags/teamnote/index.xml" rel="self" type="application/rss+xml"/><item><title>algorithm teamnote</title><link>http://makerdark98.dev/wiki/teamnote/</link><pubDate>Sat, 08 Aug 2020 00:10:21 +0900</pubDate><guid>http://makerdark98.dev/wiki/teamnote/</guid><description>Segment Tree (Range Update) &amp;amp; Index Tree (Point Update) #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; #define IDX_SIZE (1 &amp;lt;&amp;lt; 21) #define IDX_BASE (IDX_SIZE &amp;gt;&amp;gt; 1) /* min tree */ struct index_tree { int sz = IDX_SIZE, bs = IDX_BASE; int node[IDX_SIZE]; void update(int x, int v) { x |= bs; node[x] = v; while (x &amp;gt; 1) { x &amp;gt;&amp;gt;= 1; node[x] = min(node[x * 2], node[x * 2 + 1]); } } int query(int s, int e) { s |= bs; e |= bs; int retval = 1e9; while (s &amp;lt; e) { if (s &amp;amp; 1) retval = min(retval, node[s++]); if (e &amp;amp; ~1) retval = min(retval, node[e--]); s &amp;gt;&amp;gt;= 1; e &amp;gt;&amp;gt;= 1; } if (s == e) retval = min(retval, node[s]); return retval; } }; using lld = long long; #define SEG_SIZE 1 &amp;lt;&amp;lt; 18 struct node_t { lld value, lazy; }; /* sum tree */ struct seg_tree { node_t node[4 * SEG_SIZE]; lld build(lld* d, lld idx, lld s, lld e) { if (s == e) return node[idx].</description></item></channel></rss>