<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>계개모 on</title><link>https://minuk.dev/tags/%EA%B3%84%EA%B0%9C%EB%AA%A8/</link><description>Recent content in 계개모 on</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Sat, 26 Mar 2022 03:32:44 +0900</lastBuildDate><atom:link href="https://minuk.dev/tags/%EA%B3%84%EA%B0%9C%EB%AA%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>계룡 개발 모임</title><link>https://minuk.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/</link><pubDate>Tue, 28 Apr 2020 21:48:13 +0900</pubDate><guid>https://minuk.dev/wiki/%EA%B3%84%EB%A3%A1-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%EC%9E%84/</guid><description>&lt;h2 id="이벤트">이벤트&lt;/h2>
&lt;ul>
&lt;li>[[설대회]]&lt;/li>
&lt;li>[[송편대회]]&lt;/li>
&lt;li>[[Memory_Leak]]&lt;/li>
&lt;li>[[썩어버린 Query Language]]&lt;/li>
&lt;/ul>
&lt;h2 id="논문-스터디">논문 스터디&lt;/h2>
&lt;ul>
&lt;li>[[Endurable_Transient_Inconsistency_in_Byte_Addressable_Persistent_B+-Tree]]&lt;/li>
&lt;li>[[ext4]]{The new ext4 filesystem: current status and future plans}&lt;/li>
&lt;li>[[F2FS]]&lt;/li>
&lt;/ul>
&lt;h2 id="공부한-논문-리스트일자-논문-발표자">공부한 논문 리스트(일자-논문-발표자)&lt;/h2>
&lt;h3 id="2019">2019&lt;/h3>
&lt;ul>
&lt;li>2019/11/09 - F2FS: A New File System for Flash Storage - 이민욱&lt;/li>
&lt;li>2019/11/16 - A Theory of Type Polymorphism in Programming - 최영서&lt;/li>
&lt;li>2019/11/23 - Theorems for Free! - 최성은&lt;/li>
&lt;li>2019/11/30 - Faster algorithms for some optimization problems on collinear points - 구본호&lt;/li>
&lt;li>2019/12/14 - SimpleSSD: Modeling Solid State Drives for Holistic System Simulation - 이민욱&lt;/li>
&lt;li>2019/12/21 - APPx: An Automated App Acceleration Framework for Low Latency Mobile App - 최영서&lt;/li>
&lt;li>2019/12/28 - Coloring of cartesian product of cycle graph, C_7 X C_n - 구본호&lt;/li>
&lt;/ul>
&lt;h3 id="2020">2020&lt;/h3>
&lt;ul>
&lt;li>2020/01/04 - A Categorical Programming Language - 최성은&lt;/li>
&lt;li>2020/01/18 - Endurable Transient Inconsistency in Byte-Addressable Persistent B+ Tree - 이민욱&lt;/li>
&lt;li>2020/01/25 - Optimising Existing Software with Genetic Programming - 최영서&lt;/li>
&lt;li>2020/02/15 - Notion of Computation and Monad - 최성은&lt;/li>
&lt;li>2020/02/22 - The dark side of UX design - 구본호&lt;/li>
&lt;li>2020/02/29 - Spectre Attacks: Exploiting Speculative Execution - 하재형&lt;/li>
&lt;li>2020/03/07 - Why Should I Trust You - Explaining the Predictions of Any Classifier - 백동진&lt;/li>
&lt;li>2020/03/14 - An In-Depth Study of Next Generation Interface for Emerging Non-Volatile Memories - 이민욱&lt;/li>
&lt;li>2020/03/21 - Computing the Galois Group of a Polynomial - 최성은&lt;/li>
&lt;li>2020/03/28 - Terrain Synthesis from Digital Elevation Models - 이도운&lt;/li>
&lt;li>2020/04/04 - MapReduce: Simplified Data Processing on Large Clusters - 최영서&lt;/li>
&lt;li>2020/04/11 - Skip lists: A probabilistic alternative to balanced tree - 구본호&lt;/li>
&lt;li>2020/04/18 - The Web&amp;rsquo;s Identity Crisis : Understanding the Effectiveness of Website Identity Indicators. - 하재형&lt;/li>
&lt;li>2020/04/25 - Transforming Auto-encoders - 백동진&lt;/li>
&lt;li>2020/05/02 - Ext4: The Next Generation of Ext2/3 Filesystem - 이민욱&lt;/li>
&lt;li>2020/05/09 - Ghosts of Departed Proofs (Functional Pearl) - 최성은&lt;/li>
&lt;li>2020/05/16 - Physically-Based Shading at Disney - 이도운&lt;/li>
&lt;/ul></description></item><item><title>썩어버린 Query Language</title><link>https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/</link><pubDate>Tue, 07 Apr 2020 20:18:38 +0900</pubDate><guid>https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/</guid><description>&lt;h1 id="-1-sql-structured-query-language"># 1. SQL (Structured Query Language)?&lt;/h1>
&lt;ul>
&lt;li>관계형 데이터베이스들에서 원하는 데이터를 가져오기 위한 언어&lt;/li>
&lt;li>우리는 왜 이걸 사용하고 있을까?&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스의-역사">데이터베이스의 역사&lt;/h2>
&lt;ul>
&lt;li>관계형 데이터베이스가 데이터베이스 전쟁의 승자이기 때문이다.&lt;/li>
&lt;li>계층형 데이터베이스를 비롯한 수많은 종류들의 데이터베이스가 있었으나 문제들이 많아 점점 관계형 데이터베이스들만이 살아남았다. (대부분 성능상의 문제)&lt;/li>
&lt;li>관계형이 살아남은 이유는 질의 최적화기 (query optimizer)이다.&lt;/li>
&lt;/ul>
&lt;h2 id="query-optimizer">Query Optimizer&lt;/h2>
&lt;ul>
&lt;li>쿼리를 최적화해주는 무언가&lt;/li>
&lt;li>이걸 발전시키기 위해 수많은 연구가 진행되어 현재의 성능을 가지게 된다.&lt;/li>
&lt;li>그럴려면 구조화된 query 언어가 필요하고 이게 현재 사용하는 SQL이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.researchgate.net/profile/Martin_Boissier/publication/332803446/figure/fig2/AS:754092716593152@1556801122020/The-different-steps-of-the-SQL-Pipeline-leading-from-an-SQL-string-to-executable.png" alt="https://www.researchgate.net/profile/Martin_Boissier/publication/332803446/figure/fig2/AS:754092716593152@1556801122020/The-different-steps-of-the-SQL-Pipeline-leading-from-an-SQL-string-to-executable.png">&lt;/p></description></item><item><title>Javascript Memory Leak</title><link>https://minuk.dev/wiki/memory_leak/</link><pubDate>Tue, 07 Apr 2020 20:16:46 +0900</pubDate><guid>https://minuk.dev/wiki/memory_leak/</guid><description>&lt;h1 id="주제-후보">주제 후보&lt;/h1>
&lt;ul>
&lt;li>메모리 누수란 왜 일어나는가? - garbage collector의 동작방식, javascript 에서 메모리 누수 없이 코딩하는 습관 가지기&lt;/li>
&lt;li>비동기처리하기 - javascript callback, promise, async-await&lt;/li>
&lt;li>웹사이트에서 원하는 정보 추출하기 - 웹사이트 크롤링, 파싱하기&lt;/li>
&lt;li>나무위키 유의어, 반의어 - Word2Vec를 통한 나무위키 데이터 학습&lt;/li>
&lt;/ul>
&lt;p>→ 익명의 대학 동기에게 재밋는 주제를 고르라고 해서 진행되었습니다.&lt;/p>
&lt;h2 id="메모리-누수란-왜-일어나는가">메모리 누수란 왜 일어나는가?&lt;/h2>
&lt;h3 id="결론부터-말하자면-프로그래머의-실수-코딩-습관을-잘-들이자">결론부터 말하자면 프로그래머의 실수. 코딩 습관을 잘 들이자.&lt;/h3>
&lt;ul>
&lt;li>Garbage Collection 의 필요성
&lt;ul>
&lt;li>C언어에서 메모리를 직접 할당하고 해제하는 malloc, free 라는 방식을 사용하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="#include%20%3cstdio.h%3e%0a#include%20%3cstdlib.h%3e%0a%0aint%20main%28int%20argc,%20char**%20argv%29%20%7b%0a%20%20%20%20int%20n;%0a%20%20%20%20scanf%28%22%25d%22,&amp;amp;n%29;%0a%20%20%20%20int*%20arr%20=%20%28int*%29malloc%28sizeof%28int%29%20*%20n%29;%0a%20%20%20%20//%20do%20something%0a%20%20%20%20free%28arr%29;%0a%20%20%20%20return%200;%0a%7d">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> free(arr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;pre>&lt;code>- → 소프트웨어의 규모가 커지고 협업이 증가하면서 메모리를 책임지지 못하게 되었다.
- →Garbage Collection의 필요성 (cf. rust 의 memory ownership)
 - 단, 최초의 GC는 LISP 이라는 언어에서부터 있었다고 알려져있음.(1958년)
&lt;/code>&lt;/pre>
&lt;h2 id="garbage-collection">Garbage Collection&lt;/h2>
&lt;h3 id="초기-아이디어---참조-카운트reference-counting">초기 아이디어 - 참조 카운트(Reference Counting)&lt;/h3>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="A%20a%20=%20new%20A%28%29;%0aa.b%20=%20new%20B%28%29;%0aa.b.c%20=%20new%20C%28%29;%0a%0a%0aa.b.c%20=%20null;%0a%0af%28%29;%0a%0a%0avoid%20f%28%29%20%7b%0a%20%20A%20a%20=%20new%20A%28%29;%0a%20//%20do%20something%0a%7d">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>A a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> A();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> B();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.b.c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> C();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.b.c &lt;span style="color:#f92672">=&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> A();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;p>이 때 f 메서드 바깥에서는 a가 사용되지 않는다.&lt;/p></description></item><item><title>송편 생성기 (추석 대회)</title><link>https://minuk.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/</link><pubDate>Tue, 07 Apr 2020 20:16:06 +0900</pubDate><guid>https://minuk.dev/wiki/%EC%86%A1%ED%8E%B8%EB%8C%80%ED%9A%8C/</guid><description>&lt;h1 id="추석을-맞아-송편을-창의적으로-출력하기-대회가-열렸다-먼가-인공지능으로-가장-완벽한-송편을-출력해보고-싶어졌다">추석을 맞아 송편을 창의적으로 출력하기 대회가 열렸다. 먼가 인공지능으로 가장 완벽한 송편을 출력해보고 싶어졌다.&lt;/h1>
&lt;h2 id="0-configuration">0. Configuration&lt;/h2>
&lt;p>먼저 인공지능 스택으로 배운건 Tensorflow, Keras이기 때문에 언어는 편하게 모두 python으로 하기로 결정했다.&lt;/p>
&lt;p>그렇게 언어를 정하고 과정을 다음과 같이 나눴다.&lt;/p>
&lt;ol>
&lt;li>송편 이미지 크롤링 하기&lt;/li>
&lt;li>Keras를 통해 GAN모델을 구현해서 한번 테스트 해보기&lt;/li>
&lt;li>나온 결과를 확인하고 모델을 학습 데이터 특성에 맞춰서 재설계, 데이터 가공, 통계적으로 분석&amp;hellip; 등등 원하는 결과를 내도록 설계&lt;/li>
&lt;/ol>
&lt;p>이렇게 정하고 나니 필요한 라이브러리는 다음과 같았다. &lt;code>requests, beautifulsoup, tensorflow, keras, pandas&lt;/code>&lt;/p></description></item><item><title>설대회</title><link>https://minuk.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/</link><pubDate>Sun, 26 Jan 2020 23:57:47 +0900</pubDate><guid>https://minuk.dev/wiki/%EC%84%A4%EB%8C%80%ED%9A%8C/</guid><description>설 대회로 한 자료</description></item></channel></rss>