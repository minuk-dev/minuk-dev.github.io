<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>계룡전산한마당 on minuk.dev</title><link>https://minuk.dev/tags/%EA%B3%84%EB%A3%A1%EC%A0%84%EC%82%B0%ED%95%9C%EB%A7%88%EB%8B%B9/</link><description>Recent content in 계룡전산한마당 on minuk.dev</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Tue, 15 Mar 2022 02:27:10 +0900</lastBuildDate><atom:link href="https://minuk.dev/tags/%EA%B3%84%EB%A3%A1%EC%A0%84%EC%82%B0%ED%95%9C%EB%A7%88%EB%8B%B9/index.xml" rel="self" type="application/rss+xml"/><item><title>썩어버린 Query Language</title><link>https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/</link><pubDate>Tue, 07 Apr 2020 20:18:38 +0900</pubDate><guid>https://minuk.dev/wiki/%EC%8D%A9%EC%96%B4%EB%B2%84%EB%A6%B0-query-language/</guid><description>&lt;h1 id="-1-sql-structured-query-language"># 1. SQL (Structured Query Language)?&lt;/h1>
&lt;ul>
&lt;li>관계형 데이터베이스들에서 원하는 데이터를 가져오기 위한 언어&lt;/li>
&lt;li>우리는 왜 이걸 사용하고 있을까?&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스의-역사">데이터베이스의 역사&lt;/h2>
&lt;ul>
&lt;li>관계형 데이터베이스가 데이터베이스 전쟁의 승자이기 때문이다.&lt;/li>
&lt;li>계층형 데이터베이스를 비롯한 수많은 종류들의 데이터베이스가 있었으나 문제들이 많아 점점 관계형 데이터베이스들만이 살아남았다. (대부분 성능상의 문제)&lt;/li>
&lt;li>관계형이 살아남은 이유는 질의 최적화기 (query optimizer)이다.&lt;/li>
&lt;/ul>
&lt;h2 id="query-optimizer">Query Optimizer&lt;/h2>
&lt;ul>
&lt;li>쿼리를 최적화해주는 무언가&lt;/li>
&lt;li>이걸 발전시키기 위해 수많은 연구가 진행되어 현재의 성능을 가지게 된다.&lt;/li>
&lt;li>그럴려면 구조화된 query 언어가 필요하고 이게 현재 사용하는 SQL이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.researchgate.net/profile/Martin_Boissier/publication/332803446/figure/fig2/AS:754092716593152@1556801122020/The-different-steps-of-the-SQL-Pipeline-leading-from-an-SQL-string-to-executable.png" alt="https://www.researchgate.net/profile/Martin_Boissier/publication/332803446/figure/fig2/AS:754092716593152@1556801122020/The-different-steps-of-the-SQL-Pipeline-leading-from-an-SQL-string-to-executable.png">&lt;/p></description></item><item><title>Javascript Memory Leak</title><link>https://minuk.dev/wiki/memory_leak/</link><pubDate>Tue, 07 Apr 2020 20:16:46 +0900</pubDate><guid>https://minuk.dev/wiki/memory_leak/</guid><description>&lt;h1 id="주제-후보">주제 후보&lt;/h1>
&lt;ul>
&lt;li>메모리 누수란 왜 일어나는가? - garbage collector의 동작방식, javascript 에서 메모리 누수 없이 코딩하는 습관 가지기&lt;/li>
&lt;li>비동기처리하기 - javascript callback, promise, async-await&lt;/li>
&lt;li>웹사이트에서 원하는 정보 추출하기 - 웹사이트 크롤링, 파싱하기&lt;/li>
&lt;li>나무위키 유의어, 반의어 - Word2Vec를 통한 나무위키 데이터 학습&lt;/li>
&lt;/ul>
&lt;p>→ 익명의 대학 동기에게 재밋는 주제를 고르라고 해서 진행되었습니다.&lt;/p>
&lt;h2 id="메모리-누수란-왜-일어나는가">메모리 누수란 왜 일어나는가?&lt;/h2>
&lt;h3 id="결론부터-말하자면-프로그래머의-실수-코딩-습관을-잘-들이자">결론부터 말하자면 프로그래머의 실수. 코딩 습관을 잘 들이자.&lt;/h3>
&lt;ul>
&lt;li>Garbage Collection 의 필요성
&lt;ul>
&lt;li>C언어에서 메모리를 직접 할당하고 해제하는 malloc, free 라는 방식을 사용하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> free(arr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>- → 소프트웨어의 규모가 커지고 협업이 증가하면서 메모리를 책임지지 못하게 되었다.
- →Garbage Collection의 필요성 (cf. rust 의 memory ownership)
 - 단, 최초의 GC는 LISP 이라는 언어에서부터 있었다고 알려져있음.(1958년)
&lt;/code>&lt;/pre>
&lt;h2 id="garbage-collection">Garbage Collection&lt;/h2>
&lt;h3 id="초기-아이디어---참조-카운트reference-counting">초기 아이디어 - 참조 카운트(Reference Counting)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>A a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> A();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> B();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.b.c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> C();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a.b.c &lt;span style="color:#f92672">=&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> A();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 때 f 메서드 바깥에서는 a가 사용되지 않는다.&lt;/p></description></item></channel></rss>