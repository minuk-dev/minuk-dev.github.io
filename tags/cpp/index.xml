<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on MD98 page</title><link>https://makerdark98.dev/tags/cpp/</link><description>Recent content in cpp on MD98 page</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 02 Jun 2020 19:15:07 +0900</lastBuildDate><atom:link href="https://makerdark98.dev/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>clflush (cache line flush)</title><link>https://makerdark98.dev/wiki/clflush/</link><pubDate>Tue, 02 Jun 2020 19:15:07 +0900</pubDate><guid>https://makerdark98.dev/wiki/clflush/</guid><description>출처 https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_clflush&amp;amp;expand=678,679
내용 void _mm_clflush (void const* p) #include &amp;lt;emmintrin.h&amp;gt;Instruction: clflush m8 CPUID Flags: SSE2 void _mm_clflushopt (void const * p) #include &amp;lt;immintrin.h&amp;gt;Instruction: clflushopt m8 CPUID Flags: CLFLUSHOPT clflush vs clflushopt 출처 : https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/712498 clflushopt : clflush optimization</description></item><item><title>C++ Language</title><link>https://makerdark98.dev/wiki/c++/</link><pubDate>Tue, 02 Jun 2020 19:14:04 +0900</pubDate><guid>https://makerdark98.dev/wiki/c++/</guid><description>Memory [[clflush]] Books [[Modern C++ Design Pattern]]</description></item><item><title>Modern C++ Design Pattern/Chatper 18. 메멘토</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-18-%EB%A9%94%EB%A9%98%ED%86%A0/</link><pubDate>Tue, 28 Apr 2020 21:07:07 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-18-%EB%A9%94%EB%A9%98%ED%86%A0/</guid><description>간략 설명 커맨드 패턴에서 이론적으로 과거의 어떤 지점으로 상태를 되돌릴수 있다 메멘토 패턴은 모든 임의의 과거가 아니라 필요할 때 특정 시점으로 되돌리기만 하면 될때 사용한다. 특정 시점의 시스템 상태를 저장하고, 읽기 전용 속성을 가지고 자체적으로 아무 동작을 안하는 객체를 만든다 (이걸 토큰이라고 부르기도 한다) 특징 불변 속성을 가진다. 저장된 잔고 값이 나중에 변경될 수 있다면 존재한 적 없는 과거 상태로 되돌리는게 가능해져 버린다. 대상 객체에 friend로 선언한다. 필드 변수에 접근하기 위해 필수적으로 필요하다.</description></item><item><title>Modern C++ Design Pattern/Chatper 17. 매개자</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-17-%EB%A7%A4%EA%B0%9C%EC%9E%90/</link><pubDate>Mon, 27 Apr 2020 21:43:50 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-17-%EB%A7%A4%EA%B0%9C%EC%9E%90/</guid><description>간단 설명 서로 다른 컴포넌트 간에 포인터나 직접적인 참조를 통한 커뮤니케이션이 필요하다 일부 경우 상대방 객체의 존재를 알아야하는점, 객체의 생성/소멸 시점에대한 관리 때문에 포인터나 참조로 접근하는게 불안정할 수 있다. 이를 위한 매커니즘 전역 정적 변수이거나 모든 컴포넌트에 그 참조가 노출되어야 한다. 내용 여기서는 Boost.Signals2 라이브러리를 사용해서 구현한다. 잘 모르겠다. 일단 요약부분만 적고 나중에 필요하면 찾아보자 요약 매개자 디자인 패턴은 시스탬 내 컴포넌트 모두가 참조할 수 있는 어떤 중간자를 컴포넌트 간에 서로 직접적으로 참조하지 않더라도 커뮤니케이션을 할수 있게 한다는 것을 기본아이디어로 한다.</description></item><item><title>Modern C++ Design Pattern/Chatper 16. 반복자</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-16-%EB%B0%98%EB%B3%B5%EC%9E%90/</link><pubDate>Tue, 21 Apr 2020 23:12:43 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-16-%EB%B0%98%EB%B3%B5%EC%9E%90/</guid><description>간략 설명 복잡한 데이터 구조를 다루어야 할 때 데이터 순회 문제를 해결하는 방법 표준 라이브러리의 반복자 begin end rbegin rend cbegin cend crbegin crend 이진 트리의 탐색 template &amp;lt;typename U&amp;gt; struct PreOrderIterator; template &amp;lt;typename T&amp;gt; struct BinaryTree; template &amp;lt;typename T&amp;gt; struct Node { T value; Node&amp;lt;T&amp;gt; *left = nullptr; Node&amp;lt;T&amp;gt; *right = nullptr; Node&amp;lt;T&amp;gt; *parent = nullptr; BinaryTree&amp;lt;T&amp;gt;* tree = nullptr; explicit Node(const T&amp;amp; value) : value(value) {} Node(const T&amp;amp; value, Node&amp;lt;T&amp;gt;* const left, Node&amp;lt;T&amp;gt;* const right) : value(value), left(left), right(right) { this-&amp;gt;left-&amp;gt;tree =this-&amp;gt;right-&amp;gt;tree = tree; this-&amp;gt;left-&amp;gt;parent = this-&amp;gt;right-&amp;gt;parent = this; } void set_tree(BinaryTree&amp;lt;T&amp;gt;* t) { tree = t; if (left) left-&amp;gt;set_tree(t); if (right) right-&amp;gt;set_tree(t); } }; template &amp;lt;typename T&amp;gt; struct BinaryTree { Node&amp;lt;T&amp;gt;* root = nullptr; explicit BinaryTree(Node&amp;lt;T&amp;gt;* const root) : root{ root } { root-&amp;gt;set_tree(this); } typedef PreOrderIterator&amp;lt;T&amp;gt; iterator; iterator begin() { Node&amp;lt;T&amp;gt;* n = root; if (n) while (n-&amp;gt;left) n = n-&amp;gt;left; return iterator{ n } } iterator end() { return iteraotr { nullptr }; } }; template &amp;lt;typename U&amp;gt; struct PreOrderIterator { Node&amp;lt;U&amp;gt;* current; explicit PreOrderIterator(Node&amp;lt;U&amp;gt;* current) : current(current) { } bool operator!</description></item><item><title>Modern C++ Design Pattern/Chatper 15. 인터프리터</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-15-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</link><pubDate>Mon, 20 Apr 2020 22:46:23 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-15-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</guid><description>인터프리터 디자인 패턴? 입력 데이터를 해석하는 것 대부분 텍스트이지만 텍스트에 한정되지는 않음. 요약 &amp;hellip; 이책에서 굳이 이 내용을 다루는 이유를 모르겠다. 차라리 Lex/Yacc를 보는게 좋다고 생각한다. 아마도 Boost.Spirit을 알려주고 싶어서 굳이 끼워넣은 느낌? 키워드만 정리하자면, AST, Lex/Yacc</description></item><item><title>Modern C++ Design Pattern/Chatper 14. 커맨드</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-14-%EC%BB%A4%EB%A7%A8%EB%93%9C/</link><pubDate>Sun, 19 Apr 2020 21:40:23 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-14-%EC%BB%A4%EB%A7%A8%EB%93%9C/</guid><description>필요성 어떤 객체를 활용할 때 직접 그 객체의 API를 호출하여 조작하는 대신, 작업을 어떻게 하라고 명령을 보내는 방식을 제안한다. 시나리오 struct BankAccount { int balance = 0; int overdraft_limit = -500; void deposit(int amount) { balance += amount; cout &amp;lt;&amp;lt; &amp;#34;deposited &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34;, balance is now &amp;#34; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } void withdraw(int amount) { if (balance - amount &amp;gt;= overdraft_limit) { balance -= amount; cout &amp;lt;&amp;lt; &amp;#34;withdrew &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34;, balance is now &amp;#34; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } } }; 커맨드 패턴의 구현 struct Command { virtual void call() const = 0; }; struct BankAccountCommand : Command { BankAccount&amp;amp; account; enum Action { deposit, withdraw } action; int amount; BankAccountCommand(BankAccount&amp;amp; account, const Action action, const int amount) : account(account), action(action), amount(amount) {} void call() const override { switch (action) { case deposit: account.</description></item><item><title>Modern C++ Design Pattern/Chatper 13. 책임사슬(Chain of Responsibility)</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-13-%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/</link><pubDate>Sat, 18 Apr 2020 22:14:11 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-13-%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/</guid><description>시나리오 struct Creature { string name; int attack, defense; // Constructor, operator... }; 포인터 사슬 class CreatureModifier { CreatureModifier* next{nullptr}; protected: Creature&amp;amp; creture; // reference, pointer or shared_ptr public: explicit CreatureModifier(Creature&amp;amp; creature) : creature(creture) {} void add(CreatureModifier* cm) { if (next) next-&amp;gt;add(cm); else next =cm; } virtual void handle() { if (next) next-&amp;gt;handle(); } }; 참조를 넘겨받아 저장하고 변경할 준비 추상 클래스가 아님 next는 다음 변경 작업을 가리킴 add()를 통해서 작업 사슬에 연결하여 추가 handle() 맴버 함수는 단순히 다음 항목을 처리한다.</description></item><item><title>Modern C++ Design Pattern/Chapter 12. 프록시</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-12-%ED%94%84%EB%A1%9D%EC%8B%9C/</link><pubDate>Sun, 12 Apr 2020 23:10:03 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-12-%ED%94%84%EB%A1%9D%EC%8B%9C/</guid><description>스마트 포인터 가장 단순하면서도 직접적인 프록시 패턴의 예 속성 프록시 다른 프로그래밍 언어에서는 get/set 메서드를 지원하는 경우도 있음. template &amp;lt;typename T&amp;gt; struct Property { T value; Property(const T initial_value) { *this = initial_value; } operate T() { return value; } T operator=(T new_value) { return value = new_value; } } struct Creature { Property&amp;lt;int&amp;gt; strength{ 10 }; Property&amp;lt;int&amp;gt; agility{ 5 }; } Creature creature; creature.agility = 20; auto x = creature.</description></item><item><title>Modern C++ Design Pattern/Chapter 11. 플라이웨이트</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-11-%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/</link><pubDate>Sat, 11 Apr 2020 23:28:27 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-11-%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/</guid><description>플라이웨이트 패턴 : 많은 수의 가벼운 임시 객체들을 &amp;ldquo;스마트 참조&amp;quot;로 사용하는 것을 말하며, 그러한 객체들을 플라이웨이트라고 부른다. 사용자 이름 struct User { User(const string&amp;amp; first_name, const string&amp;amp; last_name) : first_name{add(first_anem)}, last_name{add(last_name)} {} protected: key first_name, last_name; static bimap&amp;lt;key, string&amp;gt; names; // boost:bimap(양방향 map) static key seed; static key add(const string&amp;amp; s) { ...} }; static key add(const string&amp;amp; s) { auto it = names.right.find(s); if (it == names.</description></item><item><title>Modern C++ Design Pattern/Chapter 10. 퍼사드</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-10-%ED%8D%BC%EC%82%AC%EB%93%9C/</link><pubDate>Thu, 09 Apr 2020 23:56:51 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-10-%ED%8D%BC%EC%82%AC%EB%93%9C/</guid><description>퍼사드는 어디에 있는가? struct Console { vector&amp;lt;Viewport*&amp;gt; viewports; Size charSize, gridSize; }; Console::Console(bool fullscreen, int char_width, int char_height, int width, int height, optional&amp;lt;Size&amp;gt; client_size) { // Implement } Console::Console(const ConsoleCreateionParamters* ccp) { ... } struct ConsoleCreationParameters { optional&amp;lt;Size&amp;gt; client_size; int character_width{10}; int character_height{14}; int width{20}; int height{30}; bool fullscreen{false}; bool create_default_view_and_buffer{true}; }; 요약 하나 이상의 복잡한 서브 시스템 앞에 단순한 인터페이스를 두기 위한 방법</description></item><item><title>Modern C++ Design Pattern</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/</guid><description>챕터별 정리</description></item><item><title>Modern C++ Design Pattern/Chatper 1. 개요</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-1-%EA%B0%9C%EC%9A%94/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-1-%EA%B0%9C%EC%9A%94/</guid><description>CRTP(Curiously Recurring Template Pattern) struct Foo : SomeBase&amp;lt;Foo&amp;gt; { ... } template &amp;lt;typename Derived&amp;gt; struct SomeBase { void foo() { for (auto&amp;amp; item : *static_cast&amp;lt;Derived*&amp;gt;(this)) { ... } } } Property class Person { private: int age_; public: int get_age() const {return age_; } void set_age(int value) {age_ = value; } __declspec(property(get=get_age, put=set_age)) int age; } Person p; p.age = 20; // calls p.set_age(20) Factory Factory Method struct Point { protected: Point(const float x, const float y) : x {x}, y {y} {} public: static Point NewCartesian(float x, float y) { return {x, y}; } static Point NewPolar(float r, float theta) { return {r * cos(theta), r * sin(theta)}; } // skip }; SOLID Design Principle SRP(Single Responsibility Principle) If you need to edit a few classes(or little more?</description></item><item><title>Modern C++ Design Pattern/Chatper 5. 싱글턴</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-5-%EC%8B%B1%EA%B8%80%ED%84%B4/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-5-%EC%8B%B1%EA%B8%80%ED%84%B4/</guid><description>Singleton static Database database{}; /* not recommended */ /** * This method is only secured about MT(Multi Thread)-Safe on C++11 or Higher. */ Database&amp;amp; get_database() { static Database databse; return database; } Traditional Implementation struct Database { protected: Database() { /* Do something */ } public: static Database&amp;amp; get() { // MT-Safe on C++11 or Higher static Database database; return database; } Database(Database const&amp;amp;) = delete; Database(Database &amp;amp;&amp;amp;) = delete; Database&amp;amp; operator=(Database const&amp;amp;) = delete; Database&amp;amp; operator=(Database &amp;amp;&amp;amp;) = delete; }; You can think over inheritance of boost::noncopyable class if you don&amp;rsquo;t perfer to this by your hands.</description></item><item><title>Modern C++ Design Pattern/Chatper 6. 어댑터</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-6-%EC%96%B4%EB%8C%91%ED%84%B0/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-6-%EC%96%B4%EB%8C%91%ED%84%B0/</guid><description>Adapter Pattern We use a example case, drawiing geometric shape. struct Point { int x, y; }; struct Line{ Point start, end; }; struct VectorObject { virtual std::vector&amp;lt;Line&amp;gt;::iterator begin() = 0; virtual std::vector&amp;lt;Line&amp;gt;::iterator end() = 0; }; struct VectorRectangle : VectorObject { VectorRectangle(int x, int y, int width, int height) { lines.emplace_back(Line{ Point{x, y}, Point{x + width, y} }); lines.emplace_back(Line{ Point{x + width, y}, Point {x + width, y + height} }); lines.</description></item><item><title>Modern C++ Design Pattern/Chatper 7. 브릿지</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-7-%EB%B8%8C%EB%A6%BF%EC%A7%80/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-7-%EB%B8%8C%EB%A6%BF%EC%A7%80/</guid><description>Bridge Pattern Pimpl (Pointer to Implmentation) struct Person { string name; void greet(); Person(); ~Person(); class PersonImpl; PersonImpl *impl; // refer to gsl::owner&amp;lt;T&amp;gt; }; struct Person:PersonImpl { void greet(Person* p); } Person::Person() : impl(new PersonImpl) {} Person::~Person() { delete imple; } void Person::greet() { impl-&amp;gt;greet(this); } void Person::PersonImpl::greet(Person* p) { printf(&amp;#34;hello %s&amp;#34;, p-&amp;gt;name.c_str()); } Props Hide implementation. If Person class has many private/protected member variable, it is exposed though the header file to client.</description></item><item><title>Modern C++ Design Pattern/Chatper 8. 컴포지트</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-8-%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-8-%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8/</guid><description>Composite Pattern How to announce the object has multiple composite attributes? It is not easy. Properties based on array. class Creature { int strength, agility, intelligence; public: int get_stringth() const { return strength; } void set_strength(int strength) { Creture::strength = strength; } // Other getter/setter.... int sum() const { return strength + agility + intelligence; } double average() const { return sum() / 3.0; } int max() const { return ::max(::max(strength, agility), intelligence); } }; It is not pretty.</description></item><item><title>Modern C++ Design Pattern/Chatper 9. 데코레이터</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-9-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-9-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/</guid><description>Decorator Dynamic Composition Static Composition Dynamic Decorator struct ColoredShape : Shape { Shape&amp;amp; shape; string color; ColoredShape(Shape&amp;amp; shape, const string&amp;amp; color) : shape{shape}, color{color} {} stinrg str() const override { ostringstream oss; oss &amp;lt;&amp;lt; shape.str() &amp;lt;, &amp;#34; Has the color &amp;#34; &amp;lt;&amp;lt; color; return oss.str(); } }; // Example Code Circle circle{0.5f}; ColoredShape redCircle{circle, &amp;#34;red&amp;#34;}; cout &amp;lt;&amp;lt; redCircle.str(); struct TransparentShape : Shape { Shape&amp;amp; shape; uint8_t transparency; TransparentShape(Shape&amp;amp; shape, const uint8_t transparency) : shape{shape}, transparency{transparency} {} string str() const override { ostringstream oss; oss &amp;lt;&amp;lt; shape.</description></item></channel></rss>