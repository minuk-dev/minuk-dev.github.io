<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memory on</title><link>https://minuk.dev/tags/memory/</link><description>Recent content in Memory on</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Thu, 03 Jun 2021 16:38:06 +0900</lastBuildDate><atom:link href="https://minuk.dev/tags/memory/index.xml" rel="self" type="application/rss+xml"/><item><title>Cache</title><link>https://minuk.dev/wiki/cache/</link><pubDate>Mon, 06 Jul 2020 20:38:22 +0900</pubDate><guid>https://minuk.dev/wiki/cache/</guid><description>&lt;h1 id="관련-스크립트">관련 스크립트&lt;/h1>
&lt;h2 id="pagecache-해제">pagecache 해제&lt;/h2>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="echo%201%20%3e%20/proc/sys/vm/drop_caches">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">1&lt;/span> &amp;gt; /proc/sys/vm/drop_caches&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;h2 id="dentries-inodes-해제">dentries, inodes 해제&lt;/h2>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="echo%202%20%3e%20/proc/sys/vm/drop_caches">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">2&lt;/span> &amp;gt; /proc/sys/vm/drop_caches&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;h2 id="pagecache-dentries-inodes-모두-해제">pagecache, dentries, inodes 모두 해제&lt;/h2>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="echo%203%20%3e%20/proc/sys/vm/drop_caches">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">3&lt;/span> &amp;gt; /proc/sys/vm/drop_caches&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;h2 id="플러싱하기">플러싱하기&lt;/h2>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="sync">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sync&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;h1 id="출처">출처&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BA%90%EC%8B%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B9%84%EC%9A%B0%EA%B8%B0">https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BA%90%EC%8B%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B9%84%EC%9A%B0%EA%B8%B0&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="요약">요약&lt;/h2>
&lt;ul>
&lt;li>Pinciple of Locality 에 따라 최근 접근한 데이터 또는 인접한 데이터를 빠르게 접근할수 있는 곳에 두고 접근하는 것.&lt;/li>
&lt;/ul>
&lt;h2 id="cache-의-종류">Cache 의 종류&lt;/h2>
&lt;ul>
&lt;li>출처 : &lt;a href="https://parksb.github.io/article/29.html">https://parksb.github.io/article/29.html&lt;/a>&lt;/li>
&lt;li>L1 Cache : 프로세서와 가장 가까운 캐시. 속도를 위해 &lt;code>I$&lt;/code> 와 &lt;code>D$&lt;/code> 로 나뉜다.
&lt;ul>
&lt;li>Instruction Cache (I$) : 메모리의 TEXT 영역 데이터를 다루는 캐시&lt;/li>
&lt;li>Data Cache (D$) : TEXT 영역을 제외한 모든 데이터를 다루는 캐시.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>L2 Cache : 용량이 큰 캐시, 크기를 위해 L1캐시처럼 나누지 않는다.&lt;/li>
&lt;li>L3 Cache : 멀티 코어 시스템에서 여러 코어가 공유하는 캐시&lt;/li>
&lt;/ul>
&lt;h3 id="궁금해서-찾아본-내-컴퓨터의-캐시-사이즈">궁금해서 찾아본 내 컴퓨터의 캐시 사이즈&lt;/h3>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="#%20lshw%20-C%20memory">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lshw -C memory&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;ul>
&lt;li>linux에서 명령어로 확인해볼수 있다.&lt;/li>
&lt;li>아래 내용을 보면 확인 할수 있듯이 L1 은 32KiB, L2 는 256KiB, L3 는 3MiB 이다.&lt;/li>
&lt;li>지금 작업하는 곳이 대학교 입학할때 사용한 i3 4세대? 5세대? 쯤이니까 감안해서 보면 될듯.&lt;/li>
&lt;/ul>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="#ZgotmplZ">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;pre>&lt;code> *-firmware
 description: BIOS
 vendor: American Megatrends Inc.
 physical id: 0
 version: P02RDQ.029.160707.JJ
 date: 07/07/2016
 size: 64KiB
 capacity: 6080KiB
 capabilities: pci upgrade shadowing cdboot bootselect socketedrom edd int13floppy1200 int13floppy720 int13floppy2880 int5printscreen int14serial int17printer acpi usb biosbootspecification uefi
 *-cache:0
 description: L1 cache
 physical id: 38
 slot: L1 Cache
 size: 32KiB
 capacity: 32KiB
 capabilities: synchronous internal write-back data
 configuration: level=1
 *-cache:1
 description: L1 cache
 physical id: 39
 slot: L1 Cache
 size: 32KiB
 capacity: 32KiB
 capabilities: synchronous internal write-back instruction
 configuration: level=1
 *-cache:2
 description: L2 cache
 physical id: 3a
 slot: L2 Cache
 size: 256KiB
 capacity: 256KiB
 capabilities: synchronous internal write-back unified
 configuration: level=2
 *-cache:3
 description: L3 cache
 physical id: 3b
 slot: L3 Cache
 size: 3MiB
 capacity: 3MiB
 capabilities: synchronous internal write-back unified
 configuration: level=3
 *-memory
 description: System Memory
 physical id: 3e
 slot: System board or motherboard
 size: 4GiB
 *-bank:0
 description: SODIMM DDR3 Synchronous 1600 MHz (0.6 ns)
 product: 8KTF51264HZ-1G9P1
 vendor: Micron
 physical id: 0
 serial: 12CACA3A
 slot: ChannelA-DIMM0
 size: 4GiB
 width: 64 bits
 clock: 1600MHz (0.6ns)
 *-bank:1
 description: DIMM [empty]
 physical id: 1
 slot: ChannelB-DIMM0&lt;/code>&lt;/pre>
 
&lt;/div>
&lt;h2 id="cache-metrics">Cache Metrics&lt;/h2>
&lt;ul>
&lt;li>캐스의 성능을 측정할 때는 Hit latency 와 Miss Latency 가 중요 요인으로 꼽힌다.&lt;/li>
&lt;li>$$\text{Miss rate} = \frac{\text{Cache misses}}{\text{Cache accesses}}$$&lt;/li>
&lt;/ul>
&lt;h2 id="cache-organization">Cache Organization&lt;/h2>
&lt;h3 id="indexing">Indexing&lt;/h3>
&lt;ul>
&lt;li>주소값 전체를 키로 사용하지 않고, 그 일부만을 사용한다.&lt;/li>
&lt;/ul>
&lt;h3 id="tag-matching">Tag Matching&lt;/h3>
&lt;ul>
&lt;li>주소값의 일부를 Tag 로 사용하여 인덱스의 충돌을 줄인다.&lt;/li>
&lt;/ul>
&lt;h3 id="associative-cache">Associative Cache&lt;/h3>
&lt;ul>
&lt;li>서로 다른 두 주소가 같은 인덱스를 가지고 계속해서 둘다 접근된다면 캐시미스가 지속적으로 발생한다. 이를 Ping-pong problem이라한다. (이건 처음 듣는다. 위의 참조 에서 처음 들음)&lt;/li>
&lt;li>이를 태그 배열과 데이터 배열을 여러 개 만드는 식으로 개선한다.
&lt;ul>
&lt;li>Direct mapped : 인덱스당 가르키는 공간이 단 1개 (위에서 설명한 방식)&lt;/li>
&lt;li>Full associative : 인덱스가 어떤 공간이던지 가리킬수 있음 (충돌이 적지만 모든 블록을 탐색해야함. 속도가 느림)&lt;/li>
&lt;li>Set associative : 인덱스가 가리키는 공간이 두개 이상인 경우 n-way set associative 캐시라고 부른다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="handling-cache-writes">Handling Cache Writes&lt;/h3>
&lt;ul>
&lt;li>Cache에서 업데이트된 데이터를 언제 메모리에 쓸것인가&lt;/li>
&lt;li>Write-through : 캐시에 데이터가 바뀔때마다 바로바로 업데이트함.&lt;/li>
&lt;li>Write-back : dirty bit를 추가하여 데이터가 변경되었다면 1로 체크해준뒤 블록이 교체될때 dirty비트를 확인하여 메모리의 데이터를 변경하는 구조.&lt;/li>
&lt;/ul></description></item><item><title>MRAM (Magnetic Random Access Memory)</title><link>https://minuk.dev/wiki/mram/</link><pubDate>Mon, 06 Jul 2020 19:19:38 +0900</pubDate><guid>https://minuk.dev/wiki/mram/</guid><description>&lt;h2 id="출처">출처&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.samsungsemiconstory.com/1992">https://www.samsungsemiconstory.com/1992&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Magnetoresistive_random-access_memory">https://en.wikipedia.org/wiki/Magnetoresistive_random-access_memory&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="간단-요약">간단 요약&lt;/h2>
&lt;ul>
&lt;li>자성체 소자를 이용한 비휘발성 메모리, Flash Memory 대비 쓰기 속도가 약 1000배 빠르고 전력 소모가 적은 특징이 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="위키피디아-번역">위키피디아 번역&lt;/h2>
&lt;ul>
&lt;li>일반적인 RAM chip 기술과는 다르게, MRAM은 데이터를 전기 충전이나 흐름으로 저장하지 않고 자기 저장 요소를 사용한다. 이 자기 저장 요소는 2가지 강자성 판들로 구성되며, 각자 자기화 되어 있으며 얇은 절연판에 의해 분리되어 있다. 한 판은 영구적으로 구성되어 있으며, 다른 한판은 메모리를 저장하기 위한 외부 장에 맞추어 바뀌게 된다. 이런 설정은 magnetic tunnel junction 으로 널리 알려져 있으며 MRAM bit 의 가장 간단한 구조이다. &amp;hellip; 생략&lt;/li>
&lt;/ul>
&lt;h3 id="다른-시스템들과의-비교">다른 시스템들과의 비교&lt;/h3>
&lt;ul>
&lt;li>Density(밀도)&lt;/li>
&lt;li>Power consumption&lt;/li>
&lt;li>Data retention&lt;/li>
&lt;li>Speed&lt;/li>
&lt;li>Endurance&lt;/li>
&lt;li>Overall&lt;/li>
&lt;/ul></description></item><item><title>mmap</title><link>https://minuk.dev/wiki/mmap/</link><pubDate>Fri, 05 Jun 2020 19:52:18 +0900</pubDate><guid>https://minuk.dev/wiki/mmap/</guid><description>&lt;h2 id="map_shared-vs-map_private">&lt;code>MAP_SHARED&lt;/code> vs &lt;code>MAP_PRIVATE&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>이에 관한 내용을 검색해보니 많은 내용들이 나온다.&lt;/li>
&lt;li>그런데 대부분 공유하는 내용이랑 메뉴얼을 참조하라고만 하지 직접적 성능비교는 못찾았다.&lt;/li>
&lt;li>그래서 결국 생각이 미친게 innodb는 빠른 방법 혹은 느리더라도 사용해야할 이유가 있는 방법을 사용할 거다.&lt;/li>
&lt;li>innodb storage engine 코드에서 Fgrep으로 찾아보니,&lt;/li>
&lt;/ul>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="/*%20os/os0proc.cc%20*/%0a%20ptr%20=%20mmap%28nullptr,%20size,%20PROT_READ%20%7c%20PROT_WRITE,%20MAP_PRIVATE%20%7c%20OS_MAP_ANON,%0a%20%20%20%20%20%20%20%20%20%20%20%20-1,%200%29;">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* os/os0proc.cc */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ptr &lt;span style="color:#f92672">=&lt;/span> mmap(&lt;span style="color:#66d9ef">nullptr&lt;/span>, size, PROT_READ &lt;span style="color:#f92672">|&lt;/span> PROT_WRITE, MAP_PRIVATE &lt;span style="color:#f92672">|&lt;/span> OS_MAP_ANON,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;p>이 내용을 찾았고, 그래서 &lt;code>MAP_PRIVATE&lt;/code>를 b+-Tree를 만들때 사용하기로 했다.
추가적으로 &lt;code>addr&lt;/code> 를 &lt;code>null&lt;/code>을 줄 경우 자동으로 PAGE 단위에 맞게 준다는 걸 알았다.&lt;/p></description></item><item><title>memory cache 비우기 (linux command)</title><link>https://minuk.dev/wiki/memory-cache-clean/</link><pubDate>Tue, 02 Jun 2020 20:39:40 +0900</pubDate><guid>https://minuk.dev/wiki/memory-cache-clean/</guid><description/></item><item><title>free (linux command)</title><link>https://minuk.dev/wiki/free/</link><pubDate>Tue, 02 Jun 2020 20:37:44 +0900</pubDate><guid>https://minuk.dev/wiki/free/</guid><description>&lt;h2 id="linux-command">linux command&lt;/h2>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="#ZgotmplZ">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;pre>&lt;code>-m : MB단위로 데이터 표시
-b : byte단위로 데이터 표시
-k : kilo byte 단위로 데이터 표시
-t : 맨 마지막에 total 량 표시
-o : buffer/cache 표시 안함
-s : 지정한 초단위(Regular interval)로 refresh
-l : low &amp;amp; High 메모리 크기 통계
-V : free명령의 버전 표시&lt;/code>&lt;/pre>
 
&lt;/div>
&lt;ul>
&lt;li>예시 : &lt;code>free -m&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>clflush (cache line flush)</title><link>https://minuk.dev/wiki/clflush/</link><pubDate>Tue, 02 Jun 2020 19:15:07 +0900</pubDate><guid>https://minuk.dev/wiki/clflush/</guid><description>&lt;h2 id="출처">출처&lt;/h2>
&lt;p>&lt;a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_clflush&amp;amp;expand=678,679">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_clflush&amp;amp;expand=678,679&lt;/a>&lt;/p>
&lt;h2 id="내용">내용&lt;/h2>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="#ZgotmplZ">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> _mm_clflush (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span>&lt;span style="color:#f92672">*&lt;/span> p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;emmintrin.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Instruction: clflush m8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CPUID Flags: SSE2&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>







&lt;div class="codeblock">
 
 &lt;div class="copy-button-box">
 &lt;button class="copy-button" state="copy" data="#ZgotmplZ">
 &lt;i class="bi bi-copy">&lt;/i>
 &lt;/button>
 &lt;/div>
 

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> _mm_clflushopt (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#f92672">*&lt;/span> p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;immintrin.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Instruction: clflushopt m8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CPUID Flags: CLFLUSHOPT&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
&lt;/div>
&lt;ul>
&lt;li>&lt;code>clflush&lt;/code> vs &lt;code>clflushopt&lt;/code>&lt;/li>
&lt;li>출처 : &lt;a href="https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/712498">https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/712498&lt;/a>&lt;/li>
&lt;li>clflushopt : clflush optimization&lt;/li>
&lt;/ul></description></item></channel></rss>