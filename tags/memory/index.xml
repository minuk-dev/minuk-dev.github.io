<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>memory on MD98 page</title><link>http://makerdark98.dev/tags/memory/</link><description>Recent content in memory on MD98 page</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 05 Jun 2020 19:52:18 +0900</lastBuildDate><atom:link href="http://makerdark98.dev/tags/memory/index.xml" rel="self" type="application/rss+xml"/><item><title>mmap</title><link>http://makerdark98.dev/wiki/mmap/</link><pubDate>Fri, 05 Jun 2020 19:52:18 +0900</pubDate><guid>http://makerdark98.dev/wiki/mmap/</guid><description>MAP_SHARED vs MAP_PRIVATE 이에 관한 내용을 검색해보니 많은 내용들이 나온다. 그런데 대부분 공유하는 내용이랑 메뉴얼을 참조하라고만 하지 직접적 성능비교는 못찾았다. 그래서 결국 생각이 미친게 innodb는 빠른 방법 혹은 느리더라도 사용해야할 이유가 있는 방법을 사용할 거다. innodb storage engine 코드에서 Fgrep으로 찾아보니, /* os/os0proc.cc */ ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | OS_MAP_ANON, -1, 0); 이 내용을 찾았고, 그래서 MAP_PRIVATE를 b+-Tree를 만들때 사용하기로 했다. 추가적으로 addr 를 null을 줄 경우 자동으로 PAGE 단위에 맞게 준다는 걸 알았다.</description></item><item><title>memory cache 비우기 (linux command)</title><link>http://makerdark98.dev/wiki/memory-cache-clean/</link><pubDate>Tue, 02 Jun 2020 20:39:40 +0900</pubDate><guid>http://makerdark98.dev/wiki/memory-cache-clean/</guid><description>pagecache 해제 echo 1 &amp;gt; /proc/sys/vm/drop_caches dentries, inodes 해제 echo 2 &amp;gt; /proc/sys/vm/drop_caches pagecache, dentries, inodes 모두 해제 echo 3 &amp;gt; /proc/sys/vm/drop_caches 플러싱하기 sync 출처 https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BA%90%EC%8B%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B9%84%EC%9A%B0%EA%B8%B0</description></item><item><title>free (linux command)</title><link>http://makerdark98.dev/wiki/free/</link><pubDate>Tue, 02 Jun 2020 20:37:44 +0900</pubDate><guid>http://makerdark98.dev/wiki/free/</guid><description>linux command -m : MB단위로 데이터 표시 -b : byte단위로 데이터 표시 -k : kilo byte 단위로 데이터 표시 -t : 맨 마지막에 total 량 표시 -o : buffer/cache 표시 안함 -s : 지정한 초단위(Regular interval)로 refresh -l : low &amp;amp; High 메모리 크기 통계 -V : free명령의 버전 표시 예시 : free -m</description></item><item><title>clflush (cache line flush)</title><link>http://makerdark98.dev/wiki/clflush/</link><pubDate>Tue, 02 Jun 2020 19:15:07 +0900</pubDate><guid>http://makerdark98.dev/wiki/clflush/</guid><description>출처 https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_clflush&amp;amp;expand=678,679
내용 void _mm_clflush (void const* p) #include &amp;lt;emmintrin.h&amp;gt;Instruction: clflush m8 CPUID Flags: SSE2 void _mm_clflushopt (void const * p) #include &amp;lt;immintrin.h&amp;gt;Instruction: clflushopt m8 CPUID Flags: CLFLUSHOPT clflush vs clflushopt 출처 : https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/712498 clflushopt : clflush optimization</description></item></channel></rss>