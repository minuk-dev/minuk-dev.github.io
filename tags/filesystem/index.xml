<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>filesystem on MD98 page</title><link>https://makerdark98.dev/tags/filesystem/</link><description>Recent content in filesystem on MD98 page</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 04 Sep 2020 20:06:36 +0900</lastBuildDate><atom:link href="https://makerdark98.dev/tags/filesystem/index.xml" rel="self" type="application/rss+xml"/><item><title>Filesystem in Userspace</title><link>https://makerdark98.dev/wiki/fuse/</link><pubDate>Fri, 04 Sep 2020 20:06:36 +0900</pubDate><guid>https://makerdark98.dev/wiki/fuse/</guid><description>계기 알게된 이유는, 옆에서 오라큰 파일 시스템이라는 단어를 말했는데 ????? 이라고 느껴서, 공부해보자고 찾아보면서 시작됬다. 기본 개념 파일시스템을 유저레벨에서 하고자 하는 경우 사용한다. 보통은 속도보다는 보호와 보안, 백업 등의 용도로 사용한다. application(user) -&amp;gt; glib(user) -&amp;gt; vfs(kernel) -&amp;gt; fuse module(kernel) -&amp;gt; glib(user) -&amp;gt; libfuse(user) -&amp;gt; user filesystem(user) -&amp;gt; &amp;hellip; 위와 같은 순서로 진행된다. 그러면 성능은? 이라는 생각이 들어서 찾아보니, FAST'17에서 나온 To FUSE or Not to FUSE: Performance of User-Space File Systems 라는 논문이 있다.</description></item><item><title>LFS Paper</title><link>https://makerdark98.dev/wiki/lfs/</link><pubDate>Thu, 16 Jul 2020 20:35:14 +0900</pubDate><guid>https://makerdark98.dev/wiki/lfs/</guid><description>The basic idea : collect large amounts of new data in a file cache in main memory</description></item><item><title>VFS-Virtual File System</title><link>https://makerdark98.dev/wiki/vfs/</link><pubDate>Fri, 03 Jul 2020 20:30:09 +0900</pubDate><guid>https://makerdark98.dev/wiki/vfs/</guid><description>용어 [[file]] [[kiocb]]</description></item><item><title>group descriptor table</title><link>https://makerdark98.dev/wiki/group-descriptor-table/</link><pubDate>Thu, 30 Apr 2020 20:17:00 +0900</pubDate><guid>https://makerdark98.dev/wiki/group-descriptor-table/</guid><description>설명 슈퍼블록 바로 다음에 위치하며, 파일 시스템의 블록 그룹들에 대한 정보를 가지고 있다. Group Descriptor의 크기는 32bytes로, 블록 크기가 1KB이라면 하나의 블록에 총 32개의 Group Descriptor가 기록될수 있다. 포함하는 주요 정보 Block Bitmap의 블록 번호, Inode Bitmap의 블록 번호, 첫번째 Inode Table Block의 블록번호, 그룹안에 있는 빈블록 수, 그룹 안에 있는 inode 수, 그룹 안에 있는 빈 디렉토리 수 등이다.</description></item><item><title>inode</title><link>https://makerdark98.dev/wiki/inode/</link><pubDate>Thu, 30 Apr 2020 20:08:55 +0900</pubDate><guid>https://makerdark98.dev/wiki/inode/</guid><description>설명 Unix에서 사용하는 전통적 파일 시스템에서 사용하는 자료 구조 정규파일, 디렉토리 등 파일시스템에 대한 정보를 가지고 있다. 일반적으로 inode에 포함된 정보 비트 내용 12-15 파일 형식(일반, 디렉터리, 문자 또는 블록 특별, 선입선출 파이프) 9-11 실행 플레그 8 소유자 읽기 권한 7 소유자 쓰기 권한 6 소유자 실행 권한 5 그룹 읽기 권한 4 그룹 쓰기 권한 3 그룹 실행 권한 2 다른 사용자 읽기 권한 1 다른 사용자 쓰기 권한 0 다른 사용자 실행 권한 링크 수 : 이 아이노드에 대한 디렉터리 참조수 소유자 아이디 그룹 아이디 파일 크기 파일 주소 (주소 정보 39바이트) 마지막 접근 시각 마지막 수정 시각 아이노드 수정 시각</description></item><item><title>The new ext4 filesystem: current status and future plans</title><link>https://makerdark98.dev/wiki/ext4/</link><pubDate>Thu, 30 Apr 2020 19:42:16 +0900</pubDate><guid>https://makerdark98.dev/wiki/ext4/</guid><description>Abstract 주요 키워드 : scalability, performance, reliability, stability 2007 년 논문임을 가만하고 읽으면 좋다. 1. Introduction ext3의 장점 : 안정성(stable), 엄격성(robust) ext3의 단점 : 큰 규모에 한계 (큰 파일과 많은 파일) 단점 극복에 관한 기존 방안 ext3는 최대 16TB 만 지원가능 이미 기업에선 한계점이 보임 (디스크 최대 용량은 매년 2배가 되고 있음) 물론, larger filesystem capacity와 extents mapping을 담고 있는 패치를 2006년 선보였으나, 이 패치는 결국 disk의 형식을 변경하고 호환성을 버릴수 밖에 없었다.</description></item></channel></rss>