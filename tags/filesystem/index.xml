<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Filesystem on minuk.dev</title><link>https://minuk.dev/tags/filesystem/</link><description>Recent content in Filesystem on minuk.dev</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Sat, 26 Mar 2022 03:40:18 +0900</lastBuildDate><atom:link href="https://minuk.dev/tags/filesystem/index.xml" rel="self" type="application/rss+xml"/><item><title>Filesystem in Userspace</title><link>https://minuk.dev/wiki/fuse/</link><pubDate>Fri, 04 Sep 2020 20:06:36 +0900</pubDate><guid>https://minuk.dev/wiki/fuse/</guid><description>&lt;h2 id="계기">계기&lt;/h2>
&lt;ul>
&lt;li>알게된 이유는, 옆에서 오라큰 파일 시스템이라는 단어를 말했는데 &lt;code>?????&lt;/code> 이라고 느껴서, 공부해보자고 찾아보면서 시작됬다.&lt;/li>
&lt;/ul>
&lt;h2 id="기본-개념">기본 개념&lt;/h2>
&lt;ul>
&lt;li>파일시스템을 유저레벨에서 하고자 하는 경우 사용한다. 보통은 속도보다는 보호와 보안, 백업 등의 용도로 사용한다.&lt;/li>
&lt;li>application(user) -&amp;gt; glib(user) -&amp;gt; vfs(kernel) -&amp;gt; fuse module(kernel) -&amp;gt; glib(user) -&amp;gt; libfuse(user) -&amp;gt; user filesystem(user) -&amp;gt; &amp;hellip;&lt;/li>
&lt;li>위와 같은 순서로 진행된다. 그러면 성능은? 이라는 생각이 들어서 찾아보니, FAST'17에서 나온 &lt;code>To FUSE or Not to FUSE: Performance of User-Space File Systems&lt;/code> 라는 논문이 있다. 간단하게 읽어보니, User Space Filesystem 을 가볍게 구성하고 ext4로 파일을 저장하게 할때, 성능을 분석한 거다. 링크를 참조하자 : &lt;a href="https://www.usenix.org/system/files/conference/fast17/fast17-vangoor.pdf">https://www.usenix.org/system/files/conference/fast17/fast17-vangoor.pdf&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>LFS Paper</title><link>https://minuk.dev/wiki/lfs/</link><pubDate>Thu, 16 Jul 2020 20:35:14 +0900</pubDate><guid>https://minuk.dev/wiki/lfs/</guid><description>The basic idea : collect large amounts of new data in a file cache in main memory</description></item><item><title>VFS-Virtual File System</title><link>https://minuk.dev/wiki/vfs/</link><pubDate>Fri, 03 Jul 2020 20:30:09 +0900</pubDate><guid>https://minuk.dev/wiki/vfs/</guid><description>&lt;h2 id="용어">용어&lt;/h2>
&lt;ul>
&lt;li>[[file]]&lt;/li>
&lt;li>[[kiocb]]&lt;/li>
&lt;/ul></description></item><item><title>journal(journaling)</title><link>https://minuk.dev/wiki/journal/</link><pubDate>Thu, 30 Apr 2020 20:21:25 +0900</pubDate><guid>https://minuk.dev/wiki/journal/</guid><description>&lt;h2 id="설명">설명&lt;/h2>
&lt;ul>
&lt;li>파일을 기록하기 전, 안정성을 위해 복사본을 기록한 뒤 기록하는 방법&lt;/li>
&lt;/ul>
&lt;h2 id="ext3의-journaling의-3가지-단계">ext3의 journaling의 3가지 단계&lt;/h2>
&lt;ul>
&lt;li>Journal : 가장 낮은 위험모드로 파일 시스템에 commit 하기 전에 데이터와 메타데이터를 저널에 모두 기록한다. 이렇게 하면 그 파일 시스템 뿐만 아니라 모든 쓰여지는 파일의 일관성이 보장되지만 성능이 크게 저하될수 있다&lt;/li>
&lt;li>Ordered : 대부분의 Linux 배포판에서 기본 설정으로써, journal에 metadata를 쓰지만, 파일시스템에는 데이터를 직접 commit한다.
&lt;ol>
&lt;li>metadata가 journal에 commit 된다&lt;/li>
&lt;li>data가 FS에 기록된 다음에야 journal에 있는 연결된 metadata가 file에 쓰여지게 된다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>이로인해 가능한 연산 : 불안전한 쓰기를 삭제가능 : 충돌이 날때 쓰여지는 파일은 손상될 수 있지만, 이외의 파일과 파일 시스템은 안전하다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Writeback : ordered에서 순서보장 내용이 빠진것. : 파일 시스템 자체는 안전하지만 기록 중 또는 장애 전후로 기록된 파일은 불안정할 수 있다.&lt;/li>
&lt;/ul></description></item><item><title>group descriptor table</title><link>https://minuk.dev/wiki/group-descriptor-table/</link><pubDate>Thu, 30 Apr 2020 20:17:00 +0900</pubDate><guid>https://minuk.dev/wiki/group-descriptor-table/</guid><description>&lt;h2 id="설명">설명&lt;/h2>
&lt;ul>
&lt;li>슈퍼블록 바로 다음에 위치하며, 파일 시스템의 블록 그룹들에 대한 정보를 가지고 있다.&lt;/li>
&lt;li>Group Descriptor의 크기는 32bytes로, 블록 크기가 1KB이라면 하나의 블록에 총 32개의 Group Descriptor가 기록될수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="포함하는-주요-정보">포함하는 주요 정보&lt;/h2>
&lt;ul>
&lt;li>Block Bitmap의 블록 번호, Inode Bitmap의 블록 번호, 첫번째 Inode Table Block의 블록번호, 그룹안에 있는 빈블록 수, 그룹 안에 있는 inode 수, 그룹 안에 있는 빈 디렉토리 수 등이다.&lt;/li>
&lt;/ul></description></item><item><title>inode</title><link>https://minuk.dev/wiki/inode/</link><pubDate>Thu, 30 Apr 2020 20:08:55 +0900</pubDate><guid>https://minuk.dev/wiki/inode/</guid><description>&lt;h2 id="설명">설명&lt;/h2>
&lt;ul>
&lt;li>Unix에서 사용하는 전통적 파일 시스템에서 사용하는 자료 구조&lt;/li>
&lt;li>정규파일, 디렉토리 등 파일시스템에 대한 정보를 가지고 있다.&lt;/li>
&lt;li>일반적으로 inode에 포함된 정보&lt;/li>
&lt;/ul>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>비트&lt;/th>
 &lt;th>내용&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>12-15&lt;/td>
 &lt;td>파일 형식(일반, 디렉터리, 문자 또는 블록 특별, 선입선출 파이프)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>9-11&lt;/td>
 &lt;td>실행 플레그&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>8&lt;/td>
 &lt;td>소유자 읽기 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>7&lt;/td>
 &lt;td>소유자 쓰기 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6&lt;/td>
 &lt;td>소유자 실행 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5&lt;/td>
 &lt;td>그룹 읽기 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>4&lt;/td>
 &lt;td>그룹 쓰기 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>그룹 실행 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>다른 사용자 읽기 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>다른 사용자 쓰기 권한&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>0&lt;/td>
 &lt;td>다른 사용자 실행 권한&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>링크 수 : 이 아이노드에 대한 디렉터리 참조수&lt;/li>
&lt;li>소유자 아이디&lt;/li>
&lt;li>그룹 아이디&lt;/li>
&lt;li>파일 크기&lt;/li>
&lt;li>파일 주소 (주소 정보 39바이트)&lt;/li>
&lt;li>마지막 접근 시각&lt;/li>
&lt;li>마지막 수정 시각&lt;/li>
&lt;li>아이노드 수정 시각&lt;/li>
&lt;/ul></description></item><item><title>Superblock</title><link>https://minuk.dev/wiki/superblock/</link><pubDate>Thu, 30 Apr 2020 20:07:08 +0900</pubDate><guid>https://minuk.dev/wiki/superblock/</guid><description>&lt;h2 id="설명">설명&lt;/h2>
&lt;ul>
&lt;li>파일시스템을 대표하는 블록, 파일시스템의 주요 설정이 들어가있다.&lt;/li>
&lt;li>주로 블록의 크기(1KB인지 4KB인지&amp;hellip;), 총 블록의 개수, 블록 그룹의 개수, [[inode]]의 개수, 그룹당 block의 개수&lt;/li>
&lt;/ul></description></item><item><title>The new ext4 filesystem: current status and future plans</title><link>https://minuk.dev/wiki/ext4/</link><pubDate>Thu, 30 Apr 2020 19:42:16 +0900</pubDate><guid>https://minuk.dev/wiki/ext4/</guid><description>&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;ul>
&lt;li>주요 키워드 : scalability, performance, reliability, stability&lt;/li>
&lt;li>2007 년 논문임을 가만하고 읽으면 좋다.&lt;/li>
&lt;/ul>
&lt;h2 id="1-introduction">1. Introduction&lt;/h2>
&lt;ul>
&lt;li>&lt;code>ext3&lt;/code>의 장점 : 안정성(stable), 엄격성(robust)&lt;/li>
&lt;li>&lt;code>ext3&lt;/code>의 단점 : 큰 규모에 한계 (큰 파일과 많은 파일)&lt;/li>
&lt;/ul>
&lt;h3 id="단점-극복에-관한-기존-방안">단점 극복에 관한 기존 방안&lt;/h3>
&lt;ul>
&lt;li>&lt;code>ext3&lt;/code>는 최대 16TB 만 지원가능&lt;/li>
&lt;li>이미 기업에선 한계점이 보임 (디스크 최대 용량은 매년 2배가 되고 있음)&lt;/li>
&lt;li>물론, &lt;code>larger filesystem capacity&lt;/code>와 &lt;code>extents mapping&lt;/code>을 담고 있는 패치를 2006년 선보였으나, 이 패치는 결국 disk의 형식을 변경하고 호환성을 버릴수 밖에 없었다.&lt;/li>
&lt;li>따라서 여기선 ext3를 버리고 ext4로 새로 분기 했다.&lt;/li>
&lt;/ul>
&lt;h3 id="주요-목표">주요 목표&lt;/h3>
&lt;ul>
&lt;li>scalability (확장성), performance (성능), reliability (신뢰성) 을 모두 고려한 주소 방식을 제시하는 것이 목표&lt;/li>
&lt;li>기존의 문제가 해결된 &lt;code>XFS&lt;/code> 기반이나, 혹은 아예 새로운 기반에서 시작하지 않는 이유 =&amp;gt; 호환성 문제 : ext3에서 ext4로 넘어오기 편하게 하기 위해서.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2-scalability-enhancements">2. Scalability enhancements&lt;/h2>
&lt;h3 id="21-large-filesystem-파일-시스템의-최대-용량">2.1 Large filesystem (파일 시스템의 최대 용량)&lt;/h3>
&lt;ul>
&lt;li>ext3에선 32-bit block number 를 사용 =&amp;gt; ext4에서 48-bit block number 사용으로 전환 (용량 2의 16승 증가 =&amp;gt; 16,384배 증가)&lt;/li>
&lt;li>각 block 별 크기는 4KB가 기본이고 이를 계산해보면 2^(48+12) = 2^60 bytes = 1EB&lt;/li>
&lt;li>이에 따른 Metadata(
[[superblock]],
[[group descriptor table]]{group descriptor},
[[journal]]) 또한 변화해야한다.
&lt;ul>
&lt;li>따라서 새로운 32-bit fields 를 block group descriptor structure에 추가함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주소 체계의 변화로 인해, journaling block layer(JBD) 또한 48bit를 지원하도록 수정해야한다. 따라서 JDB2로 분기했고, 아직(이 논문을 낼 당시) 32-bit와 64-bit filesystem이 모두 호환이 되는 JDB를 만들지는 못했다.&lt;/li>
&lt;li>질문점 : 왜 굳이 64가 아닌 48bit를 선택하였는가? 간략하게 설명하면 48 bit 만 사용해도 단순 계산으로 119년이 소모되고, 그 사이에 충분히 논의가 가능하다. 또한 실험을 통해 성능 체크를 해보았을때 64bit는 너무 많다.&lt;/li>
&lt;/ul>
&lt;h3 id="211-future-work">2.1.1 Future work&lt;/h3>
&lt;ul>
&lt;li>현재 (논문을 쓸 당시) 해결 못한 이슈로는 block groups의 수가 여전히 제한되어 있기 때문에 128MB(2^27 bytes) [[block group]] size를 그룹별로 나눠가지면, 최대 2^27/64 = 2^21 의 블록 groups 밖에 만들지 못한다.&lt;/li>
&lt;li>해결책으로 metablock group feture (META_BG) 를 사용해서 추가적으로 Block Group을 만들수 있게 하면 된다. 이럴 경우 block groups의 최대 개수는 2^32 가 되므로 1EB를 충분히 지원할수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="22-extents">2.2 Extents&lt;/h3>
&lt;ul>
&lt;li>ext3에서 사용하던 indirect block mapping은 logical block 과 disk block 이 동일하다. 물론 크기가 작은 파일에 대해서는 효율적이지만 큰파일에 대해서는 그리 효율적이지 않다.&lt;/li>
&lt;li>따라서 ext4_extent structure를 제시하여 length 를 지정할수 있게 한다.&lt;/li>
&lt;li>이때 호환성을 생각해서 ext4_extent_header를 제시한다.
&lt;ul>
&lt;li>eh_entries (몇개의 속성들이 있는지), eh_max (최대 몇개의 속성을 넣을수 있는지), eh_depth (tree의 depth, 0이면 datablock), eh_generation (tree의 세대, 종류를 나타내려고 만듬)&lt;/li>
&lt;li>추가적으로 magic number&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>tree 구조로 파일을 쌓을 꺼기 때문에 ext4_extent_idx 라는 구조를 만들어
&lt;ul>
&lt;li>ei_block(해당하는 block), ei_leaf, ei_leaf_hi, ef_unused 를 제시한다.&lt;/li>
&lt;li>자세한 구조는 논문의 Figure2. Ext4 extent tree layout 을 참조하면 도움이 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="221-future-work">2.2.1 Future work&lt;/h3>
&lt;ul>
&lt;li>사실 extents 자체가 작은 파일들, 매우 단편화된 파일들에서는 효율적이지는 않음.&lt;/li>
&lt;li>그래서 호환성을 생각하면서 ext4_extent_header를 제시해놓았으니 이를 바꿔가면서 이런 파일들을 처리하는 것을 제시해야함.&lt;/li>
&lt;li>속성을 4개 이상 추가하길 원하면 extent tail(inode number랑 inode generation을 포함해서)을 만든 다음 뒤에다가 붙이는 식으로 만들면 됨.&lt;/li>
&lt;/ul>
&lt;h3 id="23-large-files">2.3 Large files&lt;/h3>
&lt;ul>
&lt;li>Linux에서 inode 특성상 ext4에선 2TB만 가능하게 설정되게 되는데 (filesystem 에서 1 block의 크기는 4KB이더라도 disk sector의 크기가 512 Bytes라서, ext4 에서 사용하는 변수의 크기가 32bit임을 감안하면 2^32 * 512 bytes = 2^41 = 2TB, 근데 여기 부분에서 filesystem 1 block 의 크기가 아니라 왜 sector의 크기를 곱하는지 이해가 안됨.)&lt;/li>
&lt;li>따라서 HUGE_FILE flag를 도입 (EXT4_HUGE_FILE_FL), flag 값을 확인하여 처리&lt;/li>
&lt;/ul>
&lt;h3 id="24-large-number-of-files">2.4 Large number of files&lt;/h3>
&lt;ul>
&lt;li>이론적으로 수백억개가 가능하겠지만 inode table의 통계적 수치분석 결과 다 못사용하고 있음.&lt;/li>
&lt;li>inode의 최대개수를 제한(fix)하고 사용해도 괜찮다는 결론이 나옴 (무한히 생성가능하도록 만들 필요가 없음)&lt;/li>
&lt;li>따라서 아래 3가지 관점을 가지고 접근했는데
&lt;ul>
&lt;li>Performance : inode만 보고 바로 block에 접근 가능해야함. (빠르게)&lt;/li>
&lt;li>Robustness : filesystem이 고장나도 e2fsck 가 흩어져 있는 inode table blocks을 찾을수 있어아함.&lt;/li>
&lt;li>Compatibility : 64 bit inode 가 32bit 시스템에서 overflow 되더라도 잘 작동해야함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미정리 : 그림 참조&lt;/li>
&lt;/ul>
&lt;h3 id="25-directory-scalability">2.5 Directory scalability&lt;/h3>
&lt;ul>
&lt;li>무한 sub directory 기능을 지원하도록 설정해야함.&lt;/li>
&lt;li>많은 수의 entries를 가진 큰 디렉토리도 지원해야하기 때문에 HTree(32bit hashing을 응용해서 BTree를 변형, 그림 참조)&lt;/li>
&lt;/ul>
&lt;h3 id="251-future-work">2.5.1 Future work&lt;/h3>
&lt;ul>
&lt;li>HTree 의 최대 높이가 제한되어 있는데 (2로), 이를 풀어야함.&lt;/li>
&lt;li>디렉토리 내부의 파일 리스트가 파일 이름을 기반으로 정렬되어 있기 때문에, readdir(디렉토리 내부 파일 리스트 출력) 실제론 디스크에서 랜덤 엑세스하는 것과 동일해진다. 따라서 hash 순서로 돌도록 조정해주어야 한다.&lt;/li>
&lt;li>이를 해결하기 위해서 생각한 방법중 하나는, directory entry(inode 를 reference 하고 있는 데이터)가 아니라, inode 자체를 directory에다 넣는 방법을 생각해보았는데, 이러면 readdir 과정에서 inode를 찾느라고 디스크를 계속 읽을 필요 없이, 이미 memory에 올라온 데이터를 읽으면 된다.&lt;/li>
&lt;li>위에서 말한 방법이면 dynamic inode allocation도 가능해지는데 directory가 inode 의 container 개념이 되게 된다.&lt;/li>
&lt;li>hard linked file 같은 경우 여러개의 directory에 동시에 생성되면 되고, inode 자체적으로 link count를 조정하게 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="26-large-inode-and-fast-extended-attributes">2.6 Large inode and fast extended attributes&lt;/h3>
&lt;ul>
&lt;li>ext3에서는 inode size가 다양하게 되는걸 지원했다.&lt;/li>
&lt;li>ext4에서는 일정 이상 커지면 고정된 128 bytes를 추가하도록 했다. 이렇게 하면, e2fsck가 많은 코드를 짤 필요가 없어진다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="3-block-allocation-enhancements">3. Block allocation enhancements&lt;/h2>
&lt;ul>
&lt;li>현대 파일시스템 모두의 목표인 향상된 처리량(increased filesystem throughput)에 대해서 이야기한다.&lt;/li>
&lt;li>단편화(fragmentation), 추가된 metadata들이 일으키는 오버헤드에 대해서 논하고, ext4에 추가된 기능이 얼마나 장점이 많고 block allocation을 잘해서 단편화를 줄이는지 이야기한다.&lt;/li>
&lt;/ul>
&lt;h3 id="31-persistent-preallocation">3.1 Persistent preallocation&lt;/h3>
&lt;ul>
&lt;li>재시작되도 영구적으로 유지되는 사전 할당을 한다.&lt;/li>
&lt;li>사전 할당은 최대한 파일이 연속적으로 할당 되는데 도움이 되고, 사전할당된 영역에 쓰기가 가능하도록 보장해준다. (파일 영역이 커진다고 해서 추가적으로 할당할 일이 없어 단편화 문제를 논하는 듯)&lt;/li>
&lt;li>대부분의 프로그램은 연속적으로 파일을 쓰기때문에 충분하다고 생각하지만, database같이 랜덤한 부분에 쓰는 프로그램들도 고려해주어야함&lt;/li>
&lt;li>ext4_extent 에서 초기화되어있는지 여부에 대한 플레그도 만들어 놨으니 잘 사용할수 있음.&lt;/li>
&lt;li>직접적으로 이 기능을 쓰고 싶으면 posix_fallocate API에 기능을 mapping 해놓았으니 쓰면됨.&lt;/li>
&lt;/ul>
&lt;h3 id="32-delayed-and-multiple-block-allocation">3.2 Delayed and multiple block allocation&lt;/h3>
&lt;h3 id="33-online-defragmentation">3.3 Online defragmentation&lt;/h3>
&lt;h2 id="4-reliability-enhancements">4. Reliability enhancements&lt;/h2>
&lt;h3 id="41-unused-inode-count-and-fast-e2fsck">4.1 Unused inode count and fast e2fsck&lt;/h3>
&lt;h3 id="42-checksumming">4.2 Checksumming&lt;/h3>
&lt;h2 id="5-other-new-features">5. Other new features&lt;/h2>
&lt;h2 id="6-migration-tool">6. Migration tool&lt;/h2>
&lt;h3 id="61-upgrading-from-ext3-to-ext4">6.1 Upgrading from ext3 to ext4&lt;/h3>
&lt;h3 id="62-downgrading-from-ext4-to-ext3">6.2 Downgrading from ext4 to ext3&lt;/h3>
&lt;h2 id="7-performance-evaluation">7. Performance evaluation&lt;/h2>
&lt;h3 id="71-ffsb-comparison">7.1 FFSB comparison&lt;/h3>
&lt;h3 id="72-postmark-comparison">7.2 Postmark comparison&lt;/h3>
&lt;h3 id="73-iozone-comparison">7.3 IOzone comparison&lt;/h3>
&lt;h2 id="8-conclusion">8. Conclusion&lt;/h2></description></item></channel></rss>