<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design pattern on MD98 page</title><link>https://makerdark98.dev/tags/design-pattern/</link><description>Recent content in design pattern on MD98 page</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 27 Apr 2020 21:43:50 +0900</lastBuildDate><atom:link href="https://makerdark98.dev/tags/design-pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>Modern C++ Design Pattern/Chatper 17. 매개자</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-17-%EB%A7%A4%EA%B0%9C%EC%9E%90/</link><pubDate>Mon, 27 Apr 2020 21:43:50 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-17-%EB%A7%A4%EA%B0%9C%EC%9E%90/</guid><description>간단 설명 서로 다른 컴포넌트 간에 포인터나 직접적인 참조를 통한 커뮤니케이션이 필요하다 일부 경우 상대방 객체의 존재를 알아야하는점, 객체의 생성/소멸 시점에대한 관리 때문에 포인터나 참조로 접근하는게 불안정할 수 있다. 이를 위한 매커니즘 전역 정적 변수이거나 모든 컴포넌트에 그 참조가 노출되어야 한다. 내용 여기서는 Boost.Signals2 라이브러리를 사용해서 구현한다. 잘 모르겠다. 일단 요약부분만 적고 나중에 필요하면 찾아보자 요약 매개자 디자인 패턴은 시스탬 내 컴포넌트 모두가 참조할 수 있는 어떤 중간자를 컴포넌트 간에 서로 직접적으로 참조하지 않더라도 커뮤니케이션을 할수 있게 한다는 것을 기본아이디어로 한다.</description></item><item><title>Modern C++ Design Pattern/Chatper 16. 반복자</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-16-%EB%B0%98%EB%B3%B5%EC%9E%90/</link><pubDate>Tue, 21 Apr 2020 23:12:43 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-16-%EB%B0%98%EB%B3%B5%EC%9E%90/</guid><description>간략 설명 복잡한 데이터 구조를 다루어야 할 때 데이터 순회 문제를 해결하는 방법 표준 라이브러리의 반복자 begin end rbegin rend cbegin cend crbegin crend 이진 트리의 탐색 template &amp;lt;typename U&amp;gt; struct PreOrderIterator; template &amp;lt;typename T&amp;gt; struct BinaryTree; template &amp;lt;typename T&amp;gt; struct Node { T value; Node&amp;lt;T&amp;gt; *left = nullptr; Node&amp;lt;T&amp;gt; *right = nullptr; Node&amp;lt;T&amp;gt; *parent = nullptr; BinaryTree&amp;lt;T&amp;gt;* tree = nullptr; explicit Node(const T&amp;amp; value) : value(value) {} Node(const T&amp;amp; value, Node&amp;lt;T&amp;gt;* const left, Node&amp;lt;T&amp;gt;* const right) : value(value), left(left), right(right) { this-&amp;gt;left-&amp;gt;tree =this-&amp;gt;right-&amp;gt;tree = tree; this-&amp;gt;left-&amp;gt;parent = this-&amp;gt;right-&amp;gt;parent = this; } void set_tree(BinaryTree&amp;lt;T&amp;gt;* t) { tree = t; if (left) left-&amp;gt;set_tree(t); if (right) right-&amp;gt;set_tree(t); } }; template &amp;lt;typename T&amp;gt; struct BinaryTree { Node&amp;lt;T&amp;gt;* root = nullptr; explicit BinaryTree(Node&amp;lt;T&amp;gt;* const root) : root{ root } { root-&amp;gt;set_tree(this); } typedef PreOrderIterator&amp;lt;T&amp;gt; iterator; iterator begin() { Node&amp;lt;T&amp;gt;* n = root; if (n) while (n-&amp;gt;left) n = n-&amp;gt;left; return iterator{ n } } iterator end() { return iteraotr { nullptr }; } }; template &amp;lt;typename U&amp;gt; struct PreOrderIterator { Node&amp;lt;U&amp;gt;* current; explicit PreOrderIterator(Node&amp;lt;U&amp;gt;* current) : current(current) { } bool operator!</description></item><item><title>Modern C++ Design Pattern/Chatper 15. 인터프리터</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-15-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</link><pubDate>Mon, 20 Apr 2020 22:46:23 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-15-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</guid><description>인터프리터 디자인 패턴? 입력 데이터를 해석하는 것 대부분 텍스트이지만 텍스트에 한정되지는 않음. 요약 &amp;hellip; 이책에서 굳이 이 내용을 다루는 이유를 모르겠다. 차라리 Lex/Yacc를 보는게 좋다고 생각한다. 아마도 Boost.Spirit을 알려주고 싶어서 굳이 끼워넣은 느낌? 키워드만 정리하자면, AST, Lex/Yacc</description></item><item><title>Modern C++ Design Pattern/Chatper 14. 커맨드</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-14-%EC%BB%A4%EB%A7%A8%EB%93%9C/</link><pubDate>Sun, 19 Apr 2020 21:40:23 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-14-%EC%BB%A4%EB%A7%A8%EB%93%9C/</guid><description>필요성 어떤 객체를 활용할 때 직접 그 객체의 API를 호출하여 조작하는 대신, 작업을 어떻게 하라고 명령을 보내는 방식을 제안한다. 시나리오 struct BankAccount { int balance = 0; int overdraft_limit = -500; void deposit(int amount) { balance += amount; cout &amp;lt;&amp;lt; &amp;#34;deposited &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34;, balance is now &amp;#34; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } void withdraw(int amount) { if (balance - amount &amp;gt;= overdraft_limit) { balance -= amount; cout &amp;lt;&amp;lt; &amp;#34;withdrew &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34;, balance is now &amp;#34; &amp;lt;&amp;lt; balance &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; } } }; 커맨드 패턴의 구현 struct Command { virtual void call() const = 0; }; struct BankAccountCommand : Command { BankAccount&amp;amp; account; enum Action { deposit, withdraw } action; int amount; BankAccountCommand(BankAccount&amp;amp; account, const Action action, const int amount) : account(account), action(action), amount(amount) {} void call() const override { switch (action) { case deposit: account.</description></item><item><title>Modern C++ Design Pattern/Chatper 13. 책임사슬(Chain of Responsibility)</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-13-%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/</link><pubDate>Sat, 18 Apr 2020 22:14:11 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-13-%EC%B1%85%EC%9E%84%EC%82%AC%EC%8A%ACchain-of-responsibility/</guid><description>시나리오 struct Creature { string name; int attack, defense; // Constructor, operator... }; 포인터 사슬 class CreatureModifier { CreatureModifier* next{nullptr}; protected: Creature&amp;amp; creture; // reference, pointer or shared_ptr public: explicit CreatureModifier(Creature&amp;amp; creature) : creature(creture) {} void add(CreatureModifier* cm) { if (next) next-&amp;gt;add(cm); else next =cm; } virtual void handle() { if (next) next-&amp;gt;handle(); } }; 참조를 넘겨받아 저장하고 변경할 준비 추상 클래스가 아님 next는 다음 변경 작업을 가리킴 add()를 통해서 작업 사슬에 연결하여 추가 handle() 맴버 함수는 단순히 다음 항목을 처리한다.</description></item><item><title>Modern C++ Design Pattern/Chapter 12. 프록시</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-12-%ED%94%84%EB%A1%9D%EC%8B%9C/</link><pubDate>Sun, 12 Apr 2020 23:10:03 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-12-%ED%94%84%EB%A1%9D%EC%8B%9C/</guid><description>스마트 포인터 가장 단순하면서도 직접적인 프록시 패턴의 예 속성 프록시 다른 프로그래밍 언어에서는 get/set 메서드를 지원하는 경우도 있음. template &amp;lt;typename T&amp;gt; struct Property { T value; Property(const T initial_value) { *this = initial_value; } operate T() { return value; } T operator=(T new_value) { return value = new_value; } } struct Creature { Property&amp;lt;int&amp;gt; strength{ 10 }; Property&amp;lt;int&amp;gt; agility{ 5 }; } Creature creature; creature.agility = 20; auto x = creature.</description></item><item><title>Modern C++ Design Pattern/Chapter 11. 플라이웨이트</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-11-%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/</link><pubDate>Sat, 11 Apr 2020 23:28:27 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-11-%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8/</guid><description>플라이웨이트 패턴 : 많은 수의 가벼운 임시 객체들을 &amp;ldquo;스마트 참조&amp;quot;로 사용하는 것을 말하며, 그러한 객체들을 플라이웨이트라고 부른다. 사용자 이름 struct User { User(const string&amp;amp; first_name, const string&amp;amp; last_name) : first_name{add(first_anem)}, last_name{add(last_name)} {} protected: key first_name, last_name; static bimap&amp;lt;key, string&amp;gt; names; // boost:bimap(양방향 map) static key seed; static key add(const string&amp;amp; s) { ...} }; static key add(const string&amp;amp; s) { auto it = names.right.find(s); if (it == names.</description></item><item><title>Modern C++ Design Pattern/Chapter 10. 퍼사드</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-10-%ED%8D%BC%EC%82%AC%EB%93%9C/</link><pubDate>Thu, 09 Apr 2020 23:56:51 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/chapter-10-%ED%8D%BC%EC%82%AC%EB%93%9C/</guid><description>퍼사드는 어디에 있는가? struct Console { vector&amp;lt;Viewport*&amp;gt; viewports; Size charSize, gridSize; }; Console::Console(bool fullscreen, int char_width, int char_height, int width, int height, optional&amp;lt;Size&amp;gt; client_size) { // Implement } Console::Console(const ConsoleCreateionParamters* ccp) { ... } struct ConsoleCreationParameters { optional&amp;lt;Size&amp;gt; client_size; int character_width{10}; int character_height{14}; int width{20}; int height{30}; bool fullscreen{false}; bool create_default_view_and_buffer{true}; }; 요약 하나 이상의 복잡한 서브 시스템 앞에 단순한 인터페이스를 두기 위한 방법</description></item><item><title>Modern C++ Design Pattern</title><link>https://makerdark98.dev/wiki/modern-c++-design-pattern/</link><pubDate>Tue, 07 Apr 2020 20:44:17 +0900</pubDate><guid>https://makerdark98.dev/wiki/modern-c++-design-pattern/</guid><description>챕터별 정리</description></item></channel></rss>